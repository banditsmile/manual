<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>关于本文档 Node.js v0.10.18 文档 中文版</title>
  <link rel="stylesheet" href="public/api_assets/style.css">
  <link rel="stylesheet" href="public/api_assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/all.html">
</head>
<body class="alt apidoc" id="api-section-all">

    <div id="intro" class="interior">
        <a href="http://xudafeng.github.io/nodejs/" title="返回首页">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <li><a href="http://xudafeng.github.io/nodejs/" class="docs current">文档首页</a></li>
                <li><a href="http://nodejs.org/api/">英文版文档</a></li>
            </ul>
            <div style="margin-top:44px; font-size:12px;">
              <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">知识共享署名-非商业性使用 3.0 未本地化版本许可协议</a>进行许可。
            </div>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.10.18 手册 &amp; 文档</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">索引</a> |
                <a href="all.html">在单一页面中浏览</a> |
                <a href="http://jixiangac.com/doc/node/all.json">JSON格式</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>目录</h2>
            <ul>
<li><a href="all.html#all">关于本文档</a><ul>
<li><a href="all.html#all_1">稳定度</a></li>
<li><a href="all.html#all_json">JSON 输出</a></li>
</ul>
</li>
<li><a href="all.html#all_2">概述</a></li>
<li><a href="all.html#all_3">全局对象</a><ul>
<li><a href="all.html#all_global">global</a></li>
<li><a href="all.html#all_process">process</a></li>
<li><a href="all.html#all_console">console</a></li>
<li><a href="all.html#all_buffer">类: Buffer</a></li>
<li><a href="all.html#all_require">require()</a><ul>
<li><a href="all.html#all_require_resolve">require.resolve()</a></li>
<li><a href="all.html#all_require_cache">require.cache</a></li>
<li><a href="all.html#all_require_extensions">require.extensions</a></li>
</ul>
</li>
<li><a href="all.html#all_filename">__filename</a></li>
<li><a href="all.html#all_dirname">__dirname</a></li>
<li><a href="all.html#all_module">module</a></li>
<li><a href="all.html#all_exports">exports</a></li>
<li><a href="all.html#all_settimeout_cb_ms">setTimeout(cb, ms)</a></li>
<li><a href="all.html#all_cleartimeout_t">clearTimeout(t)</a></li>
<li><a href="all.html#all_setinterval_cb_ms">setInterval(cb, ms)</a></li>
<li><a href="all.html#all_clearinterval_t">clearInterval(t)</a></li>
</ul>
</li>
<li><a href="all.html#all_4">控制台</a><ul>
<li><a href="all.html#all_console_log_data">console.log([data], [...])</a></li>
<li><a href="all.html#all_console_info_data">console.info([data], [...])</a></li>
<li><a href="all.html#all_console_error_data">console.error([data], [...])</a></li>
<li><a href="all.html#all_console_warn_data">console.warn([data], [...])</a></li>
<li><a href="all.html#all_console_dir_obj">console.dir(obj)</a></li>
<li><a href="all.html#all_console_time_label">console.time(label)</a></li>
<li><a href="all.html#all_console_timeend_label">console.timeEnd(label)</a></li>
<li><a href="all.html#all_console_trace_label">console.trace(label)</a></li>
<li><a href="all.html#all_console_assert_expression_message">console.assert(expression, [message])</a></li>
</ul>
</li>
<li><a href="all.html#all_5">定时器</a><ul>
<li><a href="all.html#all_settimeout_callback_delay_arg">setTimeout(callback, delay, [arg], [...])</a></li>
<li><a href="all.html#all_cleartimeout_timeoutid">clearTimeout(timeoutId)</a></li>
<li><a href="all.html#all_setinterval_callback_delay_arg">setInterval(callback, delay, [arg], [...])</a></li>
<li><a href="all.html#all_clearinterval_intervalid">clearInterval(intervalId)</a></li>
<li><a href="all.html#all_unref">unref()</a></li>
<li><a href="all.html#all_ref">ref()</a></li>
<li><a href="all.html#all_setimmediate_callback_arg">setImmediate(callback, [arg], [...])</a></li>
<li><a href="all.html#all_clearimmediate_immediateid">clearImmediate(immediateId)</a></li>
</ul>
</li>
<li><a href="all.html#all_modules">Modules</a><ul>
<li><a href="all.html#all_6">循环</a></li>
<li><a href="all.html#all_7">核心模块</a></li>
<li><a href="all.html#all_8">文件模块</a></li>
<li><a href="all.html#all_node_modules">从<code>node_modules</code>文件夹中加载</a></li>
<li><a href="all.html#all_folders_as_modules">Folders as Modules</a></li>
<li><a href="all.html#all_caching">Caching</a><ul>
<li><a href="all.html#all_module_caching_caveats">Module Caching Caveats</a></li>
</ul>
</li>
<li><a href="all.html#all_the_module_object">The <code>module</code> Object</a><ul>
<li><a href="all.html#all_module_exports">module.exports</a></li>
<li><a href="all.html#all_module_require_id">module.require(id)</a></li>
<li><a href="all.html#all_module_id">module.id</a></li>
<li><a href="all.html#all_module_filename">module.filename</a></li>
<li><a href="all.html#all_module_loaded">module.loaded</a></li>
<li><a href="all.html#all_module_parent">module.parent</a></li>
<li><a href="all.html#all_module_children">module.children</a></li>
</ul>
</li>
<li><a href="all.html#all_9">总体来说...</a></li>
<li><a href="all.html#all_10">从全局文件夹加载</a></li>
<li><a href="all.html#all_11">访问主模块</a></li>
<li><a href="all.html#all_12">附录： 包管理技巧</a></li>
</ul>
</li>
<li><a href="all.html#all_addons">Addons插件</a><ul>
<li><a href="all.html#all_hello_world">Hello world（世界你好）</a></li>
<li><a href="all.html#all_addon_patterns">Addon patterns（插件方式）</a><ul>
<li><a href="all.html#all_function_arguments">Function arguments（函数参数）</a></li>
<li><a href="all.html#all_callbacks">Callbacks（回调）</a></li>
<li><a href="all.html#all_object_factory">Object factory（对象工厂）</a></li>
<li><a href="all.html#all_function_factory">Function factory（函数工厂）</a></li>
<li><a href="all.html#all_wrapping_c_objects_c">Wrapping C++ objects（包装c++对象）</a></li>
<li><a href="all.html#all_factory_of_wrapped_objects">Factory of wrapped objects（工厂包装对象）</a></li>
<li><a href="all.html#all_passing_wrapped_objects_around">Passing wrapped objects around（传递包装的对象）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_process_1">process</a><ul>
<li><a href="all.html#all_exit_codes">Exit Codes</a></li>
<li><a href="all.html#all_exit">事件: &apos;exit&apos;</a></li>
<li><a href="all.html#all_uncaughtexception">事件: &apos;uncaughtException&apos;（未捕获错误）</a></li>
<li><a href="all.html#all_signal_events">Signal Events</a></li>
<li><a href="all.html#all_process_stdout">process.stdout</a></li>
<li><a href="all.html#all_process_stderr">process.stderr</a></li>
<li><a href="all.html#all_process_stdin">process.stdin</a></li>
<li><a href="all.html#all_process_argv">process.argv</a></li>
<li><a href="all.html#all_process_execpath">process.execPath</a></li>
<li><a href="all.html#all_process_execargv">process.execArgv</a></li>
<li><a href="all.html#all_process_abort">process.abort()</a></li>
<li><a href="all.html#all_process_chdir_directory">process.chdir(directory)</a></li>
<li><a href="all.html#all_process_cwd">process.cwd()</a></li>
<li><a href="all.html#all_process_env">process.env</a></li>
<li><a href="all.html#all_process_exit_code">process.exit([code])</a></li>
<li><a href="all.html#all_process_exitcode">process.exitCode</a></li>
<li><a href="all.html#all_process_getgid">process.getgid()</a></li>
<li><a href="all.html#all_process_setgid_id">process.setgid(id)</a></li>
<li><a href="all.html#all_process_getuid">process.getuid()</a></li>
<li><a href="all.html#all_process_setuid_id">process.setuid(id)</a></li>
<li><a href="all.html#all_process_getgroups">process.getgroups()</a></li>
<li><a href="all.html#all_process_setgroups_groups">process.setgroups(groups)</a></li>
<li><a href="all.html#all_process_initgroups_user_extra_group">process.initgroups(user, extra_group)</a></li>
<li><a href="all.html#all_process_version">process.version</a></li>
<li><a href="all.html#all_process_versions">process.versions</a></li>
<li><a href="all.html#all_process_config">process.config</a></li>
<li><a href="all.html#all_process_kill_pid_signal">process.kill(pid, [signal])</a></li>
<li><a href="all.html#all_process_pid">process.pid</a></li>
<li><a href="all.html#all_process_title">process.title</a></li>
<li><a href="all.html#all_process_arch">process.arch</a></li>
<li><a href="all.html#all_process_platform">process.platform</a></li>
<li><a href="all.html#all_process_memoryusage">process.memoryUsage()</a></li>
<li><a href="all.html#all_process_nexttick_callback">process.nextTick(callback)</a></li>
<li><a href="all.html#all_process_umask_mask">process.umask([mask])</a></li>
<li><a href="all.html#all_process_uptime">process.uptime()</a></li>
<li><a href="all.html#all_process_hrtime">process.hrtime()</a></li>
</ul>
</li>
<li><a href="all.html#all_utils">utils</a><ul>
<li><a href="all.html#all_util_debuglog_section">util.debuglog(section)</a></li>
<li><a href="all.html#all_error">对Error(错误)对象的内容添加</a></li>
<li><a href="all.html#all_13">隐式绑定</a></li>
<li><a href="all.html#all_14">显式绑定</a></li>
<li><a href="all.html#all_domain_create">domain.create()</a></li>
<li><a href="all.html#all_domain">类: Domain</a><ul>
<li><a href="all.html#all_domain_run_fn">domain.run(fn)</a></li>
<li><a href="all.html#all_domain_members">domain.members</a></li>
<li><a href="all.html#all_domain_add_emitter">domain.add(emitter)</a></li>
<li><a href="all.html#all_domain_remove_emitter">domain.remove(emitter)</a></li>
<li><a href="all.html#all_domain_bind_callback">domain.bind(callback)</a><ul>
<li><a href="all.html#all_15">例子</a></li>
</ul>
</li>
<li><a href="all.html#all_domain_intercept_callback">domain.intercept(callback)</a><ul>
<li><a href="all.html#all_16">例子</a></li>
</ul>
</li>
<li><a href="all.html#all_domain_enter">domain.enter()</a></li>
<li><a href="all.html#all_domain_exit">domain.exit()</a></li>
<li><a href="all.html#all_domain_dispose">domain.dispose()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_buffer_1">Buffer</a><ul>
<li><a href="all.html#all_buffer_2">类: Buffer</a><ul>
<li><a href="all.html#all_new_buffer_size">new Buffer(size)</a></li>
<li><a href="all.html#all_new_buffer_array">new Buffer(array)</a></li>
<li><a href="all.html#all_new_buffer_str_encoding">new Buffer(str, [encoding])</a></li>
<li><a href="all.html#all_buffer_isencoding_encoding">类方法: Buffer.isEncoding(encoding)</a></li>
<li><a href="all.html#all_buffer_isbuffer_obj">类方法: Buffer.isBuffer(obj)</a></li>
<li><a href="all.html#all_buffer_bytelength_string_encoding">类方法: Buffer.byteLength(string, [encoding])</a></li>
<li><a href="all.html#all_buffer_concat_list_totallength">类方法: Buffer.concat(list, [totalLength])</a></li>
<li><a href="all.html#all_buf_length">buf.length</a></li>
<li><a href="all.html#all_buf_write_string_offset_length_encoding">buf.write(string, [offset], [length], [encoding])</a></li>
<li><a href="all.html#all_buf_tostring_encoding_start_end">buf.toString([encoding], [start], [end])</a></li>
<li><a href="all.html#all_buf_tojson">buf.toJSON()</a></li>
<li><a href="all.html#all_buf_index">buf[index]</a></li>
<li><a href="all.html#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</a></li>
<li><a href="all.html#all_buf_slice_start_end">buf.slice([start], [end])</a></li>
<li><a href="all.html#all_buf_readuint8_offset_noassert">buf.readUInt8(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16le_offset_noassert_1">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16be_offset_noassert_1">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32le_offset_noassert_1">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32be_offset_noassert_1">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint8_offset_noassert">buf.readInt8(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16le_offset_noassert">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16be_offset_noassert">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16le_offset_noassert_1">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16be_offset_noassert_1">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32le_offset_noassert">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32be_offset_noassert">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32le_offset_noassert_1">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32be_offset_noassert_1">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatle_offset_noassert">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatle_offset_noassert_1">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatbe_offset_noassert_1">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublele_offset_noassert_1">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublebe_offset_noassert_1">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16le_value_offset_noassert_1">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16be_value_offset_noassert_1">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32le_value_offset_noassert_1">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32be_value_offset_noassert_1">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16le_value_offset_noassert_1">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16be_value_offset_noassert_1">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32le_value_offset_noassert_1">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32be_value_offset_noassert_1">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatle_value_offset_noassert_1">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatbe_value_offset_noassert_1">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublele_value_offset_noassert_1">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublebe_value_offset_noassert_1">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_fill_value_offset_end">buf.fill(value, [offset], [end])</a></li>
</ul>
</li>
<li><a href="all.html#all_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="all.html#all_slowbuffer">类: SlowBuffer</a></li>
</ul>
</li>
<li><a href="all.html#all_17">流</a><ul>
<li><a href="all.html#all_api">面向流消费者的 API</a><ul>
<li><a href="all.html#all_stream_readable">类: stream.Readable</a><ul>
<li><a href="all.html#all_readable">事件: &apos;readable&apos;</a></li>
<li><a href="all.html#all_data">事件: &apos;data&apos;</a></li>
<li><a href="all.html#all_end">事件: &apos;end&apos;</a></li>
<li><a href="all.html#all_close">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_error_1">事件: &apos;error&apos;</a></li>
<li><a href="all.html#all_readable_read_size">readable.read([size])</a></li>
<li><a href="all.html#all_readable_setencoding_encoding">readable.setEncoding(encoding)</a></li>
<li><a href="all.html#all_readable_resume">readable.resume()</a></li>
<li><a href="all.html#all_readable_pause">readable.pause()</a></li>
<li><a href="all.html#all_readable_pipe_destination_options">readable.pipe(destination, [options])</a></li>
<li><a href="all.html#all_readable_unpipe_destination">readable.unpipe([destination])</a></li>
<li><a href="all.html#all_readable_unshift_chunk">readable.unshift(chunk)</a></li>
<li><a href="all.html#all_readable_wrap_stream">readable.wrap(stream)</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_writable">类: stream.Writable</a><ul>
<li><a href="all.html#all_writable_write_chunk_encoding_callback">writable.write(chunk, [encoding], [callback])</a></li>
<li><a href="all.html#all_drain">事件: &apos;drain&apos;</a></li>
<li><a href="all.html#all_writable_cork">writable.cork()</a></li>
<li><a href="all.html#all_writable_uncork">writable.uncork()</a></li>
<li><a href="all.html#all_writable_end_chunk_encoding_callback">writable.end([chunk], [encoding], [callback])</a></li>
<li><a href="all.html#all_finish">事件: &apos;finish&apos;</a></li>
<li><a href="all.html#all_pipe">事件: &apos;pipe&apos;</a></li>
<li><a href="all.html#all_unpipe">事件: &apos;unpipe&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_duplex">类: stream.Duplex</a></li>
<li><a href="all.html#all_stream_transform">类: stream.Transform</a></li>
</ul>
</li>
<li><a href="all.html#all_api_1">面向流实现者的 API</a><ul>
<li><a href="all.html#all_stream_readable_1">类: stream.Readable</a><ul>
<li><a href="all.html#all_18">例子: 一个计数流</a></li>
<li><a href="all.html#all_simpleprotocol_v1_sub_optimal">例子: SimpleProtocol v1 (Sub-optimal)</a></li>
<li><a href="all.html#all_new_stream_readable_options">new stream.Readable([options])</a></li>
<li><a href="all.html#all_readable_read_size_1">readable._read(size)</a></li>
<li><a href="all.html#all_readable_push_chunk_encoding">readable.push(chunk, [encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_writable_1">类: stream.Writable</a><ul>
<li><a href="all.html#all_new_stream_writable_options">new stream.Writable([options])</a></li>
<li><a href="all.html#all_writable_write_chunk_encoding_callback_1">writable._write(chunk, encoding, callback)</a></li>
</ul>
</li>
<li><a href="all.html#all_writable_writev_chunks_callback">writable._writev(chunks, callback)</a></li>
<li><a href="all.html#all_stream_duplex_1">类: stream.Duplex</a><ul>
<li><a href="all.html#all_new_stream_duplex_options">new stream.Duplex(options)</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_transform_1">类: stream.Transform</a><ul>
<li><a href="all.html#all_new_stream_transform_options">new stream.Transform([options])</a></li>
<li><a href="all.html#all_transform_transform_chunk_encoding_callback">transform._transform(chunk, encoding, callback)</a></li>
<li><a href="all.html#all_transform_flush_callback">transform._flush(callback)</a></li>
<li><a href="all.html#all_simpleprotocol_v2">例子: <code>SimpleProtocol</code> 解析器 v2</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_passthrough">类: stream.PassThrough</a></li>
</ul>
</li>
<li><a href="all.html#all_19">流：内部细节</a><ul>
<li><a href="all.html#all_20">缓冲</a></li>
<li><a href="all.html#all_stream_read_0"><code>stream.read(0)</code></a></li>
<li><a href="all.html#all_stream_push"><code>stream.push(&apos;&apos;)</code></a></li>
<li><a href="all.html#all_node">与 Node 早期版本的兼容性</a></li>
<li><a href="all.html#all_21">对象模式</a></li>
<li><a href="all.html#all_22">状态对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_crypto">加密（Crypto）</a><ul>
<li><a href="all.html#all_crypto_getciphers">crypto.getCiphers()</a></li>
<li><a href="all.html#all_crypto_gethashes">crypto.getHashes()</a></li>
<li><a href="all.html#all_crypto_createcredentials_details">crypto.createCredentials(details)</a></li>
<li><a href="all.html#all_crypto_createhash_algorithm">crypto.createHash(algorithm)</a></li>
<li><a href="all.html#all_hash">类: Hash</a><ul>
<li><a href="all.html#all_hash_update_data_input_encoding">hash.update(data, [input_encoding])</a></li>
<li><a href="all.html#all_hash_digest_encoding">hash.digest([encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createhmac_algorithm_key">crypto.createHmac(algorithm, key)</a></li>
<li><a href="all.html#all_class_hmac">Class: Hmac</a><ul>
<li><a href="all.html#all_hmac_update_data">hmac.update(data)</a></li>
<li><a href="all.html#all_hmac_digest_encoding">hmac.digest([encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createcipher_algorithm_password">crypto.createCipher(algorithm, password)</a></li>
<li><a href="all.html#all_crypto_createcipheriv_algorithm_key_iv">crypto.createCipheriv(algorithm, key, iv)</a></li>
<li><a href="all.html#all_class_cipher">Class: Cipher</a><ul>
<li><a href="all.html#all_cipher_update_data_input_encoding_output_encoding">cipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="all.html#all_cipher_final_output_encoding">cipher.final([output_encoding])</a></li>
<li><a href="all.html#all_cipher_setautopadding_auto_padding_true">cipher.setAutoPadding(auto_padding=true)</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createdecipher_algorithm_password">crypto.createDecipher(algorithm, password)</a></li>
<li><a href="all.html#all_crypto_createdecipheriv_algorithm_key_iv">crypto.createDecipheriv(algorithm, key, iv)</a></li>
<li><a href="all.html#all_class_decipher">Class: Decipher</a><ul>
<li><a href="all.html#all_decipher_update_data_input_encoding_output_encoding">decipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="all.html#all_decipher_final_output_encoding">decipher.final([output_encoding])</a></li>
<li><a href="all.html#all_decipher_setautopadding_auto_padding_true">decipher.setAutoPadding(auto_padding=true)</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createsign_algorithm">crypto.createSign(algorithm)</a></li>
<li><a href="all.html#all_class_sign">Class: Sign</a><ul>
<li><a href="all.html#all_sign_update_data">sign.update(data)</a></li>
<li><a href="all.html#all_sign_sign_private_key_output_format">sign.sign(private_key, [output_format])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createverify_algorithm">crypto.createVerify(algorithm)</a></li>
<li><a href="all.html#all_class_verify">Class: Verify</a><ul>
<li><a href="all.html#all_verifier_update_data">verifier.update(data)</a></li>
<li><a href="all.html#all_verifier_verify_object_signature_signature_format">verifier.verify(object, signature, [signature_format])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_creatediffiehellman_prime_length">crypto.createDiffieHellman(prime_length)</a></li>
<li><a href="all.html#all_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman(prime, [encoding])</a></li>
<li><a href="all.html#all_class_diffiehellman">Class: DiffieHellman</a><ul>
<li><a href="all.html#all_diffiehellman_generatekeys_encoding">diffieHellman.generateKeys([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getprime_encoding">diffieHellman.getPrime([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getgenerator_encoding">diffieHellman.getGenerator([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getpublickey_encoding">diffieHellman.getPublicKey([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getprivatekey_encoding">diffieHellman.getPrivateKey([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey(public_key, [encoding])</a></li>
<li><a href="all.html#all_diffiehellman_setprivatekey_private_key_encoding">diffieHellman.setPrivateKey(private_key, [encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_getdiffiehellman_group_name">crypto.getDiffieHellman(group_name)</a></li>
<li><a href="all.html#all_crypto_pbkdf2_password_salt_iterations_keylen_callback">crypto.pbkdf2(password, salt, iterations, keylen, callback)</a></li>
<li><a href="all.html#all_crypto_pbkdf2sync_password_salt_iterations_keylen">crypto.pbkdf2Sync(password, salt, iterations, keylen)</a></li>
<li><a href="all.html#all_crypto_randombytes_size_callback">crypto.randomBytes(size, [callback])</a></li>
<li><a href="all.html#all_crypto_pseudorandombytes_size_callback">crypto.pseudoRandomBytes(size, [callback])</a></li>
<li><a href="all.html#all_crypto_default_encoding">crypto.DEFAULT_ENCODING</a></li>
<li><a href="all.html#all_recent_api_changes">Recent API Changes</a></li>
</ul>
</li>
<li><a href="all.html#all_tls_ssl">TLS (SSL)</a><ul>
<li><a href="all.html#all_client_initiated_renegotiation_attack_mitigation">Client-initiated renegotiation attack mitigation</a></li>
<li><a href="all.html#all_npn_sni">NPN 和 SNI</a></li>
<li><a href="all.html#all_tls_getciphers">tls.getCiphers()</a></li>
<li><a href="all.html#all_tls_createserver_options_secureconnectionlistener">tls.createServer(options, [secureConnectionListener])</a></li>
<li><a href="all.html#all_tls_connect_options_callback">tls.connect(options, [callback])</a></li>
<li><a href="all.html#all_tls_connect_port_host_options_callback">tls.connect(port, [host], [options], [callback])</a></li>
<li><a href="all.html#all_tls_connect_options_callback_1">tls.connect(options, [callback])</a></li>
<li><a href="all.html#all_tls_connect_port_host_options_callback_1">tls.connect(port, [host], [options], [callback])</a></li>
<li><a href="all.html#all_tls_tlssocket">类: tls.TLSSocket</a></li>
<li><a href="all.html#all_new_tls_tlssocket_socket_options">new tls.TLSSocket(socket, options)</a></li>
<li><a href="all.html#all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</a></li>
<li><a href="all.html#all_securepair">类: SecurePair</a><ul>
<li><a href="all.html#all_secure">事件: &apos;secure&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_tls_server">类: tls.Server</a><ul>
<li><a href="all.html#all_secureconnection">事件: &apos;secureConnection&apos;</a></li>
<li><a href="all.html#all_event_clienterror">Event: &apos;clientError&apos;</a></li>
<li><a href="all.html#all_newsession">事件: &apos;newSession&apos;</a></li>
<li><a href="all.html#all_resumesession">事件: &apos;resumeSession&apos;</a></li>
<li><a href="all.html#all_server_listen_port_host_callback">server.listen(port, [host], [callback])</a></li>
<li><a href="all.html#all_server_close">server.close()</a></li>
<li><a href="all.html#all_server_address">server.address()</a></li>
<li><a href="all.html#all_server_addcontext_hostname_credentials">server.addContext(hostname, credentials)</a></li>
<li><a href="all.html#all_server_maxconnections">server.maxConnections</a></li>
<li><a href="all.html#all_server_connections">server.connections</a></li>
</ul>
</li>
<li><a href="all.html#all_cryptostream">类: CryptoStream</a><ul>
<li><a href="all.html#all_cryptostream_byteswritten">cryptoStream.bytesWritten</a></li>
</ul>
</li>
<li><a href="all.html#all_tls_tlssocket_1">类: tls.TLSSocket</a><ul>
<li><a href="all.html#all_secureconnect">事件: &apos;secureConnect&apos;</a></li>
<li><a href="all.html#all_tlssocket_authorized">tlsSocket.authorized</a></li>
<li><a href="all.html#all_tlssocket_authorizationerror">tlsSocket.authorizationError</a></li>
<li><a href="all.html#all_tlssocket_getpeercertificate">tlsSocket.getPeerCertificate()</a></li>
<li><a href="all.html#all_tlssocket_getcipher">tlsSocket.getCipher()</a></li>
<li><a href="all.html#all_tlssocket_renegotiate_options_callback">tlsSocket.renegotiate(options, callback)</a></li>
<li><a href="all.html#all_tlssocket_address">tlsSocket.address()</a></li>
<li><a href="all.html#all_tlssocket_remoteaddress">tlsSocket.remoteAddress</a></li>
<li><a href="all.html#all_tlssocket_remoteport">tlsSocket.remotePort</a></li>
<li><a href="all.html#all_tlssocket_localaddress">tlsSocket.localAddress</a></li>
<li><a href="all.html#all_tlssocket_localport">tlsSocket.localPort</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_23">字符串解码器</a><ul>
<li><a href="all.html#all_stringdecoder">类: StringDecoder</a><ul>
<li><a href="all.html#all_decoder_write_buffer">decoder.write(buffer)</a></li>
<li><a href="all.html#all_decoder_end">decoder.end()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_file_system">File System</a><ul>
<li><a href="all.html#all_fs_rename_oldpath_newpath_callback">fs.rename(oldPath, newPath, callback)</a></li>
<li><a href="all.html#all_fs_renamesync_oldpath_newpath">fs.renameSync(oldPath, newPath)</a></li>
<li><a href="all.html#all_fs_ftruncate_fd_len_callback">fs.ftruncate(fd, len, callback)</a></li>
<li><a href="all.html#all_fs_ftruncatesync_fd_len">fs.ftruncateSync(fd, len)</a></li>
<li><a href="all.html#all_fs_truncate_path_len_callback">fs.truncate(path, len, callback)</a></li>
<li><a href="all.html#all_fs_truncatesync_path_len">fs.truncateSync(path, len)</a></li>
<li><a href="all.html#all_fs_chownsync_path_uid_gid">fs.chownSync(path, uid, gid)</a></li>
<li><a href="all.html#all_fs_fchown_fd_uid_gid_callback">fs.fchown(fd, uid, gid, callback)</a></li>
<li><a href="all.html#all_fs_fchownsync_fd_uid_gid">fs.fchownSync(fd, uid, gid)</a></li>
<li><a href="all.html#all_fs_lchown_path_uid_gid_callback">fs.lchown(path, uid, gid, callback)</a></li>
<li><a href="all.html#all_fs_lchownsync_path_uid_gid">fs.lchownSync(path, uid, gid)</a></li>
<li><a href="all.html#all_fs_chmod_path_mode_callback">fs.chmod(path, mode, callback)</a></li>
<li><a href="all.html#all_fs_chmodsync_path_mode">fs.chmodSync(path, mode)</a></li>
<li><a href="all.html#all_fs_fchmod_fd_mode_callback">fs.fchmod(fd, mode, callback)</a></li>
<li><a href="all.html#all_fs_fchmodsync_fd_mode">fs.fchmodSync(fd, mode)</a></li>
<li><a href="all.html#all_fs_lchmod_path_mode_callback">fs.lchmod(path, mode, callback)</a></li>
<li><a href="all.html#all_fs_lchmodsync_path_mode">fs.lchmodSync(path, mode)</a></li>
<li><a href="all.html#all_fs_stat_path_callback">fs.stat(path, callback)</a></li>
<li><a href="all.html#all_fs_lstat_path_callback">fs.lstat(path, callback)</a></li>
<li><a href="all.html#all_fs_fstat_fd_callback">fs.fstat(fd, callback)</a></li>
<li><a href="all.html#all_fs_statsync_path">fs.statSync(path)</a></li>
<li><a href="all.html#all_fs_lstatsync_path">fs.lstatSync(path)</a></li>
<li><a href="all.html#all_fs_fstatsync_fd">fs.fstatSync(fd)</a></li>
<li><a href="all.html#all_fs_link_srcpath_dstpath_callback">fs.link(srcpath, dstpath, callback)</a></li>
<li><a href="all.html#all_fs_linksync_srcpath_dstpath">fs.linkSync(srcpath, dstpath)</a></li>
<li><a href="all.html#all_fs_symlink_srcpath_dstpath_type_callback">fs.symlink(srcpath, dstpath, [type], callback)</a></li>
<li><a href="all.html#all_fs_symlinksync_srcpath_dstpath_type">fs.symlinkSync(srcpath, dstpath, [type])</a></li>
<li><a href="all.html#all_fs_readlink_path_callback">fs.readlink(path, callback)</a></li>
<li><a href="all.html#all_fs_readlinksync_path">fs.readlinkSync(path)</a></li>
<li><a href="all.html#all_fs_realpath_path_cache_callback">fs.realpath(path, [cache], callback)</a></li>
<li><a href="all.html#all_fs_realpathsync_path_cache">fs.realpathSync(path, [cache])</a></li>
<li><a href="all.html#all_fs_unlink_path_callback">fs.unlink(path, callback)</a></li>
<li><a href="all.html#all_fs_unlinksync_path">fs.unlinkSync(path)</a></li>
<li><a href="all.html#all_fs_rmdir_path_callback">fs.rmdir(path, callback)</a></li>
<li><a href="all.html#all_fs_rmdirsync_path">fs.rmdirSync(path)</a></li>
<li><a href="all.html#all_fs_mkdir_path_mode_callback">fs.mkdir(path, [mode], callback)</a></li>
<li><a href="all.html#all_fs_mkdirsync_path_mode">fs.mkdirSync(path, [mode])</a></li>
<li><a href="all.html#all_fs_readdir_path_callback">fs.readdir(path, callback)</a></li>
<li><a href="all.html#all_fs_readdirsync_path">fs.readdirSync(path)</a></li>
<li><a href="all.html#all_fs_close_fd_callback">fs.close(fd, callback)</a></li>
<li><a href="all.html#all_fs_closesync_fd">fs.closeSync(fd)</a></li>
<li><a href="all.html#all_fs_open_path_flags_mode_callback">fs.open(path, flags, [mode], callback)</a></li>
<li><a href="all.html#all_fs_opensync_path_flags_mode">fs.openSync(path, flags, [mode])</a></li>
<li><a href="all.html#all_fs_utimes_path_atime_mtime_callback">fs.utimes(path, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_utimessync_path_atime_mtime">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="all.html#all_fs_utimes_path_atime_mtime_callback_1">fs.utimes(path, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_utimessync_path_atime_mtime_1">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="all.html#all_fs_futimes_fd_atime_mtime_callback">fs.futimes(fd, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_futimessync_fd_atime_mtime">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="all.html#all_fs_futimes_fd_atime_mtime_callback_1">fs.futimes(fd, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_futimessync_fd_atime_mtime_1">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="all.html#all_fs_fsync_fd_callback">fs.fsync(fd, callback)</a></li>
<li><a href="all.html#all_fs_fsyncsync_fd">fs.fsyncSync(fd)</a></li>
<li><a href="all.html#all_fs_write_fd_buffer_offset_length_position_callback">fs.write(fd, buffer, offset, length[, position], callback)</a></li>
<li><a href="all.html#all_fs_write_fd_data_position_encoding_callback">fs.write(fd, data[, position[, encoding]], callback)</a></li>
<li><a href="all.html#all_fs_writesync_fd_buffer_offset_length_position">fs.writeSync(fd, buffer, offset, length[, position])</a></li>
<li><a href="all.html#all_fs_writesync_fd_data_position_encoding">fs.writeSync(fd, data[, position[, encoding]])</a></li>
<li><a href="all.html#all_fs_read_fd_buffer_offset_length_position_callback">fs.read(fd, buffer, offset, length, position, callback)</a></li>
<li><a href="all.html#all_fs_readsync_fd_buffer_offset_length_position">fs.readSync(fd, buffer, offset, length, position)</a></li>
<li><a href="all.html#all_fs_readfile_filename_options_callback">fs.readFile(filename, [options], callback)</a></li>
<li><a href="all.html#all_fs_readfilesync_filename_options">fs.readFileSync(filename, [options])</a></li>
<li><a href="all.html#all_fs_writefile_filename_data_options_callback">fs.writeFile(filename, data, [options], callback)</a></li>
<li><a href="all.html#all_fs_writefilesync_filename_data_options">fs.writeFileSync(filename, data, [options])</a></li>
<li><a href="all.html#all_fs_appendfile_filename_data_options_callback">fs.appendFile(filename, data, [options], callback)</a></li>
<li><a href="all.html#all_fs_appendfilesync_filename_data_options">fs.appendFileSync(filename, data, [options])</a></li>
<li><a href="all.html#all_fs_watchfile_filename_options_listener">fs.watchFile(filename, [options], listener)</a></li>
<li><a href="all.html#all_fs_unwatchfile_filename_listener">fs.unwatchFile(filename, [listener])</a></li>
<li><a href="all.html#all_fs_watch_filename_options_listener">fs.watch(filename, [options], [listener])</a><ul>
<li><a href="all.html#all_24">注意事项</a><ul>
<li><a href="all.html#all_25">可用性</a></li>
<li><a href="all.html#all_26">文件名参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_fs_exists_path_callback">fs.exists(path, callback)</a></li>
<li><a href="all.html#all_fs_existssync_path">fs.existsSync(path)</a></li>
<li><a href="all.html#all_class_fs_stats">Class: fs.Stats</a><ul>
<li><a href="all.html#all_stat_time_values">Stat Time Values</a></li>
</ul>
</li>
<li><a href="all.html#all_fs_createreadstream_path_options">fs.createReadStream(path, [options])</a></li>
<li><a href="all.html#all_class_fs_readstream">Class: fs.ReadStream</a><ul>
<li><a href="all.html#all_open">事件: &apos;open&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_fs_createwritestream_path_options">fs.createWriteStream(path, [options])</a></li>
<li><a href="all.html#all_class_fs_writestream">Class: fs.WriteStream</a><ul>
<li><a href="all.html#all_open_1">事件: &apos;open&apos;</a></li>
<li><a href="all.html#all_file_byteswritten">file.bytesWritten</a></li>
</ul>
</li>
<li><a href="all.html#all_class_fs_fswatcher">Class: fs.FSWatcher</a><ul>
<li><a href="all.html#all_watcher_close">watcher.close()</a></li>
<li><a href="all.html#all_change">事件: &apos;change&apos;</a></li>
<li><a href="all.html#all_error_2">事件: &apos;error&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_path">路径 (Path)</a><ul>
<li><a href="all.html#all_path_normalize_p">path.normalize(p)</a></li>
<li><a href="all.html#all_path_join_path1_path2">path.join([path1], [path2], [...])</a></li>
<li><a href="all.html#all_path_resolve_from_to">path.resolve([from ...], to)</a></li>
<li><a href="all.html#all_path_isabsolute_path">path.isAbsolute(path)</a></li>
<li><a href="all.html#all_path_relative_from_to">path.relative(from, to)</a></li>
<li><a href="all.html#all_path_dirname_p">path.dirname(p)</a></li>
<li><a href="all.html#all_path_basename_p_ext">path.basename(p, [ext])</a></li>
<li><a href="all.html#all_path_extname_p">path.extname(p)</a></li>
<li><a href="all.html#all_path_sep">path.sep</a></li>
<li><a href="all.html#all_path_delimiter">path.delimiter</a></li>
</ul>
</li>
<li><a href="all.html#all_27">网络</a><ul>
<li><a href="all.html#all_net_createserver_options_connectionlistener">net.createServer([options], [connectionListener])</a></li>
<li><a href="all.html#all_net_connect_options_connectionlistener">net.connect(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_createconnection_options_connectionlistener">net.createConnection(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_connect_options_connectionlistener_1">net.connect(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_createconnection_options_connectionlistener_1">net.createConnection(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_connect_port_host_connectlistener">net.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_port_host_connectlistener">net.createConnection(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_connect_port_host_connectlistener_1">net.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_port_host_connectlistener_1">net.createConnection(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_connect_path_connectlistener">net.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_path_connectlistener">net.createConnection(path, [connectListener])</a></li>
<li><a href="all.html#all_net_connect_path_connectlistener_1">net.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_path_connectlistener_1">net.createConnection(path, [connectListener])</a></li>
<li><a href="all.html#all_net_server">类: net.Server</a><ul>
<li><a href="all.html#all_server_listen_port_host_backlog_callback">server.listen(port, [host], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_close_callback">server.close([callback])</a></li>
<li><a href="all.html#all_server_address_1">server.address()</a></li>
<li><a href="all.html#all_server_unref">server.unref()</a></li>
<li><a href="all.html#all_server_ref">server.ref()</a></li>
<li><a href="all.html#all_server_maxconnections_1">server.maxConnections</a></li>
<li><a href="all.html#all_server_connections_1">server.connections</a></li>
<li><a href="all.html#all_server_getconnections_callback">server.getConnections(callback)</a></li>
<li><a href="all.html#all_listening">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_connection">事件: &apos;connection&apos;</a></li>
<li><a href="all.html#all_close_1">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_error_3">事件: &apos;error&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_net_socket">类: net.Socket</a><ul>
<li><a href="all.html#all_new_net_socket_options">new net.Socket([options])</a></li>
<li><a href="all.html#all_socket_connect_port_host_connectlistener">socket.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_socket_connect_path_connectlistener">socket.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_socket_connect_port_host_connectlistener_1">socket.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_socket_connect_path_connectlistener_1">socket.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_socket_buffersize">socket.bufferSize</a></li>
<li><a href="all.html#all_socket_setencoding_encoding">socket.setEncoding([encoding])</a></li>
<li><a href="all.html#all_socket_write_data_encoding_callback">socket.write(data, [encoding], [callback])</a></li>
<li><a href="all.html#all_socket_end_data_encoding">socket.end([data], [encoding])</a></li>
<li><a href="all.html#all_socket_destroy">socket.destroy()</a></li>
<li><a href="all.html#all_socket_pause">socket.pause()</a></li>
<li><a href="all.html#all_socket_resume">socket.resume()</a></li>
<li><a href="all.html#all_socket_settimeout_timeout_callback">socket.setTimeout(timeout, [callback])</a></li>
<li><a href="all.html#all_socket_setnodelay_nodelay">socket.setNoDelay([noDelay])</a></li>
<li><a href="all.html#all_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive([enable], [initialDelay])</a></li>
<li><a href="all.html#all_socket_address">socket.address()</a></li>
<li><a href="all.html#all_socket_unref">socket.unref()</a></li>
<li><a href="all.html#all_socket_ref">socket.ref()</a></li>
<li><a href="all.html#all_socket_remoteaddress">socket.remoteAddress</a></li>
<li><a href="all.html#all_socket_remoteport">socket.remotePort</a></li>
<li><a href="all.html#all_socket_localaddress">socket.localAddress</a></li>
<li><a href="all.html#all_socket_localport">socket.localPort</a></li>
<li><a href="all.html#all_socket_bytesread">socket.bytesRead</a></li>
<li><a href="all.html#all_socket_byteswritten">socket.bytesWritten</a></li>
<li><a href="all.html#all_lookup">事件: &apos;lookup&apos;</a></li>
<li><a href="all.html#all_connect">事件: &apos;connect&apos;</a></li>
<li><a href="all.html#all_data_1">事件: &apos;data&apos;</a></li>
<li><a href="all.html#all_end_1">事件: &apos;end&apos;</a></li>
<li><a href="all.html#all_timeout">事件: &apos;timeout&apos;</a></li>
<li><a href="all.html#all_drain_1">事件: &apos;drain&apos;</a></li>
<li><a href="all.html#all_error_4">事件: &apos;error&apos;</a></li>
<li><a href="all.html#all_close_2">事件: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_net_isip_input">net.isIP(input)</a></li>
<li><a href="all.html#all_net_isipv4_input">net.isIPv4(input)</a></li>
<li><a href="all.html#all_net_isipv6_input">net.isIPv6(input)</a></li>
</ul>
</li>
<li><a href="all.html#all_udp">UDP / 数据报套接字</a><ul>
<li><a href="all.html#all_dgram_createsocket_type_callback">dgram.createSocket(type, [callback])</a></li>
<li><a href="all.html#all_dgram_socket">类: dgram.Socket</a><ul>
<li><a href="all.html#all_message">事件: &apos;message&apos;</a></li>
<li><a href="all.html#all_listening_1">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_close_3">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_error_5">事件: &apos;error&apos;</a></li>
<li><a href="all.html#all_socket_send_buf_offset_length_port_address_callback">socket.send(buf, offset, length, port, address, [callback])</a></li>
<li><a href="all.html#all_socket_bind_port_address_callback">socket.bind(port, [address], [callback])</a></li>
<li><a href="all.html#all_socket_close">socket.close()</a></li>
<li><a href="all.html#all_socket_address_1">socket.address()</a></li>
<li><a href="all.html#all_socket_setbroadcast_flag">socket.setBroadcast(flag)</a></li>
<li><a href="all.html#all_socket_setttl_ttl">socket.setTTL(ttl)</a></li>
<li><a href="all.html#all_socket_setmulticastttl_ttl">socket.setMulticastTTL(ttl)</a></li>
<li><a href="all.html#all_socket_setmulticastloopback_flag">socket.setMulticastLoopback(flag)</a></li>
<li><a href="all.html#all_socket_addmembership_multicastaddress_multicastinterface">socket.addMembership(multicastAddress, [multicastInterface])</a></li>
<li><a href="all.html#all_socket_dropmembership_multicastaddress_multicastinterface">socket.dropMembership(multicastAddress, [multicastInterface])</a></li>
<li><a href="all.html#all_socket_unref_1">socket.unref()</a></li>
<li><a href="all.html#all_socket_ref_1">socket.ref()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_dns">DNS</a><ul>
<li><a href="all.html#all_dns_lookup_domain_family_callback">dns.lookup(domain, [family], callback)</a></li>
<li><a href="all.html#all_dns_resolve_domain_rrtype_callback">dns.resolve(domain, [rrtype], callback)</a></li>
<li><a href="all.html#all_dns_resolve4_domain_callback">dns.resolve4(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolve6_domain_callback">dns.resolve6(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvemx_domain_callback">dns.resolveMx(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvetxt_domain_callback">dns.resolveTxt(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvesrv_domain_callback">dns.resolveSrv(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvens_domain_callback">dns.resolveNs(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvecname_domain_callback">dns.resolveCname(domain, callback)</a></li>
<li><a href="all.html#all_dns_reverse_ip_callback">dns.reverse(ip, callback)</a></li>
<li><a href="all.html#all_dns_getservers">dns.getServers()</a></li>
<li><a href="all.html#all_dns_setservers_servers">dns.setServers(servers)</a></li>
<li><a href="all.html#all_28">错误代码</a></li>
</ul>
</li>
<li><a href="all.html#all_http">HTTP</a><ul>
<li><a href="all.html#all_http_status_codes">http.STATUS_CODES</a></li>
<li><a href="all.html#all_http_createserver_requestlistener">http.createServer([requestListener])</a></li>
<li><a href="all.html#all_http_createclient_port_host">http.createClient([port], [host])</a></li>
<li><a href="all.html#all_class_http_server">Class: http.Server</a><ul>
<li><a href="all.html#all_event_request">Event: &apos;request&apos;</a></li>
<li><a href="all.html#all_connection_1">事件: &apos;connection&apos;</a></li>
<li><a href="all.html#all_close_4">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_event_checkcontinue">Event: &apos;checkContinue&apos;</a></li>
<li><a href="all.html#all_connect_1">事件: &apos;connect&apos;</a></li>
<li><a href="all.html#all_event_upgrade">Event: &apos;upgrade&apos;</a></li>
<li><a href="all.html#all_event_clienterror_1">Event: &apos;clientError&apos;</a></li>
<li><a href="all.html#all_server_listen_port_hostname_backlog_callback">server.listen(port, [hostname], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback_1">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback_1">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_close_callback_1">server.close([callback])</a></li>
<li><a href="all.html#all_server_maxheaderscount">server.maxHeadersCount</a></li>
<li><a href="all.html#all_server_settimeout_msecs_callback">server.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_server_timeout">server.timeout</a></li>
</ul>
</li>
<li><a href="all.html#all_class_http_serverresponse">Class: http.ServerResponse</a><ul>
<li><a href="all.html#all_close_5">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_response_writecontinue">response.writeContinue()</a></li>
<li><a href="all.html#all_response_writehead_statuscode_reasonphrase_headers">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li>
<li><a href="all.html#all_response_settimeout_msecs_callback">response.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_response_statuscode">response.statusCode</a></li>
<li><a href="all.html#all_response_setheader_name_value">response.setHeader(name, value)</a></li>
<li><a href="all.html#all_response_headerssent">response.headersSent</a></li>
<li><a href="all.html#all_response_senddate">response.sendDate</a></li>
<li><a href="all.html#all_response_getheader_name">response.getHeader(name)</a></li>
<li><a href="all.html#all_response_removeheader_name">response.removeHeader(name)</a></li>
<li><a href="all.html#all_response_write_chunk_encoding">response.write(chunk, [encoding])</a></li>
<li><a href="all.html#all_response_addtrailers_headers">response.addTrailers(headers)</a></li>
<li><a href="all.html#all_response_end_data_encoding">response.end([data], [encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_http_request_options_callback">http.request(options, callback)</a></li>
<li><a href="all.html#all_http_get_options_callback">http.get(options, callback)</a></li>
<li><a href="all.html#all_class_http_agent">Class: http.Agent</a><ul>
<li><a href="all.html#all_new_agent_options">new Agent([options])</a></li>
<li><a href="all.html#all_agent_maxsockets">agent.maxSockets</a></li>
<li><a href="all.html#all_agent_maxfreesockets">agent.maxFreeSockets</a></li>
<li><a href="all.html#all_agent_sockets">agent.sockets</a></li>
<li><a href="all.html#all_agent_freesockets">agent.freeSockets</a></li>
<li><a href="all.html#all_agent_requests">agent.requests</a></li>
<li><a href="all.html#all_agent_destroy">agent.destroy()</a></li>
<li><a href="all.html#all_agent_getname_options">agent.getName(options)</a></li>
</ul>
</li>
<li><a href="all.html#all_http_globalagent">http.globalAgent</a></li>
<li><a href="all.html#all_class_http_clientrequest">Class: http.ClientRequest</a><ul>
<li><a href="all.html#all_event_response">Event &apos;response&apos;</a></li>
<li><a href="all.html#all_event_socket">Event: &apos;socket&apos;</a></li>
<li><a href="all.html#all_connect_2">事件: &apos;connect&apos;</a></li>
<li><a href="all.html#all_event_upgrade_1">Event: &apos;upgrade&apos;</a></li>
<li><a href="all.html#all_event_continue">Event: &apos;continue&apos;</a></li>
<li><a href="all.html#all_request_write_chunk_encoding">request.write(chunk, [encoding])</a></li>
<li><a href="all.html#all_request_end_data_encoding">request.end([data], [encoding])</a></li>
<li><a href="all.html#all_request_abort">request.abort()</a></li>
<li><a href="all.html#all_request_settimeout_timeout_callback">request.setTimeout(timeout, [callback])</a></li>
<li><a href="all.html#all_request_setnodelay_nodelay">request.setNoDelay([noDelay])</a></li>
<li><a href="all.html#all_request_setsocketkeepalive_enable_initialdelay">request.setSocketKeepAlive([enable], [initialDelay])</a></li>
</ul>
</li>
<li><a href="all.html#all_http_incomingmessage">http.IncomingMessage</a><ul>
<li><a href="all.html#all_close_6">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_message_httpversion">message.httpVersion</a></li>
<li><a href="all.html#all_message_headers">message.headers</a></li>
<li><a href="all.html#all_message_rawheaders">message.rawHeaders</a></li>
<li><a href="all.html#all_message_trailers">message.trailers</a></li>
<li><a href="all.html#all_message_rawtrailers">message.rawTrailers</a></li>
<li><a href="all.html#all_message_settimeout_msecs_callback">message.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_message_method">message.method</a></li>
<li><a href="all.html#all_message_url">message.url</a></li>
<li><a href="all.html#all_message_statuscode">message.statusCode</a></li>
<li><a href="all.html#all_message_socket">message.socket</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_https">HTTPS</a><ul>
<li><a href="all.html#all_https_server">类: https.Server</a><ul>
<li><a href="all.html#all_server_settimeout_msecs_callback_1">server.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_server_timeout_1">server.timeout</a></li>
</ul>
</li>
<li><a href="all.html#all_https_createserver_options_requestlistener">https.createServer(options, [requestListener])</a><ul>
<li><a href="all.html#all_server_listen_port_host_backlog_callback_1">server.listen(port, [host], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback_2">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback_2">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_listen_port_host_backlog_callback_2">server.listen(port, [host], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback_3">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback_3">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_close_callback_2">server.close([callback])</a></li>
</ul>
</li>
<li><a href="all.html#all_https_request_options_callback">https.request(options, callback)</a></li>
<li><a href="all.html#all_https_get_options_callback">https.get(options, callback)</a></li>
<li><a href="all.html#all_https_agent">类: https.Agent</a></li>
<li><a href="all.html#all_https_globalagent">https.globalAgent</a></li>
</ul>
</li>
<li><a href="all.html#all_url">URL</a><ul>
<li><a href="all.html#all_url_parse_urlstr_parsequerystring_slashesdenotehost">url.parse(urlStr, [parseQueryString], [slashesDenoteHost])</a></li>
<li><a href="all.html#all_url_format_urlobj">url.format(urlObj)</a></li>
<li><a href="all.html#all_url_resolve_from_to">url.resolve(from, to)</a></li>
</ul>
</li>
<li><a href="all.html#all_query_string">Query String</a><ul>
<li><a href="all.html#all_querystring_stringify_obj_sep_eq">querystring.stringify(obj, [sep], [eq])</a></li>
<li><a href="all.html#all_querystring_parse_str_sep_eq_options">querystring.parse(str, [sep], [eq], [options])</a></li>
<li><a href="all.html#all_querystring_escape">querystring.escape</a></li>
<li><a href="all.html#all_querystring_unescape">querystring.unescape</a></li>
</ul>
</li>
<li><a href="all.html#all_punycode">punycode</a><ul>
<li><a href="all.html#all_punycode_decode_string">punycode.decode(string)</a></li>
<li><a href="all.html#all_punycode_encode_string">punycode.encode(string)</a></li>
<li><a href="all.html#all_punycode_tounicode_domain">punycode.toUnicode(domain)</a></li>
<li><a href="all.html#all_punycode_toascii_domain">punycode.toASCII(domain)</a></li>
<li><a href="all.html#all_punycode_ucs2">punycode.ucs2</a><ul>
<li><a href="all.html#all_punycode_ucs2_decode_string">punycode.ucs2.decode(string)</a></li>
<li><a href="all.html#all_punycode_ucs2_encode_codepoints">punycode.ucs2.encode(codePoints)</a></li>
</ul>
</li>
<li><a href="all.html#all_punycode_version">punycode.version</a></li>
</ul>
</li>
<li><a href="all.html#all_readline">Readline</a><ul>
<li><a href="all.html#all_readline_createinterface_options">readline.createInterface(options)</a></li>
<li><a href="all.html#all_29">类: 接口</a><ul>
<li><a href="all.html#all_rl_setprompt_prompt">rl.setPrompt(prompt)</a></li>
<li><a href="all.html#all_rl_prompt_preservecursor">rl.prompt([preserveCursor])</a></li>
<li><a href="all.html#all_rl_question_query_callback">rl.question(query, callback)</a></li>
<li><a href="all.html#all_rl_pause">rl.pause()</a></li>
<li><a href="all.html#all_rl_resume">rl.resume()</a></li>
<li><a href="all.html#all_rl_close">rl.close()</a></li>
<li><a href="all.html#all_rl_write_data_key">rl.write(data, [key])</a></li>
</ul>
</li>
<li><a href="all.html#all_events">Events</a><ul>
<li><a href="all.html#all_event_line">Event: &apos;line&apos;</a></li>
<li><a href="all.html#all_pause">事件: &apos;pause&apos;</a></li>
<li><a href="all.html#all_resume">事件: &apos;resume&apos;</a></li>
<li><a href="all.html#all_close_7">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_event_sigint">Event: &apos;SIGINT&apos;</a></li>
<li><a href="all.html#all_event_sigtstp">Event: &apos;SIGTSTP&apos;</a></li>
<li><a href="all.html#all_event_sigcont">Event: &apos;SIGCONT&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_tiny_cli">示例: Tiny CLI</a></li>
</ul>
</li>
<li><a href="all.html#all_repl">REPL</a><ul>
<li><a href="all.html#all_repl_start_options">repl.start(options)</a><ul>
<li><a href="all.html#all_exit_1">事件: &apos;exit&apos;</a></li>
<li><a href="all.html#all_reset">事件: &apos;reset&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_repl_1">REPL 特性</a></li>
</ul>
</li>
<li><a href="all.html#all_javascript">执行 JavaScript</a><ul>
<li><a href="all.html#all_vm_runinthiscontext_code_options">vm.runInThisContext(code, [options])</a></li>
<li><a href="all.html#all_vm_createcontext_sandbox">vm.createContext([sandbox])</a></li>
<li><a href="all.html#all_vm_iscontext_sandbox">vm.isContext(sandbox)</a></li>
<li><a href="all.html#all_vm_runincontext_code_contextifiedsandbox_options">vm.runInContext(code, contextifiedSandbox, [options])</a></li>
<li><a href="all.html#all_vm_runinnewcontext_code_sandbox_options">vm.runInNewContext(code, [sandbox], [options])</a></li>
<li><a href="all.html#all_script">类: Script</a><ul>
<li><a href="all.html#all_new_vm_script_code_options">new vm.Script(code, options)</a></li>
<li><a href="all.html#all_script_runinthiscontext_options">script.runInThisContext([options])</a></li>
<li><a href="all.html#all_script_runincontext_contextifiedsandbox_options">script.runInContext(contextifiedSandbox, [options])</a></li>
<li><a href="all.html#all_script_runinnewcontext_sandbox_options">script.runInNewContext([sandbox], [options])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_30">子进程</a><ul>
<li><a href="all.html#all_childprocess">类: ChildProcess</a><ul>
<li><a href="all.html#all_error_6">事件:  &apos;error&apos;</a></li>
<li><a href="all.html#all_exit_2">事件:  &apos;exit&apos;</a></li>
<li><a href="all.html#all_close_8">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_disconnect">事件: &apos;disconnect&apos;</a></li>
<li><a href="all.html#all_message_1">事件: &apos;message&apos;</a></li>
<li><a href="all.html#all_child_stdin">child.stdin</a></li>
<li><a href="all.html#all_child_stdout">child.stdout</a></li>
<li><a href="all.html#all_child_stderr">child.stderr</a></li>
<li><a href="all.html#all_child_pid">child.pid</a></li>
<li><a href="all.html#all_child_kill_signal">child.kill([signal])</a></li>
<li><a href="all.html#all_child_send_message_sendhandle">child.send(message, [sendHandle])</a><ul>
<li><a href="all.html#all_server">例子: 发送一个server对象</a></li>
<li><a href="all.html#all_socket">示例: 发送socket对象</a></li>
</ul>
</li>
<li><a href="all.html#all_child_disconnect">child.disconnect()</a></li>
</ul>
</li>
<li><a href="all.html#all_child_process_spawn_command_args_options">child_process.spawn(command, [args], [options])</a></li>
<li><a href="all.html#all_child_process_exec_command_options_callback">child_process.exec(command, [options], callback)</a></li>
<li><a href="all.html#all_child_process_execfile_file_args_options_callback">child_process.execFile(file, args, options, callback)</a></li>
<li><a href="all.html#all_child_process_fork_modulepath_args_options">child_process.fork(modulePath, [args], [options])</a></li>
</ul>
</li>
<li><a href="all.html#all_assert">断言 (assert)</a><ul>
<li><a href="all.html#all_assert_fail_actual_expected_message_operator">assert.fail(actual, expected, message, operator)</a></li>
<li><a href="all.html#all_assert_value_message_assert_ok_value_message">assert(value, message), assert.ok(value, [message])</a></li>
<li><a href="all.html#all_assert_equal_actual_expected_message">assert.equal(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_notequal_actual_expected_message">assert.notEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_deepequal_actual_expected_message">assert.deepEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_notdeepequal_actual_expected_message">assert.notDeepEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_strictequal_actual_expected_message">assert.strictEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_notstrictequal_actual_expected_message">assert.notStrictEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_throws_block_error_message">assert.throws(block, [error], [message])</a></li>
<li><a href="all.html#all_assert_doesnotthrow_block_message">assert.doesNotThrow(block, [message])</a></li>
<li><a href="all.html#all_assert_iferror_value">assert.ifError(value)</a></li>
</ul>
</li>
<li><a href="all.html#all_tty">TTY</a><ul>
<li><a href="all.html#all_tty_isatty_fd">tty.isatty(fd)</a></li>
<li><a href="all.html#all_tty_setrawmode_mode">tty.setRawMode(mode)</a></li>
<li><a href="all.html#all_readstream">类: ReadStream</a><ul>
<li><a href="all.html#all_rs_israw">rs.isRaw</a></li>
<li><a href="all.html#all_rs_setrawmode_mode">rs.setRawMode(mode)</a></li>
</ul>
</li>
<li><a href="all.html#all_writestream">类: WriteStream</a><ul>
<li><a href="all.html#all_ws_columns">ws.columns</a></li>
<li><a href="all.html#all_ws_rows">ws.rows</a></li>
<li><a href="all.html#all_resize">事件: &apos;resize&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_zlib">Zlib</a><ul>
<li><a href="all.html#all_31">例子</a></li>
<li><a href="all.html#all_zlib_creategzip_options">zlib.createGzip([options])</a></li>
<li><a href="all.html#all_zlib_creategunzip_options">zlib.createGunzip([options])</a></li>
<li><a href="all.html#all_zlib_createdeflate_options">zlib.createDeflate([options])</a></li>
<li><a href="all.html#all_zlib_createinflate_options">zlib.createInflate([options])</a></li>
<li><a href="all.html#all_zlib_createdeflateraw_options">zlib.createDeflateRaw([options])</a></li>
<li><a href="all.html#all_zlib_createinflateraw_options">zlib.createInflateRaw([options])</a></li>
<li><a href="all.html#all_zlib_createunzip_options">zlib.createUnzip([options])</a></li>
<li><a href="all.html#all_zlib_zlib">类: zlib.Zlib</a><ul>
<li><a href="all.html#all_zlib_flush_kind_callback">zlib.flush([kind], callback)</a></li>
<li><a href="all.html#all_zlib_params_level_strategy_callback">zlib.params(level, strategy, callback)</a></li>
<li><a href="all.html#all_zlib_reset">zlib.reset()</a></li>
</ul>
</li>
<li><a href="all.html#all_zlib_gzip">类: zlib.Gzip</a></li>
<li><a href="all.html#all_zlib_gunzip">类: zlib.Gunzip</a></li>
<li><a href="all.html#all_zlib_deflate">类: zlib.Deflate</a></li>
<li><a href="all.html#all_zlib_inflate">类: zlib.Inflate</a></li>
<li><a href="all.html#all_zlib_deflateraw">类: zlib.DeflateRaw</a></li>
<li><a href="all.html#all_zlib_inflateraw">类: zlib.InflateRaw</a></li>
<li><a href="all.html#all_zlib_unzip">类: zlib.Unzip</a></li>
<li><a href="all.html#all_32">快捷方法</a></li>
<li><a href="all.html#all_zlib_deflate_buf_options_callback">zlib.deflate(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_deflateraw_buf_options_callback">zlib.deflateRaw(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_gzip_buf_options_callback">zlib.Gzip(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_gunzip_buf_options_callback">zlib.gunzip(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_inflate_buf_options_callback">zlib.inflate(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_inflateraw_buf_options_callback">zlib.inflateRaw(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_unzip_buf_options_callback">zlib.unzip(buf, [options], callback)</a></li>
<li><a href="all.html#all_33">选项</a></li>
<li><a href="all.html#all_34">内存使用调优</a></li>
<li><a href="all.html#all_35">常量</a></li>
</ul>
</li>
<li><a href="all.html#all_36">操作系统</a><ul>
<li><a href="all.html#all_os_tmpdir">os.tmpdir()</a></li>
<li><a href="all.html#all_os_endianness">os.endianness()</a></li>
<li><a href="all.html#all_os_hostname">os.hostname()</a></li>
<li><a href="all.html#all_os_type">os.type()</a></li>
<li><a href="all.html#all_os_platform">os.platform()</a></li>
<li><a href="all.html#all_os_arch">os.arch()</a></li>
<li><a href="all.html#all_os_release">os.release()</a></li>
<li><a href="all.html#all_os_uptime">os.uptime()</a></li>
<li><a href="all.html#all_os_loadavg">os.loadavg()</a></li>
<li><a href="all.html#all_os_totalmem">os.totalmem()</a></li>
<li><a href="all.html#all_os_freemem">os.freemem()</a></li>
<li><a href="all.html#all_os_cpus">os.cpus()</a></li>
<li><a href="all.html#all_os_networkinterfaces">os.networkInterfaces()</a></li>
<li><a href="all.html#all_os_eol">os.EOL</a></li>
</ul>
</li>
<li><a href="all.html#all_37">调试器</a><ul>
<li><a href="all.html#all_38">监视器</a></li>
<li><a href="all.html#all_39">命令参考</a><ul>
<li><a href="all.html#all_40">步进</a></li>
<li><a href="all.html#all_41">断点</a></li>
<li><a href="all.html#all_42">信息</a></li>
<li><a href="all.html#all_43">执行控制</a></li>
<li><a href="all.html#all_44">杂项</a></li>
</ul>
</li>
<li><a href="all.html#all_45">高级使用</a></li>
</ul>
</li>
<li><a href="all.html#all_46">集群</a><ul>
<li><a href="all.html#all_47">它是如何工作的</a></li>
<li><a href="all.html#all_cluster_schedulingpolicy">cluster.schedulingPolicy</a></li>
<li><a href="all.html#all_cluster_settings">cluster.settings</a></li>
<li><a href="all.html#all_48">集群的主进程(判断当前进程是否是主进程)</a></li>
<li><a href="all.html#all_49">集群的主线程(判断当前线程是否是主线程)</a></li>
<li><a href="all.html#all_fork">事件: &apos;fork&apos;</a></li>
<li><a href="all.html#all_online">事件: &apos;online&apos;</a></li>
<li><a href="all.html#all_listening_2">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_disconnect_1">事件: &apos;disconnect&apos;</a></li>
<li><a href="all.html#all_exit_3">事件: &apos;exit&apos;</a></li>
<li><a href="all.html#all_setup">事件: &apos;setup&apos;</a></li>
<li><a href="all.html#all_cluster_setupmaster_settings">cluster.setupMaster([settings])</a></li>
<li><a href="all.html#all_cluster_fork_env">cluster.fork([env])</a></li>
<li><a href="all.html#all_cluster_disconnect_callback">cluster.disconnect([callback])</a></li>
<li><a href="all.html#all_cluster_worker">cluster.worker</a></li>
<li><a href="all.html#all_cluster_workers">cluster.workers</a></li>
<li><a href="all.html#all_worker">类: Worker</a><ul>
<li><a href="all.html#all_worker_id">worker.id</a></li>
<li><a href="all.html#all_worker_process">worker.process</a></li>
<li><a href="all.html#all_worker_suicide">worker.suicide</a></li>
<li><a href="all.html#all_worker_send_message_sendhandle">worker.send(message, [sendHandle])</a></li>
<li><a href="all.html#all_worker_kill_signal_sigterm">worker.kill([signal=&apos;SIGTERM&apos;])</a></li>
<li><a href="all.html#all_worker_disconnect">worker.disconnect()</a></li>
<li><a href="all.html#all_message_2">事件: &apos;message&apos;</a></li>
<li><a href="all.html#all_online_1">事件: &apos;online&apos;</a></li>
<li><a href="all.html#all_listening_3">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_disconnect_2">事件: &apos;disconnect&apos;</a></li>
<li><a href="all.html#all_exit_4">事件: &apos;exit&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_smalloc">Smalloc</a><ul>
<li><a href="all.html#all_smalloc_alloc_length_receiver_type">smalloc.alloc(length[, receiver][, type])</a></li>
<li><a href="all.html#all_smalloc_copyonto_source_sourcestart_dest_deststart_copylength">smalloc.copyOnto(source, sourceStart, dest, destStart, copyLength);</a></li>
<li><a href="all.html#all_smalloc_dispose_obj">smalloc.dispose(obj)</a></li>
<li><a href="all.html#all_smalloc_kmaxlength">smalloc.kMaxLength</a></li>
<li><a href="all.html#all_smalloc_types">smalloc.Types</a></li>
</ul>
</li>
<li><a href="all.html#all_50">关于本文档</a><ul>
<li><a href="all.html#all_51">稳定度</a></li>
<li><a href="all.html#all_json_1">JSON 输出</a></li>
</ul>
</li>
<li><a href="all.html#all_52">概述</a></li>
<li><a href="all.html#all_53">全局对象</a><ul>
<li><a href="all.html#all_global_1">global</a></li>
<li><a href="all.html#all_process_2">process</a></li>
<li><a href="all.html#all_console_1">console</a></li>
<li><a href="all.html#all_buffer_3">类: Buffer</a></li>
<li><a href="all.html#all_require_1">require()</a><ul>
<li><a href="all.html#all_require_resolve_1">require.resolve()</a></li>
<li><a href="all.html#all_require_cache_1">require.cache</a></li>
<li><a href="all.html#all_require_extensions_1">require.extensions</a></li>
</ul>
</li>
<li><a href="all.html#all_filename_1">__filename</a></li>
<li><a href="all.html#all_dirname_1">__dirname</a></li>
<li><a href="all.html#all_module_1">module</a></li>
<li><a href="all.html#all_exports_1">exports</a></li>
<li><a href="all.html#all_settimeout_cb_ms_1">setTimeout(cb, ms)</a></li>
<li><a href="all.html#all_cleartimeout_t_1">clearTimeout(t)</a></li>
<li><a href="all.html#all_setinterval_cb_ms_1">setInterval(cb, ms)</a></li>
<li><a href="all.html#all_clearinterval_t_1">clearInterval(t)</a></li>
</ul>
</li>
<li><a href="all.html#all_54">控制台</a><ul>
<li><a href="all.html#all_console_log_data_1">console.log([data], [...])</a></li>
<li><a href="all.html#all_console_info_data_1">console.info([data], [...])</a></li>
<li><a href="all.html#all_console_error_data_1">console.error([data], [...])</a></li>
<li><a href="all.html#all_console_warn_data_1">console.warn([data], [...])</a></li>
<li><a href="all.html#all_console_dir_obj_1">console.dir(obj)</a></li>
<li><a href="all.html#all_console_time_label_1">console.time(label)</a></li>
<li><a href="all.html#all_console_timeend_label_1">console.timeEnd(label)</a></li>
<li><a href="all.html#all_console_trace_label_1">console.trace(label)</a></li>
<li><a href="all.html#all_console_assert_expression_message_1">console.assert(expression, [message])</a></li>
</ul>
</li>
<li><a href="all.html#all_55">定时器</a><ul>
<li><a href="all.html#all_settimeout_callback_delay_arg_1">setTimeout(callback, delay, [arg], [...])</a></li>
<li><a href="all.html#all_cleartimeout_timeoutid_1">clearTimeout(timeoutId)</a></li>
<li><a href="all.html#all_setinterval_callback_delay_arg_1">setInterval(callback, delay, [arg], [...])</a></li>
<li><a href="all.html#all_clearinterval_intervalid_1">clearInterval(intervalId)</a></li>
<li><a href="all.html#all_unref_1">unref()</a></li>
<li><a href="all.html#all_ref_1">ref()</a></li>
<li><a href="all.html#all_setimmediate_callback_arg_1">setImmediate(callback, [arg], [...])</a></li>
<li><a href="all.html#all_clearimmediate_immediateid_1">clearImmediate(immediateId)</a></li>
</ul>
</li>
<li><a href="all.html#all_modules_1">Modules</a><ul>
<li><a href="all.html#all_56">循环</a></li>
<li><a href="all.html#all_57">核心模块</a></li>
<li><a href="all.html#all_58">文件模块</a></li>
<li><a href="all.html#all_node_modules_1">从<code>node_modules</code>文件夹中加载</a></li>
<li><a href="all.html#all_folders_as_modules_1">Folders as Modules</a></li>
<li><a href="all.html#all_caching_1">Caching</a><ul>
<li><a href="all.html#all_module_caching_caveats_1">Module Caching Caveats</a></li>
</ul>
</li>
<li><a href="all.html#all_the_module_object_1">The <code>module</code> Object</a><ul>
<li><a href="all.html#all_module_exports_1">module.exports</a></li>
<li><a href="all.html#all_module_require_id_1">module.require(id)</a></li>
<li><a href="all.html#all_module_id_1">module.id</a></li>
<li><a href="all.html#all_module_filename_1">module.filename</a></li>
<li><a href="all.html#all_module_loaded_1">module.loaded</a></li>
<li><a href="all.html#all_module_parent_1">module.parent</a></li>
<li><a href="all.html#all_module_children_1">module.children</a></li>
</ul>
</li>
<li><a href="all.html#all_59">总体来说...</a></li>
<li><a href="all.html#all_60">从全局文件夹加载</a></li>
<li><a href="all.html#all_61">访问主模块</a></li>
<li><a href="all.html#all_62">附录： 包管理技巧</a></li>
</ul>
</li>
<li><a href="all.html#all_addons_1">Addons插件</a><ul>
<li><a href="all.html#all_hello_world_1">Hello world（世界你好）</a></li>
<li><a href="all.html#all_addon_patterns_1">Addon patterns（插件方式）</a><ul>
<li><a href="all.html#all_function_arguments_1">Function arguments（函数参数）</a></li>
<li><a href="all.html#all_callbacks_1">Callbacks（回调）</a></li>
<li><a href="all.html#all_object_factory_1">Object factory（对象工厂）</a></li>
<li><a href="all.html#all_function_factory_1">Function factory（函数工厂）</a></li>
<li><a href="all.html#all_wrapping_c_objects_c_1">Wrapping C++ objects（包装c++对象）</a></li>
<li><a href="all.html#all_factory_of_wrapped_objects_1">Factory of wrapped objects（工厂包装对象）</a></li>
<li><a href="all.html#all_passing_wrapped_objects_around_1">Passing wrapped objects around（传递包装的对象）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_process_3">process</a><ul>
<li><a href="all.html#all_exit_codes_1">Exit Codes</a></li>
<li><a href="all.html#all_exit_5">事件: &apos;exit&apos;</a></li>
<li><a href="all.html#all_uncaughtexception_1">事件: &apos;uncaughtException&apos;（未捕获错误）</a></li>
<li><a href="all.html#all_signal_events_1">Signal Events</a></li>
<li><a href="all.html#all_process_stdout_1">process.stdout</a></li>
<li><a href="all.html#all_process_stderr_1">process.stderr</a></li>
<li><a href="all.html#all_process_stdin_1">process.stdin</a></li>
<li><a href="all.html#all_process_argv_1">process.argv</a></li>
<li><a href="all.html#all_process_execpath_1">process.execPath</a></li>
<li><a href="all.html#all_process_execargv_1">process.execArgv</a></li>
<li><a href="all.html#all_process_abort_1">process.abort()</a></li>
<li><a href="all.html#all_process_chdir_directory_1">process.chdir(directory)</a></li>
<li><a href="all.html#all_process_cwd_1">process.cwd()</a></li>
<li><a href="all.html#all_process_env_1">process.env</a></li>
<li><a href="all.html#all_process_exit_code_1">process.exit([code])</a></li>
<li><a href="all.html#all_process_exitcode_1">process.exitCode</a></li>
<li><a href="all.html#all_process_getgid_1">process.getgid()</a></li>
<li><a href="all.html#all_process_setgid_id_1">process.setgid(id)</a></li>
<li><a href="all.html#all_process_getuid_1">process.getuid()</a></li>
<li><a href="all.html#all_process_setuid_id_1">process.setuid(id)</a></li>
<li><a href="all.html#all_process_getgroups_1">process.getgroups()</a></li>
<li><a href="all.html#all_process_setgroups_groups_1">process.setgroups(groups)</a></li>
<li><a href="all.html#all_process_initgroups_user_extra_group_1">process.initgroups(user, extra_group)</a></li>
<li><a href="all.html#all_process_version_1">process.version</a></li>
<li><a href="all.html#all_process_versions_1">process.versions</a></li>
<li><a href="all.html#all_process_config_1">process.config</a></li>
<li><a href="all.html#all_process_kill_pid_signal_1">process.kill(pid, [signal])</a></li>
<li><a href="all.html#all_process_pid_1">process.pid</a></li>
<li><a href="all.html#all_process_title_1">process.title</a></li>
<li><a href="all.html#all_process_arch_1">process.arch</a></li>
<li><a href="all.html#all_process_platform_1">process.platform</a></li>
<li><a href="all.html#all_process_memoryusage_1">process.memoryUsage()</a></li>
<li><a href="all.html#all_process_nexttick_callback_1">process.nextTick(callback)</a></li>
<li><a href="all.html#all_process_umask_mask_1">process.umask([mask])</a></li>
<li><a href="all.html#all_process_uptime_1">process.uptime()</a></li>
<li><a href="all.html#all_process_hrtime_1">process.hrtime()</a></li>
</ul>
</li>
<li><a href="all.html#all_utils_1">utils</a><ul>
<li><a href="all.html#all_util_debuglog_section_1">util.debuglog(section)</a></li>
<li><a href="all.html#all_error_7">对Error(错误)对象的内容添加</a></li>
<li><a href="all.html#all_63">隐式绑定</a></li>
<li><a href="all.html#all_64">显式绑定</a></li>
<li><a href="all.html#all_domain_create_1">domain.create()</a></li>
<li><a href="all.html#all_domain_1">类: Domain</a><ul>
<li><a href="all.html#all_domain_run_fn_1">domain.run(fn)</a></li>
<li><a href="all.html#all_domain_members_1">domain.members</a></li>
<li><a href="all.html#all_domain_add_emitter_1">domain.add(emitter)</a></li>
<li><a href="all.html#all_domain_remove_emitter_1">domain.remove(emitter)</a></li>
<li><a href="all.html#all_domain_bind_callback_1">domain.bind(callback)</a><ul>
<li><a href="all.html#all_65">例子</a></li>
</ul>
</li>
<li><a href="all.html#all_domain_intercept_callback_1">domain.intercept(callback)</a><ul>
<li><a href="all.html#all_66">例子</a></li>
</ul>
</li>
<li><a href="all.html#all_domain_enter_1">domain.enter()</a></li>
<li><a href="all.html#all_domain_exit_1">domain.exit()</a></li>
<li><a href="all.html#all_domain_dispose_1">domain.dispose()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_buffer_4">Buffer</a><ul>
<li><a href="all.html#all_buffer_5">类: Buffer</a><ul>
<li><a href="all.html#all_new_buffer_size_1">new Buffer(size)</a></li>
<li><a href="all.html#all_new_buffer_array_1">new Buffer(array)</a></li>
<li><a href="all.html#all_new_buffer_str_encoding_1">new Buffer(str, [encoding])</a></li>
<li><a href="all.html#all_buffer_isencoding_encoding_1">类方法: Buffer.isEncoding(encoding)</a></li>
<li><a href="all.html#all_buffer_isbuffer_obj_1">类方法: Buffer.isBuffer(obj)</a></li>
<li><a href="all.html#all_buffer_bytelength_string_encoding_1">类方法: Buffer.byteLength(string, [encoding])</a></li>
<li><a href="all.html#all_buffer_concat_list_totallength_1">类方法: Buffer.concat(list, [totalLength])</a></li>
<li><a href="all.html#all_buf_length_1">buf.length</a></li>
<li><a href="all.html#all_buf_write_string_offset_length_encoding_1">buf.write(string, [offset], [length], [encoding])</a></li>
<li><a href="all.html#all_buf_tostring_encoding_start_end_1">buf.toString([encoding], [start], [end])</a></li>
<li><a href="all.html#all_buf_tojson_1">buf.toJSON()</a></li>
<li><a href="all.html#all_buf_index_1">buf[index]</a></li>
<li><a href="all.html#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend_1">buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])</a></li>
<li><a href="all.html#all_buf_slice_start_end_1">buf.slice([start], [end])</a></li>
<li><a href="all.html#all_buf_readuint8_offset_noassert_1">buf.readUInt8(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16le_offset_noassert_2">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16be_offset_noassert_2">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16le_offset_noassert_3">buf.readUInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint16be_offset_noassert_3">buf.readUInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32le_offset_noassert_2">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32be_offset_noassert_2">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32le_offset_noassert_3">buf.readUInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readuint32be_offset_noassert_3">buf.readUInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint8_offset_noassert_1">buf.readInt8(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16le_offset_noassert_2">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16be_offset_noassert_2">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16le_offset_noassert_3">buf.readInt16LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint16be_offset_noassert_3">buf.readInt16BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32le_offset_noassert_2">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32be_offset_noassert_2">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32le_offset_noassert_3">buf.readInt32LE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readint32be_offset_noassert_3">buf.readInt32BE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatle_offset_noassert_2">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatbe_offset_noassert_2">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatle_offset_noassert_3">buf.readFloatLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readfloatbe_offset_noassert_3">buf.readFloatBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublele_offset_noassert_2">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublebe_offset_noassert_2">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublele_offset_noassert_3">buf.readDoubleLE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_readdoublebe_offset_noassert_3">buf.readDoubleBE(offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint8_value_offset_noassert_1">buf.writeUInt8(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16le_value_offset_noassert_2">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16be_value_offset_noassert_2">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16le_value_offset_noassert_3">buf.writeUInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint16be_value_offset_noassert_3">buf.writeUInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32le_value_offset_noassert_2">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32be_value_offset_noassert_2">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32le_value_offset_noassert_3">buf.writeUInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeuint32be_value_offset_noassert_3">buf.writeUInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint8_value_offset_noassert_1">buf.writeInt8(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16le_value_offset_noassert_2">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16be_value_offset_noassert_2">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16le_value_offset_noassert_3">buf.writeInt16LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint16be_value_offset_noassert_3">buf.writeInt16BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32le_value_offset_noassert_2">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32be_value_offset_noassert_2">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32le_value_offset_noassert_3">buf.writeInt32LE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writeint32be_value_offset_noassert_3">buf.writeInt32BE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatle_value_offset_noassert_2">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatbe_value_offset_noassert_2">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatle_value_offset_noassert_3">buf.writeFloatLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writefloatbe_value_offset_noassert_3">buf.writeFloatBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublele_value_offset_noassert_2">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublebe_value_offset_noassert_2">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublele_value_offset_noassert_3">buf.writeDoubleLE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_writedoublebe_value_offset_noassert_3">buf.writeDoubleBE(value, offset, [noAssert])</a></li>
<li><a href="all.html#all_buf_fill_value_offset_end_1">buf.fill(value, [offset], [end])</a></li>
</ul>
</li>
<li><a href="all.html#all_buffer_inspect_max_bytes_1">buffer.INSPECT_MAX_BYTES</a></li>
<li><a href="all.html#all_slowbuffer_1">类: SlowBuffer</a></li>
</ul>
</li>
<li><a href="all.html#all_67">流</a><ul>
<li><a href="all.html#all_api_2">面向流消费者的 API</a><ul>
<li><a href="all.html#all_stream_readable_2">类: stream.Readable</a><ul>
<li><a href="all.html#all_readable_1">事件: &apos;readable&apos;</a></li>
<li><a href="all.html#all_data_2">事件: &apos;data&apos;</a></li>
<li><a href="all.html#all_end_2">事件: &apos;end&apos;</a></li>
<li><a href="all.html#all_close_9">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_error_8">事件: &apos;error&apos;</a></li>
<li><a href="all.html#all_readable_read_size_2">readable.read([size])</a></li>
<li><a href="all.html#all_readable_setencoding_encoding_1">readable.setEncoding(encoding)</a></li>
<li><a href="all.html#all_readable_resume_1">readable.resume()</a></li>
<li><a href="all.html#all_readable_pause_1">readable.pause()</a></li>
<li><a href="all.html#all_readable_pipe_destination_options_1">readable.pipe(destination, [options])</a></li>
<li><a href="all.html#all_readable_unpipe_destination_1">readable.unpipe([destination])</a></li>
<li><a href="all.html#all_readable_unshift_chunk_1">readable.unshift(chunk)</a></li>
<li><a href="all.html#all_readable_wrap_stream_1">readable.wrap(stream)</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_writable_2">类: stream.Writable</a><ul>
<li><a href="all.html#all_writable_write_chunk_encoding_callback_2">writable.write(chunk, [encoding], [callback])</a></li>
<li><a href="all.html#all_drain_2">事件: &apos;drain&apos;</a></li>
<li><a href="all.html#all_writable_cork_1">writable.cork()</a></li>
<li><a href="all.html#all_writable_uncork_1">writable.uncork()</a></li>
<li><a href="all.html#all_writable_end_chunk_encoding_callback_1">writable.end([chunk], [encoding], [callback])</a></li>
<li><a href="all.html#all_finish_1">事件: &apos;finish&apos;</a></li>
<li><a href="all.html#all_pipe_1">事件: &apos;pipe&apos;</a></li>
<li><a href="all.html#all_unpipe_1">事件: &apos;unpipe&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_duplex_2">类: stream.Duplex</a></li>
<li><a href="all.html#all_stream_transform_2">类: stream.Transform</a></li>
</ul>
</li>
<li><a href="all.html#all_api_3">面向流实现者的 API</a><ul>
<li><a href="all.html#all_stream_readable_3">类: stream.Readable</a><ul>
<li><a href="all.html#all_68">例子: 一个计数流</a></li>
<li><a href="all.html#all_simpleprotocol_v1_sub_optimal_1">例子: SimpleProtocol v1 (Sub-optimal)</a></li>
<li><a href="all.html#all_new_stream_readable_options_1">new stream.Readable([options])</a></li>
<li><a href="all.html#all_readable_read_size_3">readable._read(size)</a></li>
<li><a href="all.html#all_readable_push_chunk_encoding_1">readable.push(chunk, [encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_writable_3">类: stream.Writable</a><ul>
<li><a href="all.html#all_new_stream_writable_options_1">new stream.Writable([options])</a></li>
<li><a href="all.html#all_writable_write_chunk_encoding_callback_3">writable._write(chunk, encoding, callback)</a></li>
</ul>
</li>
<li><a href="all.html#all_writable_writev_chunks_callback_1">writable._writev(chunks, callback)</a></li>
<li><a href="all.html#all_stream_duplex_3">类: stream.Duplex</a><ul>
<li><a href="all.html#all_new_stream_duplex_options_1">new stream.Duplex(options)</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_transform_3">类: stream.Transform</a><ul>
<li><a href="all.html#all_new_stream_transform_options_1">new stream.Transform([options])</a></li>
<li><a href="all.html#all_transform_transform_chunk_encoding_callback_1">transform._transform(chunk, encoding, callback)</a></li>
<li><a href="all.html#all_transform_flush_callback_1">transform._flush(callback)</a></li>
<li><a href="all.html#all_simpleprotocol_v2_1">例子: <code>SimpleProtocol</code> 解析器 v2</a></li>
</ul>
</li>
<li><a href="all.html#all_stream_passthrough_1">类: stream.PassThrough</a></li>
</ul>
</li>
<li><a href="all.html#all_69">流：内部细节</a><ul>
<li><a href="all.html#all_70">缓冲</a></li>
<li><a href="all.html#all_stream_read_0_1"><code>stream.read(0)</code></a></li>
<li><a href="all.html#all_stream_push_1"><code>stream.push(&apos;&apos;)</code></a></li>
<li><a href="all.html#all_node_1">与 Node 早期版本的兼容性</a></li>
<li><a href="all.html#all_71">对象模式</a></li>
<li><a href="all.html#all_72">状态对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_crypto_1">加密（Crypto）</a><ul>
<li><a href="all.html#all_crypto_getciphers_1">crypto.getCiphers()</a></li>
<li><a href="all.html#all_crypto_gethashes_1">crypto.getHashes()</a></li>
<li><a href="all.html#all_crypto_createcredentials_details_1">crypto.createCredentials(details)</a></li>
<li><a href="all.html#all_crypto_createhash_algorithm_1">crypto.createHash(algorithm)</a></li>
<li><a href="all.html#all_hash_1">类: Hash</a><ul>
<li><a href="all.html#all_hash_update_data_input_encoding_1">hash.update(data, [input_encoding])</a></li>
<li><a href="all.html#all_hash_digest_encoding_1">hash.digest([encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createhmac_algorithm_key_1">crypto.createHmac(algorithm, key)</a></li>
<li><a href="all.html#all_class_hmac_1">Class: Hmac</a><ul>
<li><a href="all.html#all_hmac_update_data_1">hmac.update(data)</a></li>
<li><a href="all.html#all_hmac_digest_encoding_1">hmac.digest([encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createcipher_algorithm_password_1">crypto.createCipher(algorithm, password)</a></li>
<li><a href="all.html#all_crypto_createcipheriv_algorithm_key_iv_1">crypto.createCipheriv(algorithm, key, iv)</a></li>
<li><a href="all.html#all_class_cipher_1">Class: Cipher</a><ul>
<li><a href="all.html#all_cipher_update_data_input_encoding_output_encoding_1">cipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="all.html#all_cipher_final_output_encoding_1">cipher.final([output_encoding])</a></li>
<li><a href="all.html#all_cipher_setautopadding_auto_padding_true_1">cipher.setAutoPadding(auto_padding=true)</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createdecipher_algorithm_password_1">crypto.createDecipher(algorithm, password)</a></li>
<li><a href="all.html#all_crypto_createdecipheriv_algorithm_key_iv_1">crypto.createDecipheriv(algorithm, key, iv)</a></li>
<li><a href="all.html#all_class_decipher_1">Class: Decipher</a><ul>
<li><a href="all.html#all_decipher_update_data_input_encoding_output_encoding_1">decipher.update(data, [input_encoding], [output_encoding])</a></li>
<li><a href="all.html#all_decipher_final_output_encoding_1">decipher.final([output_encoding])</a></li>
<li><a href="all.html#all_decipher_setautopadding_auto_padding_true_1">decipher.setAutoPadding(auto_padding=true)</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createsign_algorithm_1">crypto.createSign(algorithm)</a></li>
<li><a href="all.html#all_class_sign_1">Class: Sign</a><ul>
<li><a href="all.html#all_sign_update_data_1">sign.update(data)</a></li>
<li><a href="all.html#all_sign_sign_private_key_output_format_1">sign.sign(private_key, [output_format])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_createverify_algorithm_1">crypto.createVerify(algorithm)</a></li>
<li><a href="all.html#all_class_verify_1">Class: Verify</a><ul>
<li><a href="all.html#all_verifier_update_data_1">verifier.update(data)</a></li>
<li><a href="all.html#all_verifier_verify_object_signature_signature_format_1">verifier.verify(object, signature, [signature_format])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_creatediffiehellman_prime_length_1">crypto.createDiffieHellman(prime_length)</a></li>
<li><a href="all.html#all_crypto_creatediffiehellman_prime_encoding_1">crypto.createDiffieHellman(prime, [encoding])</a></li>
<li><a href="all.html#all_class_diffiehellman_1">Class: DiffieHellman</a><ul>
<li><a href="all.html#all_diffiehellman_generatekeys_encoding_1">diffieHellman.generateKeys([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding_1">diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getprime_encoding_1">diffieHellman.getPrime([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getgenerator_encoding_1">diffieHellman.getGenerator([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getpublickey_encoding_1">diffieHellman.getPublicKey([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_getprivatekey_encoding_1">diffieHellman.getPrivateKey([encoding])</a></li>
<li><a href="all.html#all_diffiehellman_setpublickey_public_key_encoding_1">diffieHellman.setPublicKey(public_key, [encoding])</a></li>
<li><a href="all.html#all_diffiehellman_setprivatekey_private_key_encoding_1">diffieHellman.setPrivateKey(private_key, [encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_crypto_getdiffiehellman_group_name_1">crypto.getDiffieHellman(group_name)</a></li>
<li><a href="all.html#all_crypto_pbkdf2_password_salt_iterations_keylen_callback_1">crypto.pbkdf2(password, salt, iterations, keylen, callback)</a></li>
<li><a href="all.html#all_crypto_pbkdf2sync_password_salt_iterations_keylen_1">crypto.pbkdf2Sync(password, salt, iterations, keylen)</a></li>
<li><a href="all.html#all_crypto_randombytes_size_callback_1">crypto.randomBytes(size, [callback])</a></li>
<li><a href="all.html#all_crypto_pseudorandombytes_size_callback_1">crypto.pseudoRandomBytes(size, [callback])</a></li>
<li><a href="all.html#all_crypto_default_encoding_1">crypto.DEFAULT_ENCODING</a></li>
<li><a href="all.html#all_recent_api_changes_1">Recent API Changes</a></li>
</ul>
</li>
<li><a href="all.html#all_tls_ssl_1">TLS (SSL)</a><ul>
<li><a href="all.html#all_client_initiated_renegotiation_attack_mitigation_1">Client-initiated renegotiation attack mitigation</a></li>
<li><a href="all.html#all_npn_sni_1">NPN 和 SNI</a></li>
<li><a href="all.html#all_tls_getciphers_1">tls.getCiphers()</a></li>
<li><a href="all.html#all_tls_createserver_options_secureconnectionlistener_1">tls.createServer(options, [secureConnectionListener])</a></li>
<li><a href="all.html#all_tls_connect_options_callback_2">tls.connect(options, [callback])</a></li>
<li><a href="all.html#all_tls_connect_port_host_options_callback_2">tls.connect(port, [host], [options], [callback])</a></li>
<li><a href="all.html#all_tls_connect_options_callback_3">tls.connect(options, [callback])</a></li>
<li><a href="all.html#all_tls_connect_port_host_options_callback_3">tls.connect(port, [host], [options], [callback])</a></li>
<li><a href="all.html#all_tls_tlssocket_2">类: tls.TLSSocket</a></li>
<li><a href="all.html#all_new_tls_tlssocket_socket_options_1">new tls.TLSSocket(socket, options)</a></li>
<li><a href="all.html#all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized_1">tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])</a></li>
<li><a href="all.html#all_securepair_1">类: SecurePair</a><ul>
<li><a href="all.html#all_secure_1">事件: &apos;secure&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_tls_server_1">类: tls.Server</a><ul>
<li><a href="all.html#all_secureconnection_1">事件: &apos;secureConnection&apos;</a></li>
<li><a href="all.html#all_event_clienterror_2">Event: &apos;clientError&apos;</a></li>
<li><a href="all.html#all_newsession_1">事件: &apos;newSession&apos;</a></li>
<li><a href="all.html#all_resumesession_1">事件: &apos;resumeSession&apos;</a></li>
<li><a href="all.html#all_server_listen_port_host_callback_1">server.listen(port, [host], [callback])</a></li>
<li><a href="all.html#all_server_close_1">server.close()</a></li>
<li><a href="all.html#all_server_address_2">server.address()</a></li>
<li><a href="all.html#all_server_addcontext_hostname_credentials_1">server.addContext(hostname, credentials)</a></li>
<li><a href="all.html#all_server_maxconnections_2">server.maxConnections</a></li>
<li><a href="all.html#all_server_connections_2">server.connections</a></li>
</ul>
</li>
<li><a href="all.html#all_cryptostream_1">类: CryptoStream</a><ul>
<li><a href="all.html#all_cryptostream_byteswritten_1">cryptoStream.bytesWritten</a></li>
</ul>
</li>
<li><a href="all.html#all_tls_tlssocket_3">类: tls.TLSSocket</a><ul>
<li><a href="all.html#all_secureconnect_1">事件: &apos;secureConnect&apos;</a></li>
<li><a href="all.html#all_tlssocket_authorized_1">tlsSocket.authorized</a></li>
<li><a href="all.html#all_tlssocket_authorizationerror_1">tlsSocket.authorizationError</a></li>
<li><a href="all.html#all_tlssocket_getpeercertificate_1">tlsSocket.getPeerCertificate()</a></li>
<li><a href="all.html#all_tlssocket_getcipher_1">tlsSocket.getCipher()</a></li>
<li><a href="all.html#all_tlssocket_renegotiate_options_callback_1">tlsSocket.renegotiate(options, callback)</a></li>
<li><a href="all.html#all_tlssocket_address_1">tlsSocket.address()</a></li>
<li><a href="all.html#all_tlssocket_remoteaddress_1">tlsSocket.remoteAddress</a></li>
<li><a href="all.html#all_tlssocket_remoteport_1">tlsSocket.remotePort</a></li>
<li><a href="all.html#all_tlssocket_localaddress_1">tlsSocket.localAddress</a></li>
<li><a href="all.html#all_tlssocket_localport_1">tlsSocket.localPort</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_73">字符串解码器</a><ul>
<li><a href="all.html#all_stringdecoder_1">类: StringDecoder</a><ul>
<li><a href="all.html#all_decoder_write_buffer_1">decoder.write(buffer)</a></li>
<li><a href="all.html#all_decoder_end_1">decoder.end()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_file_system_1">File System</a><ul>
<li><a href="all.html#all_fs_rename_oldpath_newpath_callback_1">fs.rename(oldPath, newPath, callback)</a></li>
<li><a href="all.html#all_fs_renamesync_oldpath_newpath_1">fs.renameSync(oldPath, newPath)</a></li>
<li><a href="all.html#all_fs_ftruncate_fd_len_callback_1">fs.ftruncate(fd, len, callback)</a></li>
<li><a href="all.html#all_fs_ftruncatesync_fd_len_1">fs.ftruncateSync(fd, len)</a></li>
<li><a href="all.html#all_fs_truncate_path_len_callback_1">fs.truncate(path, len, callback)</a></li>
<li><a href="all.html#all_fs_truncatesync_path_len_1">fs.truncateSync(path, len)</a></li>
<li><a href="all.html#all_fs_chownsync_path_uid_gid_1">fs.chownSync(path, uid, gid)</a></li>
<li><a href="all.html#all_fs_fchown_fd_uid_gid_callback_1">fs.fchown(fd, uid, gid, callback)</a></li>
<li><a href="all.html#all_fs_fchownsync_fd_uid_gid_1">fs.fchownSync(fd, uid, gid)</a></li>
<li><a href="all.html#all_fs_lchown_path_uid_gid_callback_1">fs.lchown(path, uid, gid, callback)</a></li>
<li><a href="all.html#all_fs_lchownsync_path_uid_gid_1">fs.lchownSync(path, uid, gid)</a></li>
<li><a href="all.html#all_fs_chmod_path_mode_callback_1">fs.chmod(path, mode, callback)</a></li>
<li><a href="all.html#all_fs_chmodsync_path_mode_1">fs.chmodSync(path, mode)</a></li>
<li><a href="all.html#all_fs_fchmod_fd_mode_callback_1">fs.fchmod(fd, mode, callback)</a></li>
<li><a href="all.html#all_fs_fchmodsync_fd_mode_1">fs.fchmodSync(fd, mode)</a></li>
<li><a href="all.html#all_fs_lchmod_path_mode_callback_1">fs.lchmod(path, mode, callback)</a></li>
<li><a href="all.html#all_fs_lchmodsync_path_mode_1">fs.lchmodSync(path, mode)</a></li>
<li><a href="all.html#all_fs_stat_path_callback_1">fs.stat(path, callback)</a></li>
<li><a href="all.html#all_fs_lstat_path_callback_1">fs.lstat(path, callback)</a></li>
<li><a href="all.html#all_fs_fstat_fd_callback_1">fs.fstat(fd, callback)</a></li>
<li><a href="all.html#all_fs_statsync_path_1">fs.statSync(path)</a></li>
<li><a href="all.html#all_fs_lstatsync_path_1">fs.lstatSync(path)</a></li>
<li><a href="all.html#all_fs_fstatsync_fd_1">fs.fstatSync(fd)</a></li>
<li><a href="all.html#all_fs_link_srcpath_dstpath_callback_1">fs.link(srcpath, dstpath, callback)</a></li>
<li><a href="all.html#all_fs_linksync_srcpath_dstpath_1">fs.linkSync(srcpath, dstpath)</a></li>
<li><a href="all.html#all_fs_symlink_srcpath_dstpath_type_callback_1">fs.symlink(srcpath, dstpath, [type], callback)</a></li>
<li><a href="all.html#all_fs_symlinksync_srcpath_dstpath_type_1">fs.symlinkSync(srcpath, dstpath, [type])</a></li>
<li><a href="all.html#all_fs_readlink_path_callback_1">fs.readlink(path, callback)</a></li>
<li><a href="all.html#all_fs_readlinksync_path_1">fs.readlinkSync(path)</a></li>
<li><a href="all.html#all_fs_realpath_path_cache_callback_1">fs.realpath(path, [cache], callback)</a></li>
<li><a href="all.html#all_fs_realpathsync_path_cache_1">fs.realpathSync(path, [cache])</a></li>
<li><a href="all.html#all_fs_unlink_path_callback_1">fs.unlink(path, callback)</a></li>
<li><a href="all.html#all_fs_unlinksync_path_1">fs.unlinkSync(path)</a></li>
<li><a href="all.html#all_fs_rmdir_path_callback_1">fs.rmdir(path, callback)</a></li>
<li><a href="all.html#all_fs_rmdirsync_path_1">fs.rmdirSync(path)</a></li>
<li><a href="all.html#all_fs_mkdir_path_mode_callback_1">fs.mkdir(path, [mode], callback)</a></li>
<li><a href="all.html#all_fs_mkdirsync_path_mode_1">fs.mkdirSync(path, [mode])</a></li>
<li><a href="all.html#all_fs_readdir_path_callback_1">fs.readdir(path, callback)</a></li>
<li><a href="all.html#all_fs_readdirsync_path_1">fs.readdirSync(path)</a></li>
<li><a href="all.html#all_fs_close_fd_callback_1">fs.close(fd, callback)</a></li>
<li><a href="all.html#all_fs_closesync_fd_1">fs.closeSync(fd)</a></li>
<li><a href="all.html#all_fs_open_path_flags_mode_callback_1">fs.open(path, flags, [mode], callback)</a></li>
<li><a href="all.html#all_fs_opensync_path_flags_mode_1">fs.openSync(path, flags, [mode])</a></li>
<li><a href="all.html#all_fs_utimes_path_atime_mtime_callback_2">fs.utimes(path, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_utimessync_path_atime_mtime_2">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="all.html#all_fs_utimes_path_atime_mtime_callback_3">fs.utimes(path, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_utimessync_path_atime_mtime_3">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="all.html#all_fs_futimes_fd_atime_mtime_callback_2">fs.futimes(fd, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_futimessync_fd_atime_mtime_2">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="all.html#all_fs_futimes_fd_atime_mtime_callback_3">fs.futimes(fd, atime, mtime, callback)</a></li>
<li><a href="all.html#all_fs_futimessync_fd_atime_mtime_3">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="all.html#all_fs_fsync_fd_callback_1">fs.fsync(fd, callback)</a></li>
<li><a href="all.html#all_fs_fsyncsync_fd_1">fs.fsyncSync(fd)</a></li>
<li><a href="all.html#all_fs_write_fd_buffer_offset_length_position_callback_1">fs.write(fd, buffer, offset, length[, position], callback)</a></li>
<li><a href="all.html#all_fs_write_fd_data_position_encoding_callback_1">fs.write(fd, data[, position[, encoding]], callback)</a></li>
<li><a href="all.html#all_fs_writesync_fd_buffer_offset_length_position_1">fs.writeSync(fd, buffer, offset, length[, position])</a></li>
<li><a href="all.html#all_fs_writesync_fd_data_position_encoding_1">fs.writeSync(fd, data[, position[, encoding]])</a></li>
<li><a href="all.html#all_fs_read_fd_buffer_offset_length_position_callback_1">fs.read(fd, buffer, offset, length, position, callback)</a></li>
<li><a href="all.html#all_fs_readsync_fd_buffer_offset_length_position_1">fs.readSync(fd, buffer, offset, length, position)</a></li>
<li><a href="all.html#all_fs_readfile_filename_options_callback_1">fs.readFile(filename, [options], callback)</a></li>
<li><a href="all.html#all_fs_readfilesync_filename_options_1">fs.readFileSync(filename, [options])</a></li>
<li><a href="all.html#all_fs_writefile_filename_data_options_callback_1">fs.writeFile(filename, data, [options], callback)</a></li>
<li><a href="all.html#all_fs_writefilesync_filename_data_options_1">fs.writeFileSync(filename, data, [options])</a></li>
<li><a href="all.html#all_fs_appendfile_filename_data_options_callback_1">fs.appendFile(filename, data, [options], callback)</a></li>
<li><a href="all.html#all_fs_appendfilesync_filename_data_options_1">fs.appendFileSync(filename, data, [options])</a></li>
<li><a href="all.html#all_fs_watchfile_filename_options_listener_1">fs.watchFile(filename, [options], listener)</a></li>
<li><a href="all.html#all_fs_unwatchfile_filename_listener_1">fs.unwatchFile(filename, [listener])</a></li>
<li><a href="all.html#all_fs_watch_filename_options_listener_1">fs.watch(filename, [options], [listener])</a><ul>
<li><a href="all.html#all_74">注意事项</a><ul>
<li><a href="all.html#all_75">可用性</a></li>
<li><a href="all.html#all_76">文件名参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_fs_exists_path_callback_1">fs.exists(path, callback)</a></li>
<li><a href="all.html#all_fs_existssync_path_1">fs.existsSync(path)</a></li>
<li><a href="all.html#all_class_fs_stats_1">Class: fs.Stats</a><ul>
<li><a href="all.html#all_stat_time_values_1">Stat Time Values</a></li>
</ul>
</li>
<li><a href="all.html#all_fs_createreadstream_path_options_1">fs.createReadStream(path, [options])</a></li>
<li><a href="all.html#all_class_fs_readstream_1">Class: fs.ReadStream</a><ul>
<li><a href="all.html#all_open_2">事件: &apos;open&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_fs_createwritestream_path_options_1">fs.createWriteStream(path, [options])</a></li>
<li><a href="all.html#all_class_fs_writestream_1">Class: fs.WriteStream</a><ul>
<li><a href="all.html#all_open_3">事件: &apos;open&apos;</a></li>
<li><a href="all.html#all_file_byteswritten_1">file.bytesWritten</a></li>
</ul>
</li>
<li><a href="all.html#all_class_fs_fswatcher_1">Class: fs.FSWatcher</a><ul>
<li><a href="all.html#all_watcher_close_1">watcher.close()</a></li>
<li><a href="all.html#all_change_1">事件: &apos;change&apos;</a></li>
<li><a href="all.html#all_error_9">事件: &apos;error&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_path_1">路径 (Path)</a><ul>
<li><a href="all.html#all_path_normalize_p_1">path.normalize(p)</a></li>
<li><a href="all.html#all_path_join_path1_path2_1">path.join([path1], [path2], [...])</a></li>
<li><a href="all.html#all_path_resolve_from_to_1">path.resolve([from ...], to)</a></li>
<li><a href="all.html#all_path_isabsolute_path_1">path.isAbsolute(path)</a></li>
<li><a href="all.html#all_path_relative_from_to_1">path.relative(from, to)</a></li>
<li><a href="all.html#all_path_dirname_p_1">path.dirname(p)</a></li>
<li><a href="all.html#all_path_basename_p_ext_1">path.basename(p, [ext])</a></li>
<li><a href="all.html#all_path_extname_p_1">path.extname(p)</a></li>
<li><a href="all.html#all_path_sep_1">path.sep</a></li>
<li><a href="all.html#all_path_delimiter_1">path.delimiter</a></li>
</ul>
</li>
<li><a href="all.html#all_77">网络</a><ul>
<li><a href="all.html#all_net_createserver_options_connectionlistener_1">net.createServer([options], [connectionListener])</a></li>
<li><a href="all.html#all_net_connect_options_connectionlistener_2">net.connect(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_createconnection_options_connectionlistener_2">net.createConnection(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_connect_options_connectionlistener_3">net.connect(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_createconnection_options_connectionlistener_3">net.createConnection(options, [connectionListener])</a></li>
<li><a href="all.html#all_net_connect_port_host_connectlistener_2">net.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_port_host_connectlistener_2">net.createConnection(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_connect_port_host_connectlistener_3">net.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_port_host_connectlistener_3">net.createConnection(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_net_connect_path_connectlistener_2">net.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_path_connectlistener_2">net.createConnection(path, [connectListener])</a></li>
<li><a href="all.html#all_net_connect_path_connectlistener_3">net.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_net_createconnection_path_connectlistener_3">net.createConnection(path, [connectListener])</a></li>
<li><a href="all.html#all_net_server_1">类: net.Server</a><ul>
<li><a href="all.html#all_server_listen_port_host_backlog_callback_3">server.listen(port, [host], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback_4">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback_4">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_close_callback_3">server.close([callback])</a></li>
<li><a href="all.html#all_server_address_3">server.address()</a></li>
<li><a href="all.html#all_server_unref_1">server.unref()</a></li>
<li><a href="all.html#all_server_ref_1">server.ref()</a></li>
<li><a href="all.html#all_server_maxconnections_3">server.maxConnections</a></li>
<li><a href="all.html#all_server_connections_3">server.connections</a></li>
<li><a href="all.html#all_server_getconnections_callback_1">server.getConnections(callback)</a></li>
<li><a href="all.html#all_listening_4">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_connection_2">事件: &apos;connection&apos;</a></li>
<li><a href="all.html#all_close_10">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_error_10">事件: &apos;error&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_net_socket_1">类: net.Socket</a><ul>
<li><a href="all.html#all_new_net_socket_options_1">new net.Socket([options])</a></li>
<li><a href="all.html#all_socket_connect_port_host_connectlistener_2">socket.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_socket_connect_path_connectlistener_2">socket.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_socket_connect_port_host_connectlistener_3">socket.connect(port, [host], [connectListener])</a></li>
<li><a href="all.html#all_socket_connect_path_connectlistener_3">socket.connect(path, [connectListener])</a></li>
<li><a href="all.html#all_socket_buffersize_1">socket.bufferSize</a></li>
<li><a href="all.html#all_socket_setencoding_encoding_1">socket.setEncoding([encoding])</a></li>
<li><a href="all.html#all_socket_write_data_encoding_callback_1">socket.write(data, [encoding], [callback])</a></li>
<li><a href="all.html#all_socket_end_data_encoding_1">socket.end([data], [encoding])</a></li>
<li><a href="all.html#all_socket_destroy_1">socket.destroy()</a></li>
<li><a href="all.html#all_socket_pause_1">socket.pause()</a></li>
<li><a href="all.html#all_socket_resume_1">socket.resume()</a></li>
<li><a href="all.html#all_socket_settimeout_timeout_callback_1">socket.setTimeout(timeout, [callback])</a></li>
<li><a href="all.html#all_socket_setnodelay_nodelay_1">socket.setNoDelay([noDelay])</a></li>
<li><a href="all.html#all_socket_setkeepalive_enable_initialdelay_1">socket.setKeepAlive([enable], [initialDelay])</a></li>
<li><a href="all.html#all_socket_address_2">socket.address()</a></li>
<li><a href="all.html#all_socket_unref_2">socket.unref()</a></li>
<li><a href="all.html#all_socket_ref_2">socket.ref()</a></li>
<li><a href="all.html#all_socket_remoteaddress_1">socket.remoteAddress</a></li>
<li><a href="all.html#all_socket_remoteport_1">socket.remotePort</a></li>
<li><a href="all.html#all_socket_localaddress_1">socket.localAddress</a></li>
<li><a href="all.html#all_socket_localport_1">socket.localPort</a></li>
<li><a href="all.html#all_socket_bytesread_1">socket.bytesRead</a></li>
<li><a href="all.html#all_socket_byteswritten_1">socket.bytesWritten</a></li>
<li><a href="all.html#all_lookup_1">事件: &apos;lookup&apos;</a></li>
<li><a href="all.html#all_connect_3">事件: &apos;connect&apos;</a></li>
<li><a href="all.html#all_data_3">事件: &apos;data&apos;</a></li>
<li><a href="all.html#all_end_3">事件: &apos;end&apos;</a></li>
<li><a href="all.html#all_timeout_1">事件: &apos;timeout&apos;</a></li>
<li><a href="all.html#all_drain_3">事件: &apos;drain&apos;</a></li>
<li><a href="all.html#all_error_11">事件: &apos;error&apos;</a></li>
<li><a href="all.html#all_close_11">事件: &apos;close&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_net_isip_input_1">net.isIP(input)</a></li>
<li><a href="all.html#all_net_isipv4_input_1">net.isIPv4(input)</a></li>
<li><a href="all.html#all_net_isipv6_input_1">net.isIPv6(input)</a></li>
</ul>
</li>
<li><a href="all.html#all_udp_1">UDP / 数据报套接字</a><ul>
<li><a href="all.html#all_dgram_createsocket_type_callback_1">dgram.createSocket(type, [callback])</a></li>
<li><a href="all.html#all_dgram_socket_1">类: dgram.Socket</a><ul>
<li><a href="all.html#all_message_3">事件: &apos;message&apos;</a></li>
<li><a href="all.html#all_listening_5">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_close_12">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_error_12">事件: &apos;error&apos;</a></li>
<li><a href="all.html#all_socket_send_buf_offset_length_port_address_callback_1">socket.send(buf, offset, length, port, address, [callback])</a></li>
<li><a href="all.html#all_socket_bind_port_address_callback_1">socket.bind(port, [address], [callback])</a></li>
<li><a href="all.html#all_socket_close_1">socket.close()</a></li>
<li><a href="all.html#all_socket_address_3">socket.address()</a></li>
<li><a href="all.html#all_socket_setbroadcast_flag_1">socket.setBroadcast(flag)</a></li>
<li><a href="all.html#all_socket_setttl_ttl_1">socket.setTTL(ttl)</a></li>
<li><a href="all.html#all_socket_setmulticastttl_ttl_1">socket.setMulticastTTL(ttl)</a></li>
<li><a href="all.html#all_socket_setmulticastloopback_flag_1">socket.setMulticastLoopback(flag)</a></li>
<li><a href="all.html#all_socket_addmembership_multicastaddress_multicastinterface_1">socket.addMembership(multicastAddress, [multicastInterface])</a></li>
<li><a href="all.html#all_socket_dropmembership_multicastaddress_multicastinterface_1">socket.dropMembership(multicastAddress, [multicastInterface])</a></li>
<li><a href="all.html#all_socket_unref_3">socket.unref()</a></li>
<li><a href="all.html#all_socket_ref_3">socket.ref()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_dns_1">DNS</a><ul>
<li><a href="all.html#all_dns_lookup_domain_family_callback_1">dns.lookup(domain, [family], callback)</a></li>
<li><a href="all.html#all_dns_resolve_domain_rrtype_callback_1">dns.resolve(domain, [rrtype], callback)</a></li>
<li><a href="all.html#all_dns_resolve4_domain_callback_1">dns.resolve4(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolve6_domain_callback_1">dns.resolve6(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvemx_domain_callback_1">dns.resolveMx(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvetxt_domain_callback_1">dns.resolveTxt(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvesrv_domain_callback_1">dns.resolveSrv(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvens_domain_callback_1">dns.resolveNs(domain, callback)</a></li>
<li><a href="all.html#all_dns_resolvecname_domain_callback_1">dns.resolveCname(domain, callback)</a></li>
<li><a href="all.html#all_dns_reverse_ip_callback_1">dns.reverse(ip, callback)</a></li>
<li><a href="all.html#all_dns_getservers_1">dns.getServers()</a></li>
<li><a href="all.html#all_dns_setservers_servers_1">dns.setServers(servers)</a></li>
<li><a href="all.html#all_78">错误代码</a></li>
</ul>
</li>
<li><a href="all.html#all_http_1">HTTP</a><ul>
<li><a href="all.html#all_http_status_codes_1">http.STATUS_CODES</a></li>
<li><a href="all.html#all_http_createserver_requestlistener_1">http.createServer([requestListener])</a></li>
<li><a href="all.html#all_http_createclient_port_host_1">http.createClient([port], [host])</a></li>
<li><a href="all.html#all_class_http_server_1">Class: http.Server</a><ul>
<li><a href="all.html#all_event_request_1">Event: &apos;request&apos;</a></li>
<li><a href="all.html#all_connection_3">事件: &apos;connection&apos;</a></li>
<li><a href="all.html#all_close_13">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_event_checkcontinue_1">Event: &apos;checkContinue&apos;</a></li>
<li><a href="all.html#all_connect_4">事件: &apos;connect&apos;</a></li>
<li><a href="all.html#all_event_upgrade_2">Event: &apos;upgrade&apos;</a></li>
<li><a href="all.html#all_event_clienterror_3">Event: &apos;clientError&apos;</a></li>
<li><a href="all.html#all_server_listen_port_hostname_backlog_callback_1">server.listen(port, [hostname], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback_5">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback_5">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_close_callback_4">server.close([callback])</a></li>
<li><a href="all.html#all_server_maxheaderscount_1">server.maxHeadersCount</a></li>
<li><a href="all.html#all_server_settimeout_msecs_callback_2">server.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_server_timeout_2">server.timeout</a></li>
</ul>
</li>
<li><a href="all.html#all_class_http_serverresponse_1">Class: http.ServerResponse</a><ul>
<li><a href="all.html#all_close_14">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_response_writecontinue_1">response.writeContinue()</a></li>
<li><a href="all.html#all_response_writehead_statuscode_reasonphrase_headers_1">response.writeHead(statusCode, [reasonPhrase], [headers])</a></li>
<li><a href="all.html#all_response_settimeout_msecs_callback_1">response.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_response_statuscode_1">response.statusCode</a></li>
<li><a href="all.html#all_response_setheader_name_value_1">response.setHeader(name, value)</a></li>
<li><a href="all.html#all_response_headerssent_1">response.headersSent</a></li>
<li><a href="all.html#all_response_senddate_1">response.sendDate</a></li>
<li><a href="all.html#all_response_getheader_name_1">response.getHeader(name)</a></li>
<li><a href="all.html#all_response_removeheader_name_1">response.removeHeader(name)</a></li>
<li><a href="all.html#all_response_write_chunk_encoding_1">response.write(chunk, [encoding])</a></li>
<li><a href="all.html#all_response_addtrailers_headers_1">response.addTrailers(headers)</a></li>
<li><a href="all.html#all_response_end_data_encoding_1">response.end([data], [encoding])</a></li>
</ul>
</li>
<li><a href="all.html#all_http_request_options_callback_1">http.request(options, callback)</a></li>
<li><a href="all.html#all_http_get_options_callback_1">http.get(options, callback)</a></li>
<li><a href="all.html#all_class_http_agent_1">Class: http.Agent</a><ul>
<li><a href="all.html#all_new_agent_options_1">new Agent([options])</a></li>
<li><a href="all.html#all_agent_maxsockets_1">agent.maxSockets</a></li>
<li><a href="all.html#all_agent_maxfreesockets_1">agent.maxFreeSockets</a></li>
<li><a href="all.html#all_agent_sockets_1">agent.sockets</a></li>
<li><a href="all.html#all_agent_freesockets_1">agent.freeSockets</a></li>
<li><a href="all.html#all_agent_requests_1">agent.requests</a></li>
<li><a href="all.html#all_agent_destroy_1">agent.destroy()</a></li>
<li><a href="all.html#all_agent_getname_options_1">agent.getName(options)</a></li>
</ul>
</li>
<li><a href="all.html#all_http_globalagent_1">http.globalAgent</a></li>
<li><a href="all.html#all_class_http_clientrequest_1">Class: http.ClientRequest</a><ul>
<li><a href="all.html#all_event_response_1">Event &apos;response&apos;</a></li>
<li><a href="all.html#all_event_socket_1">Event: &apos;socket&apos;</a></li>
<li><a href="all.html#all_connect_5">事件: &apos;connect&apos;</a></li>
<li><a href="all.html#all_event_upgrade_3">Event: &apos;upgrade&apos;</a></li>
<li><a href="all.html#all_event_continue_1">Event: &apos;continue&apos;</a></li>
<li><a href="all.html#all_request_write_chunk_encoding_1">request.write(chunk, [encoding])</a></li>
<li><a href="all.html#all_request_end_data_encoding_1">request.end([data], [encoding])</a></li>
<li><a href="all.html#all_request_abort_1">request.abort()</a></li>
<li><a href="all.html#all_request_settimeout_timeout_callback_1">request.setTimeout(timeout, [callback])</a></li>
<li><a href="all.html#all_request_setnodelay_nodelay_1">request.setNoDelay([noDelay])</a></li>
<li><a href="all.html#all_request_setsocketkeepalive_enable_initialdelay_1">request.setSocketKeepAlive([enable], [initialDelay])</a></li>
</ul>
</li>
<li><a href="all.html#all_http_incomingmessage_1">http.IncomingMessage</a><ul>
<li><a href="all.html#all_close_15">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_message_httpversion_1">message.httpVersion</a></li>
<li><a href="all.html#all_message_headers_1">message.headers</a></li>
<li><a href="all.html#all_message_rawheaders_1">message.rawHeaders</a></li>
<li><a href="all.html#all_message_trailers_1">message.trailers</a></li>
<li><a href="all.html#all_message_rawtrailers_1">message.rawTrailers</a></li>
<li><a href="all.html#all_message_settimeout_msecs_callback_1">message.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_message_method_1">message.method</a></li>
<li><a href="all.html#all_message_url_1">message.url</a></li>
<li><a href="all.html#all_message_statuscode_1">message.statusCode</a></li>
<li><a href="all.html#all_message_socket_1">message.socket</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_https_1">HTTPS</a><ul>
<li><a href="all.html#all_https_server_1">类: https.Server</a><ul>
<li><a href="all.html#all_server_settimeout_msecs_callback_3">server.setTimeout(msecs, callback)</a></li>
<li><a href="all.html#all_server_timeout_3">server.timeout</a></li>
</ul>
</li>
<li><a href="all.html#all_https_createserver_options_requestlistener_1">https.createServer(options, [requestListener])</a><ul>
<li><a href="all.html#all_server_listen_port_host_backlog_callback_4">server.listen(port, [host], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback_6">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback_6">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_listen_port_host_backlog_callback_5">server.listen(port, [host], [backlog], [callback])</a></li>
<li><a href="all.html#all_server_listen_path_callback_7">server.listen(path, [callback])</a></li>
<li><a href="all.html#all_server_listen_handle_callback_7">server.listen(handle, [callback])</a></li>
<li><a href="all.html#all_server_close_callback_5">server.close([callback])</a></li>
</ul>
</li>
<li><a href="all.html#all_https_request_options_callback_1">https.request(options, callback)</a></li>
<li><a href="all.html#all_https_get_options_callback_1">https.get(options, callback)</a></li>
<li><a href="all.html#all_https_agent_1">类: https.Agent</a></li>
<li><a href="all.html#all_https_globalagent_1">https.globalAgent</a></li>
</ul>
</li>
<li><a href="all.html#all_url_1">URL</a><ul>
<li><a href="all.html#all_url_parse_urlstr_parsequerystring_slashesdenotehost_1">url.parse(urlStr, [parseQueryString], [slashesDenoteHost])</a></li>
<li><a href="all.html#all_url_format_urlobj_1">url.format(urlObj)</a></li>
<li><a href="all.html#all_url_resolve_from_to_1">url.resolve(from, to)</a></li>
</ul>
</li>
<li><a href="all.html#all_query_string_1">Query String</a><ul>
<li><a href="all.html#all_querystring_stringify_obj_sep_eq_1">querystring.stringify(obj, [sep], [eq])</a></li>
<li><a href="all.html#all_querystring_parse_str_sep_eq_options_1">querystring.parse(str, [sep], [eq], [options])</a></li>
<li><a href="all.html#all_querystring_escape_1">querystring.escape</a></li>
<li><a href="all.html#all_querystring_unescape_1">querystring.unescape</a></li>
</ul>
</li>
<li><a href="all.html#all_punycode_1">punycode</a><ul>
<li><a href="all.html#all_punycode_decode_string_1">punycode.decode(string)</a></li>
<li><a href="all.html#all_punycode_encode_string_1">punycode.encode(string)</a></li>
<li><a href="all.html#all_punycode_tounicode_domain_1">punycode.toUnicode(domain)</a></li>
<li><a href="all.html#all_punycode_toascii_domain_1">punycode.toASCII(domain)</a></li>
<li><a href="all.html#all_punycode_ucs2_1">punycode.ucs2</a><ul>
<li><a href="all.html#all_punycode_ucs2_decode_string_1">punycode.ucs2.decode(string)</a></li>
<li><a href="all.html#all_punycode_ucs2_encode_codepoints_1">punycode.ucs2.encode(codePoints)</a></li>
</ul>
</li>
<li><a href="all.html#all_punycode_version_1">punycode.version</a></li>
</ul>
</li>
<li><a href="all.html#all_readline_1">Readline</a><ul>
<li><a href="all.html#all_readline_createinterface_options_1">readline.createInterface(options)</a></li>
<li><a href="all.html#all_79">类: 接口</a><ul>
<li><a href="all.html#all_rl_setprompt_prompt_1">rl.setPrompt(prompt)</a></li>
<li><a href="all.html#all_rl_prompt_preservecursor_1">rl.prompt([preserveCursor])</a></li>
<li><a href="all.html#all_rl_question_query_callback_1">rl.question(query, callback)</a></li>
<li><a href="all.html#all_rl_pause_1">rl.pause()</a></li>
<li><a href="all.html#all_rl_resume_1">rl.resume()</a></li>
<li><a href="all.html#all_rl_close_1">rl.close()</a></li>
<li><a href="all.html#all_rl_write_data_key_1">rl.write(data, [key])</a></li>
</ul>
</li>
<li><a href="all.html#all_events_1">Events</a><ul>
<li><a href="all.html#all_event_line_1">Event: &apos;line&apos;</a></li>
<li><a href="all.html#all_pause_1">事件: &apos;pause&apos;</a></li>
<li><a href="all.html#all_resume_1">事件: &apos;resume&apos;</a></li>
<li><a href="all.html#all_close_16">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_event_sigint_1">Event: &apos;SIGINT&apos;</a></li>
<li><a href="all.html#all_event_sigtstp_1">Event: &apos;SIGTSTP&apos;</a></li>
<li><a href="all.html#all_event_sigcont_1">Event: &apos;SIGCONT&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_tiny_cli_1">示例: Tiny CLI</a></li>
</ul>
</li>
<li><a href="all.html#all_repl_2">REPL</a><ul>
<li><a href="all.html#all_repl_start_options_1">repl.start(options)</a><ul>
<li><a href="all.html#all_exit_6">事件: &apos;exit&apos;</a></li>
<li><a href="all.html#all_reset_1">事件: &apos;reset&apos;</a></li>
</ul>
</li>
<li><a href="all.html#all_repl_3">REPL 特性</a></li>
</ul>
</li>
<li><a href="all.html#all_javascript_1">执行 JavaScript</a><ul>
<li><a href="all.html#all_vm_runinthiscontext_code_options_1">vm.runInThisContext(code, [options])</a></li>
<li><a href="all.html#all_vm_createcontext_sandbox_1">vm.createContext([sandbox])</a></li>
<li><a href="all.html#all_vm_iscontext_sandbox_1">vm.isContext(sandbox)</a></li>
<li><a href="all.html#all_vm_runincontext_code_contextifiedsandbox_options_1">vm.runInContext(code, contextifiedSandbox, [options])</a></li>
<li><a href="all.html#all_vm_runinnewcontext_code_sandbox_options_1">vm.runInNewContext(code, [sandbox], [options])</a></li>
<li><a href="all.html#all_script_1">类: Script</a><ul>
<li><a href="all.html#all_new_vm_script_code_options_1">new vm.Script(code, options)</a></li>
<li><a href="all.html#all_script_runinthiscontext_options_1">script.runInThisContext([options])</a></li>
<li><a href="all.html#all_script_runincontext_contextifiedsandbox_options_1">script.runInContext(contextifiedSandbox, [options])</a></li>
<li><a href="all.html#all_script_runinnewcontext_sandbox_options_1">script.runInNewContext([sandbox], [options])</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_80">子进程</a><ul>
<li><a href="all.html#all_childprocess_1">类: ChildProcess</a><ul>
<li><a href="all.html#all_error_13">事件:  &apos;error&apos;</a></li>
<li><a href="all.html#all_exit_7">事件:  &apos;exit&apos;</a></li>
<li><a href="all.html#all_close_17">事件: &apos;close&apos;</a></li>
<li><a href="all.html#all_disconnect_3">事件: &apos;disconnect&apos;</a></li>
<li><a href="all.html#all_message_4">事件: &apos;message&apos;</a></li>
<li><a href="all.html#all_child_stdin_1">child.stdin</a></li>
<li><a href="all.html#all_child_stdout_1">child.stdout</a></li>
<li><a href="all.html#all_child_stderr_1">child.stderr</a></li>
<li><a href="all.html#all_child_pid_1">child.pid</a></li>
<li><a href="all.html#all_child_kill_signal_1">child.kill([signal])</a></li>
<li><a href="all.html#all_child_send_message_sendhandle_1">child.send(message, [sendHandle])</a><ul>
<li><a href="all.html#all_server_1">例子: 发送一个server对象</a></li>
<li><a href="all.html#all_socket_1">示例: 发送socket对象</a></li>
</ul>
</li>
<li><a href="all.html#all_child_disconnect_1">child.disconnect()</a></li>
</ul>
</li>
<li><a href="all.html#all_child_process_spawn_command_args_options_1">child_process.spawn(command, [args], [options])</a></li>
<li><a href="all.html#all_child_process_exec_command_options_callback_1">child_process.exec(command, [options], callback)</a></li>
<li><a href="all.html#all_child_process_execfile_file_args_options_callback_1">child_process.execFile(file, args, options, callback)</a></li>
<li><a href="all.html#all_child_process_fork_modulepath_args_options_1">child_process.fork(modulePath, [args], [options])</a></li>
</ul>
</li>
<li><a href="all.html#all_assert_1">断言 (assert)</a><ul>
<li><a href="all.html#all_assert_fail_actual_expected_message_operator_1">assert.fail(actual, expected, message, operator)</a></li>
<li><a href="all.html#all_assert_value_message_assert_ok_value_message_1">assert(value, message), assert.ok(value, [message])</a></li>
<li><a href="all.html#all_assert_equal_actual_expected_message_1">assert.equal(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_notequal_actual_expected_message_1">assert.notEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_deepequal_actual_expected_message_1">assert.deepEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_notdeepequal_actual_expected_message_1">assert.notDeepEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_strictequal_actual_expected_message_1">assert.strictEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_notstrictequal_actual_expected_message_1">assert.notStrictEqual(actual, expected, [message])</a></li>
<li><a href="all.html#all_assert_throws_block_error_message_1">assert.throws(block, [error], [message])</a></li>
<li><a href="all.html#all_assert_doesnotthrow_block_message_1">assert.doesNotThrow(block, [message])</a></li>
<li><a href="all.html#all_assert_iferror_value_1">assert.ifError(value)</a></li>
</ul>
</li>
<li><a href="all.html#all_tty_1">TTY</a><ul>
<li><a href="all.html#all_tty_isatty_fd_1">tty.isatty(fd)</a></li>
<li><a href="all.html#all_tty_setrawmode_mode_1">tty.setRawMode(mode)</a></li>
<li><a href="all.html#all_readstream_1">类: ReadStream</a><ul>
<li><a href="all.html#all_rs_israw_1">rs.isRaw</a></li>
<li><a href="all.html#all_rs_setrawmode_mode_1">rs.setRawMode(mode)</a></li>
</ul>
</li>
<li><a href="all.html#all_writestream_1">类: WriteStream</a><ul>
<li><a href="all.html#all_ws_columns_1">ws.columns</a></li>
<li><a href="all.html#all_ws_rows_1">ws.rows</a></li>
<li><a href="all.html#all_resize_1">事件: &apos;resize&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_zlib_1">Zlib</a><ul>
<li><a href="all.html#all_81">例子</a></li>
<li><a href="all.html#all_zlib_creategzip_options_1">zlib.createGzip([options])</a></li>
<li><a href="all.html#all_zlib_creategunzip_options_1">zlib.createGunzip([options])</a></li>
<li><a href="all.html#all_zlib_createdeflate_options_1">zlib.createDeflate([options])</a></li>
<li><a href="all.html#all_zlib_createinflate_options_1">zlib.createInflate([options])</a></li>
<li><a href="all.html#all_zlib_createdeflateraw_options_1">zlib.createDeflateRaw([options])</a></li>
<li><a href="all.html#all_zlib_createinflateraw_options_1">zlib.createInflateRaw([options])</a></li>
<li><a href="all.html#all_zlib_createunzip_options_1">zlib.createUnzip([options])</a></li>
<li><a href="all.html#all_zlib_zlib_1">类: zlib.Zlib</a><ul>
<li><a href="all.html#all_zlib_flush_kind_callback_1">zlib.flush([kind], callback)</a></li>
<li><a href="all.html#all_zlib_params_level_strategy_callback_1">zlib.params(level, strategy, callback)</a></li>
<li><a href="all.html#all_zlib_reset_1">zlib.reset()</a></li>
</ul>
</li>
<li><a href="all.html#all_zlib_gzip_1">类: zlib.Gzip</a></li>
<li><a href="all.html#all_zlib_gunzip_1">类: zlib.Gunzip</a></li>
<li><a href="all.html#all_zlib_deflate_1">类: zlib.Deflate</a></li>
<li><a href="all.html#all_zlib_inflate_1">类: zlib.Inflate</a></li>
<li><a href="all.html#all_zlib_deflateraw_1">类: zlib.DeflateRaw</a></li>
<li><a href="all.html#all_zlib_inflateraw_1">类: zlib.InflateRaw</a></li>
<li><a href="all.html#all_zlib_unzip_1">类: zlib.Unzip</a></li>
<li><a href="all.html#all_82">快捷方法</a></li>
<li><a href="all.html#all_zlib_deflate_buf_options_callback_1">zlib.deflate(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_deflateraw_buf_options_callback_1">zlib.deflateRaw(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_gzip_buf_options_callback_1">zlib.Gzip(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_gunzip_buf_options_callback_1">zlib.gunzip(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_inflate_buf_options_callback_1">zlib.inflate(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_inflateraw_buf_options_callback_1">zlib.inflateRaw(buf, [options], callback)</a></li>
<li><a href="all.html#all_zlib_unzip_buf_options_callback_1">zlib.unzip(buf, [options], callback)</a></li>
<li><a href="all.html#all_83">选项</a></li>
<li><a href="all.html#all_84">内存使用调优</a></li>
<li><a href="all.html#all_85">常量</a></li>
</ul>
</li>
<li><a href="all.html#all_86">操作系统</a><ul>
<li><a href="all.html#all_os_tmpdir_1">os.tmpdir()</a></li>
<li><a href="all.html#all_os_endianness_1">os.endianness()</a></li>
<li><a href="all.html#all_os_hostname_1">os.hostname()</a></li>
<li><a href="all.html#all_os_type_1">os.type()</a></li>
<li><a href="all.html#all_os_platform_1">os.platform()</a></li>
<li><a href="all.html#all_os_arch_1">os.arch()</a></li>
<li><a href="all.html#all_os_release_1">os.release()</a></li>
<li><a href="all.html#all_os_uptime_1">os.uptime()</a></li>
<li><a href="all.html#all_os_loadavg_1">os.loadavg()</a></li>
<li><a href="all.html#all_os_totalmem_1">os.totalmem()</a></li>
<li><a href="all.html#all_os_freemem_1">os.freemem()</a></li>
<li><a href="all.html#all_os_cpus_1">os.cpus()</a></li>
<li><a href="all.html#all_os_networkinterfaces_1">os.networkInterfaces()</a></li>
<li><a href="all.html#all_os_eol_1">os.EOL</a></li>
</ul>
</li>
<li><a href="all.html#all_87">调试器</a><ul>
<li><a href="all.html#all_88">监视器</a></li>
<li><a href="all.html#all_89">命令参考</a><ul>
<li><a href="all.html#all_90">步进</a></li>
<li><a href="all.html#all_91">断点</a></li>
<li><a href="all.html#all_92">信息</a></li>
<li><a href="all.html#all_93">执行控制</a></li>
<li><a href="all.html#all_94">杂项</a></li>
</ul>
</li>
<li><a href="all.html#all_95">高级使用</a></li>
</ul>
</li>
<li><a href="all.html#all_96">集群</a><ul>
<li><a href="all.html#all_97">它是如何工作的</a></li>
<li><a href="all.html#all_cluster_schedulingpolicy_1">cluster.schedulingPolicy</a></li>
<li><a href="all.html#all_cluster_settings_1">cluster.settings</a></li>
<li><a href="all.html#all_98">集群的主进程(判断当前进程是否是主进程)</a></li>
<li><a href="all.html#all_99">集群的主线程(判断当前线程是否是主线程)</a></li>
<li><a href="all.html#all_fork_1">事件: &apos;fork&apos;</a></li>
<li><a href="all.html#all_online_2">事件: &apos;online&apos;</a></li>
<li><a href="all.html#all_listening_6">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_disconnect_4">事件: &apos;disconnect&apos;</a></li>
<li><a href="all.html#all_exit_8">事件: &apos;exit&apos;</a></li>
<li><a href="all.html#all_setup_1">事件: &apos;setup&apos;</a></li>
<li><a href="all.html#all_cluster_setupmaster_settings_1">cluster.setupMaster([settings])</a></li>
<li><a href="all.html#all_cluster_fork_env_1">cluster.fork([env])</a></li>
<li><a href="all.html#all_cluster_disconnect_callback_1">cluster.disconnect([callback])</a></li>
<li><a href="all.html#all_cluster_worker_1">cluster.worker</a></li>
<li><a href="all.html#all_cluster_workers_1">cluster.workers</a></li>
<li><a href="all.html#all_worker_1">类: Worker</a><ul>
<li><a href="all.html#all_worker_id_1">worker.id</a></li>
<li><a href="all.html#all_worker_process_1">worker.process</a></li>
<li><a href="all.html#all_worker_suicide_1">worker.suicide</a></li>
<li><a href="all.html#all_worker_send_message_sendhandle_1">worker.send(message, [sendHandle])</a></li>
<li><a href="all.html#all_worker_kill_signal_sigterm_1">worker.kill([signal=&apos;SIGTERM&apos;])</a></li>
<li><a href="all.html#all_worker_disconnect_1">worker.disconnect()</a></li>
<li><a href="all.html#all_message_5">事件: &apos;message&apos;</a></li>
<li><a href="all.html#all_online_3">事件: &apos;online&apos;</a></li>
<li><a href="all.html#all_listening_7">事件: &apos;listening&apos;</a></li>
<li><a href="all.html#all_disconnect_5">事件: &apos;disconnect&apos;</a></li>
<li><a href="all.html#all_exit_9">事件: &apos;exit&apos;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="all.html#all_smalloc_1">Smalloc</a><ul>
<li><a href="all.html#all_smalloc_alloc_length_receiver_type_1">smalloc.alloc(length[, receiver][, type])</a></li>
<li><a href="all.html#all_smalloc_copyonto_source_sourcestart_dest_deststart_copylength_1">smalloc.copyOnto(source, sourceStart, dest, destStart, copyLength);</a></li>
<li><a href="all.html#all_smalloc_dispose_obj_1">smalloc.dispose(obj)</a></li>
<li><a href="all.html#all_smalloc_kmaxlength_1">smalloc.kMaxLength</a></li>
<li><a href="all.html#all_smalloc_types_1">smalloc.Types</a></li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>关于本文档<span><a href="all.html#all" id="all">#</a></span></h1>
<!-- type=misc -->

<p>The goal of this documentation is to comprehensively explain the Node.js
API, both from a reference as well as a conceptual point of view.  Each
section describes a built-in module or high-level concept.

</p>
<p>本文档的目标是从参考和概念的角度全面解释 Node.js 的 API，每章节描述一个内置模块或高级概念。

</p>
<p>Where appropriate, property types, method arguments, and the arguments
provided to event handlers are detailed in a list underneath the topic
heading.

</p>
<p>在某些情况下，属性类型、方法参数以及事件处理过程（handler）参数 会被列在主标题下的列表中。

</p>
<p>Every <code>.html</code> document has a corresponding <code>.json</code> document presenting
the same information in a structured manner.  This feature is
experimental, and added for the benefit of IDEs and other utilities that
wish to do programmatic things with the documentation.

</p>
<p>每一个 <code>.html</code> 文件都对应一份内容相同的结构化 <code>.json</code> 文档。这个特性现在还是实验性质的，希望能够为一些需要对文档进行操作的IDE或者其他工具提供帮助。

</p>
<p>Every <code>.html</code> and <code>.json</code> file is generated based on the corresponding
<code>.markdown</code> file in the <code>doc/api/</code> folder in node&apos;s source tree.  The
documentation is generated using the <code>tools/doc/generate.js</code> program.
The HTML template is located at <code>doc/template.html</code>.

</p>
<p>每个 <code>.html</code> 和 <code>.json</code> 文件都是基于源码的 <code>doc/api/</code> 目录下的 <code>.markdown</code> 文件生成的。本文档使用 <code>tools/doc/generate.js</code> 这个程序来生产的。 HTML 模板文件为 <code>doc/template.html</code>。

</p>
<h2>稳定度<span><a href="all.html#all_1" id="all_1">#</a></span></h2>
<!--type=misc-->

<p>Throughout the documentation, you will see indications of a section&apos;s
stability.  The Node.js API is still somewhat changing, and as it
matures, certain parts are more reliable than others.  Some are so
proven, and so relied upon, that they are unlikely to ever change at
all.  Others are brand new and experimental, or known to be hazardous
and in the process of being redesigned.

</p>
<p>在文档中，您可以了解每一个小节的稳定性。Node.js的API会有一些小的改变，当它成熟的时候，会有些部分相比另外一些来说更加可靠。有一部分接受过严格验证，被大量依赖的API几乎是不会改变的。也有一些是新增的、实验性的或者因被证实具有危险性而在重新设计中。

</p>
<p>The stability indices are as follows:

</p>
<p>稳定度定义如下

</p>
<pre><code>稳定度: 5 - 已锁定
除非发现严重缺陷，该代码不会被更改。请不要对此区域提出更改，更改提议将被拒绝。</code></pre>
<h2>JSON 输出<span><a href="all.html#all_json" id="all_json">#</a></span></h2>
<pre><code>稳定度: 1 - 实验性</code></pre>
<p>Every HTML file in the markdown has a corresponding JSON file with the
same data.

</p>
<p>每个通过 markdown 生成的 HTML 文件都对应于一个具有相同数据的 JSON 文件。

</p>
<p>This feature is new as of node v0.6.12.  It is experimental.


</p>
<p>该特性引入于 node v0.6.12。当前是测试性功能。

</p>
<h1>概述<span><a href="all.html#all_2" id="all_2">#</a></span></h1>
<!--type=misc-->

<p>An example of a <a href="http.html">web server</a> written with Node which responds with &apos;Hello
World&apos;:

</p>
<p>一个输出 “Hello World” 的简单 <a href="http.html">Web 服务器</a>例子：

</p>
<pre><code>console.log(&apos;服务器已运行，请打开 http://127.0.0.1:8124/&apos;);</code></pre>
<p>To run the server, put the code into a file called <code>example.js</code> and execute
it with the node program

</p>
<p>要运行这个服务器，先将程序保存为文件 “example.js”，并使用 node 命令来执行：

</p>
<pre><code>&gt; node example.js
服务器已运行，请打开 http://127.0.0.1:8124/</code></pre>
<p>All of the examples in the documentation can be run similarly.


</p>
<p>所有的文档中的例子均使用相同的方式运行。
</p>
<h1>全局对象<span><a href="all.html#all_3" id="all_3">#</a></span></h1>
<!-- type=misc -->

<p>These objects are available in all modules. Some of these objects aren&apos;t
actually in the global scope but in the module scope - this will be noted.

</p>
<p>这些对象在所有模块中都是可用的。有些对象实际上并非在全局作用域内而是在模块作用域内——这种情况在以下文档中会特别指出。

</p>
<h2>global<span><a href="all.html#all_global" id="all_global">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Object} The global namespace object.</p>
</li>
<li><p>{Object} 全局命名空间对象。</p>
</li>
</ul>
<p>In browsers, the top-level scope is the global scope. That means that in
browsers if you&apos;re in the global scope <code>var something</code> will define a global
variable. In Node this is different. The top-level scope is not the global
scope; <code>var something</code> inside a Node module will be local to that module.

</p>
<p>在浏览器中，顶级作用域就是全局作用域。这就是说，在浏览器中，如果当前是在全局作用域内，<code>var something</code>将会声明一个全局变量。在Node中则不同。顶级作用域并非全局作用域，在Node模块里的<code>var something</code>只属于那个模块。

</p>
<h2>process<span><a href="all.html#all_process" id="all_process">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>The process object. See the <a href="process.html#process_process">process object</a> section.

</p>
<p>进程对象。见 <a href="process.html#process_process">进程对象</a>章节。

</p>
<h2>console<span><a href="all.html#all_console" id="all_console">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>Used to print to stdout and stderr. See the <a href="console.html">console</a> section.

</p>
<p>用于打印标准输出和标准错误。见<a href="console.html">控制台</a>章节。

</p>
<h2>类: Buffer<span><a href="all.html#all_buffer" id="all_buffer">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Function}</p>
</li>
<li><p>{Function}</p>
</li>
</ul>
<p>Used to handle binary data. See the <a href="buffer.html">buffer section</a>

</p>
<p>用于处理二进制数据。见<a href="buffer.html#buffer_buffer">Buffer</a>章节。

</p>
<h2>require()<span><a href="all.html#all_require" id="all_require">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{Function}</p>
</li>
<li><p>{Function}</p>
</li>
</ul>
<p>To require modules. See the <a href="modules.html#modules_modules">Modules</a> section.  <code>require</code> isn&apos;t actually a
global but rather local to each module.

</p>
<p>引入模块。见<a href="modules.html#modules_modules">Modules</a>章节。<code>require</code>实际上并非全局的而是各个模块本地的。

</p>
<h3>require.resolve()<span><a href="all.html#all_require_resolve" id="all_require_resolve">#</a></span></h3>
<p>Use the internal <code>require()</code> machinery to look up the location of a module,
but rather than loading the module, just return the resolved filename.

</p>
<p>使用内部的<code>require()</code>机制查找模块的位置，但不加载模块，只返回解析过的模块文件路径。

</p>
<h3>require.cache<span><a href="all.html#all_require_cache" id="all_require_cache">#</a></span></h3>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>Modules are cached in this object when they are required. By deleting a key
value from this object, the next <code>require</code> will reload the module.

</p>
<p>模块在引入时会缓存到该对象。通过删除该对象的键值，下次调用<code>require</code>时会重新加载相应模块。

</p>
<h3>require.extensions<span><a href="all.html#all_require_extensions" id="all_require_extensions">#</a></span></h3>
<pre><code>稳定度：0 - 已废弃</code></pre>
<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>Instruct <code>require</code> on how to handle certain file extensions.

</p>
<p>指导<code>require</code>方法如何处理特定的文件扩展名。

</p>
<p>Process files with the extension <code>.sjs</code> as <code>.js</code>:

</p>
<p>将<code>.sjs</code>文件作为<code>.js</code>文件处理：

</p>
<pre><code>require.extensions[&apos;.sjs&apos;] = require.extensions[&apos;.js&apos;];</code></pre>
<p><strong>Deprecated</strong>  In the past, this list has been used to load
non-JavaScript modules into Node by compiling them on-demand.
However, in practice, there are much better ways to do this, such as
loading modules via some other Node program, or compiling them to
JavaScript ahead of time.

</p>
<p><strong>已废弃</strong> 之前，该列表用于按需编译非JavaScript模块并加载进Node。然而，实践中有更好的方式实现该功能，如通过其他Node程序加载模块，或提前将他们编译成JavaScript代码。

</p>
<p>Since the Module system is locked, this feature will probably never go
away.  However, it may have subtle bugs and complexities that are best
left untouched.

</p>
<p>由于模块系统的API已锁定，该功能可能永远不会去掉。改动它可能会产生细微的错误和复杂性，所以最好保持不变。

</p>
<h2>__filename<span><a href="all.html#all_filename" id="all_filename">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{String}</p>
</li>
<li><p>{String}</p>
</li>
</ul>
<p>The filename of the code being executed.  This is the resolved absolute path
of this code file.  For a main program this is not necessarily the same
filename used in the command line.  The value inside a module is the path
to that module file.

</p>
<p>当前所执行代码文件的文件路径。这是该代码文件经过解析后的绝对路径。对于主程序来说，这和命令行中使用的文件路径未必是相同的。在模块中此变量值是该模块文件的路径。

</p>
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>

</p>
<p>例子：在<code>/Users/mjr</code>下运行<code>node example.js</code>

</p>
<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>
<p><code>__filename</code> isn&apos;t actually a global but rather local to each module.

</p>
<p><code>__filename</code>实际上并非全局的而是各个模块本地的。

</p>
<h2>__dirname<span><a href="all.html#all_dirname" id="all_dirname">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{String}</p>
</li>
<li><p>{String}</p>
</li>
</ul>
<p>The name of the directory that the currently executing script resides in.

</p>
<p>当前执行脚本所在目录的目录名。

</p>
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>

</p>
<p>例子：在<code>/Users/mjr</code>下运行<code>node example.js</code>

</p>
<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>
<p><code>__dirname</code> isn&apos;t actually a global but rather local to each module.

</p>
<p><code>__dirname</code>实际上并非全局的而是各个模块本地的。

</p>
<h2>module<span><a href="all.html#all_module" id="all_module">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>A reference to the current module. In particular
<code>module.exports</code> is the same as the <code>exports</code> object.
<code>module</code> isn&apos;t actually a global but rather local to each module.

</p>
<p>当前模块的引用。特别地，<code>module.exports</code>和<code>exports</code>指向同一个对象。<code>module</code>实际上并非全局的而是各个模块本地的。

</p>
<p>See the <a href="modules.html">module system documentation</a> for more information.

</p>
<p>详情可见<a href="modules.html">模块系统文档</a>。

</p>
<h2>exports<span><a href="all.html#all_exports" id="all_exports">#</a></span></h2>
<!-- type=var -->

<p>A reference to the <code>module.exports</code> object which is shared between all
instances of the current module and made accessible through <code>require()</code>.
See <a href="modules.html">module system documentation</a> for details on when to use <code>exports</code> and
when to use <code>module.exports</code>.
<code>exports</code> isn&apos;t actually a global but rather local to each module.

</p>
<p><code>module.exports</code>对象的引用，该对象被当前模块的所有实例所共享，通过<code>require()</code>可访问该对象。
何时使用<code>exports</code>以及何时使用<code>module.exports</code>的详情可参见<a href="modules.html">模块系统文档</a>。
<code>exports</code>实际上并非全局的而是各个模块本地的。

</p>
<p>See the <a href="modules.html">module system documentation</a> for more information.

</p>
<p>详情可见<a href="modules.html">模块系统文档</a>。

</p>
<p>See the <a href="modules.html">module section</a> for more information.

</p>
<p>关于模块系统的更多信息可参见<a href="modules.html">模块</a> 。

</p>
<h2>setTimeout(cb, ms)<span><a href="all.html#all_settimeout_cb_ms" id="all_settimeout_cb_ms">#</a></span></h2>
<p>Run callback <code>cb</code> after <em>at least</em> <code>ms</code> milliseconds. The actual delay depends
on external factors like OS timer granularity and system load.

</p>
<p>在<em>至少</em><code>ms</code>毫秒后调用回调<code>cb</code>。实际延迟取决于外部因素，如操作系统定时器粒度及系统负载。

</p>
<p>The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&apos;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.

</p>
<p>超时值必须在1-2147483647的范围内（包含1和2147483647）。如果该值超出范围，则该值被当作1毫秒处理。一般来说，一个定时器不能超过24.8天。

</p>
<p>Returns an opaque value that represents the timer.

</p>
<p>返回一个代表该定时器的句柄值。

</p>
<h2>clearTimeout(t)<span><a href="all.html#all_cleartimeout_t" id="all_cleartimeout_t">#</a></span></h2>
<p>Stop a timer that was previously created with <code>setTimeout()</code>. The callback will
not execute.

</p>
<p>停止一个之前通过<code>setTimeout()</code>创建的定时器。回调不会再被执行。

</p>
<h2>setInterval(cb, ms)<span><a href="all.html#all_setinterval_cb_ms" id="all_setinterval_cb_ms">#</a></span></h2>
<p>Run callback <code>cb</code> repeatedly every <code>ms</code> milliseconds. Note that the actual
interval may vary, depending on external factors like OS timer granularity and
system load. It&apos;s never less than <code>ms</code> but it may be longer.

</p>
<p>每隔<code>ms</code>毫秒重复调用回调<code>cb</code>。注意，取决于外部因素，如操作系统定时器粒度及系统负载，实际间隔可能会改变。它不会少于<code>ms</code>但可能比<code>ms</code>长。

</p>
<p>The interval must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&apos;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.

</p>
<p>间隔值必须在1-2147483647的范围内（包含1和2147483647）。如果该值超出范围，则该值被当作1毫秒处理。一般来说，一个定时器不能超过24.8天。

</p>
<p>Returns an opaque value that represents the timer.

</p>
<p>返回一个代表该定时器的句柄值。

</p>
<h2>clearInterval(t)<span><a href="all.html#all_clearinterval_t" id="all_clearinterval_t">#</a></span></h2>
<p>Stop a timer that was previously created with <code>setInterval()</code>. The callback
will not execute.

</p>
<p>停止一个之前通过<code>setInterval()</code>创建的定时器。回调不会再被执行。

</p>
<!--type=global-->

<p>The timer functions are global variables. See the <a href="timers.html">timers</a> section.

</p>
<p>定制器函数是全局变量。见<a href="timers.html">定时器</a>章节。

</p>
<h1>控制台<span><a href="all.html#all_4" id="all_4">#</a></span></h1>
<pre><code>稳定度: 4 - 冻结</code></pre>
<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<!--type=global-->

<p>For printing to stdout and stderr.  Similar to the console object functions
provided by most web browsers, here the output is sent to stdout or stderr.

</p>
<p>用于向 stdout 和 stderr 打印字符。类似于大部分 Web 浏览器提供的 console 对象函数，在这里则是输出到 stdout 或 stderr。

</p>
<p>The console functions are synchronous when the destination is a terminal or
a file (to avoid lost messages in case of premature exit) and asynchronous
when it&apos;s a pipe (to avoid blocking for long periods of time).

</p>
<p>当输出目标是一个终端或者文件时,console函数是同步的(为了防止过早退出时丢失信息).当输出目标是一个管道时它们是异步的(防止阻塞过长时间).

</p>
<p>That is, in the following example, stdout is non-blocking while stderr
is blocking:

</p>
<p>也就是说，在下面的例子中，stdout 是非阻塞的，而 stderr 则是阻塞的。

</p>
<pre><code>$ node script.js 2&gt; error.log | tee info.log</code></pre>
<p>In daily use, the blocking/non-blocking dichotomy is not something you
should worry about unless you log huge amounts of data.

</p>
<p>在日常使用中，您不需要太担心阻塞/非阻塞的差别，除非您需要记录大量数据。

</p>
<h2>console.log([data], [...])<span><a href="all.html#all_console_log_data" id="all_console_log_data">#</a></span></h2>
<p>Prints to stdout with newline. This function can take multiple arguments in a
<code>printf()</code>-like way. Example:

</p>
<p>向 stdout 打印并新起一行。这个函数可以像 <code>printf()</code> 那样接受多个参数，例如：

</p>
<pre><code>console.log(&apos;count: %d&apos;, count);</code></pre>
<p>If formatting elements are not found in the first string then <code>util.inspect</code>
is used on each argument.  See <a href="util.html#util_util_format_format">util.format()</a> for more information.

</p>
<p>如果在第一个字符串中没有找到格式化元素，那么 <code>util.inspect</code> 将被应用到各个参数。详见 <a href="util.html#util_util_format_format">util.format()</a>。

</p>
<h2>console.info([data], [...])<span><a href="all.html#all_console_info_data" id="all_console_info_data">#</a></span></h2>
<p>Same as <code>console.log</code>.

</p>
<p>同 <code>console.log</code>。

</p>
<h2>console.error([data], [...])<span><a href="all.html#all_console_error_data" id="all_console_error_data">#</a></span></h2>
<p>Same as <code>console.log</code> but prints to stderr.

</p>
<p>同 <code>console.log</code>，但输出到 stderr。

</p>
<h2>console.warn([data], [...])<span><a href="all.html#all_console_warn_data" id="all_console_warn_data">#</a></span></h2>
<p>Same as <code>console.error</code>.

</p>
<p>同 <code>console.error</code>。

</p>
<h2>console.dir(obj)<span><a href="all.html#all_console_dir_obj" id="all_console_dir_obj">#</a></span></h2>
<p>Uses <code>util.inspect</code> on <code>obj</code> and prints resulting string to stdout. This function
bypasses any custom <code>inspect()</code> function on <code>obj</code>.

</p>
<p>对 <code>obj</code> 使用 <code>util.inspect</code> 并将结果字符串输出到 stdout。这个函数会忽略 <code>obj</code> 上的任何自定义 <code>inspect()</code>。

</p>
<h2>console.time(label)<span><a href="all.html#all_console_time_label" id="all_console_time_label">#</a></span></h2>
<p>Mark a time.

</p>
<p>标记一个时间点。

</p>
<h2>console.timeEnd(label)<span><a href="all.html#all_console_timeend_label" id="all_console_timeend_label">#</a></span></h2>
<p>Finish timer, record output. Example:

</p>
<p>结束计时器，记录输出。例如：

</p>
<pre><code>console.time(&apos;100-elements&apos;);
for (var i = 0; i &lt; 100; i++) {
  ;
}
console.timeEnd(&apos;100-elements&apos;);</code></pre>
<h2>console.trace(label)<span><a href="all.html#all_console_trace_label" id="all_console_trace_label">#</a></span></h2>
<p>Print a stack trace to stderr of the current position.

</p>
<p>打印当前位置的栈跟踪到 stderr。

</p>
<h2>console.assert(expression, [message])<span><a href="all.html#all_console_assert_expression_message" id="all_console_assert_expression_message">#</a></span></h2>
<p>Same as <a href="assert.html#assert_assert_value_message_assert_ok_value_message">assert.ok()</a> where if the <code>expression</code> evaluates as <code>false</code> throw an
AssertionError with <code>message</code>.

</p>
<p>与 <a href="assert.html#assert_assert_value_message_assert_ok_value_message">assert.ok()</a> 相同，如果 <code>expression</code> 执行结果为 <code>false</code> 则抛出一个带上 <code>message</code> 的 AssertionError。

</p>
<h1>定时器<span><a href="all.html#all_5" id="all_5">#</a></span></h1>
<pre><code>稳定度: 5 - 已锁定</code></pre>
<p>All of the timer functions are globals.  You do not need to <code>require()</code>
this module in order to use them.

</p>
<p>所有的定时器函数都是全局变量. 你使用这些函数时不需要 <code>require()</code>模块.

</p>
<h2>setTimeout(callback, delay, [arg], [...])<span><a href="all.html#all_settimeout_callback_delay_arg" id="all_settimeout_callback_delay_arg">#</a></span></h2>
<p>To schedule execution of a one-time <code>callback</code> after <code>delay</code> milliseconds. Returns a
<code>timeoutId</code> for possible use with <code>clearTimeout()</code>. Optionally you can
also pass arguments to the callback.

</p>
<p>调度 <code>delay</code> 毫秒后的一次 <code>callback</code> 执行。返回一个可能被 <code>clearTimeout()</code> 用到的 <code>timeoutId</code>。可选地，您还能给回调传入参数。

</p>
<p>It is important to note that your callback will probably not be called in exactly
<code>delay</code> milliseconds - Node.js makes no guarantees about the exact timing of when
the callback will fire, nor of the ordering things will fire in. The callback will
be called as close as possible to the time specified.

</p>
<p>请务必注意，您的回调有可能不会在准确的 <code>delay</code> 毫秒后被调用。Node.js 不保证回调被触发的精确时间和顺序。回调会在尽可能接近所指定时间上被调用。

</p>
<h2>clearTimeout(timeoutId)<span><a href="all.html#all_cleartimeout_timeoutid" id="all_cleartimeout_timeoutid">#</a></span></h2>
<p>Prevents a timeout from triggering.

</p>
<p>阻止一个 timeout 被触发。

</p>
<h2>setInterval(callback, delay, [arg], [...])<span><a href="all.html#all_setinterval_callback_delay_arg" id="all_setinterval_callback_delay_arg">#</a></span></h2>
<p>To schedule the repeated execution of <code>callback</code> every <code>delay</code> milliseconds.
Returns a <code>intervalId</code> for possible use with <code>clearInterval()</code>. Optionally
you can also pass arguments to the callback.

</p>
<p>调度每隔 <code>delay</code> 毫秒执行一次的 <code>callback</code>。返回一个可能被 <code>clearInterval()</code> 用到的 <code>intervalId</code>。可选地，您还能给回调传入参数。

</p>
<h2>clearInterval(intervalId)<span><a href="all.html#all_clearinterval_intervalid" id="all_clearinterval_intervalid">#</a></span></h2>
<p>Stops a interval from triggering.

</p>
<p>停止一个 interval 的触发。

</p>
<h2>unref()<span><a href="all.html#all_unref" id="all_unref">#</a></span></h2>
<p>The opaque value returned by <code>setTimeout</code> and <code>setInterval</code> also has the method
<code>timer.unref()</code> which will allow you to create a timer that is active but if
it is the only item left in the event loop won&apos;t keep the program running.
If the timer is already <code>unref</code>d calling <code>unref</code> again will have no effect.

</p>
<p><code>setTimeout</code> 和 <code>setInterval</code> 所返回的值同时具有 <code>timer.unref()</code> 方法，允许您创建一个活动的、但当它是事件循环中仅剩的项目时不会保持程序运行的定时器。如果定时器已被 <code>unref</code>，再次调用 <code>unref</code> 不会产生其它影响。

</p>
<p>In the case of <code>setTimeout</code> when you <code>unref</code> you create a separate timer that
will wakeup the event loop, creating too many of these may adversely effect
event loop performance -- use wisely.

</p>
<p>在 <code>setTimeout</code> 的情景中当您 <code>unref</code> 您会创建另一个定时器，并唤醒事件循环。创建太多这种定时器可能会影响事件循环的性能，慎用。

</p>
<h2>ref()<span><a href="all.html#all_ref" id="all_ref">#</a></span></h2>
<p>If you had previously <code>unref()</code>d a timer you can call <code>ref()</code> to explicitly
request the timer hold the program open. If the timer is already <code>ref</code>d calling
<code>ref</code> again will have no effect.

</p>
<p>如果您之前 <code>unref()</code> 了一个定时器，您可以调用 <code>ref()</code> 来明确要求定时器让程序保持运行。如果定时器已被 <code>ref</code> 那么再次调用 <code>ref</code> 不会产生其它影响。

</p>
<h2>setImmediate(callback, [arg], [...])<span><a href="all.html#all_setimmediate_callback_arg" id="all_setimmediate_callback_arg">#</a></span></h2>
<p>To schedule the &quot;immediate&quot; execution of <code>callback</code> after I/O events
callbacks and before <code>setTimeout</code> and <code>setInterval</code> . Returns an
<code>immediateId</code> for possible use with <code>clearImmediate()</code>. Optionally you
can also pass arguments to the callback.

</p>
<p>调度在所有 I/O 事件回调之后、<code>setTimeout</code> 和 <code>setInterval</code> 之前“立即”执行 <code>callback</code>。返回一个可能被 <code>clearImmediate()</code> 用到的 <code>immediateId</code>。可选地，您还能给回调传入参数。

</p>
<p>Callbacks for immediates are queued in the order in which they were created.
The entire callback queue is processed every event loop iteration. If you queue
an immediate from a inside an executing callback that immediate won&apos;t fire
until the next event loop iteration.

</p>
<p>immediate 的回调以它们创建的顺序被加入队列。整个回调队列会在每个事件循环迭代中被处理。如果您在一个正被执行的回调中添加 immediate，那么这个 immediate 在下一个事件循环迭代之前都不会被触发。

</p>
<h2>clearImmediate(immediateId)<span><a href="all.html#all_clearimmediate_immediateid" id="all_clearimmediate_immediateid">#</a></span></h2>
<p>Stops an immediate from triggering.


</p>
<p>停止一个 immediate 的触发。
</p>
<h1>Modules<span><a href="all.html#all_modules" id="all_modules">#</a></span></h1>
<pre><code>稳定度: 5 - 已锁定</code></pre>
<!--name=module-->

<p>Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, <code>foo.js</code> loads the module
<code>circle.js</code> in the same directory.

</p>
<p>Node有一个简易的模块加载系统。在node中，文件和模块是一一对应的。下面示例是<code>foo.js</code>加载同一目录下的<code>circle.js</code>。

</p>
<p>The contents of <code>foo.js</code>:

</p>
<p> <code>foo.js</code>的内容：

</p>
<pre><code>var circle = require(&apos;./circle.js&apos;);
console.log( &apos;The area of a circle of radius 4 is &apos;
           + circle.area(4));</code></pre>
<p>The contents of <code>circle.js</code>:

</p>
<p><code>circle.js</code>的内容:

</p>
<pre><code>var PI = Math.PI;
exports.area = function (r) {
    return PI * r * r;
};
exports.circumference = function (r) {
    return 2 * PI * r;
};</code></pre>
<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and
<code>circumference()</code>.  To export an object, add to the special <code>exports</code>
object.

</p>
<p><code>circle.js</code>模块输出了<code>area()</code>和<code>circumference()</code>两个函数。要输出某个对象，把它加到<code>exports</code>这个特殊对象下即可。

</p>
<p>Note that <code>exports</code> is a reference to <code>module.exports</code> making it suitable
for augmentation only. If you are exporting a single item such as a
constructor you will want to use <code>module.exports</code> directly instead.

</p>
<p>注意，<code>exports</code>是<code>module.exports</code>的一个引用，只是为了用起来方便。当你想输出的是例如构造函数这样的单个项目，那么需要使用<code>module.exports</code>。

</p>
<pre><code>// 正确输出构造函数
module.exports = MyConstructor;</code></pre>
<p>Variables
local to the module will be private. In this example the variable <code>PI</code> is
private to <code>circle.js</code>.

</p>
<p>模块内的本地变量是私有的。在这里例子中，<code>PI</code>这个变量就是<code>circle.js</code>私有的。

</p>
<p>The module system is implemented in the <code>require(&quot;module&quot;)</code> module.

</p>
<p>模块系统的实现在<code>require(&quot;module&quot;)</code>中。

</p>
<h2>循环<span><a href="all.html#all_6" id="all_6">#</a></span></h2>
<!--type=misc-->

<p>When there are circular <code>require()</code> calls, a module might not be
done being executed when it is returned.

</p>
<p>当存在循环的<code>require()</code>调用时，一个模块可能在返回时并不会被执行。

</p>
<p>Consider this situation:

</p>
<p>考虑这样一种情形:

</p>
<p><code>a.js</code>:

</p>
<p><code>a.js</code>:

</p>
<pre><code>console.log(&apos;a starting&apos;);
exports.done = false;
var b = require(&apos;./b.js&apos;);
console.log(&apos;in a, b.done = %j&apos;, b.done);
exports.done = true;
console.log(&apos;a done&apos;);</code></pre>
<p><code>b.js</code>:

</p>
<p><code>b.js</code>:

</p>
<pre><code>console.log(&apos;b starting&apos;);
exports.done = false;
var a = require(&apos;./a.js&apos;);
console.log(&apos;in b, a.done = %j&apos;, a.done);
exports.done = true;
console.log(&apos;b done&apos;);</code></pre>
<p><code>main.js</code>:

</p>
<p><code>main.js</code>:

</p>
<pre><code>console.log(&apos;main starting&apos;);
var a = require(&apos;./a.js&apos;);
var b = require(&apos;./b.js&apos;);
console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done);</code></pre>
<p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>.  At that
point, <code>b.js</code> tries to load <code>a.js</code>.  In order to prevent an infinite
loop an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the
<code>b.js</code> module.  <code>b.js</code> then finishes loading, and its <code>exports</code> object is
provided to the <code>a.js</code> module.

</p>
<p>首先<code>main.js</code>加载<code>a.js</code>,接着<code>a.js</code>又去加载<code>b.js</code>。这时，<code>b.js</code>会尝试去加载<code>a.js</code>。为了防止无限的循环，<code>a.js</code>会返回一个<strong>unfinished copy</strong>给<code>b.js</code>。然后<code>b.js</code>就会停止加载，并将其<code>exports</code>对象返回给<code>a.js</code>模块。

</p>
<p>By the time <code>main.js</code> has loaded both modules, they&apos;re both finished.
The output of this program would thus be:

</p>
<p>这样<code>main.js</code>就把这两个模块都加载完成了。这段程序的输出如下：

</p>
<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true</code></pre>
<p>If you have cyclic module dependencies in your program, make sure to
plan accordingly.

</p>
<p>如果你的程序中有循环的模块依赖，请确保工作正常。

</p>
<h2>核心模块<span><a href="all.html#all_7" id="all_7">#</a></span></h2>
<!--type=misc-->

<p>Node has several modules compiled into the binary.  These modules are
described in greater detail elsewhere in this documentation.

</p>
<p>Node中有一些模块是编译成二进制的。这些模块在本文档的其他地方有更详细的描述。

</p>
<p>The core modules are defined in node&apos;s source in the <code>lib/</code> folder.

</p>
<p>核心模块定义在node源代码的<code>lib/</code>目录下。

</p>
<p>Core modules are always preferentially loaded if their identifier is
passed to <code>require()</code>.  For instance, <code>require(&apos;http&apos;)</code> will always
return the built in HTTP module, even if there is a file by that name.

</p>
<p><code>require()</code>总是会优先加载核心模块。例如，<code>require(&apos;http&apos;)</code>总是返回编译好的HTTP模块，而不管是否有这个名字的文件。

</p>
<h2>文件模块<span><a href="all.html#all_8" id="all_8">#</a></span></h2>
<!--type=misc-->

<p>If the exact filename is not found, then node will attempt to load the
required filename with the added extension of <code>.js</code>, <code>.json</code>, and then <code>.node</code>.

</p>
<p>如果按文件名没有查找到，那么node会添加 <code>.js</code>和 <code>.json</code>后缀名，再尝试加载，如果还是没有找到，最后会加上<code>.node</code>的后缀名再次尝试加载。

</p>
<p><code>.js</code> files are interpreted as JavaScript text files, and <code>.json</code> files are
parsed as JSON text files. <code>.node</code> files are interpreted as compiled addon
modules loaded with <code>dlopen</code>.

</p>
<p><code>.js</code> 会被解析为Javascript纯文本文件，<code>.json</code> 会被解析为JSON格式的纯文本文件. <code>.node</code> 则会被解析为编译后的插件模块，由<code>dlopen</code>进行加载。

</p>
<p>A module prefixed with <code>&apos;/&apos;</code> is an absolute path to the file.  For
example, <code>require(&apos;/home/marco/foo.js&apos;)</code> will load the file at
<code>/home/marco/foo.js</code>.

</p>
<p>模块以<code>&apos;/&apos;</code>为前缀，则表示绝对路径。例如，<code>require(&apos;/home/marco/foo.js&apos;)</code> ，加载的是<code>/home/marco/foo.js</code>这个文件。

</p>
<p>A module prefixed with <code>&apos;./&apos;</code> is relative to the file calling <code>require()</code>.
That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for
<code>require(&apos;./circle&apos;)</code> to find it.

</p>
<p>模块以<code>&apos;./&apos;</code>为前缀，则路径是相对于调用<code>require()</code>的文件。
也就是说，<code>circle.js</code>必须和<code>foo.js</code>在同一目录下，<code>require(&apos;./circle&apos;)</code>才能找到。

</p>
<p>Without a leading &apos;/&apos; or &apos;./&apos; to indicate a file, the module is either a
&quot;core module&quot; or is loaded from a <code>node_modules</code> folder.

</p>
<p>当没有以&apos;/&apos;或者&apos;./&apos;来指向一个文件时，这个模块要么是&quot;核心模块&quot;，要么就是从<code>node_modules</code>文件夹加载的。

</p>
<p>If the given path does not exist, <code>require()</code> will throw an Error with its
<code>code</code> property set to <code>&apos;MODULE_NOT_FOUND&apos;</code>.

</p>
<p>如果指定的路径不存在，<code>require()</code>会抛出一个<code>code</code>属性为<code>&apos;MODULE_NOT_FOUND&apos;</code>的错误。

</p>
<h2>从<code>node_modules</code>文件夹中加载<span><a href="all.html#all_node_modules" id="all_node_modules">#</a></span></h2>
<!--type=misc-->

<p>If the module identifier passed to <code>require()</code> is not a native module,
and does not begin with <code>&apos;/&apos;</code>, <code>&apos;../&apos;</code>, or <code>&apos;./&apos;</code>, then node starts at the
parent directory of the current module, and adds <code>/node_modules</code>, and
attempts to load the module from that location.

</p>
<p>如果<code>require()</code>中的模块名不是一个本地模块，也没有以<code>&apos;/&apos;</code>, <code>&apos;../&apos;</code>, 或是 <code>&apos;./&apos;</code>开头，那么node会从当前模块的父目录开始，尝试在它的<code>/node_modules</code>文件夹里加载相应模块。

</p>
<p>If it is not found there, then it moves to the parent directory, and so
on, until the root of the tree is reached.

</p>
<p>如果没有找到，那么就再向上移动到父目录，直到到达顶层目录位置。

</p>
<p>For example, if the file at <code>&apos;/home/ry/projects/foo.js&apos;</code> called
<code>require(&apos;bar.js&apos;)</code>, then node would look in the following locations, in
this order:

</p>
<p>例如，如果位于<code>&apos;/home/ry/projects/foo.js&apos;</code>的文件调用了<code>require(&apos;bar.js&apos;)</code>，那么node查找的位置依次为：

</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><p><code>/node_modules/bar.js</code></p>
</li>
<li><p><code>/home/ry/projects/node_modules/bar.js</code></p>
</li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>This allows programs to localize their dependencies, so that they do not
clash.

</p>
<p>这就要求程序员应尽量把依赖放在就近的位置，以防崩溃。

</p>
<h2>Folders as Modules<span><a href="all.html#all_folders_as_modules" id="all_folders_as_modules">#</a></span></h2>
<!--type=misc-->

<p>It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library.
There are three ways in which a folder may be passed to <code>require()</code> as
an argument.

</p>
<p>可以把程序和库放到一个单独的文件夹里，并提供单一入口来指向它。有三种方法，使一个文件夹可以作为<code>require()</code>的参数来加载。

</p>
<p>The first is to create a <code>package.json</code> file in the root of the folder,
which specifies a <code>main</code> module.  An example package.json file might
look like this:

</p>
<p>首先是在文件夹的根目录创建一个叫做<code>package.json</code>的文件，它需要指定一个<code>main</code>模块。下面是一个package.json文件的示例。

</p>
<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>
<p>If this was in a folder at <code>./some-library</code>, then
<code>require(&apos;./some-library&apos;)</code> would attempt to load
<code>./some-library/lib/some-library.js</code>.

</p>
<p>示例中这个文件，如果是放在<code>./some-library</code>目录下面，那么<code>require(&apos;./some-library&apos;)</code>就将会去加载<code>./some-library/lib/some-library.js</code>。

</p>
<p>This is the extent of Node&apos;s awareness of package.json files.

</p>
<p>This is the extent of Node&apos;s awareness of package.json files.

</p>
<p>If there is no package.json file present in the directory, then node
will attempt to load an <code>index.js</code> or <code>index.node</code> file out of that
directory.  For example, if there was no package.json file in the above
example, then <code>require(&apos;./some-library&apos;)</code> would attempt to load:

</p>
<p>如果目录里没有package.json这个文件，那么node就会尝试去加载这个路径下的<code>index.js</code>或者<code>index.node</code>。例如，若上面例子中，没有package.json，那么<code>require(&apos;./some-library&apos;)</code>就将尝试加载下面的文件：

</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><p><code>./some-library/index.node</code></p>
</li>
<li><p><code>./some-library/index.js</code></p>
</li>
<li><code>./some-library/index.node</code></li>
</ul>
<h2>Caching<span><a href="all.html#all_caching" id="all_caching">#</a></span></h2>
<!--type=misc-->

<p>Modules are cached after the first time they are loaded.  This means
(among other things) that every call to <code>require(&apos;foo&apos;)</code> will get
exactly the same object returned, if it would resolve to the same file.

</p>
<p>模块在第一次加载后会被缓存。这意味着（类似其他缓存）每次调用<code>require(&apos;foo&apos;)</code>的时候都会返回同一个对象，当然，必须是每次都解析到同一个文件。

</p>
<p>Multiple calls to <code>require(&apos;foo&apos;)</code> may not cause the module code to be
executed multiple times.  This is an important feature.  With it,
&quot;partially done&quot; objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.

</p>
<p>Multiple calls to <code>require(&apos;foo&apos;)</code> may not cause the module code to be
executed multiple times.  This is an important feature.  With it,
&quot;partially done&quot; objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.

</p>
<p>If you want to have a module execute code multiple times, then export a
function, and call that function.

</p>
<p>如果你希望一个模块多次执行，那么就输出一个函数，然后调用这个函数。

</p>
<h3>Module Caching Caveats<span><a href="all.html#all_module_caching_caveats" id="all_module_caching_caveats">#</a></span></h3>
<!--type=misc-->

<p>Modules are cached based on their resolved filename.  Since modules may
resolve to a different filename based on the location of the calling
module (loading from <code>node_modules</code> folders), it is not a <em>guarantee</em>
that <code>require(&apos;foo&apos;)</code> will always return the exact same object, if it
would resolve to different files.

</p>
<p>模块的缓存是依赖于解析后的文件名。由于随着调用的位置不同，可能解析到不同的文件（比如需从<code>node_modules</code>文件夹加载的情况），所以，如果解析到其他文件时，就不能<em>保证</em><code>require(&apos;foo&apos;)</code>总是会返回确切的同一对象。

</p>
<h2>The <code>module</code> Object<span><a href="all.html#all_the_module_object" id="all_the_module_object">#</a></span></h2>
<!-- type=var -->
<!-- name=module -->

<!-- type=var -->
<!-- name=module -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>In each module, the <code>module</code> free variable is a reference to the object
representing the current module.  In particular
<code>module.exports</code> is accessible via the <code>exports</code> module-global.
<code>module</code> isn&apos;t actually a global but rather local to each module.

</p>
<p>在每一个模块中，变量 <code>module</code> 是一个代表当前模块的对象的引用。
特别地，<code>module.exports</code> 可以通过全局模块对象 <code>exports</code> 获取到。
<code>module</code> 不是事实上的全局对象，而更像是每个模块内部的。

</p>
<h3>module.exports<span><a href="all.html#all_module_exports" id="all_module_exports">#</a></span></h3>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>The <code>module.exports</code> object is created by the Module system. Sometimes this is not
acceptable, many want their module to be an instance of some class. To do this
assign the desired export object to <code>module.exports</code>. For example suppose we
were making a module called <code>a.js</code>

</p>
<p><code>module.exports</code> 对象是通过模块系统产生的。有时候这是难以接受的，许多人想让他们的模块是某个类的实例。
因此，将要导出的对象赋值给 <code>module.exports</code> 。例如，假设我们有一个模块称之为 <code>a.js</code>

</p>
<pre><code>// Do some work, and after some time emit
// the &apos;ready&apos; event from the module itself.
setTimeout(function() {
  module.exports.emit(&apos;ready&apos;);
}, 1000);</code></pre>
<p>Then in another file we could do

</p>
<p>那么，在另一个文件中我们可以这样写

</p>
<pre><code>var a = require(&apos;./a&apos;);
a.on(&apos;ready&apos;, function() {
  console.log(&apos;module a is ready&apos;);
});</code></pre>
<p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be
done in any callbacks.  This does not work:

</p>
<p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be
done in any callbacks.  This does not work:

</p>
<p>x.js:

</p>
<p>x.js:

</p>
<pre><code>setTimeout(function() {
  module.exports = { a: &quot;hello&quot; };
}, 0);</code></pre>
<p>y.js:

</p>
<p>y.js:

</p>
<pre><code>var x = require(&apos;./x&apos;);
console.log(x.a);</code></pre>
<h3>module.require(id)<span><a href="all.html#all_module_require_id" id="all_module_require_id">#</a></span></h3>
<div><ul>
<li><code>id</code> <span>String</span></li>
<li><p>Return: <span>Object</span> <code>module.exports</code> from the resolved module</p>
</li>
<li><p><code>id</code> <span>String</span></p>
</li>
<li>Return: <span>Object</span> 已解析模块的 <code>module.exports</code></li>
</div></ul>
<p>The <code>module.require</code> method provides a way to load a module as if
<code>require()</code> was called from the original module.

</p>
<p><code>module.require</code> 方法提供了一种像 <code>require()</code> 一样从最初的模块加载一个模块的方法。

</p>
<p>Note that in order to do this, you must get a reference to the <code>module</code>
object.  Since <code>require()</code> returns the <code>module.exports</code>, and the <code>module</code> is
typically <em>only</em> available within a specific module&apos;s code, it must be
explicitly exported in order to be used.

</p>
<p>注意，为了这样做，你必须取得一个对 <code>module</code> 对象的引用。
<code>require()</code> 返回 <code>module.exports</code>，并且 <code>module</code> 是一个典型的只能在特定模块作用域内有效的变量，如果要使用它，就必须明确的导出。

</p>
<h3>module.id<span><a href="all.html#all_module_id" id="all_module_id">#</a></span></h3>
<div><ul>
<li><p><span>String</span></p>
</li>
<li><p><span>String</span></p>
</li>
</div></ul>
<p>The identifier for the module.  Typically this is the fully resolved
filename.

</p>
<p>用于区别模块的标识符。通常是完全解析后的文件名。

</p>
<h3>module.filename<span><a href="all.html#all_module_filename" id="all_module_filename">#</a></span></h3>
<div><ul>
<li><p><span>String</span></p>
</li>
<li><p><span>String</span></p>
</li>
</div></ul>
<p>The fully resolved filename to the module.

</p>
<p>模块完全解析后的文件名。

</p>
<h3>module.loaded<span><a href="all.html#all_module_loaded" id="all_module_loaded">#</a></span></h3>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>Whether or not the module is done loading, or is in the process of
loading.

</p>
<p>不论该模块是否加载完毕，或者正在加载的过程中。

</p>
<h3>module.parent<span><a href="all.html#all_module_parent" id="all_module_parent">#</a></span></h3>
<div><ul>
<li><p><span>Module Object</span></p>
</li>
<li><p><span>Module Object</span></p>
</li>
</div></ul>
<p>The module that required this one.

</p>
<p>引入这个模块的模块。

</p>
<h3>module.children<span><a href="all.html#all_module_children" id="all_module_children">#</a></span></h3>
<div><ul>
<li><p><span>Array</span></p>
</li>
<li><p><span>Array</span></p>
</li>
</div></ul>
<p>The module objects required by this one.

</p>
<p>这个模块引入的所有模块对象。

</p>
<h2>总体来说...<span><a href="all.html#all_9" id="all_9">#</a></span></h2>
<!-- type=misc -->

<p>To get the exact filename that will be loaded when <code>require()</code> is called, use
the <code>require.resolve()</code> function.

</p>
<p>为了获取调用 <code>require</code> 加载的确切的文件名，使用 <code>require.resolve()</code> 函数。

</p>
<p>Putting together all of the above, here is the high-level algorithm
in pseudocode of what require.resolve does:

</p>
<p>综上所述，下面用伪代码的高级算法形式表达了 require.resolve 是如何工作的：

</p>
<pre><code>NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of &quot;node_modules&quot; in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS</code></pre>
<h2>从全局文件夹加载<span><a href="all.html#all_10" id="all_10">#</a></span></h2>
<!-- type=misc -->

<p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list
of absolute paths, then node will search those paths for modules if they
are not found elsewhere.  (Note: On Windows, <code>NODE_PATH</code> is delimited by
semicolons instead of colons.)

</p>
<p>如果 <code>NODE_PATH</code> 环境变量设置为一个以冒号分割的绝对路径的列表，
找不到模块时 node 将会从这些路径中搜索模块。
（注意：在 windows 操作系统上，<code>NODE_PATH</code> 是以分号间隔的）

</p>
<p>Additionally, node will search in the following locations:

</p>
<p>此外，node 将会搜索以下地址：

</p>
<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li><p>3: <code>$PREFIX/lib/node</code></p>
</li>
<li><p>1: <code>$HOME/.node_modules</code></p>
</li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>
<p>Where <code>$HOME</code> is the user&apos;s home directory, and <code>$PREFIX</code> is node&apos;s
configured <code>node_prefix</code>.

</p>
<p><code>$HOME</code> 是用户的主目录，<code>$PREFIX</code> 是 node 里配置的 <code>node_prefix</code> 。

</p>
<p>These are mostly for historic reasons.  You are highly encouraged to
place your dependencies locally in <code>node_modules</code> folders.  They will be
loaded faster, and more reliably.

</p>
<p>这些大多是由于历史原因。强烈建议读者将所依赖的模块放到 <code>node_modules</code> 文件夹里。
这样加载的更快也更可靠。

</p>
<h2>访问主模块<span><a href="all.html#all_11" id="all_11">#</a></span></h2>
<!-- type=misc -->

<p>When a file is run directly from Node, <code>require.main</code> is set to its
<code>module</code>. That means that you can determine whether a file has been run
directly by testing

</p>
<p>当 Node 直接运行一个文件时，<code>require.main</code> 就被设置为它的 <code>module</code> 。
也就是说你可以判断一个文件是否是直接被运行的

</p>
<pre><code>require.main === module</code></pre>
<p>For a file <code>foo.js</code>, this will be <code>true</code> if run via <code>node foo.js</code>, but
<code>false</code> if run by <code>require(&apos;./foo&apos;)</code>.

</p>
<p>对于一个 <code>foo.js</code> 文件，如果通过 <code>node foo.js</code> 运行是 <code>true</code> ，但是通过 <code>require(&apos;./foo&apos;)</code> 运行却是 <code>false</code> 。

</p>
<p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to
<code>__filename</code>), the entry point of the current application can be obtained
by checking <code>require.main.filename</code>.

</p>
<p>因为 <code>module </code> 提供了一个 <code>filename </code> 属性（通常等于 <code>__filename</code>），
所以当前程序的入口点可以通过 <code>require.main.filename</code> 来获取。

</p>
<h2>附录： 包管理技巧<span><a href="all.html#all_12" id="all_12">#</a></span></h2>
<!-- type=misc -->

<p>The semantics of Node&apos;s <code>require()</code> function were designed to be general
enough to support a number of sane directory structures. Package manager
programs such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to
build native packages from Node modules without modification.

</p>
<p>Node 的 <code>require()</code> 函数的语义被设计的足够通用化，以支持各种常规目录结构。
包管理程序如 dpkg，rpm 和 npm 将不用修改就能够从 Node 模块构建本地包。

</p>
<p>Below we give a suggested directory structure that could work:

</p>
<p>接下来我们将给你一个可行的目录结构建议：

</p>
<p>Let&apos;s say that we wanted to have the folder at
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a
specific version of a package.

</p>
<p>假设我们希望将一个包的指定版本放在 <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> 目录中。

</p>
<p>Packages can depend on one another. In order to install package <code>foo</code>, you
may have to install a specific version of package <code>bar</code>.  The <code>bar</code> package
may itself have dependencies, and in some cases, these dependencies may even
collide or form cycles.

</p>
<p>包可以依赖于其他包。为了安装包 foo，可能需要安装包 bar 的一个指定版本。
包 bar 也可能有依赖关系，在某些情况下依赖关系可能发生冲突或者形成循环。

</p>
<p>Since Node looks up the <code>realpath</code> of any modules it loads (that is,
resolves symlinks), and then looks for their dependencies in the
<code>node_modules</code> folders as described above, this situation is very simple to
resolve with the following architecture:

</p>
<p>因为 Node 会查找它所加载的模块的真实路径（也就是说会解析符号链接），
然后按照上文描述的方式在 node_modules 目录中寻找依赖关系，这种情形跟以下体系结构非常相像：

</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code>
depends on.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><p><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages
that <code>bar</code> depends on.</p>
</li>
<li><p>/usr/lib/node/foo/1.2.3/ - foo 包 1.2.3 版本的内容</p>
</li>
<li>/usr/lib/node/bar/4.3.2/ - foo 包所依赖的 bar 包的内容</li>
<li>/usr/lib/node/foo/1.2.3/node_modules/bar - 指向 /usr/lib/node/bar/4.3.2/ 的符号链接</li>
<li>/usr/lib/node/bar/4.3.2/node_modules/* - 指向 bar 包所依赖的包的符号链接</li>
</ul>
<p>Thus, even if a cycle is encountered, or if there are dependency
conflicts, every module will be able to get a version of its dependency
that it can use.

</p>
<p>因此即便存在循环依赖或依赖冲突，每个模块还是可以获得他所依赖的包的一个可用版本。

</p>
<p>When the code in the <code>foo</code> package does <code>require(&apos;bar&apos;)</code>, it will get the
version that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Then, when the code in the <code>bar</code> package calls <code>require(&apos;quux&apos;)</code>, it&apos;ll get
the version that is symlinked into
<code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.

</p>
<p>当 foo 包中的代码调用 require(&apos;bar&apos;)，将获得符号链接 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> 指向的版本。
然后，当 bar 包中的代码调用 <code>require(&apos;queue&apos;)</code>，将会获得符号链接 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code> 指向的版本。

</p>
<p>Furthermore, to make the module lookup process even more optimal, rather
than putting packages directly in <code>/usr/lib/node</code>, we could put them in
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then node will not bother
looking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.

</p>
<p>此外，为了进一步优化模块搜索过程，不要将包直接放在 <code>/usr/lib/node</code> 目录中，而是将它们放在 <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code> 目录中。
这样在依赖的包找不到的情况下，就不会一直寻找 <code>/usr/node_modules</code> 目录或 <code>/node_modules</code> 目录了。

</p>
<p>In order to make modules available to the node REPL, it might be useful to
also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment
variable.  Since the module lookups using <code>node_modules</code> folders are all
relative, and based on the real path of the files making the calls to
<code>require()</code>, the packages themselves can be anywhere.


</p>
<p>为了使模块在 node 的 REPL 中可用，你可能需要将 <code>/usr/lib/node_modules</code> 目录加入到 <code>$NODE_PATH</code> 环境变量中。
由于在 node_modules 目录中搜索模块使用的是相对路径，基于调用 <code>require()</code> 的文件所在真实路径，因此包本身可以放在任何位置。
</p>
<h1>Addons插件<span><a href="all.html#all_addons" id="all_addons">#</a></span></h1>
<p>Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:

</p>
<p>Addons插件就是动态连接库。它类似胶水，将c、c++和Node粘贴起来。它的API（目前来说）相当复杂，涉及到了几个类库的知识。

</p>
<ul>
<li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:
creating objects, calling functions, etc.  Documented mostly in the
<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node source
tree), which is also available
<a href="http://izs.me/v8-docs/main.html">online</a>.</p>
</li>
<li><p>V8 JavaScript引擎,一个 C++ 类库. 用于和JavaScript进行交互的接口。
创建对象, 调用函数等. 文档大部分在这里：
<code>v8.h</code> 头文件 (<code>deps/v8/include/v8.h</code>在Node源代码目录里), 也有可用的线上文档
<a href="http://izs.me/v8-docs/main.html">线上</a>.
（译者：想要学习c++的addons插件编写，必须先了解v8的接口）</p>
</li>
<li><p><a href="https://github.com/joyent/libuv">libuv</a>, C event loop library.
Anytime one needs to wait for a file descriptor to become readable,
wait for a timer, or wait for a signal to be received one will need
to interface with libuv. That is, if you perform any I/O, libuv will
need to be used.</p>
</li>
<li><p><a href="https://github.com/joyent/libuv">libuv</a>, C语言编写的事件循环类库。任何时候需要等待一个文件描述符变为可读状态，等待一个定时器，或者等待一个接受信号都需要使用libuv类库的接口。也就是说，如果你执行任何I/O操作，libuv类库将会被用到。</p>
</li>
<li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code>
class which you will likely want to derive from.</p>
</li>
<li><p>内部 Node 类库.最重要的接口就是 <code>node::ObjectWrap</code> 类，这个类你应该是最可能想要派生的。</p>
</li>
<li><p>Others. Look in <code>deps/</code> for what else is available.</p>
</li>
<li><p>其他.请参阅 <code>deps/</code> 获得更多可用类库。</p>
</li>
</ul>
<p>Node statically compiles all its dependencies into the executable.
When compiling your module, you don&apos;t need to worry about linking to
any of these libraries.

</p>
<p>Node 静态编译了所有依赖到它的可执行文件中去了。当编译你的模块时，你不必担心无法连接上述那些类库。
（译者：换而言之，你在编译自己的addons插件时，只管在头部 #include &lt;uv.h&gt;，不必在binding.gyp中声明）

</p>
<p>All of the following examples are available for
<a href="https://github.com/rvagg/node-addon-examples">download</a> and may be
used as a starting-point for your own Addon.

</p>
<p>下面所有的例子都可以下载到：
<a href="https://github.com/rvagg/node-addon-examples">下载</a> 
这或许能成为你学习和创作自己addon插件的起点。

</p>
<h2>Hello world（世界你好）<span><a href="all.html#all_hello_world" id="all_hello_world">#</a></span></h2>
<p>To get started let&apos;s make a small Addon which is the C++ equivalent of
the following JavaScript code:

</p>
<p>作为开始，让我们用编写一个小的addon插件，这个addon插件的c++代码相当于下面的JavaScript代码。

</p>
<pre><code>module.exports.hello = function() { return &apos;world&apos;; };</code></pre>
<p>First we create a file <code>hello.cc</code>:

</p>
<p>首先我们创建一个 <code>hello.cc</code>文件:

</p>
<pre><code>NODE_MODULE(hello, init)//译者：将addon插件名hello和上述init函数关联输出</code></pre>
<p>Note that all Node addons must export an initialization function:

</p>
<p>注意所有Node的addons插件都必须输出一个初始化函数：

</p>
<pre><code>void Initialize (Handle&lt;Object&gt; exports);
NODE_MODULE(module_name, Initialize)</code></pre>
<p>There is no semi-colon after <code>NODE_MODULE</code> as it&apos;s not a function (see
<code>node.h</code>).

</p>
<p>在<code>NODE_MODULE</code>之后没有分号，因为它不是一个函数（请参阅<code>node.h</code>）

</p>
<p>The <code>module_name</code> needs to match the filename of the final binary (minus the
.node suffix).

</p>
<p>这个<code>module_name</code>（模块名）需要和最后编译生成的2进制文件名（减去.node后缀名）相同。

</p>
<p>The source code needs to be built into <code>hello.node</code>, the binary Addon. To
do this we create a file called <code>binding.gyp</code> which describes the configuration
to build your module in a JSON-like format. This file gets compiled by
<a href="https://github.com/TooTallNate/node-gyp">node-gyp</a>.

</p>
<p>源代码需要生成在<code>hello.node</code>，这个2进制addon插件中。
需要做到这些，我们要创建一个名为<code>binding.gyp</code>的文件，它描述了创建这个模块的配置，并且它的格式是类似JSON的。
文件将被命令：<a href="https://github.com/TooTallNate/node-gyp">node-gyp</a> 编译。

</p>
<pre><code>{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;hello&quot;, //译者：addon插件名，注意这里的名字必需和上面NODE_MODULE中的一致
      &quot;sources&quot;: [ &quot;hello.cc&quot; ]  //译者：这是需要编译的源文件
    }
  ]
}</code></pre>
<p>The next step is to generate the appropriate project build files for the
current platform. Use <code>node-gyp configure</code> for that.

</p>
<p>下一步是根据当前的操作系统平台，利用<code>node-gyp configure</code>命令，生成合适的项目文件。

</p>
<p>Now you will have either a <code>Makefile</code> (on Unix platforms) or a <code>vcxproj</code> file
(on Windows) in the <code>build/</code> directory. Next invoke the <code>node-gyp build</code>
command.

</p>
<p>现在你会有一个<code>Makefile</code> (在Unix平台) 或者一个 <code>vcxproj</code> file
(在Windows上)，它们都在<code>build/</code> 文件夹中. 
然后执行命令 <code>node-gyp build</code>进行编译。
（译者：当然你可以执行 <code>node-gyp rebuild</code>一步搞定）

</p>
<p>Now you have your compiled <code>.node</code> bindings file! The compiled bindings end up
in <code>build/Release/</code>.

</p>
<p>现在你已经有了编译好的 <code>.node</code> 文件了，这个编译好的绑定文件会在目录 <code>build/Release/</code>下

</p>
<p>You can now use the binary addon in a Node project <code>hello.js</code> by pointing
<code>require</code> to the recently built <code>hello.node</code> module:

</p>
<p>现在你可以使用这个2进制addon插件在Node项目<code>hello.js</code> 中了，通过指明<code>require</code>这个刚刚创建的<code>hello.node</code>模块使用它。

</p>
<pre><code>console.log(addon.hello()); // &apos;world&apos;</code></pre>
<p>Please see patterns below for further information or
</p>
<p><a href="https://github.com/arturadib/node-qt">https://github.com/arturadib/node-qt</a> for an example in production.

</p>
<p>请阅读下面的内容获得更多详情或者访问<a href="https://github.com/arturadib/node-qt">https://github.com/arturadib/node-qt</a>获取一个生产环境的例子。

</p>
<h2>Addon patterns（插件方式）<span><a href="all.html#all_addon_patterns" id="all_addon_patterns">#</a></span></h2>
<p>Below are some addon patterns to help you get started. Consult the online
<a href="http://izs.me/v8-docs/main.html">v8 reference</a> for help with the various v8
calls, and v8&apos;s <a href="http://code.google.com/apis/v8/embed.html">Embedder&apos;s Guide</a>
for an explanation of several concepts used such as handles, scopes,
function templates, etc.

</p>
<p>下面是一些帮助你开始编写addon插件的方式。参考这个在线的<a href="http://izs.me/v8-docs/main.html">v8 手册</a>用来帮助你调用各种v8接口， 然后是v8的 <a href="http://code.google.com/apis/v8/embed.html">嵌入式开发向导</a> ，解释几个概念，如 handles, scopes,function templates等。


</p>
<p>In order to use these examples you need to compile them using <code>node-gyp</code>.
Create the following <code>binding.gyp</code> file:

</p>
<p>为了能跑起来这些例子，你必须用 <code>node-gyp</code> 来编译他们。
创建一个<code>binding.gyp</code> 文件：

</p>
<pre><code>{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;addon&quot;,
      &quot;sources&quot;: [ &quot;addon.cc&quot; ]
    }
  ]
}</code></pre>
<p>In cases where there is more than one <code>.cc</code> file, simply add the file name to
the <code>sources</code> array, e.g.:

</p>
<p>事实上可以有多个  <code>.cc</code> 文件, 就简单的在 <code>sources</code>  数组里加上即可，例子：

</p>
<pre><code>&quot;sources&quot;: [&quot;addon.cc&quot;, &quot;myexample.cc&quot;]</code></pre>
<p>Now that you have your <code>binding.gyp</code> ready, you can configure and build the
addon:

</p>
<p>现在你有了你的<code>binding.gyp</code>文件了，你可要开始执行configure 和 build 命令构建你的addon插件了

</p>
<pre><code>$ node-gyp configure build</code></pre>
<h3>Function arguments（函数参数）<span><a href="all.html#all_function_arguments" id="all_function_arguments">#</a></span></h3>
<p>The following pattern illustrates how to read arguments from JavaScript
function calls and return a result. This is the main and only needed source
<code>addon.cc</code>:

</p>
<p>下面的部分说明了如何从JavaScript的函数调用获得参数然后返回一个值。这是主要的内容并且仅需要源代码<code>addon.cc</code>。

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>You can test it with the following JavaScript snippet:

</p>
<p>你可以使用下面的JavaScript代码片段来测试它

</p>
<pre><code>console.log( &apos;This should be eight:&apos;, addon.add(3,5) );</code></pre>
<h3>Callbacks（回调）<span><a href="all.html#all_callbacks" id="all_callbacks">#</a></span></h3>
<p>You can pass JavaScript functions to a C++ function and execute them from
there. Here&apos;s <code>addon.cc</code>:

</p>
<p>你可以传递JavaScript functions 到一个C++ function 并且执行他们，这里是 <code>addon.cc</code>文件:

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>Note that this example uses a two-argument form of <code>Init()</code> that receives
the full <code>module</code> object as the second argument. This allows the addon
to completely overwrite <code>exports</code> with a single function instead of
adding the function as a property of <code>exports</code>.

</p>
<p>注意这个例子对<code>Init()</code>使用了两个参数，将完整的 <code>module</code> 对象作为第二个参数传入。这允许addon插件完全的重写 <code>exports</code>，这样就可以用一个函数代替多个函数作为<code>exports</code>的属性了。

</p>
<p>To test it run the following JavaScript snippet:

</p>
<p>你可以使用下面的JavaScript代码片段来测试它

</p>
<pre><code>addon(function(msg){
  console.log(msg); // &apos;hello world&apos;
});</code></pre>
<h3>Object factory（对象工厂）<span><a href="all.html#all_object_factory" id="all_object_factory">#</a></span></h3>
<p>You can create and return new objects from within a C++ function with this
<code>addon.cc</code> pattern, which returns an object with property <code>msg</code> that echoes
the string passed to <code>createObject()</code>:

</p>
<p>在这个<code>addon.cc</code>文件里用一个c++函数，你可以创建并且返回一个新的对象，这个新的对象拥有一个msg的属性，它的值是通过createObject()方法传入的

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>To test it in JavaScript:

</p>
<p>在js中测试如下:

</p>
<pre><code>var obj1 = addon(&apos;hello&apos;);
var obj2 = addon(&apos;world&apos;);
console.log(obj1.msg+&apos; &apos;+obj2.msg); // &apos;hello world&apos;</code></pre>
<h3>Function factory（函数工厂）<span><a href="all.html#all_function_factory" id="all_function_factory">#</a></span></h3>
<p>This pattern illustrates how to create and return a JavaScript function that
wraps a C++ function:

</p>
<p>这次将展示如何创建并返回一个JavaScript function函数，这个函数其实是通过c++包装的。

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>To test:

</p>
<p>测试它:

</p>
<pre><code>var fn = addon();
console.log(fn()); // &apos;hello world&apos;</code></pre>
<h3>Wrapping C++ objects（包装c++对象）<span><a href="all.html#all_wrapping_c_objects_c" id="all_wrapping_c_objects_c">#</a></span></h3>
<p>Here we will create a wrapper for a C++ object/class <code>MyObject</code> that can be
instantiated in JavaScript through the <code>new</code> operator. First prepare the main
module <code>addon.cc</code>:

</p>
<p>这里将创建一个被c++包裹的对象或类<code>MyObject</code>，它是可以在JavaScript中通过<code>new</code>操作符实例化的。
首先我们要准备主要的模块文件<code>addon.cc</code>:

</p>
<pre><code>NODE_MODULE(addon, InitAll)</code></pre>
<p>Then in <code>myobject.h</code> make your wrapper inherit from <code>node::ObjectWrap</code>:

</p>
<p>然后在<code>myobject.h</code>文件中创建你的包装类，它继承自 <code>node::ObjectWrap</code>:

</p>
<pre><code>#endif</code></pre>
<p>And in <code>myobject.cc</code> implement the various methods that you want to expose.
Here we expose the method <code>plusOne</code> by adding it to the constructor&apos;s
prototype:

</p>
<p>在文件 <code>myobject.cc</code> 可以实施各种你想要暴露给js的方法。 
这里我们暴露方法名为 <code>plusOne</code>给就是，它表示将构造函数的属性加1.

</p>
<pre><code>  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<p>Test it with:

</p>
<p>测试它:

</p>
<pre><code>var obj = new addon.MyObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13</code></pre>
<h3>Factory of wrapped objects（工厂包装对象）<span><a href="all.html#all_factory_of_wrapped_objects" id="all_factory_of_wrapped_objects">#</a></span></h3>
<p>This is useful when you want to be able to create native objects without
explicitly instantiating them with the <code>new</code> operator in JavaScript, e.g.

</p>
<p>这是非常有用的，当你想创建原生的JavaScript对象时，又不想明确的使用JavaScript的<code>new</code>操作符。

</p>
<pre><code>var obj = addon.createObject();
// 用上面的方式代替下面的:
// var obj = new addon.Object();</code></pre>
<p>Let&apos;s register our <code>createObject</code> method in <code>addon.cc</code>:

</p>
<p>让我们注册在 <code>addon.cc</code> 文件中注册<code>createObject</code>方法:

</p>
<pre><code>NODE_MODULE(addon, InitAll)</code></pre>
<p>In <code>myobject.h</code> we now introduce the static method <code>NewInstance</code> that takes
care of instantiating the object (i.e. it does the job of <code>new</code> in JavaScript):

</p>
<p>在<code>myobject.h</code>文件中，我们现在介绍静态方法NewInstance<code>，它能够实例化对象（举个例子，它的工作就像是 在JavaScript中的</code>new` 操作符。）

</p>
<pre><code>#endif</code></pre>
<p>The implementation is similar to the above in <code>myobject.cc</code>:

</p>
<p>这里的处理方式和上面的 <code>myobject.cc</code>很像:

</p>
<pre><code>  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<p>Test it with:

</p>
<p>测试它:

</p>
<pre><code>var obj2 = createObject(20);
console.log( obj2.plusOne() ); // 21
console.log( obj2.plusOne() ); // 22
console.log( obj2.plusOne() ); // 23</code></pre>
<h3>Passing wrapped objects around（传递包装的对象）<span><a href="all.html#all_passing_wrapped_objects_around" id="all_passing_wrapped_objects_around">#</a></span></h3>
<p>In addition to wrapping and returning C++ objects, you can pass them around
by unwrapping them with Node&apos;s <code>node::ObjectWrap::Unwrap</code> helper function.
In the following <code>addon.cc</code> we introduce a function <code>add()</code> that can take on two
<code>MyObject</code> objects:

</p>
<p>除了包装和返回c++对象以外，你可以传递他们并且通过Node的<code>node::ObjectWrap::Unwrap</code>帮助函数解包装他们。
在下面的<code>addon.cc</code> 文件中，我们介绍了一个函数<code>add()</code>，它能够获取2个<code>MyObject</code>对象。

</p>
<pre><code>NODE_MODULE(addon, InitAll)</code></pre>
<p>To make things interesting we introduce a public method in <code>myobject.h</code> so we
can probe private values after unwrapping the object:

</p>
<p>为了使事情变得有趣，我们在 <code>myobject.h</code> 采用一个公共的方法，所以我们能够在unwrapping解包装对象之后使用私有成员的值。

</p>
<pre><code>#endif</code></pre>
<p>The implementation of <code>myobject.cc</code> is similar as before:

</p>
<p><code>myobject.cc</code>文件的处理方式和前面类似

</p>
<pre><code>  return scope.Close(instance);
}</code></pre>
<p>Test it with:

</p>
<p>测试它:

</p>
<pre><code>var obj1 = addon.createObject(10);
var obj2 = addon.createObject(20);
var result = addon.add(obj1, obj2);

console.log(result); // 30


console.log(result); // 30</code></pre>
<h1>process<span><a href="all.html#all_process_1" id="all_process_1">#</a></span></h1>
<!-- type=global -->

<p>The <code>process</code> object is a global object and can be accessed from anywhere.
It is an instance of <a href="events.html#events_class_events_eventemitter">EventEmitter</a>.

</p>
<p><code>process</code>对象是一个全局对象，可以在任何地方访问到它。
它是<a href="events.html#events_class_events_eventemitter">EventEmitter</a>的一个实例。

</p>
<h2>Exit Codes<span><a href="all.html#all_exit_codes" id="all_exit_codes">#</a></span></h2>
<p>Node will normally exit with a <code>0</code> status code when no more async
operations are pending.  The following status codes are used in other
cases:

</p>
<p>Node 执行程序正常情况下会返回 0，这也意味着，包括所有“异步”在内的操作都已结束。（笔者注：linux terminal 下使用 echo $? 查看，win cmd 下使用 echo %ERRORLEVEL% 查看）除此之外的其他返回状态如下：

</p>
<ul>
<li><code>1</code> <strong>Uncaught Fatal Exception</strong> - There was an uncaught exception,
and it was not handled by a domain or an <code>uncaughtException</code> event
handler.</li>
<li><code>2</code> - Unused (reserved by Bash for builtin misuse)</li>
<li><code>3</code> <strong>Internal JavaScript Parse Error</strong> - The JavaScript source code
internal in Node&apos;s bootstrapping process caused a parse error.  This
is extremely rare, and generally can only happen during development
of Node itself.</li>
<li><code>4</code> <strong>Internal JavaScript Evaluation Failure</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process failed to
return a function value when evaluated.  This is extremely rare, and
generally can only happen during development of Node itself.</li>
<li><code>5</code> <strong>Fatal Error</strong> - There was a fatal unrecoverable error in V8.
Typically a message will be printed to stderr with the prefix <code>FATAL
ERROR</code>.</li>
<li><code>6</code> <strong>Non-function Internal Exception Handler</strong> - There was an
uncaught exception, but the internal fatal exception handler
function was somehow set to a non-function, and could not be called.</li>
<li><code>7</code> <strong>Internal Exception Handler Run-Time Failure</strong> - There was an
uncaught exception, and the internal fatal exception handler
function itself threw an error while attempting to handle it.  This
can happen, for example, if a <code>process.on(&apos;uncaughtException&apos;)</code> or
<code>domain.on(&apos;error&apos;)</code> handler throws an error.</li>
<li><code>8</code> - Unused.  In previous versions of Node, exit code 8 sometimes
indicated an uncaught exception.</li>
<li><code>9</code> - <strong>Invalid Argument</strong> - Either an unknown option was specified,
or an option requiring a value was provided without a value.</li>
<li><code>10</code> <strong>Internal JavaScript Run-Time Failure</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process threw an error
when the bootstrapping function was called.  This is extremely rare,
and generally can only happen during development of Node itself.</li>
<li><code>12</code> <strong>Invalid Debug Argument</strong> - The <code>--debug</code> and/or <code>--debug-brk</code>
options were set, but an invalid port number was chosen.</li>
<li><p><code>&gt;128</code> <strong>Signal Exits</strong> - If Node receives a fatal signal such as
<code>SIGKILL</code> or <code>SIGHUP</code>, then its exit code will be <code>128</code> plus the
value of the signal code.  This is a standard Unix practice, since
exit codes are defined to be 7-bit integers, and signal exits set
the high-order bit, and then contain the value of the signal code.</p>
</li>
<li><p><code>1</code> <strong>未捕获的致命异常(Uncaught Fatal Exception)</strong> - There was an uncaught exception,
and it was not handled by a domain or an <code>uncaughtException</code> event
handler.</p>
</li>
<li><code>2</code> - 未使用(Unused) (reserved by Bash for builtin misuse)</li>
<li><code>3</code> <strong>解析错误(Internal JavaScript Parse Error)</strong> - The JavaScript source code
internal in Node&apos;s bootstrapping process caused a parse error.  This
is extremely rare, and generally can only happen during development
of Node itself.</li>
<li><code>4</code> <strong>评估失败(Internal JavaScript Evaluation Failure)</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process failed to
return a function value when evaluated.  This is extremely rare, and
generally can only happen during development of Node itself.</li>
<li><code>5</code> <strong>致命错误(Fatal Error)</strong> - There was a fatal unrecoverable error in V8.
Typically a message will be printed to stderr with the prefix <code>FATAL
ERROR</code>.</li>
<li><code>6</code> <strong>未正确的异常处理(Non-function Internal Exception Handler)</strong> - There was an
uncaught exception, but the internal fatal exception handler
function was somehow set to a non-function, and could not be called.</li>
<li><code>7</code> <strong>异常处理函数运行时失败(Internal Exception Handler Run-Time Failure)</strong> - There was an
uncaught exception, and the internal fatal exception handler
function itself threw an error while attempting to handle it.  This
can happen, for example, if a <code>process.on(&apos;uncaughtException&apos;)</code> or
<code>domain.on(&apos;error&apos;)</code> handler throws an error.</li>
<li><code>8</code> - 未使用(Unused).  In previous versions of Node, exit code 8 sometimes
indicated an uncaught exception.</li>
<li><code>9</code> - <strong>无效的参数(Invalid Argument)</strong> - Either an unknown option was specified,
or an option requiring a value was provided without a value.</li>
<li><code>10</code> <strong>运行时失败(Internal JavaScript Run-Time Failure)</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process threw an error
when the bootstrapping function was called.  This is extremely rare,
and generally can only happen during development of Node itself.</li>
<li><code>12</code> <strong>无效的调试参数(Invalid Debug Argument)</strong> - The <code>--debug</code> and/or <code>--debug-brk</code>
options were set, but an invalid port number was chosen.</li>
<li><code>&gt;128</code> <strong>信号退出(Signal Exits)</strong> - If Node receives a fatal signal such as
<code>SIGKILL</code> or <code>SIGHUP</code>, then its exit code will be <code>128</code> plus the
value of the signal code.  This is a standard Unix practice, since
exit codes are defined to be 7-bit integers, and signal exits set
the high-order bit, and then contain the value of the signal code.</li>
</ul>
<h2>事件: &apos;exit&apos;<span><a href="all.html#all_exit" id="all_exit">#</a></span></h2>
<p>Emitted when the process is about to exit.  This is a good hook to perform
constant time checks of the module&apos;s state (like for unit tests).  The main
event loop will no longer be run after the &apos;exit&apos; callback finishes, so
timers may not be scheduled.

</p>
<p>当进程将要退出时触发。这是一个在固定时间检查模块状态（如单元测试）的好时机。需要注意的是 &apos;exit&apos; 的回调结束后，主事件循环将不再运行，所以计时器也会失效。

</p>
<p>Example of listening for <code>exit</code>:

</p>
<p>监听 <code>exit</code> 事件的例子：

</p>
<pre><code>process.on(&apos;exit&apos;, function() {
  // 设置一个延迟执行
  setTimeout(function() {
    console.log(&apos;主事件循环已停止，所以不会执行&apos;);
  }, 0);
  console.log(&apos;退出前执行&apos;);
});</code></pre>
<h2>事件: &apos;uncaughtException&apos;（未捕获错误）<span><a href="all.html#all_uncaughtexception" id="all_uncaughtexception">#</a></span></h2>
<p>Emitted when an exception bubbles all the way back to the event loop. If a
listener is added for this exception, the default action (which is to print
a stack trace and exit) will not occur.

</p>
<p>当一个异常冒泡回归到事件循环中就会触发这个事件，如果建立了一个监听器来监听这个异常，默认的行为（打印堆栈跟踪信息并退出）就不会发生。

</p>
<p>Example of listening for <code>uncaughtException</code>:

</p>
<p>监听 <code>uncaughtException</code> 示例:

</p>
<pre><code>// 故意制造一个异常，而且不catch捕获它.
nonexistentFunc();
console.log(&apos;This will not run.&apos;);</code></pre>
<p>Note that <code>uncaughtException</code> is a very crude mechanism for exception
handling.

</p>
<p>注意，<code>uncaughtException</code>未捕获异常是一个非常粗略的异常处理。

</p>
<p>Don&apos;t use it, use <a href="domain.html">domains</a> instead. If you do use it, restart
your application after every unhandled exception!

</p>
<p>尽量不要使用它，使用 <a href="domain.html">domains</a> 来代替它，如果你已经使用了，请在不处理这个异常之后重启你的应用。

</p>
<p>Do <em>not</em> use it as the node.js equivalent of <code>On Error Resume Next</code>. An
unhandled exception means your application - and by extension node.js itself -
is in an undefined state. Blindly resuming means <em>anything</em> could happen.

</p>
<p>请 <em>不要</em> 象使用node.js的<code>有错误回复执行</code>这样使用.一个未处理异常意味着你的应用和你的扩展Node.js自身是有未知状态的。盲目的恢复意味着<em>任何事情</em>都可能发生。

</p>
<p>Think of resuming as pulling the power cord when you are upgrading your system.
Nine out of ten times nothing happens - but the 10th time, your system is bust.

</p>
<p>你在升级的系统时拉掉了电源线，然后恢复了。可能10次里有9次每一偶问题，但是第10次，你的系统就会崩溃。

</p>
<p>You have been warned.

</p>
<p>你已经被警告。

</p>
<h2>Signal Events<span><a href="all.html#all_signal_events" id="all_signal_events">#</a></span></h2>
<!--type=event-->
<!--name=SIGINT, SIGUSR1, etc.-->

<!--type=event-->
<!--name=SIGINT, SIGUSR1, etc.-->

<p>Emitted when the processes receives a signal. See sigaction(2) for a list of
standard POSIX signal names such as SIGINT, SIGUSR1, etc.

</p>
<p>当进程接收到信号时触发。信号列表详见 POSIX 标准的 sigaction（2）如 SIGINT、SIGUSR1 等。

</p>
<p>Example of listening for <code>SIGINT</code>:

</p>
<p>监听 <code>SIGINT</code> 信号的示例：

</p>
<pre><code>// 设置 &apos;SIGINT&apos; 信号触发事件
process.on(&apos;SIGINT&apos;, function() {
  console.log(&apos;收到 SIGINT 信号。  退出请使用 Ctrl + D &apos;);
});</code></pre>
<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal
programs.

</p>
<p>在大多数终端下，一个发送 <code>SIGINT</code> 信号的简单方法是按下 <code>ctrl + c</code> 。

</p>
<h2>process.stdout<span><a href="all.html#all_process_stdout" id="all_process_stdout">#</a></span></h2>
<p>A <code>Writable Stream</code> to <code>stdout</code>.

</p>
<p>一个指向<code>标准输出流(stdout)</code>的 <code>可写的流(Writable Stream)</code>。

</p>
<p>Example: the definition of <code>console.log</code>

</p>
<p>举例: <code>console.log</code> 的实现

</p>
<pre><code>console.log = function(d) {
  process.stdout.write(d + &apos;\n&apos;);
}; </code></pre>
<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.

</p>
<p>process.stderr 和 process.stdout 不像 Node 中其他的流(Streams) 那样，他们通常是阻塞式的写入。当其引用指向 <code>普通文件</code> 或者 <code>TTY文件描述符</code> 时他们就是阻塞的（注：TTY 可以理解为终端的一种，可联想 PuTTY，详见<a href="http://baike.baidu.com/view/749979.htm">百科</a>）。当他们引用指向管道(pipes)时，他们就同其他的流(Streams)一样是非阻塞的。

</p>
<p>To check if Node is being run in a TTY context, read the <code>isTTY</code> property
on <code>process.stderr</code>, <code>process.stdout</code>, or <code>process.stdin</code>:

</p>
<p>要检查 Node 是否正在运行一个 TTY上下文 中（注：linux 中没有运行在 tty 下的进程是 <code>守护进程</code> ），可以用使用 process.stderr、process.stdout 或 process.stdin 的 isTTY 属性：

</p>
<pre><code>$ node -p &quot;Boolean(process.stdout.isTTY)&quot;
true
$ node -p &quot;Boolean(process.stdout.isTTY)&quot; | cat
false </code></pre>
<p>See <a href="tty.html#tty_tty">the tty docs</a> for more information.

</p>
<p>更多信息，请查看 <a href="tty.html#tty_tty">tty 文档</a>。

</p>
<h2>process.stderr<span><a href="all.html#all_process_stderr" id="all_process_stderr">#</a></span></h2>
<p>A writable stream to stderr.

</p>
<p>一个指向标准错误流(stderr)的 可写的流(Writable Stream)。

</p>
<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.

</p>
<p>process.stderr 和 process.stdout 不像 Node 中其他的流(Streams) 那样，他们通常是阻塞式的写入。当其引用指向 <code>普通文件</code> 或者 <code>TTY文件描述符</code> 时他们就是阻塞的（注：TTY 可以理解为终端的一种，可联想 PuTTY，详见<a href="http://baike.baidu.com/view/749979.htm">百科</a>）。当他们引用指向管道(pipes)时，他们就同其他的流(Streams)一样是非阻塞的。

</p>
<h2>process.stdin<span><a href="all.html#all_process_stdin" id="all_process_stdin">#</a></span></h2>
<p>A <code>Readable Stream</code> for stdin. The stdin stream is paused by default, so one
must call <code>process.stdin.resume()</code> to read from it.

</p>
<p>一个指向 标准输入流(stdin) 的可读流(Readable Stream)。标准输入流默认是暂停 (pause) 的，所以必须要调用 process.stdin.resume() 来恢复 (resume) 接收。

</p>
<p>Example of opening standard input and listening for both events:

</p>
<p>打开标准输入流，并监听两个事件的示例：

</p>
<pre><code>process.stdin.on(&apos;end&apos;, function() {
  process.stdout.write(&apos;end&apos;);
});


// gets 函数的简单实现
function gets(cb){
  process.stdin.resume();
  process.stdin.setEncoding(&apos;utf8&apos;);

  process.stdin.on(&apos;data&apos;, function(chunk) {
     process.stdin.pause();
     cb(chunk);
  });
}

gets(function(reuslt){
  console.log(&quot;[&quot;+reuslt+&quot;]&quot;);
});</code></pre>
<h2>process.argv<span><a href="all.html#all_process_argv" id="all_process_argv">#</a></span></h2>
<p>An array containing the command line arguments.  The first element will be
&apos;node&apos;, the second element will be the name of the JavaScript file.  The
next elements will be any additional command line arguments.

</p>
<p>一个包含命令行参数的数组。第一个元素会是 &apos;node&apos;， 第二个元素将是 .Js 文件的名称。接下来的元素依次是命令行传入的参数。

</p>
<pre><code>// 打印 process.argv
process.argv.forEach(function(val, index, array) {
  console.log(index + &apos;: &apos; + val);
});</code></pre>
<p>This will generate:

</p>
<p>输出将会是：

</p>
<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four </code></pre>
<h2>process.execPath<span><a href="all.html#all_process_execpath" id="all_process_execpath">#</a></span></h2>
<p>This is the absolute pathname of the executable that started the process.

</p>
<p>开启当前进程的这个可执行文件的绝对路径。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>/usr/local/bin/node </code></pre>
<h2>process.execArgv<span><a href="all.html#all_process_execargv" id="all_process_execargv">#</a></span></h2>
<p>This is the set of node-specific command line options from the
executable that started the process.  These options do not show up in
<code>process.argv</code>, and do not include the node executable, the name of
the script, or any options following the script name. These options
are useful in order to spawn child processes with the same execution
environment as the parent.

</p>
<p>与 <code>process.argv</code> 类似，不过是用于保存 node特殊(node-specific) 的命令行选项（参数）。这些特殊的选项不会出现在 <code>process.argv</code> 中，而且 process.execArgv 不会保存 <code>process.argv</code> 中保存的参数（如 0:node 1:文件名 2.3.4.参数 等），
所有文件名之后的参数都会被忽视。这些选项可以用于派生与与父进程相同执行环境的子进程。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>$ node --harmony script.js --version </code></pre>
<p>results in process.execArgv:

</p>
<p>process.execArgv 中的特殊选项:

</p>
<pre><code>[&apos;--harmony&apos;] </code></pre>
<p>and process.argv:

</p>
<p>process.argv 接收到的参数:

</p>
<pre><code>[&apos;/usr/local/bin/node&apos;, &apos;script.js&apos;, &apos;--version&apos;] </code></pre>
<h2>process.abort()<span><a href="all.html#all_process_abort" id="all_process_abort">#</a></span></h2>
<p>This causes node to emit an abort. This will cause node to exit and
generate a core file.

</p>
<p>这将导致 Node 触发一个abort事件，这会导致Node退出并且创建一个核心文件。

</p>
<h2>process.chdir(directory)<span><a href="all.html#all_process_chdir_directory" id="all_process_chdir_directory">#</a></span></h2>
<p>Changes the current working directory of the process or throws an exception if that fails.

</p>
<p>改变进程的当前进程的工作目录，若操作失败则抛出异常。 

</p>
<pre><code>console.log(&apos;当前目录：&apos; + process.cwd());
try {
  process.chdir(&apos;/tmp&apos;);
  console.log(&apos;新目录：&apos; + process.cwd());
}
catch (err) {
  console.log(&apos;chdir: &apos; + err);
}</code></pre>
<h2>process.cwd()<span><a href="all.html#all_process_cwd" id="all_process_cwd">#</a></span></h2>
<p>Returns the current working directory of the process.

</p>
<p>返回进程当前的工作目录。 

</p>
<pre><code>console.log(&apos;当前目录：&apos; + process.cwd());</code></pre>
<h2>process.env<span><a href="all.html#all_process_env" id="all_process_env">#</a></span></h2>
<p>An object containing the user environment. See environ(7).

</p>
<p>一个包括用户环境的对象。详细参见 environ(7)。

</p>
<h2>process.exit([code])<span><a href="all.html#all_process_exit_code" id="all_process_exit_code">#</a></span></h2>
<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the
&apos;success&apos; code <code>0</code>.

</p>
<p>终止当前进程并返回给定的 <code>code</code>。如果省略了 <code>code</code>，退出是会默认返回成功的状态码(&apos;success&apos; code) 也就是 <code>0</code>。

</p>
<p>To exit with a &apos;failure&apos; code:

</p>
<p>退出并返回失败的状态 (&apos;failure&apos; code):

</p>
<pre><code>process.exit(1); </code></pre>
<p>The shell that executed node should see the exit code as 1.

</p>
<p>执行上述代码，用来执行 node 的 shell 就能收到值为 1 的 exit code

</p>
<h2>process.exitCode<span><a href="all.html#all_process_exitcode" id="all_process_exitcode">#</a></span></h2>
<p>A number which will be the process exit code, when the process either
exits gracefully, or is exited via <code>process.exit()</code> without specifying
a code.

</p>
<p>当进程既正常退出，或者通过未指定 code 的 <code>process.exit()</code> 退出时，这个属性中所存储的数字将会成为进程退出的错误码 (exit code)。

</p>
<p>Specifying a code to <code>process.exit(code)</code> will override any previous
setting of <code>process.exitCode</code>.

</p>
<p>如果指名了 <code>process.exit(code)</code> 中退出的错误码 (code)，则会覆盖掉 <code>process.exitCode</code> 的设置。

</p>
<h2>process.getgid()<span><a href="all.html#all_process_getgid" id="all_process_getgid">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Gets the group identity of the process. (See getgid(2).)
This is the numerical group id, not the group name.

</p>
<p>获取进程的群组标识（详见getgid(2)）。获取到的是群组的数字ID，不是群组名称。

</p>
<pre><code>if (process.getgid) {
  console.log(&apos;当前 gid: &apos; + process.getgid());
}</code></pre>
<h2>process.setgid(id)<span><a href="all.html#all_process_setgid_id" id="all_process_setgid_id">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Sets the group identity of the process. (See setgid(2).)  This accepts either
a numerical ID or a groupname string. If a groupname is specified, this method
blocks while resolving it to a numerical ID.

</p>
<p>设置进程的群组标识（详见getgid(2)）。参数可以是一个数字ID或者群组名字符串。如果指定了一个群组名，这个方法会阻塞等待将群组名解析为数字ID。 

</p>
<pre><code>if (process.getgid &amp;&amp; process.setgid) {
  console.log(&apos;当前 gid: &apos; + process.getgid());
  try {
    process.setgid(501);
    console.log(&apos;新 gid: &apos; + process.getgid());
  }
  catch (err) {
    console.log(&apos;设置 gid 失败: &apos; + err);
  }
}</code></pre>
<h2>process.getuid()<span><a href="all.html#all_process_getuid" id="all_process_getuid">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Gets the user identity of the process. (See getuid(2).)
This is the numerical userid, not the username.

</p>
<p>获取执行进程的用户ID（详见getgid(2)）。这是用户的数字ID，不是用户名。

</p>
<pre><code>if (process.getuid) {
  console.log(&apos;当前 uid: &apos; + process.getuid());
}</code></pre>
<h2>process.setuid(id)<span><a href="all.html#all_process_setuid_id" id="all_process_setuid_id">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Sets the user identity of the process. (See setuid(2).)  This accepts either
a numerical ID or a username string.  If a username is specified, this method
blocks while resolving it to a numerical ID.

</p>
<p>设置执行进程的用户ID（详见getgid(2)）。参数可以使一个数字ID或者用户名字符串。如果指定了一个用户名，那么该方法会阻塞等待将用户名解析为数字ID。

</p>
<pre><code>if (process.getuid &amp;&amp; process.setuid) {
  console.log(&apos;当前 uid: &apos; + process.getuid());
  try {
    process.setuid(501);
    console.log(&apos;新 uid: &apos; + process.getuid());
  }
  catch (err) {
    console.log(&apos;设置 uid 失败: &apos; + err);
  }
}</code></pre>
<h2>process.getgroups()<span><a href="all.html#all_process_getgroups" id="all_process_getgroups">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Returns an array with the supplementary group IDs. POSIX leaves it unspecified
if the effective group ID is included but node.js ensures it always is.

</p>
<p>返回一个保存补充组ID(supplementary group ID)的数组。POSIX 标准没有指名 如果有效组 ID（effective group ID）被包括在内的情况，而在 node.js 中则确保它始终是。（POSIX leaves it unspecified if the effective group ID is included but node.js ensures it always is.  ）

</p>
<h2>process.setgroups(groups)<span><a href="all.html#all_process_setgroups_groups" id="all_process_setgroups_groups">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Sets the supplementary group IDs. This is a privileged operation, meaning you
need to be root or have the CAP_SETGID capability.

</p>
<p>设置补充分组的ID标识. 这是一个特殊的操作, 意味着你必须拥有root或者CAP_SETGID权限才可以。（译者：CAP_SETGID表示设定程序允许普通用户使用setgid函数,这与文件的setgid权限位无关）

</p>
<p>The list can contain group IDs, group names or both.

</p>
<p>这个列表可以包括分组的ID表示，或分组名或两者都有。

</p>
<h2>process.initgroups(user, extra_group)<span><a href="all.html#all_process_initgroups_user_extra_group" id="all_process_initgroups_user_extra_group">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Reads /etc/group and initializes the group access list, using all groups of
which the user is a member. This is a privileged operation, meaning you need
to be root or have the CAP_SETGID capability.

</p>
<p>读取 /etc/group 并且初始化group分组访问列表，使用改成员所在的所有分组， 这是一个特殊的操作, 意味着你必须拥有root或者CAP_SETGID权限才可以。

</p>
<p><code>user</code> is a user name or user ID. <code>extra_group</code> is a group name or group ID.

</p>
<p><code>user</code> 是一个用户名或者用户ID. <code>extra_group</code>是分组的组名或者分组ID。

</p>
<p>Some care needs to be taken when dropping privileges. Example:

</p>
<p>有时候，当你在注销权限 (dropping privileges) 的时候需要注意。例如： 

</p>
<pre><code>console.log(process.getgroups());         // [ 0 ]
process.initgroups(&apos;bnoordhuis&apos;, 1000);   // switch user
console.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]
process.setgid(1000);                     // drop root gid
console.log(process.getgroups());         // [ 27, 30, 46, 1000 ]</code></pre>
<h2>process.version<span><a href="all.html#all_process_version" id="all_process_version">#</a></span></h2>
<p>A compiled-in property that exposes <code>NODE_VERSION</code>.

</p>
<p>一个暴露编译时存储版本信息的内置变量 <code>NODE_VERSION</code> 的属性。

</p>
<pre><code>console.log(&apos;版本: &apos; + process.version);</code></pre>
<h2>process.versions<span><a href="all.html#all_process_versions" id="all_process_versions">#</a></span></h2>
<p>A property exposing version strings of node and its dependencies.

</p>
<p>一个暴露存储 node 以及其依赖包 版本信息的属性。

</p>
<pre><code>console.log(process.versions); </code></pre>
<p>Will print something like:

</p>
<p>输出：

</p>
<pre><code>{ http_parser: &apos;1.0&apos;,
  node: &apos;0.10.4&apos;,
  v8: &apos;3.14.5.8&apos;,
  ares: &apos;1.9.0-DEV&apos;,
  uv: &apos;0.10.3&apos;,
  zlib: &apos;1.2.3&apos;,
  modules: &apos;11&apos;,
  openssl: &apos;1.0.1e&apos; }</code></pre>
<h2>process.config<span><a href="all.html#all_process_config" id="all_process_config">#</a></span></h2>
<p>An Object containing the JavaScript representation of the configure options
that were used to compile the current node executable. This is the same as
the &quot;config.gypi&quot; file that was produced when running the <code>./configure</code> script.

</p>
<p>一个包含用来编译当前 node.exe 的配置选项的对象。内容与运行 <code>./configure</code> 脚本生成的 &quot;config.gypi&quot; 文件相同。

</p>
<p>An example of the possible output looks like:

</p>
<p>最可能的输出示例如下：

</p>
<pre><code>{ target_defaults:
   { cflags: [],
     default_configuration: &apos;Release&apos;,
     defines: [],
     include_dirs: [],
     libraries: [] },
  variables:
   { host_arch: &apos;x64&apos;,
     node_install_npm: &apos;true&apos;,
     node_prefix: &apos;&apos;,
     node_shared_cares: &apos;false&apos;,
     node_shared_http_parser: &apos;false&apos;,
     node_shared_libuv: &apos;false&apos;,
     node_shared_v8: &apos;false&apos;,
     node_shared_zlib: &apos;false&apos;,
     node_use_dtrace: &apos;false&apos;,
     node_use_openssl: &apos;true&apos;,
     node_shared_openssl: &apos;false&apos;,
     strict_aliasing: &apos;true&apos;,
     target_arch: &apos;x64&apos;,
     v8_use_snapshot: &apos;true&apos; } }</code></pre>
<h2>process.kill(pid, [signal])<span><a href="all.html#all_process_kill_pid_signal" id="all_process_kill_pid_signal">#</a></span></h2>
<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the
string describing the signal to send.  Signal names are strings like
&apos;SIGINT&apos; or &apos;SIGUSR1&apos;.  If omitted, the signal will be &apos;SIGTERM&apos;.
See kill(2) for more information.

</p>
<p>向进程发送一个信号。 <code>pid</code> 是进程的 id 而 <code>signal</code> 则是描述信号的字符串名称。信号的名称都形似 &apos;SIGINT&apos; 或者 &apos;SIGUSR1&apos;。如果没有指定参数则会默认发送 &apos;SIGTERM&apos; 信号，更多信息请查看 kill(2) 。

</p>
<p>Note that just because the name of this function is <code>process.kill</code>, it is
really just a signal sender, like the <code>kill</code> system call.  The signal sent
may do something other than kill the target process.

</p>
<p>值得注意的是，这个函数的名称虽然是 <code>process.kill</code>， 但就像 <code>kill</code> 系统调用（详见《Unix高级编程》）一样，它仅仅只是一个信号发送器。而信号的发送不仅仅只是用来杀死（kill）目标进程。

</p>
<p>Example of sending a signal to yourself:

</p>
<p>向当前进程发送信号的示例：

</p>
<pre><code>process.kill(process.pid, &apos;SIGHUP&apos;); </code></pre>
<h2>process.pid<span><a href="all.html#all_process_pid" id="all_process_pid">#</a></span></h2>
<p>The PID of the process.

</p>
<p>当前进程的 PID 

</p>
<pre><code>console.log(&apos;当前进程 id: &apos; + process.pid);</code></pre>
<h2>process.title<span><a href="all.html#all_process_title" id="all_process_title">#</a></span></h2>
<p>Getter/setter to set what is displayed in &apos;ps&apos;.

</p>
<p>获取/设置 (Getter/setter) &apos;ps&apos; 中显示的进程名。

</p>
<p>When used as a setter, the maximum length is platform-specific and probably
short.

</p>
<p>当设置该属性时，所能设置的字符串最大长度视具体平台而定，如果超过的话会自动截断。

</p>
<p>On Linux and OS X, it&apos;s limited to the size of the binary name plus the
length of the command line arguments because it overwrites the argv memory.

</p>
<p>在 Linux 和 OS X 上，它受限于名称的字节长度加上命令行参数的长度，因为它有覆盖参数内存(argv memory)。

</p>
<p>v0.8 allowed for longer process title strings by also overwriting the environ
memory but that was potentially insecure/confusing in some (rather obscure)
cases.

</p>
<p>v0.8 版本允许更长的进程标题字符串，也支持覆盖环境内存，但是存在潜在的不安全和混乱（很难说清楚）。

</p>
<h2>process.arch<span><a href="all.html#all_process_arch" id="all_process_arch">#</a></span></h2>
<p>What processor architecture you&apos;re running on: <code>&apos;arm&apos;</code>, <code>&apos;ia32&apos;</code>, or <code>&apos;x64&apos;</code>.

</p>
<p>返回当前 CPU 处理器的架构：&apos;arm&apos;、&apos;ia32&apos; 或者 &apos;x64&apos;.

</p>
<pre><code>console.log(&apos;当前CPU架构是：&apos; + process.arch);</code></pre>
<h2>process.platform<span><a href="all.html#all_process_platform" id="all_process_platform">#</a></span></h2>
<p>What platform you&apos;re running on:
<code>&apos;darwin&apos;</code>, <code>&apos;freebsd&apos;</code>, <code>&apos;linux&apos;</code>, <code>&apos;sunos&apos;</code> or <code>&apos;win32&apos;</code>

</p>
<p>返回当前程序运行的平台：<code>&apos;darwin&apos;</code>, <code>&apos;freebsd&apos;</code>, <code>&apos;linux&apos;</code>, <code>&apos;sunos&apos;</code> 或者 <code>&apos;win32&apos;</code>

</p>
<pre><code>console.log(&apos;当前系统平台是： &apos; + process.platform);</code></pre>
<h2>process.memoryUsage()<span><a href="all.html#all_process_memoryusage" id="all_process_memoryusage">#</a></span></h2>
<p>Returns an object describing the memory usage of the Node process
measured in bytes.

</p>
<p>返回一个对象，它描述了Node进程的内存使用情况单位是bytes。 

</p>
<pre><code>console.log(util.inspect(process.memoryUsage())); </code></pre>
<p>This will generate:

</p>
<p>输出将会是：

</p>
<pre><code>{ rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472 } </code></pre>
<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8&apos;s memory usage.

</p>
<p><code>heapTotal</code> 和 <code>heapUsed</code> 是根据 V8引擎的内存使用情况来的

</p>
<h2>process.nextTick(callback)<span><a href="all.html#all_process_nexttick_callback" id="all_process_nexttick_callback">#</a></span></h2>
<div><ul>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
</div></ul>
<p>Once the current event loop turn runs to completion, call the callback
function.

</p>
<p>在事件循环的下一次循环中调用 callback 回调函数。

</p>
<p>This is <em>not</em> a simple alias to <code>setTimeout(fn, 0)</code>, it&apos;s much more
efficient.  It runs before any additional I/O events (including
timers) fire in subsequent ticks of the event loop.

</p>
<p>这 <em>不是</em> <code>setTimeout(fn, 0)</code> 函数的一个简单别名，因为它的效率高多了。该函数能在任何 I/O 事前之前调用我们的回调函数。但是这个函数在层次超过某个限制的时候，也会出现瑕疵，详细见 <code>process.maxTickDepth</code>。

</p>
<pre><code>console.log(&apos;开始&apos;);
process.nextTick(function() {
  console.log(&apos;nextTick 回调&apos;);
});
console.log(&apos;已设定&apos;);
// 输出:
// 开始
// 已设定
// nextTick 回调</code></pre>
<p>This is important in developing APIs where you want to give the user the
chance to assign event handlers after an object has been constructed,
but before any I/O has occurred.

</p>
<p>如果你想要在【对象创建】之后而【I/O 操作】发生之前执行某些操作，那么这个函数对你而言就十分重要了。

</p>
<pre><code>// thing.startDoingStuff() 现在被调用了, 而不是之前.</code></pre>
<p>It is very important for APIs to be either 100% synchronous or 100%
asynchronous.  Consider this example:

</p>
<p>【注意！！】保证你的函数一定是同步执行或者一定是异步执行，这非常重要！！参考如下的例子：

</p>
<pre><code>  fs.stat(&apos;file&apos;, cb);
} </code></pre>
<p>This API is hazardous.  If you do this:

</p>
<p>这样执行是很危险。如果你还不清楚上述行为的危害请看下面的例子：

</p>
<pre><code>maybeSync(true, function() {
  foo();
});
bar(); </code></pre>
<p>then it&apos;s not clear whether <code>foo()</code> or <code>bar()</code> will be called first.

</p>
<p>那么，使用刚才那个不知道是同步还是异步的操作，在编程的时候你就会发现，你不能确定到底是 foo() 先执行，还是 bar() 先执行。

</p>
<p>This approach is much better:

</p>
<p>用下面的方法就可以更好的解决：

</p>
<pre><code>  fs.stat(&apos;file&apos;, cb);
} </code></pre>
<p>Note: the nextTick queue is completely drained on each pass of the
event loop <strong>before</strong> additional I/O is processed.  As a result,
recursively setting nextTick callbacks will block any I/O from
happening, just like a <code>while(true);</code> loop.

</p>
<p>注意：nextTick 的队列会在完全执行完毕之后才调用 I/O 操作 (the nextTick queue is completely drained on each pass of the event loop <strong>before</strong> additional I/O is processed.) 。因此，递归设置 nextTick 的回调就像一个 <code>while(true) ;</code> 循环一样，将会阻止任何 I/O 操作的发生。

</p>
<h2>process.umask([mask])<span><a href="all.html#all_process_umask_mask" id="all_process_umask_mask">#</a></span></h2>
<p>Sets or reads the process&apos;s file mode creation mask. Child processes inherit
the mask from the parent process. Returns the old mask if <code>mask</code> argument is
given, otherwise returns the current mask.

</p>
<p>设置或者读取进程的文件模式的创建掩码。子进程从父进程中继承这个掩码。如果设定了参数 mask 那么返回旧的掩码，否则返回当前的掩码。

</p>
<pre><code>oldmask = process.umask(newmask);
console.log(&apos;原掩码: &apos; + oldmask.toString(8) + &apos;\n&apos;
            &apos;新掩码: &apos; + newmask.toString(8));</code></pre>
<h2>process.uptime()<span><a href="all.html#all_process_uptime" id="all_process_uptime">#</a></span></h2>
<p>Number of seconds Node has been running.

</p>
<p>返回 Node 程序已运行的秒数。

</p>
<h2>process.hrtime()<span><a href="all.html#all_process_hrtime" id="all_process_hrtime">#</a></span></h2>
<p>Returns the current high-resolution real time in a <code>[seconds, nanoseconds]</code>
tuple Array. It is relative to an arbitrary time in the past. It is not
related to the time of day and therefore not subject to clock drift. The
primary use is for measuring performance between intervals.

</p>
<p>返回当前的高分辨时间，形式为 <code>[秒，纳秒]</code> 的元组数组。它是相对于在过去的任意时间。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。

</p>
<p>You may pass in the result of a previous call to <code>process.hrtime()</code> to get
a diff reading, useful for benchmarks and measuring intervals:

</p>
<p>你可以将前一个 <code>process.hrtime()</code> 的结果传递给当前的 <code>process.hrtime()</code> 函数，结果会返回一个比较值，用于基准和衡量时间间隔。

</p>
<pre><code>  console.log(&apos;基准相差 %d 纳秒&apos;, diff[0] * 1e9 + diff[1]);
  // 基准相差 1000000527 纳秒
}, 1000);</code></pre>
<h1>utils<span><a href="all.html#all_utils" id="all_utils">#</a></span></h1>
<pre><code>稳定度: 4 - 冻结</code></pre>
<p>These functions are in the module <code>&apos;util&apos;</code>. Use <code>require(&apos;util&apos;)</code> to
access them.

</p>
<p>如果你想使用模块 <code>&apos;util&apos;</code>中已定义的方法. 只需 <code>require(&apos;util&apos;)</code> 即可使用.

</p>
<p>The <code>util</code> module is primarily designed to support the needs of Node&apos;s
internal APIs.  Many of these utilities are useful for your own
programs.  If you find that these functions are lacking for your
purposes, however, you are encouraged to write your own utilities.  We
are not interested in any future additions to the <code>util</code> module that
are unnecessary for Node&apos;s internal functionality.

</p>
<p><code>util</code>模块设计的主要目的是为了满足Node内部API的需求
。这个模块中的很多方法在你编写Node程序的时候都是很有帮助的。如果你觉得提供的这些方法满足不了你的需求，那么我们鼓励你编写自己的实用工具方法。我们
不希望<code>util</code>模块中添加任何对于Node的内部功能非必要的扩展。

</p>
<h2>util.debuglog(section)<span><a href="all.html#all_util_debuglog_section" id="all_util_debuglog_section">#</a></span></h2>
<div><ul>
<li><code>section</code> <span>String</span> The section of the program to be debugged</li>
<li><p>Returns: <span>Function</span> The logging function</p>
</li>
<li><p><code>section</code> <span>String</span> 被调试的程序节点部分</p>
</li>
<li>返回值: <span>Function</span> 日志处理函数</li>
</div></ul>
<p>This is used to create a function which conditionally writes to stderr
based on the existence of a <code>NODE_DEBUG</code> environment variable.  If the
<code>section</code> name appears in that environment variable, then the returned
function will be similar to <code>console.error()</code>.  If not, then the
returned function is a no-op.

</p>
<p>这个方法是在存在<code>NODE_DEBUG</code>环境变量的基础上，创建一个有条件写到stderr里的函数。如果“节点”的名字出现在这个环境变量里,那么就返回一个功能类似于<code>console.error()</code>的函数.如果不是,那么返回一个空函数.

</p>
<p>For example:

</p>
<p>例如：

</p>
<p>var bar = 123;
debuglog(&apos;hello from foo [%d]&apos;, bar);
</p>
<pre><code>
If this program is run with `NODE_DEBUG=foo` in the environment, then
it will output something like:

如果这个程序以`NODE_DEBUG=foo` 的环境运行，那么它将会输出：

    FOO 3245: hello from foo [123]

where `3245` is the process id.  If it is not run with that
environment variable set, then it will not print anything.

`3245`是进程的ID, 如果程序不以刚才那样设置的环境变量运行，那么将不会输出任何东西。

You may separate multiple `NODE_DEBUG` environment variables with a
comma.  For example, `NODE_DEBUG=fs,net,tls`.

多个`NODE_DEBUG`环境变量,你可以用逗号进行分割。例如，`NODE_DEBUG= fs, net, tls`。

## util.format(format, [...])

Returns a formatted string using the first argument as a `printf`-like format.

根据第一个参数，返回一个格式化字符串，类似`printf`的格式化输出。

The first argument is a string that contains zero or more *placeholders*.
Each placeholder is replaced with the converted value from its corresponding
argument. Supported placeholders are:

第一个参数是一个字符串，包含零个或多个*占位符*。
每一个占位符被替换为与其对应的转换后的值。
支持的占位符有:

* `%s` - String.
* `%d` - Number (both integer and float).
* `%j` - JSON.  Replaced with the string `&apos;[Circular]&apos;` if the argument
         contains circular references.
* `%%` - single percent sign (`&apos;%&apos;`). This does not consume an argument.

* `%s` - 字符串.
* `%d` - 数字 (整型和浮点型).
* `%j` - JSON. 如果这个参数包含循环对象的引用，将会被替换成字符串 `&apos;[Circular]&apos;`。
* `%%` - 单独一个百分号(`&apos;%&apos;`)。不会消耗一个参数。

If the placeholder does not have a corresponding argument, the placeholder is
not replaced.

如果占位符没有相对应的参数，占位符将不会被替换。

    util.format(&apos;%s:%s&apos;, &apos;foo&apos;); // &apos;foo:%s&apos;

If there are more arguments than placeholders, the extra arguments are
converted to strings with `util.inspect()` and these strings are concatenated,
delimited by a space.

如果有多个参数占位符，额外的参数将会调用`util.inspect()`转换为字符串。这些字符串被连接在一起，并且以空格分隔。

    util.format(&apos;%s:%s&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;); // &apos;foo:bar baz&apos;

If the first argument is not a format string then `util.format()` returns
a string that is the concatenation of all its arguments separated by spaces.
Each argument is converted to a string with `util.inspect()`.

如果第一个参数是一个非格式化字符串，那么`util.format()`将会把所有的参数转成字符串，以空格隔开，拼接在一块，并返回该字符串。`util.inspect()`会把每个参数都转成一个字符串。

    util.format(1, 2, 3); // &apos;1 2 3&apos;

## util.log(string)

Output with timestamp on `stdout`.

在控制台进行输出，并带有时间戳。

    示例：require(&apos;util&apos;).log(&apos;Timestamped message.&apos;);

## util.inspect(object, [options])

Return a string representation of `object`, which is useful for debugging.

返回一个对象的字符串表现形式, 在代码调试的时候非常有用.

An optional *options* object may be passed that alters certain aspects of the
formatted string:

可以通过加入一些可选选项，来改变对象的格式化输出形式：

 - `showHidden` - if `true` then the object&apos;s non-enumerable properties will be
   shown too. Defaults to `false`.

 - `showHidden` - 如果设为 `true`，那么该对象的不可枚举的属性将会被显示出来。默认为`false`.

 - `depth` - tells `inspect` how many times to recurse while formatting the
   object. This is useful for inspecting large complicated objects. Defaults to
   `2`. To make it recurse indefinitely pass `null`.

 - `depth` - 告诉 `inspect` 格式化对象的时候递归多少次。这个选项在格式化复杂对象的时候比较有用。 默认为
   `2`。如果想无穷递归下去，则赋值为`null`即可。

 - `colors` - if `true`, then the output will be styled with ANSI color codes.
   Defaults to `false`. Colors are customizable, see below.

 - `colors` - 如果设为`true`，将会以`ANSI`颜色代码风格进行输出.
   默认是`false`。颜色是可定制的，请看下面：

 - `customInspect` - if `false`, then custom `inspect(depth, opts)` functions
   defined on the objects being inspected won&apos;t be called. Defaults to `true`.

 - `customInspect` - 如果设为 `false`，那么定义在被检查对象上的`inspect(depth, opts)` 方法将不会被调用。 默认为`true`。

Example of inspecting all properties of the `util` object:

示例：检查`util`对象上的所有属性

    console.log(util.inspect(util, { showHidden: true, depth: null }));

Values may supply their own custom `inspect(depth, opts)` functions, when
called they receive the current depth in the recursive inspection, as well as
the options object passed to `util.inspect()`.

当被调用的时候，参数值可以提供自己的自定义`inspect(depth, opts)`方法。该方法会接收当前的递归检查深度，以及传入`util.inspect()`的其他参数。

### 自定义 `util.inspect` 颜色

&lt;!-- type=misc --&gt;

Color output (if enabled) of `util.inspect` is customizable globally
via `util.inspect.styles` and `util.inspect.colors` objects.

`util.inspect`彩色输出(如果启用的话) ，可以通过`util.inspect.styles` 和 `util.inspect.colors` 来全局定义。

`util.inspect.styles` is a map assigning each style a color
from `util.inspect.colors`.
Highlighted styles and their default values are:
 * `number` (yellow)
 * `boolean` (yellow)
 * `string` (green)
 * `date` (magenta)
 * `regexp` (red)
 * `null` (bold)
 * `undefined` (grey)
 * `special` - only function at this time (cyan)
 * `name` (intentionally no styling)

`util.inspect.styles`是通过`util.inspect.colors`分配给每个风格颜色的一个映射。
高亮风格和它们的默认值:
 * `number` (黄色)
 * `boolean` (黄色)
 * `string` (绿色)
 * `date` (洋红色)
 * `regexp` (红色)
 * `null` (粗体)
 * `undefined` (灰色)
 * `special` - 在这个时候的唯一方法 (青绿色)
 * `name` (无风格)

Predefined color codes are: `white`, `grey`, `black`, `blue`, `cyan`, 
`green`, `magenta`, `red` and `yellow`.
There are also `bold`, `italic`, `underline` and `inverse` codes.

预定义的颜色代码: `white`, `grey`, `black`, `blue`, `cyan`, 
`green`, `magenta`, `red` 和 `yellow`。
还有 `bold`, `italic`, `underline` 和 `inverse` 代码。

### 自定义对象的`inspect()`方法

&lt;!-- type=misc --&gt;

Objects also may define their own `inspect(depth)` function which `util.inspect()`
will invoke and use the result of when inspecting the object:

对象可以定义自己的 `inspect(depth)`方法；当使用`util.inspect()`检查该对象的时候，将会执行对象自定义的检查方法。

    util.inspect(obj);
      // &quot;{nate}&quot;

You may also return another Object entirely, and the returned String will be
formatted according to the returned Object. This is similar to how
`JSON.stringify()` works:

您也可以返回完全不同的另一个对象，而且返回的字符串将被根据返回的对象格式化。它和`JSON.stringify()`工作原理类似:

    util.inspect(obj);
      // &quot;{ bar: &apos;baz&apos; }&quot;

## util.isArray(object)

Returns `true` if the given &quot;object&quot; is an `Array`. `false` otherwise.

如果给定的对象是`数组`类型，就返回`true`，否则返回`false`

    util.isArray([])
      // true
    util.isArray(new Array)
      // true
    util.isArray({})
      // false

## util.isRegExp(object)

Returns `true` if the given &quot;object&quot; is a `RegExp`. `false` otherwise.

如果给定的对象是`RegExp`类型，就返回`true`，否则返回`false`。

    util.isRegExp(/some regexp/)
      // true
    util.isRegExp(new RegExp(&apos;another regexp&apos;))
      // true
    util.isRegExp({})
      // false

## util.isDate(object)

Returns `true` if the given &quot;object&quot; is a `Date`. `false` otherwise.

如果给定的对象是`Date`类型，就返回`true`，否则返回`false`。

    util.isDate(new Date())
      // true
    util.isDate(Date())
      // false (没有关键字 &apos;new&apos; 返回一个字符串)
    util.isDate({})
      // false

## util.isError(object)

Returns `true` if the given &quot;object&quot; is an `Error`. `false` otherwise.

如果给定的对象是`Error`类型，就返回`true`，否则返回`false`。

    util.isError(new Error())
      // true
    util.isError(new TypeError())
      // true
    util.isError({ name: &apos;Error&apos;, message: &apos;an error occurred&apos; })
      // false

## util.inherits(constructor, superConstructor)

Inherit the prototype methods from one
[constructor](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor)
into another.  The prototype of `constructor` will be set to a new
object created from `superConstructor`.

通过[构造函数](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor)，继承原型对象上的方法。构造函数的`原型`将被设置为一个新的
从`超类`创建的对象。

As an additional convenience, `superConstructor` will be accessible
through the `constructor.super_` property.

你可以很方便的通过 `constructor.super_`来访问到`superConstructor` 

    stream.on(&quot;data&quot;, function(data) {
        console.log(&apos;Received data: &quot;&apos; + data + &apos;&quot;&apos;);
    })
    stream.write(&quot;It works!&quot;); // 输出结果：Received data: &quot;It works!&quot;

## util.debug(string)

    稳定度: 0 - 已过时: 请使用 console.error() 代替

Deprecated predecessor of `console.error`.

`console.error`的已过时的前身

## util.error([...])

    稳定度: 0 - 已过时: 请使用 console.error() 代替

Deprecated predecessor of `console.error`.

`console.error`的已过时的前身

## util.puts([...])

   稳定度: 0 - 已过时: 请使用 console.log() 代替

Deprecated predecessor of `console.log`.

`console.log`的已过时的前身

## util.print([...])

   稳定度: 0 - 已过时: 请使用 console.log() 代替

Deprecated predecessor of `console.log`.

`console.log`的已过时的前身

## util.pump(readableStream, writableStream, [callback])

   稳定度: 0 - 已过时: 请使用readableStream.pipe(writableStream)代替

Deprecated predecessor of `stream.pipe()`.


`stream.pipe()`的已过时的前身

# 事件 (Events)

    稳定度: 4 - 冻结

&lt;!--type=module--&gt;

Many objects in Node emit events: a `net.Server` emits an event each time
a peer connects to it, a `fs.readStream` emits an event when the file is
opened. All objects which emit events are instances of `events.EventEmitter`.
You can access this module by doing: `require(&quot;events&quot;);`

Node里面的许多对象都会分发事件：一个`net.Server`对象会在每次有新连接时分发一个事件， 一个`fs.readStream`对象会在文件被打开的时候发出一个事件。
所有这些产生事件的对象都是 `events.EventEmitter` 的实例。
你可以通过`require(&quot;events&quot;);`来访问该模块

Typically, event names are represented by a camel-cased string, however,
there aren&apos;t any strict restrictions on that, as any string will be accepted.

通常，事件名是驼峰命名 (camel-cased) 的字符串。不过也没有强制的要求，任何字符串都是可以使用的。

Functions can then be attached to objects, to be executed when an event
is emitted. These functions are called _listeners_. Inside a listener
function, `this` refers to the `EventEmitter` that the listener was
attached to.

为了处理发出的事件，我们将函数 (Function) 关联到对象上。
我们把这些函数称为 _监听器 (listeners)_。
在监听函数中 `this` 指向当前监听函数所关联的 `EventEmitter` 对象。

## 类: events.EventEmitter

To access the EventEmitter class, `require(&apos;events&apos;).EventEmitter`.

通过 `require(&apos;events&apos;).EventEmitter` 获取 EventEmitter 类。

When an `EventEmitter` instance experiences an error, the typical action is
to emit an `&apos;error&apos;` event.  Error events are treated as a special case in node.
If there is no listener for it, then the default action is to print a stack
trace and exit the program.

当 `EventEmitter` 实例遇到错误，通常的处理方法是产生一个 `&apos;error&apos;` 事件，node 对错误事件做特殊处理。
如果程序没有监听错误事件，程序会按照默认行为在打印出 栈追踪信息 (stack trace) 后退出。

All EventEmitters emit the event `&apos;newListener&apos;` when new listeners are
added and `&apos;removeListener&apos;` when a listener is removed.

EventEmitter 会在添加 listener 时触发 `&apos;newListener&apos;` 事件，删除 listener 时触发 `&apos;removeListener&apos;` 事件

### emitter.addListener(event, listener)
### emitter.on(event, listener)

### emitter.addListener(event, listener)
### emitter.on(event, listener)

Adds a listener to the end of the listeners array for the specified event.

添加一个 listener 至特定事件的 listener 数组尾部。

    server.on(&apos;connection&apos;, function (stream) {
      console.log(&apos;someone connected!&apos;);
    });

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.once(event, listener)

Adds a **one time** listener for the event. This listener is
invoked only the next time the event is fired, after which
it is removed.

添加一个 **一次性** listener，这个 listener 只会在下一次事件发生时被触发一次，触发完成后就被删除。

    server.once(&apos;connection&apos;, function (stream) {
      console.log(&apos;Ah, we have our first user!&apos;);
    });

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.removeListener(event, listener)

Remove a listener from the listener array for the specified event.
**Caution**: changes array indices in the listener array behind the listener.

从一个事件的 listener 数组中删除一个 listener
**注意**：此操作会改变 listener 数组中当前 listener 后的所有 listener 在的下标

    var callback = function(stream) {
      console.log(&apos;someone connected!&apos;);
    };
    server.on(&apos;connection&apos;, callback);
    // ...
    server.removeListener(&apos;connection&apos;, callback);

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.removeAllListeners([event])

Removes all listeners, or those of the specified event.

删除所有 listener，或者删除某些事件 (event) 的 listener

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.setMaxListeners(n)

By default EventEmitters will print a warning if more than 10 listeners are
added for a particular event. This is a useful default which helps finding
memory leaks. Obviously not all Emitters should be limited to 10. This function
allows that to be increased. Set to zero for unlimited.

在默认情况下，EventEmitter 会在多于 10 个 listener 监听某个事件的时候出现警告，此限制在寻找内存泄露时非常有用。
显然，也不是所有的 Emitter 事件都要被限制在 10 个 listener 以下，在这种情况下可以使用这个函数来改变这个限制。

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### EventEmitter.defaultMaxListeners

`emitter.setMaxListeners(n)` sets the maximum on a per-instance basis.
This class property lets you set it for *all* `EventEmitter` instances,
current and future, effective immediately. Use with care.

`emitter.setMaxListeners(n)` 设置每个 emitter 实例的最大监听数。
这个类属性为 **所有** `EventEmitter` 实例设置最大监听数（对所有已创建的实例和今后创建的实例都将立即生效）。
使用时请注意。

Note that `emitter.setMaxListeners(n)` still has precedence over
`EventEmitter.defaultMaxListeners`.

请注意，`emitter.setMaxListeners(n)` 优先于 `EventEmitter.defaultMaxListeners`。

### emitter.listeners(event)

Returns an array of listeners for the specified event.

返回指定事件的 listener 数组

    server.on(&apos;connection&apos;, function (stream) {
      console.log(&apos;someone connected!&apos;);
    });
    console.log(util.inspect(server.listeners(&apos;connection&apos;))); // [ [Function] ]

### emitter.emit(event, [arg1], [arg2], [...])

Execute each of the listeners in order with the supplied arguments.

使用提供的参数按顺序执行指定事件的 listener

Returns `true` if event had listeners, `false` otherwise.

若事件有 listener 则返回 `true` 否则返回 `false`。

### 类方法: EventEmitter.listenerCount(emitter, event)

Return the number of listeners for a given event.

返回指定事件的 listener 数量

### 事件: &apos;newListener&apos;

* `event` {String} The event name
* `listener` {Function} The event handler function

* `event` {String} 事件名
* `listener` {Function} 事件处理函数

This event is emitted any time someone adds a new listener.  It is unspecified
if `listener` is in the list returned by `emitter.listeners(event)`.

在添加 listener 时会发生该事件。
此时无法确定 `listener` 是否在 `emitter.listeners(event)` 返回的列表中。

### 事件: &apos;removeListener&apos;

* `event` {String} The event name
* `listener` {Function} The event handler function

* `event` {String} 事件名
* `listener` {Function} 事件处理函数

This event is emitted any time someone removes a listener.  It is unspecified
if `listener` is in the list returned by `emitter.listeners(event)`.


在移除 listener 时会发生该事件。
此时无法确定 `listener` 是否在 `emitter.listeners(event)` 返回的列表中。

# 域

    稳定度: 2 - 不稳定

Domains provide a way to handle multiple different IO operations as a
single group.  If any of the event emitters or callbacks registered to a
domain emit an `error` event, or throw an error, then the domain object
will be notified, rather than losing the context of the error in the
`process.on(&apos;uncaughtException&apos;)` handler, or causing the program to
exit immediately with an error code.

Domains 提供了一种方式，即以一个单一的组的形式来处理多个不同的IO操作。如果任何一个注册到domain的事件触发器或回调触发了一个‘error’事件，或者抛出一个错误，那么domain对象将会被通知到。而不是直接让这个错误的上下文从`process.on（&apos;uncaughtException&apos;）&apos;处理程序中丢失掉，也不会致使程序因为这个错误伴随着错误码立即退出。

## 警告: 不要忽视错误!

&lt;!-- type=misc --&gt;

Domain error handlers are not a substitute for closing down your
process when an error occurs.

Domain error处理程序不是一个在错误发生时，关闭你的进程的替代品

By the very nature of how `throw` works in JavaScript, there is almost
never any way to safely &quot;pick up where you left off&quot;, without leaking
references, or creating some other sort of undefined brittle state.

基于&apos;抛出（throw）&apos;在JavaScript中工作的方式，几乎从来没有任何方式能够在‘不泄露引用，不造成一些其他种类的未定义的脆弱状态’的前提下，安全的“从你离开的地方重新拾起（pick up where you left off）”，

The safest way to respond to a thrown error is to shut down the
process.  Of course, in a normal web server, you might have many
connections open, and it is not reasonable to abruptly shut those down
because an error was triggered by someone else.

响应一个被抛出错误的最安全方式就是关闭进程。当然，在一个正常的Web服务器中，你可能会有很多活跃的连接。由于其他触发的错误你去突然关闭这些连接是不合理。

The better approach is send an error response to the request that
triggered the error, while letting the others finish in their normal
time, and stop listening for new requests in that worker.

更好的方法是发送错误响应给那个触发错误的请求，在保证其他人正常完成工作时，停止监听那个触发错误的人的新请求。

In this way, `domain` usage goes hand-in-hand with the cluster module,
since the master process can fork a new worker when a worker
encounters an error.  For node programs that scale to multiple
machines, the terminating proxy or service registry can take note of
the failure, and react accordingly.

在这种方式中，`域`使用伴随着集群模块，由于主过程可以叉新工人时，一个工人发生了一个错误。节点程序规模的多
机，终止代理或服务注册可以注意一下失败，并做出相应的反应。

For example, this is not a good idea:

举例来说，以下就不是一个好想法：

var d = require(&apos;domain&apos;).create();
d.on(&apos;error&apos;, function(er) {
  // 这个错误不会导致进程崩溃，但是情况会更糟糕！
  // 虽然我们阻止了进程突然重启动，但是我们已经发生了资源泄露
  // 这种事情的发生会让我们发疯。
  // 不如调用 process.on(&apos;uncaughtException&apos;)!
  console.log(&apos;error, but oh well&apos;, er.message);
});
d.run(function() {
  require(&apos;http&apos;).createServer(function(req, res) {
    handleRequest(req, res);
  }).listen(PORT);
});</code></pre>
<p>By using the context of a domain, and the resilience of separating our
program into multiple worker processes, we can react more
appropriately, and handle errors with much greater safety.

</p>
<p>通过对域的上下文的使用，以及将我们的程序分隔成多个工作进程的反射，我们可以做出更加恰当的反应和更加安全的处理。

</p>
<pre><code>// 好一些的做法！

var cluster = require(&apos;cluster&apos;);
var PORT = +process.env.PORT || 1337;

var cluster = require(&apos;cluster&apos;);
var PORT = +process.env.PORT || 1337;

if (cluster.isMaster) {
  // In real life, you&apos;d probably use more than just 2 workers,
  // and perhaps not put the master and worker in the same file.
  //
  // You can also of course get a bit fancier about logging, and
  // implement whatever custom logic you need to prevent DoS
  // attacks and other bad behavior.
  //
  // See the options in the cluster documentation.
  //
  // The important thing is that the master does very little,
  // increasing our resilience to unexpected errors.

if (cluster.isMaster) {
  // 在工作环境中，你可能会使用到不止一个工作分支
  // 而且可能不会把主干和分支放在同一个文件中
  //
  //你当然可以通过日志进行猜测，并且对你需要防止的DoS攻击等不良行为实施自定义的逻辑
  //
  // 看集群文件的选项
  //
  // 最重要的是主干非常小，增加了我们抵抗以外错误的可能性。

  cluster.fork();
  cluster.fork();

  cluster.fork();
  cluster.fork();

  cluster.on(&apos;disconnect&apos;, function(worker) {
    console.error(&apos;disconnect!&apos;);
    cluster.fork();
  });

  cluster.on(&apos;disconnect&apos;, function(worker) {
    console.error(&apos;disconnect!&apos;);
    cluster.fork();
  });

} else {
  // the worker
  //
  // This is where we put our bugs!

} else {
  // 工作进程
  //
  // 这是我们出错的地方

  var domain = require(&apos;domain&apos;);

  var domain = require(&apos;domain&apos;);

  // See the cluster documentation for more details about using
  // worker processes to serve requests.  How it works, caveats, etc.

  //看集群文件对于使用工作进程处理请求的更多细节，它是如何工作的，它的警告等等。

  var server = require(&apos;http&apos;).createServer(function(req, res) {
    var d = domain.create();
    d.on(&apos;error&apos;, function(er) {
      console.error(&apos;error&apos;, er.stack);

  var server = require(&apos;http&apos;).createServer(function(req, res) {
    var d = domain.create();
    d.on(&apos;error&apos;, function(er) {
      console.error(&apos;error&apos;, er.stack);

    // 因为req和res在这个域存在之前就被创建，
    // 所以我们需要显式添加它们。
    // 详见下面关于显式和隐式绑定的解释。
    d.add(req);
    d.add(res);

    // Now run the handler function in the domain.
    d.run(function() {
      handleRequest(req, res);
    });
  });
  server.listen(PORT);
}

    // 现在在域里面运行处理器函数。
    d.run(function() {
      handleRequest(req, res);
    });
  });
  server.listen(PORT);
}

    // 这个部分不是很重要。只是一个简单的路由例子。
    // 你会想把你的超级给力的应用逻辑放在这里。
    function handleRequest(req, res) {
      switch(req.url) {
        case &apos;/error&apos;:
          // 我们干了一些异步的东西，然后。。。
          setTimeout(function() {
            // 呃。。。
            flerb.bark();
          });
          break;
        default:
          res.end(&apos;ok&apos;);
      }
    }</code></pre>
<h2>对Error(错误)对象的内容添加<span><a href="all.html#all_error" id="all_error">#</a></span></h2>
<!-- type=misc -->

<p>Any time an Error object is routed through a domain, a few extra fields
are added to it.

</p>
<p>每一次一个Error对象被导向经过一个域，它会添加几个新的字段。

</p>
<ul>
<li><code>error.domain</code> The domain that first handled the error.</li>
<li><code>error.domainEmitter</code> The event emitter that emitted an &apos;error&apos; event
with the error object.</li>
<li><code>error.domainBound</code> The callback function which was bound to the
domain, and passed an error as its first argument.</li>
<li><p><code>error.domainThrown</code> A boolean indicating whether the error was
thrown, emitted, or passed to a bound callback function.</p>
</li>
<li><p><code>error.domain</code> 第一个处理这个错误的域。</p>
</li>
<li><code>error.domainEmitter</code> 用这个错误对象触发&apos;error&apos;事件的事件分发器。</li>
<li><code>error.domainBound</code> 回调函数，该回调函数被绑定到域，并且一个错误会作为第一参数传递给这个回调函数。</li>
<li><code>error.domainThrown</code> 一个布尔值表明这个错误是否被抛出，分发或者传递给一个绑定的回调函数。</li>
</ul>
<h2>隐式绑定<span><a href="all.html#all_13" id="all_13">#</a></span></h2>
<!--type=misc-->

<p>If domains are in use, then all <strong>new</strong> EventEmitter objects (including
Stream objects, requests, responses, etc.) will be implicitly bound to
the active domain at the time of their creation.

</p>
<p>如果多个域正在被使用，那么所有的<strong>新</strong>EventEmitter对象（包括Stream对象，请求，应答等等）会被隐式绑定到它们被创建时的有效域。

</p>
<p>Additionally, callbacks passed to lowlevel event loop requests (such as
to fs.open, or other callback-taking methods) will automatically be
bound to the active domain.  If they throw, then the domain will catch
the error.

</p>
<p>而且，被传递到低层事件分发请求的回调函数（例如fs.open，或者其它接受回调函数的函数）会自动绑定到有效域。如果这些回调函数抛出错误，那么这个域会捕捉到这个错误。

</p>
<p>In order to prevent excessive memory usage, Domain objects themselves
are not implicitly added as children of the active domain.  If they
were, then it would be too easy to prevent request and response objects
from being properly garbage collected.

</p>
<p>为了防止内存的过度使用，Domain对象自己不会作为有效域的子对象被隐式添加到有效域。因为如果这样做的话，会很容易影响到请求和应答对象的正常垃圾回收。

</p>
<p>If you <em>want</em> to nest Domain objects as children of a parent Domain,
then you must explicitly add them.

</p>
<p>如果你<em>想</em>在一个父Domain对象里嵌套子Domain对象，那么你需要显式地添加它们。

</p>
<p>Implicit binding routes thrown errors and <code>&apos;error&apos;</code> events to the
Domain&apos;s <code>error</code> event, but does not register the EventEmitter on the
Domain, so <code>domain.dispose()</code> will not shut down the EventEmitter.
Implicit binding only takes care of thrown errors and <code>&apos;error&apos;</code> events.

</p>
<p>隐式绑定将被抛出的错误和<code>&apos;error&apos;</code>事件导向到Domain对象的<code>error</code>事件，但不会注册到Domain对象上的EventEmitter对象，所以<code>domain.dispose()</code>不会令EventEmitter对象停止运作。隐式绑定只关心被抛出的错误和 <code>&apos;error&apos;</code>事件。

</p>
<h2>显式绑定<span><a href="all.html#all_14" id="all_14">#</a></span></h2>
<!--type=misc-->

<p>Sometimes, the domain in use is not the one that ought to be used for a
specific event emitter.  Or, the event emitter could have been created
in the context of one domain, but ought to instead be bound to some
other domain.

</p>
<p>有时，正在使用的域并不是某个事件分发器所应属的域。又或者，事件分发器在一个域内被创建，但是应该被绑定到另一个域。

</p>
<p>For example, there could be one domain in use for an HTTP server, but
perhaps we would like to have a separate domain to use for each request.

</p>
<p>例如，对于一个HTTP服务器，可以有一个正在使用的域，但我们可能希望对每一个请求使用一个不同的域。

</p>
<p>That is possible via explicit binding.

</p>
<p>这可以通过显示绑定来达到。

</p>
<p>For example:

</p>
<p>例如：

</p>
<pre><code>serverDomain.run(function() {
  // 服务器在serverDomain的作用域内被创建
  http.createServer(function(req, res) {
    // req和res同样在serverDomain的作用域内被创建
    // 但是，我们想对于每一个请求使用一个不一样的域。
    // 所以我们首先创建一个域，然后将req和res添加到这个域上。
    var reqd = domain.create();
    reqd.add(req);
    reqd.add(res);
    reqd.on(&apos;error&apos;, function(er) {
      console.error(&apos;Error&apos;, er, req.url);
      try {
        res.writeHead(500);
        res.end(&apos;Error occurred, sorry.&apos;);
      } catch (er) {
        console.error(&apos;Error sending 500&apos;, er, req.url);
      }
    });
  }).listen(1337);    
});
```</code></pre>
<h2>domain.create()<span><a href="all.html#all_domain_create" id="all_domain_create">#</a></span></h2>
<div><ul>
<li><p>return: <span>Domain</span></p>
</li>
<li><p>return: <span>Domain</span></p>
</li>
</div></ul>
<p>Returns a new Domain object.

</p>
<p>返回一个新的Domain对象。

</p>
<h2>类: Domain<span><a href="all.html#all_domain" id="all_domain">#</a></span></h2>
<p>The Domain class encapsulates the functionality of routing errors and
uncaught exceptions to the active Domain object.

</p>
<p>Domain类封装了将错误和没有被捕捉的异常导向到有效对象的功能。

</p>
<p>Domain is a child class of <a href="events.html#events_class_events_eventemitter">EventEmitter</a>.  To handle the errors that it
catches, listen to its <code>error</code> event.

</p>
<p>Domain是 <a href="events.html#events_class_events_eventemitter">EventEmitter</a>类的一个子类。监听它的<code>error</code>事件来处理它捕捉到的错误。

</p>
<h3>domain.run(fn)<span><a href="all.html#all_domain_run_fn" id="all_domain_run_fn">#</a></span></h3>
<div><ul>
<li><p><code>fn</code> <span>Function</span></p>
</li>
<li><p><code>fn</code> <span>Function</span></p>
</li>
</div></ul>
<p>Run the supplied function in the context of the domain, implicitly
binding all event emitters, timers, and lowlevel requests that are
created in that context.

</p>
<p>在域的上下文里运行提供的函数，隐式地绑定所有该上下文里创建的事件分发器，计时器和低层请求。

</p>
<p>This is the most basic way to use a domain.

</p>
<p>这是使用一个域的最基本的方式。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var d = domain.create();
d.on(&apos;error&apos;, function(er) {
  console.error(&apos;Caught error!&apos;, er);
});
d.run(function() {
  process.nextTick(function() {
    setTimeout(function() { // 模拟几个不同的异步的东西
      fs.open(&apos;non-existent file&apos;, &apos;r&apos;, function(er, fd) {
        if (er) throw er;
        // 继续。。。
      });
    }, 100);
  });
});</code></pre>
<p>In this example, the <code>d.on(&apos;error&apos;)</code> handler will be triggered, rather
than crashing the program.

</p>
<p>在这个例子里， <code>d.on(&apos;error&apos;)</code> 处理器会被触发，而不是导致程序崩溃。

</p>
<h3>domain.members<span><a href="all.html#all_domain_members" id="all_domain_members">#</a></span></h3>
<div><ul>
<li><p><span>Array</span></p>
</li>
<li><p><span>Array</span></p>
</li>
</div></ul>
<p>An array of timers and event emitters that have been explicitly added
to the domain.

</p>
<p>一个数组，里面的元素是被显式添加到域里的计时器和事件分发器。

</p>
<h3>domain.add(emitter)<span><a href="all.html#all_domain_add_emitter" id="all_domain_add_emitter">#</a></span></h3>
<div><ul>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> emitter or timer to be added to the domain</p>
</li>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> 被添加到域里的时间分发器或计时器</p>
</li>
</div></ul>
<p>Explicitly adds an emitter to the domain.  If any event handlers called by
the emitter throw an error, or if the emitter emits an <code>error</code> event, it
will be routed to the domain&apos;s <code>error</code> event, just like with implicit
binding.

</p>
<p>显式地将一个分发器添加到域。如果这个分发器调用的任意一个事件处理器抛出一个错误，或是这个分发器分发了一个<code>error</code>事，那么它会被导向到这个域的<code>error</code>事件，就像隐式绑定所做的一样。

</p>
<p>This also works with timers that are returned from <code>setInterval</code> and
<code>setTimeout</code>.  If their callback function throws, it will be caught by
the domain &apos;error&apos; handler.

</p>
<p>这对于从<code>setInterval</code>和<code>setTimeout</code>返回的计时器同样适用。如果这些计时器的回调函数抛出错误，它将会被这个域的<code>error</code>处理器捕捉到。

</p>
<p>If the Timer or EventEmitter was already bound to a domain, it is removed
from that one, and bound to this one instead.

</p>
<p>如果这个Timer或EventEmitter对象已经被绑定到另外一个域，那么它将会从那个域被移除，然后绑定到当前的域。

</p>
<h3>domain.remove(emitter)<span><a href="all.html#all_domain_remove_emitter" id="all_domain_remove_emitter">#</a></span></h3>
<div><ul>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> emitter or timer to be removed from the domain</p>
</li>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> 要从域里被移除的分发器或计时器</p>
</li>
</div></ul>
<p>The opposite of <code>domain.add(emitter)</code>.  Removes domain handling from the
specified emitter.

</p>
<p>与<code>domain.add(emitter)</code>函数恰恰相反，这个函数将域处理从指明的分发器里移除。

</p>
<h3>domain.bind(callback)<span><a href="all.html#all_domain_bind_callback" id="all_domain_bind_callback">#</a></span></h3>
<div><ul>
<li><code>callback</code> <span>Function</span> The callback function</li>
<li><p>return: <span>Function</span> The bound function</p>
</li>
<li><p><code>callback</code> <span>Function</span> 回调函数</p>
</li>
<li>return: <span>Function</span> 被绑定的函数</li>
</div></ul>
<p>The returned function will be a wrapper around the supplied callback
function.  When the returned function is called, any errors that are
thrown will be routed to the domain&apos;s <code>error</code> event.

</p>
<p>返回的函数会是一个对于所提供的回调函数的包装函数。当这个被返回的函数被调用时，所有被抛出的错误都会被导向到这个域的<code>error</code>事件。

</p>
<h4>例子<span><a href="all.html#all_15" id="all_15">#</a></span></h4>
<pre><code>d.on(&apos;error&apos;, function(er) {
  // 有个地方发生了一个错误。
  // 如果我们现在抛出这个错误，它会让整个程序崩溃
  // 并给出行号和栈信息。
});</code></pre>
<h3>domain.intercept(callback)<span><a href="all.html#all_domain_intercept_callback" id="all_domain_intercept_callback">#</a></span></h3>
<div><ul>
<li><code>callback</code> <span>Function</span> The callback function</li>
<li><p>return: <span>Function</span> The intercepted function</p>
</li>
<li><p><code>callback</code> <span>Function</span> 回调函数</p>
</li>
<li>return: <span>Function</span> 被拦截的函数</li>
</div></ul>
<p>This method is almost identical to <code>domain.bind(callback)</code>.  However, in
addition to catching thrown errors, it will also intercept <code>Error</code>
objects sent as the first argument to the function.

</p>
<p>这个函数与<code>domain.bind(callback)</code>几乎一模一样。但是，除了捕捉被抛出的错误外，它还会拦截作为第一参数被传递到这个函数的<code>Error</code>对象。

</p>
<p>In this way, the common <code>if (er) return callback(er);</code> pattern can be replaced
with a single error handler in a single place.

</p>
<p>在这种方式下，常见的&apos;if(er) return callback(er);&apos;的方式可以被一个单独地方的单独的错误处理所取代。

</p>
<h4>例子<span><a href="all.html#all_16" id="all_16">#</a></span></h4>
<pre><code>d.on(&apos;error&apos;, function(er) {
  // 有个地方发生了一个错误。
  // 如果我们现在抛出这个错误，它会让整个程序崩溃
  // 并给出行号和栈信息。
});</code></pre>
<h3>domain.enter()<span><a href="all.html#all_domain_enter" id="all_domain_enter">#</a></span></h3>
<p>The <code>enter</code> method is plumbing used by the <code>run</code>, <code>bind</code>, and <code>intercept</code>
methods to set the active domain. It sets <code>domain.active</code> and <code>process.domain</code>
to the domain, and implicitly pushes the domain onto the domain stack managed
by the domain module (see <code>domain.exit()</code> for details on the domain stack). The
call to <code>enter</code> delimits the beginning of a chain of asynchronous calls and I/O
operations bound to a domain.

</p>
<p><code>enter</code>函数对于<code>run</code>，<code>bind</code>和<code>intercept</code>来说就像它们的管道系统：它们使用<code>enter</code>函数来设置有效域。<code>enter</code>函数对于域设定了<code>domain.active</code>和 <code>process.domain</code>
，还隐式地将域推入了由域模块管理的域栈（关于域栈的细节详见<code>domain.exit()</code>）。<code>enter</code>函数的调用，分隔了异步调用链以及绑定到一个域的I/O操作的结束或中断。

</p>
<p>Calling <code>enter</code> changes only the active domain, and does not alter the domain
itself. <code>Enter</code> and <code>exit</code> can be called an arbitrary number of times on a
single domain.

</p>
<p>调用<code>enter</code>仅仅改变活动的域，而不改变域本身。
<code>Enter</code> 和 <code>exit</code>在一个单独的域可以被调用任意多次。

</p>
<p>If the domain on which <code>enter</code> is called has been disposed, <code>enter</code> will return
without setting the domain.

</p>
<p>如果域的<code>enter</code>已经设置，<code>enter</code>将不设置域就返回。

</p>
<h3>domain.exit()<span><a href="all.html#all_domain_exit" id="all_domain_exit">#</a></span></h3>
<p>The <code>exit</code> method exits the current domain, popping it off the domain stack.
Any time execution is going to switch to the context of a different chain of
asynchronous calls, it&apos;s important to ensure that the current domain is exited.
The call to <code>exit</code> delimits either the end of or an interruption to the chain
of asynchronous calls and I/O operations bound to a domain.

</p>
<p><code>exit</code>函数退出当前的域，将当前域从域的栈里移除。每当当程序的执行流程准要切换到一个不同的异步调用链的上下文时，要保证退出当前的域。<code>exit</code>函数的调用，分隔了异步调用链以及绑定到一个域的I/O操作的结束或中断。


</p>
<p>If there are multiple, nested domains bound to the current execution context,
<code>exit</code> will exit any domains nested within this domain.

</p>
<p>如果有多个嵌套的域绑定到当前的执行上下文，
<code>退出</code>将退出在这个域里的所有的嵌套。

</p>
<p>Calling <code>exit</code> changes only the active domain, and does not alter the domain
itself. <code>Enter</code> and <code>exit</code> can be called an arbitrary number of times on a
single domain.

</p>
<p>调用<code>exit</code>只会改变有效域，而不会改变域自身。在一个单一域上，<code>Enter</code>和<code>exit</code>可以被调用任意次。

</p>
<p>If the domain on which <code>exit</code> is called has been disposed, <code>exit</code> will return
without exiting the domain.

</p>
<p>如果在这个域名下<code>exit </code>已经被设置，<code>exit </code>将不退出域返回。

</p>
<h3>domain.dispose()<span><a href="all.html#all_domain_dispose" id="all_domain_dispose">#</a></span></h3>
<pre><code>稳定度: 0 - 已过时。请通过设置在域上的错误事件处理器，显式地东失败的IO操作中恢复。</code></pre>
<p>Once <code>dispose</code> has been called, the domain will no longer be used by callbacks
bound into the domain via <code>run</code>, <code>bind</code>, or <code>intercept</code>, and a <code>dispose</code> event
is emitted.

</p>
<p>一旦<code>dispose</code>被调用，通过<code>run</code>，<code>bind</code>或<code>intercept</code>绑定到这个域的回调函数将不再使用这个域，并且一个<code>dispose</code>事件会被分发。

</p>
<h1>Buffer<span><a href="all.html#all_buffer_1" id="all_buffer_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Pure JavaScript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it&apos;s necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.

</p>
<p>纯javascript对Unicode比较友好，但是无法很好地处理二进制数据。当我们面对TCP流或者文件系统的时候，是需要处理八位字节流的。Node有几种操作，创建和消化八位字节流的策略。

</p>
<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.

</p>
<p>原始数据保存在 <code>Buffer</code> 类的实例中。一个 <code>Buffer</code> 实例类似于一个整数数组，但对应者 V8 堆之外的一个原始内存分配区域。一个 <code>Buffer</code> 的大小不可变。

</p>
<p>The <code>Buffer</code> class is a global, making it very rare that one would need
to ever <code>require(&apos;buffer&apos;)</code>.

</p>
<p><code>Buffer</code> 类是一个全局的类，所以它很罕有地不需要<code>require</code>语句就可以调用。

</p>
<p>Converting between Buffers and JavaScript string objects requires an explicit
encoding method.  Here are the different string encodings.

</p>
<p>在Buffers和JavaScript string转换时，需要明确的一个编码方法。下面是一些不同的string编码。

</p>
<ul>
<li><p><code>&apos;ascii&apos;</code> - for 7 bit ASCII data only.  This encoding method is very fast, and
will strip the high bit if set.</p>
</li>
<li><p><code>&apos;ascii&apos;</code> - 仅适用 7 bit ASCII 格式数据。这个编码方式非常快速，而且会剥离设置过高的bit。</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - 多字节编码 Unicode字符。很多网页或者其他文档的编码格式都是使用 UTF-8的。</p>
</li>
<li><p><code>&apos;utf16le&apos;</code> - 2 or 4 bytes, little endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code>&apos;utf16le&apos;</code> - 2 或者 4 字节, Little Endian (LE)  编码Unicode字符。
代理对 (U+10000 to U+10FFFF) 是支持的.（BE和LE表示大端和小端，Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端；Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端；下同）</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> - Alias of <code>&apos;utf16le&apos;</code>.</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> -  <code>&apos;utf16le&apos;</code>的别名.</p>
</li>
<li><p><code>&apos;base64&apos;</code> - Base64 string encoding.</p>
</li>
<li><p><code>&apos;base64&apos;</code> - Base64 字符串编码。</p>
</li>
<li><p><code>&apos;binary&apos;</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is deprecated and
should be avoided in favor of <code>Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p>
</li>
<li><p><code>&apos;binary&apos;</code> - 一个将原始2进制数据编码为字符串的方法，仅使用每个字符的前8bits。 这个编码方式已经被弃用而且应该被避免，尽可能的使用<code>Buffer</code>对象。这个编码方式将会在未来的Node版本中移除。</p>
</li>
<li><p><code>&apos;hex&apos;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
<li><p><code>&apos;hex&apos;</code> - 把每个byte编码成2个十六进制字符</p>
</li>
</ul>
<h2>类: Buffer<span><a href="all.html#all_buffer_2" id="all_buffer_2">#</a></span></h2>
<p>The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.

</p>
<p>Buffer 类是一个全局变量类型，用来直接处理2进制数据的。
它能够使用多种方式构建。

</p>
<h3>new Buffer(size)<span><a href="all.html#all_new_buffer_size" id="all_new_buffer_size">#</a></span></h3>
<div><ul>
<li><p><code>size</code> Number</p>
</li>
<li><p><code>size</code> Number</p>
</li>
</div></ul>
<p>Allocates a new buffer of <code>size</code> octets.

</p>
<p>分配一个新的 buffer 大小是 <code>size</code> 的8位字节.

</p>
<h3>new Buffer(array)<span><a href="all.html#all_new_buffer_array" id="all_new_buffer_array">#</a></span></h3>
<div><ul>
<li><p><code>array</code> Array</p>
</li>
<li><p><code>array</code> Array</p>
</li>
</div></ul>
<p>Allocates a new buffer using an <code>array</code> of octets.

</p>
<p>分配一个新的 buffer 使用一个8位字节 <code>array</code> 数组.

</p>
<h3>new Buffer(str, [encoding])<span><a href="all.html#all_new_buffer_str_encoding" id="all_new_buffer_str_encoding">#</a></span></h3>
<div><ul>
<li><code>str</code> String - string to encode.</li>
<li><p><code>encoding</code> String - encoding to use, Optional.</p>
</li>
<li><p><code>str</code> String类型 - 需要存入buffer的string字符串.</p>
</li>
<li><code>encoding</code> String类型 - 使用什么编码方式，参数可选.</li>
</div></ul>
<p>Allocates a new buffer containing the given <code>str</code>.
<code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.

</p>
<p>分配一个新的 buffer ，其中包含着给定的 <code>str</code>字符串.
<code>encoding</code> 编码方式默认是：<code>&apos;utf8&apos;</code>.

</p>
<h3>类方法: Buffer.isEncoding(encoding)<span><a href="all.html#all_buffer_isencoding_encoding" id="all_buffer_isencoding_encoding">#</a></span></h3>
<div><ul>
<li><p><code>encoding</code> <span>String</span> The encoding string to test</p>
</li>
<li><p><code>encoding</code> <span>String</span> 用来测试给定的编码字符串</p>
</li>
</div></ul>
<p>Returns true if the <code>encoding</code> is a valid encoding argument, or false
otherwise.

</p>
<p>如果给定的编码 <code>encoding</code> 是有效的，返回 true，否则返回 false。

</p>
<h3>类方法: Buffer.isBuffer(obj)<span><a href="all.html#all_buffer_isbuffer_obj" id="all_buffer_isbuffer_obj">#</a></span></h3>
<div><ul>
<li><code>obj</code> Object</li>
<li><p>Return: Boolean</p>
</li>
<li><p><code>obj</code> Object</p>
</li>
<li>返回: Boolean</li>
</div></ul>
<p>Tests if <code>obj</code> is a <code>Buffer</code>.

</p>
<p>测试这个 <code>obj</code> 是否是一个 <code>Buffer</code>.

</p>
<h3>类方法: Buffer.byteLength(string, [encoding])<span><a href="all.html#all_buffer_bytelength_string_encoding" id="all_buffer_bytelength_string_encoding">#</a></span></h3>
<div><ul>
<li><code>string</code> String</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li><p>Return: Number</p>
</li>
<li><p><code>string</code> String类型</p>
</li>
<li><code>encoding</code> String类型, 可选参数, 默认是: &apos;utf8&apos;</li>
<li>Return: Number类型</li>
</div></ul>
<p>Gives the actual byte length of a string. <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.
This is not the same as <code>String.prototype.length</code> since that returns the
number of <em>characters</em> in a string.

</p>
<p>将会返回这个字符串真实byte长度。 <code>encoding</code> 编码默认是： <code>&apos;utf8&apos;</code>.
这个和 <code>String.prototype.length</code> 是不一样的，因为那个方法返回这个字符串中有几个字符的数量。
（译者：当用户在写http响应头Cotent-Length的时候，千万记得一定要用 <code>Buffer.byteLength</code> 方法，不要使用 <code>String.prototype.length</code> ）

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
<h3>类方法: Buffer.concat(list, [totalLength])<span><a href="all.html#all_buffer_concat_list_totallength" id="all_buffer_concat_list_totallength">#</a></span></h3>
<div><ul>
<li><code>list</code> <span>Array</span> List of Buffer objects to concat</li>
<li><p><code>totalLength</code> <span>Number</span> Total length of the buffers when concatenated</p>
</li>
<li><p><code>list</code> <span>Array</span>数组类型，Buffer数组，用于被连接。</p>
</li>
<li><code>totalLength</code> <span>Number</span>类型 上述Buffer数组的所有Buffer的总大小。（译者：注意这里的totalLength不是数组长度是数组里Buffer实例的大小总和）</li>
</div></ul>
<p>Returns a buffer which is the result of concatenating all the buffers in
the list together.

</p>
<p>返回一个保存着将传入buffer数组中所有buffer对象拼接在一起的buffer对象。（译者：有点拗口，其实就是将数组中所有的buffer实例通过复制拼接在一起）

</p>
<p>If the list has no items, or if the totalLength is 0, then it returns a
zero-length buffer.

</p>
<p>如果传入的数组没有内容，或者 totalLength 参数是0，那将返回一个zero-length的buffer。

</p>
<p>If the list has exactly one item, then the first item of the list is
returned.

</p>
<p>如果数组中只有一项，那么这第一项就会被返回。

</p>
<p>If the list has more than one item, then a new Buffer is created.

</p>
<p>如果数组中的项多于一个，那么一个新的Buffer实例将被创建。

</p>
<p>If totalLength is not provided, it is read from the buffers in the list.
However, this adds an additional loop to the function, so it is faster
to provide the length explicitly.

</p>
<p>如果 totalLength 参数没有提供，虽然会从buffer数组中计算读取，但是会增加一个额外的循环来计算它，所以提供一个明确的 totalLength  参数将会更快。

</p>
<h3>buf.length<span><a href="all.html#all_buf_length" id="all_buf_length">#</a></span></h3>
<div><ul>
<li><p>Number</p>
</li>
<li><p>Number类型</p>
</li>
</div></ul>
<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.

</p>
<p>这个buffer的bytes大小。注意这未必是这buffer里面内容的大小。<code>length</code> 的依据是buffer对象所分配的内存数值，它不会随着这个buffer对象内容的改变而改变。

</p>
<pre><code>// 1234
// 1234</code></pre>
<h3>buf.write(string, [offset], [length], [encoding])<span><a href="all.html#all_buf_write_string_offset_length_encoding" id="all_buf_write_string_offset_length_encoding">#</a></span></h3>
<div><ul>
<li><code>string</code> String - data to be written to buffer</li>
<li><code>offset</code> Number, Optional, Default: 0</li>
<li><code>length</code> Number, Optional, Default: <code>buffer.length - offset</code></li>
<li><p><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</p>
</li>
<li><p><code>string</code> String类型 - 将要被写入 buffer 的数据</p>
</li>
<li><code>offset</code> Number类型, 可选参数, 默认: 0</li>
<li><code>length</code> Number类型, 可选参数, 默认: <code>buffer.length - offset</code></li>
<li><code>encoding</code> String类型, 可选参数, 默认: &apos;utf8&apos;</li>
</div></ul>
<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding.
<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>. <code>length</code> is
the number of bytes to write. Returns number of octets written. If <code>buffer</code> did
not contain enough space to fit the entire string, it will write a partial
amount of the string. <code>length</code> defaults to <code>buffer.length - offset</code>.
The method will not write partial characters.

</p>
<p>根据参数 <code>offset</code> 偏移量和指定的<code>encoding</code>编码方式，将参数 <code>string</code> 数据写入buffer。
<code>offset</code>偏移量 默认是 <code>0</code>, <code>encoding</code>编码方式默认是 <code>&apos;utf8&apos;</code>。 
<code>length</code>长度是将要写入的字符串的bytes大小。
返回number类型，表示多少8位字节流被写入了。如果<code>buffer</code> 没有足够的空间来放入整个string，它将只会写入部分的字符串。
<code>length</code> 默认是 <code>buffer.length - offset</code>。
这个方法不会出现写入部分字符。


</p>
<pre><code>buf = new Buffer(256);
len = buf.write(&apos;\u00bd + \u00bc = \u00be&apos;, 0);
console.log(len + &quot; bytes: &quot; + buf.toString(&apos;utf8&apos;, 0, len));</code></pre>
<h3>buf.toString([encoding], [start], [end])<span><a href="all.html#all_buf_tostring_encoding_start_end" id="all_buf_tostring_encoding_start_end">#</a></span></h3>
<div><ul>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><p><code>end</code> Number, Optional, Default: <code>buffer.length</code></p>
</li>
<li><p><code>encoding</code> String类型, 可选参数, 默认: &apos;utf8&apos;</p>
</li>
<li><code>start</code> Number类型, 可选参数, 默认: 0</li>
<li><code>end</code> Number类型, 可选参数, 默认: <code>buffer.length</code></li>
</div></ul>
<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>
(defaults to <code>&apos;utf8&apos;</code>) beginning at <code>start</code> (defaults to <code>0</code>) and ending at
<code>end</code> (defaults to <code>buffer.length</code>).

</p>
<p>根据 <code>encoding</code>参数（默认是 <code>&apos;utf8&apos;</code>）返回一个解码的 string 类型。还会根据传入的参数 <code>start</code> (默认是<code>0</code>) 和 <code>end</code> (默认是 <code>buffer.length</code>)作为取值范围。

</p>
<p>See <code>buffer.write()</code> example, above.

</p>
<p>查看上面<code>buffer.write()</code> 的例子.

</p>
<h3>buf.toJSON()<span><a href="all.html#all_buf_tojson" id="all_buf_tojson">#</a></span></h3>
<p>Returns a JSON-representation of the Buffer instance.  <code>JSON.stringify</code>
implicitly calls this function when stringifying a Buffer instance.

</p>
<p>返回一个 JSON表示的Buffer实例。<code>JSON.stringify</code>将会默认调用来字符串序列化这个Buffer实例。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>console.log(copy);
// &lt;Buffer 74 65 73 74&gt;</code></pre>
<h3>buf[index]<span><a href="all.html#all_buf_index" id="all_buf_index">#</a></span></h3>
<!--type=property-->
<!--name=[index]-->

<!--type=property-->
<!--name=[index]-->

<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.

</p>
<p>获取或者设置在指定<code>index</code>索引位置的8位字节。这个值是指单个字节，所以这个值必须在合法的范围，16进制的<code>0x00</code> 到<code>0xFF</code>，或者<code>0</code> 到<code>255</code>。

</p>
<p>Example: copy an ASCII string into a buffer, one byte at a time:

</p>
<p>例子: 拷贝一个 ASCII 编码的 string 字符串到一个 buffer, 一次一个 byte 进行拷贝:

</p>
<pre><code>// node.js</code></pre>
<h3>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])<span><a href="all.html#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend" id="all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">#</a></span></h3>
<div><ul>
<li><code>targetBuffer</code> Buffer object - Buffer to copy into</li>
<li><code>targetStart</code> Number, Optional, Default: 0</li>
<li><code>sourceStart</code> Number, Optional, Default: 0</li>
<li><p><code>sourceEnd</code> Number, Optional, Default: <code>buffer.length</code></p>
</li>
<li><p><code>targetBuffer</code> Buffer 类型对象 - 将要进行拷贝的Buffer</p>
</li>
<li><code>targetStart</code> Number类型, 可选参数, 默认: 0</li>
<li><code>sourceStart</code> Number类型, 可选参数, 默认: 0</li>
<li><code>sourceEnd</code> Number类型, 可选参数, 默认: <code>buffer.length</code></li>
</div></ul>
<p>Does copy between buffers. The source and target regions can be overlapped.
<code>targetStart</code> and <code>sourceStart</code> default to <code>0</code>.
<code>sourceEnd</code> defaults to <code>buffer.length</code>.

</p>
<p>进行buffer的拷贝，源和目标可以是重叠的。
<code>targetStart</code> 目标开始偏移 和<code>sourceStart</code>源开始偏移 默认都是 <code>0</code>.
<code>sourceEnd</code> 源结束位置偏移默认是源的长度 <code>buffer.length</code>.

</p>
<p>All values passed that are <code>undefined</code>/<code>NaN</code> or are out of bounds are set equal
to their respective defaults.

</p>
<p>如果传递的值是<code>undefined</code>/<code>NaN</code> 或者是 out of bounds 超越边界的，就将设置为他们的默认值。（译者：这个默认值下面有的例子有说明）

</p>
<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.

</p>
<p>例子: 创建2个Buffer，然后把将<code>buf1</code>的16位到19位 拷贝到 <code>buf2</code>中，并且从<code>buf2</code>的第8位开始拷贝。

</p>
<pre><code>// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
<h3>buf.slice([start], [end])<span><a href="all.html#all_buf_slice_start_end" id="all_buf_slice_start_end">#</a></span></h3>
<div><ul>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><p><code>end</code> Number, Optional, Default: <code>buffer.length</code></p>
</li>
<li><p><code>start</code> Number类型, 可选参数, 默认: 0</p>
</li>
<li><code>end</code> Number类型, 可选参数, 默认: <code>buffer.length</code></li>
</div></ul>
<p>Returns a new buffer which references the same memory as the old, but offset
and cropped by the <code>start</code> (defaults to <code>0</code>) and <code>end</code> (defaults to
<code>buffer.length</code>) indexes.  Negative indexes start from the end of the buffer.

</p>
<p>返回一个新的buffer，这个buffer将会和老的buffer引用相同的内存地址，只是根据 <code> start</code> (默认是 <code>0</code>) 和<code>end</code> (默认是<code>buffer.length</code>)  偏移和裁剪了索引。
负的索引是从buffer尾部开始计算的。

</p>
<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong>

</p>
<p><strong>修改这个新的buffer实例slice切片，也会改变原来的buffer</strong>

</p>
<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.

</p>
<p>例子: 创建一个ASCII 字母的 Buffer，对它slice切片，然后修改源Buffer上的一个byte。

</p>
<pre><code>// abc
// !bc</code></pre>
<h3>buf.readUInt8(offset, [noAssert])<span><a href="all.html#all_buf_readuint8_offset_noassert" id="all_buf_readuint8_offset_noassert">#</a></span></h3>
<div><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</div></ul>
<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.

</p>
<p>从这个buffer对象里，根据指定的偏移量，读取一个 unsigned 8 bit integer整形。 

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x3
// 0x4
// 0x23
// 0x42</code></pre>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16le_offset_noassert" id="all_buf_readuint16le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16be_offset_noassert" id="all_buf_readuint16be_offset_noassert">#</a></span></h3>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16le_offset_noassert_1" id="all_buf_readuint16le_offset_noassert_1">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16be_offset_noassert_1" id="all_buf_readuint16be_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用特殊的 endian字节序格式读取一个 unsigned 16 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32le_offset_noassert" id="all_buf_readuint32le_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32be_offset_noassert" id="all_buf_readuint32be_offset_noassert">#</a></span></h3>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32le_offset_noassert_1" id="all_buf_readuint32le_offset_noassert_1">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32be_offset_noassert_1" id="all_buf_readuint32be_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 unsigned 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x03042342
// 0x42230403</code></pre>
<h3>buf.readInt8(offset, [noAssert])<span><a href="all.html#all_buf_readint8_offset_noassert" id="all_buf_readint8_offset_noassert">#</a></span></h3>
<div><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</div></ul>
<p>Reads a signed 8 bit integer from the buffer at the specified offset.

</p>
<p>从这个buffer对象里，根据指定的偏移量，读取一个 signed 8 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<p>和 <code>buffer.readUInt8</code>一样的返回，除非buffer中包含了有作为2的补码的有符号值。

</p>
<h3>buf.readInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readint16le_offset_noassert" id="all_buf_readint16le_offset_noassert">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readint16be_offset_noassert" id="all_buf_readint16be_offset_noassert">#</a></span></h3>
<h3>buf.readInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readint16le_offset_noassert_1" id="all_buf_readint16le_offset_noassert_1">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readint16be_offset_noassert_1" id="all_buf_readint16be_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用特殊的 endian字节序格式读取一个 signed 16 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<p>和 buffer.readUInt16一样返回，除非buffer中包含了有作为2的补码的有符号值。

</p>
<h3>buf.readInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readint32le_offset_noassert" id="all_buf_readint32le_offset_noassert">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readint32be_offset_noassert" id="all_buf_readint32be_offset_noassert">#</a></span></h3>
<h3>buf.readInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readint32le_offset_noassert_1" id="all_buf_readint32le_offset_noassert_1">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readint32be_offset_noassert_1" id="all_buf_readint32be_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 signed 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<p>和 buffer.readUInt32一样返回，除非buffer中包含了有作为2的补码的有符号值。

</p>
<h3>buf.readFloatLE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatle_offset_noassert" id="all_buf_readfloatle_offset_noassert">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatbe_offset_noassert" id="all_buf_readfloatbe_offset_noassert">#</a></span></h3>
<h3>buf.readFloatLE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatle_offset_noassert_1" id="all_buf_readfloatle_offset_noassert_1">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatbe_offset_noassert_1" id="all_buf_readfloatbe_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 32 bit float。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x01</code></pre>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublele_offset_noassert" id="all_buf_readdoublele_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublebe_offset_noassert" id="all_buf_readdoublebe_offset_noassert">#</a></span></h3>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublele_offset_noassert_1" id="all_buf_readdoublele_offset_noassert_1">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublebe_offset_noassert_1" id="all_buf_readdoublebe_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 bit double。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0.3333333333333333</code></pre>
<h3>buf.writeUInt8(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint8_value_offset_noassert" id="all_buf_writeuint8_value_offset_noassert">#</a></span></h3>
<div><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.

</p>
<p>根据指定的offset偏移量将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的unsigned 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer 03 04 23 42&gt;</code></pre>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16le_value_offset_noassert" id="all_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16be_value_offset_noassert" id="all_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16le_value_offset_noassert_1" id="all_buf_writeuint16le_value_offset_noassert_1">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16be_value_offset_noassert_1" id="all_buf_writeuint16be_value_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的unsigned 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32le_value_offset_noassert" id="all_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32be_value_offset_noassert" id="all_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32le_value_offset_noassert_1" id="all_buf_writeuint32le_value_offset_noassert_1">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32be_value_offset_noassert_1" id="all_buf_writeuint32be_value_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的unsigned 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>
<h3>buf.writeInt8(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint8_value_offset_noassert" id="all_buf_writeint8_value_offset_noassert">#</a></span></h3>
<div><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.

</p>
<p>根据指定的offset偏移量将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的 signed 8 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&apos;s complement
signed integer into <code>buffer</code>.

</p>
<p>和 <code>buffer.writeUInt8</code> 一样工作，除非是把有2的补码的 signed integer 有符号整形写入<code>buffer</code>。

</p>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16le_value_offset_noassert" id="all_buf_writeint16le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16be_value_offset_noassert" id="all_buf_writeint16be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16le_value_offset_noassert_1" id="all_buf_writeint16le_value_offset_noassert_1">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16be_value_offset_noassert_1" id="all_buf_writeint16be_value_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的 signed 16 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<p>和 <code>buffer.writeUInt16*</code> 一样工作，除非是把有2的补码的 signed integer 有符号整形写入<code>buffer</code>。

</p>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32le_value_offset_noassert" id="all_buf_writeint32le_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32be_value_offset_noassert" id="all_buf_writeint32be_value_offset_noassert">#</a></span></h3>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32le_value_offset_noassert_1" id="all_buf_writeint32le_value_offset_noassert_1">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32be_value_offset_noassert_1" id="all_buf_writeint32be_value_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的 signed 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<p>和 <code>buffer.writeUInt32*</code> 一样工作，除非是把有2的补码的 signed integer 有符号整形写入<code>buffer</code>。

</p>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatle_value_offset_noassert" id="all_buf_writefloatle_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatbe_value_offset_noassert" id="all_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatle_value_offset_noassert_1" id="all_buf_writefloatle_value_offset_noassert_1">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatbe_value_offset_noassert_1" id="all_buf_writefloatbe_value_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, behavior is unspecified if <code>value</code> is not a 32 bit float.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：当<code>value</code> 不是一个 32 bit float 类型的值时，结果将是不确定的。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublele_value_offset_noassert" id="all_buf_writedoublele_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublebe_value_offset_noassert" id="all_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublele_value_offset_noassert_1" id="all_buf_writedoublele_value_offset_noassert_1">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublebe_value_offset_noassert_1" id="all_buf_writedoublebe_value_offset_noassert_1">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个有效的 64 bit double 类型的值。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
<h3>buf.fill(value, [offset], [end])<span><a href="all.html#all_buf_fill_value_offset_end" id="all_buf_fill_value_offset_end">#</a></span></h3>
<div><ul>
<li><code>value</code></li>
<li><code>offset</code> Number, Optional</li>
<li><p><code>end</code> Number, Optional</p>
</li>
<li><p><code>value</code></p>
</li>
<li><code>offset</code> Number类型, 可选参数</li>
<li><code>end</code> Number类型, 可选参数</li>
</div></ul>
<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire
buffer.

</p>
<p>使用指定的value来填充这个buffer。如果 <code>offset</code> (默认是 <code>0</code>) 并且 <code>end</code> (默认是 <code>buffer.length</code>) 没有明确给出，就会填充整个buffer。
（译者：buf.fill调用的是C语言的memset函数非常高效）

</p>
<pre><code>var b = new Buffer(50);
b.fill(&quot;h&quot;);</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a href="all.html#all_buffer_inspect_max_bytes" id="all_buffer_inspect_max_bytes">#</a></span></h2>
<div><ul>
<li><p>Number, Default: 50</p>
</li>
<li><p>Number类型, 默认: 50</p>
</li>
</div></ul>
<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overridden by user modules.

</p>
<p>设置当调用<code>buffer.inspect()</code>方法后，多少bytes将会返回。这个值可以被用户模块重写。
（译者：这个值主要用在当我们打印console.log(buf)时，设置返回多少长度内容）

</p>
<p>Note that this is a property on the buffer module returned by
<code>require(&apos;buffer&apos;)</code>, not on the Buffer global, or a buffer instance.

</p>
<p>注意这个属性是<code>require(&apos;buffer&apos;)</code>模块返回的。这个属性不是在全局变量Buffer中，也不再buffer的实例里。 

</p>
<h2>类: SlowBuffer<span><a href="all.html#all_slowbuffer" id="all_slowbuffer">#</a></span></h2>
<p>Returns an un-pooled <code>Buffer</code>.

</p>
<p>返回一个不被池管理的 <code>Buffer</code>。

</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated Buffers, by default allocations under 4KB are sliced from a single
larger allocated object. This approach improves both performance and memory
usage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.

</p>
<p>为了避免创建大量独立分配的 Buffer 带来的垃圾回收开销，默认情况下小于 4KB 的空间都是切割自一个较大的独立对象。这种策略既提高了性能也改善了内存使用，因为 V8 不需要跟踪和清理很多 <code>Persistent</code> 对象。

</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time it may be appropriate to create an
un-pooled Buffer instance using SlowBuffer and copy out the relevant bits.

</p>
<p>当开发者需要将池中一小块数据保留不确定的一段时间，较为妥当的办法是用 SlowBuffer 创建一个不被池管理的 Buffer 实例并将相应数据拷贝出来。

</p>
<pre><code>socket.on(&apos;readable&apos;, function() {
  var data = socket.read();
  // 为需要保留的数据分配内存
  var sb = new SlowBuffer(10);
  // 将数据拷贝到新的空间中
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});</code></pre>
<p>Though this should used sparingly and only be a last resort <em>after</em> a developer
has actively observed undue memory retention in their applications.


</p>
<p>请谨慎使用，仅作为开发者频繁观察到他们的应用中过度的内存保留时的<em>最后</em>手段。
</p>
<h1>流<span><a href="all.html#all_17" id="all_17">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p>A stream is an abstract interface implemented by various objects in
Node.  For example a <a href="http.html#http_http_incomingmessage">request to an HTTP
server</a> is a stream, as is
<a href="process.html#process_process_stdout">stdout</a>. Streams are readable, writable, or both. All streams are
instances of <a href="events.html#events_class_events_eventemitter">EventEmitter</a>

</p>
<p>流是一个抽象接口，被 Node 中的很多对象所实现。比如<a href="http.html#http_http_incomingmessage">对一个 HTTP 服务器的请求</a>是一个流，<a href="process.html#process_process_stdout">stdout</a> 也是一个流。流是可读、可写或兼具两者的。所有流都是 <a href="events.html#events_class_events_eventemitter">EventEmitter</a> 的实例。

</p>
<p>You can load the Stream base classes by doing <code>require(&apos;stream&apos;)</code>.
There are base classes provided for <a href="all.html#stream_class_stream_readable">Readable</a> streams, <a href="all.html#stream_class_stream_writable">Writable</a>
streams, <a href="all.html#stream_class_stream_duplex">Duplex</a> streams, and <a href="all.html#stream_class_stream_transform">Transform</a> streams.

</p>
<p>您可以通过 <code>require(&apos;stream&apos;)</code> 加载 Stream 基类，其中包括了 <a href="all.html#stream_class_stream_readable">Readable</a> 流、<a href="all.html#stream_class_stream_writable">Writable</a> 流、<a href="all.html#stream_class_stream_duplex">Duplex</a> 流和 <a href="all.html#stream_class_stream_transform">Transform</a> 流的基类。

</p>
<p>This document is split up into 3 sections.  The first explains the
parts of the API that you need to be aware of to use streams in your
programs.  If you never implement a streaming API yourself, you can
stop there.

</p>
<p>本文档分为三个章节。第一章节解释了您在您的程序中使用流时需要了解的那部分 API，如果您不打算自己实现一个流式 API，您可以只阅读这一章节。

</p>
<p>The second section explains the parts of the API that you need to use
if you implement your own custom streams yourself.  The API is
designed to make this easy for you to do.

</p>
<p>第二章节解释了当您自己实现一个流时需要用到的那部分 API，这些 API 是为了方便您这么做而设计的。

</p>
<p>The third section goes into more depth about how streams work,
including some of the internal mechanisms and functions that you
should probably not modify unless you definitely know what you are
doing.

</p>
<p>第三章节深入讲解了流的工作方式，包括一些内部机制和函数，除非您明确知道您在做什么，否则尽量不要改动它们。

</p>
<h2>面向流消费者的 API<span><a href="all.html#all_api" id="all_api">#</a></span></h2>
<!--type=misc-->

<p>Streams can be either <a href="all.html#stream_class_stream_readable">Readable</a>, <a href="all.html#stream_class_stream_writable">Writable</a>, or both (<a href="all.html#stream_class_stream_duplex">Duplex</a>).

</p>
<p>流可以是可读（<a href="all.html#stream_class_stream_readable">Readable</a>）或可写（<a href="all.html#stream_class_stream_writable">Writable</a>），或者兼具两者（<a href="all.html#stream_class_stream_duplex">Duplex</a>，双工）的。

</p>
<p>All streams are EventEmitters, but they also have other custom methods
and properties depending on whether they are Readable, Writable, or
Duplex.

</p>
<p>所有流都是 EventEmitter，但它们也具有其它自定义方法和属性，取决于它们是 Readable、Writable 或 Duplex。

</p>
<p>If a stream is both Readable and Writable, then it implements all of
the methods and events below.  So, a <a href="all.html#stream_class_stream_duplex">Duplex</a> or <a href="all.html#stream_class_stream_transform">Transform</a> stream is
fully described by this API, though their implementation may be
somewhat different.

</p>
<p>如果一个流既可读（Readable）也可写（Writable），则它实现了下文所述的所有方法和事件。因此，这些 API 同时也涵盖了 <a href="all.html#stream_class_stream_duplex">Duplex</a> 或 <a href="all.html#stream_class_stream_transform">Transform</a> 流，即便它们的实现可能有点不同。

</p>
<p>It is not necessary to implement Stream interfaces in order to consume
streams in your programs.  If you <strong>are</strong> implementing streaming
interfaces in your own program, please also refer to
<a href="all.html#stream_api_for_stream_implementors">API for Stream Implementors</a> below.

</p>
<p>为了消费流而在您的程序中自己实现 Stream 接口是没有必要的。如果您<strong>确实</strong>正在您自己的程序中实现流式接口，请同时参考下文<a href="all.html#stream_api_for_stream_implementors">面向流实现者的 API</a>。

</p>
<p>Almost all Node programs, no matter how simple, use Streams in some
way.  Here is an example of using Streams in a Node program:

</p>
<p>几乎所有 Node 程序，无论多简单，都在某种途径用到了流。这里有一个使用流的 Node 程序的例子：

</p>
<pre><code>var http = require(&apos;http&apos;);

var server = http.createServer(function (req, res) {
  // req is an http.IncomingMessage, which is a Readable Stream
  // res is an http.ServerResponse, which is a Writable Stream

var server = http.createServer(function (req, res) {
  // req 为 http.IncomingMessage，是一个可读流（Readable Stream）
  // res 为 http.ServerResponse，是一个可写流（Writable Stream）

  var body = &apos;&apos;;
  // we want to get the data as utf8 strings
  // If you don&apos;t set an encoding, then you&apos;ll get Buffer objects
  req.setEncoding(&apos;utf8&apos;);

  var body = &apos;&apos;;
  // 我们打算以 UTF-8 字符串的形式获取数据
  // 如果您不设置编码，您将得到一个 Buffer 对象
  req.setEncoding(&apos;utf8&apos;);

  // Readable streams emit &apos;data&apos; events once a listener is added
  req.on(&apos;data&apos;, function (chunk) {
    body += chunk;
  })

  // 一旦监听器被添加，可读流会触发 &apos;data&apos; 事件
  req.on(&apos;data&apos;, function (chunk) {
    body += chunk;
  })

  // the end event tells you that you have entire body
  req.on(&apos;end&apos;, function () {
    try {
      var data = JSON.parse(body);
    } catch (er) {
      // uh oh!  bad json!
      res.statusCode = 400;
      return res.end(&apos;error: &apos; + er.message);
    }

  // &apos;end&apos; 事件表明您已经得到了完整的 body
  req.on(&apos;end&apos;, function () {
    try {
      var data = JSON.parse(body);
    } catch (er) {
      // uh oh!  bad json!
      res.statusCode = 400;
      return res.end(&apos;错误: &apos; + er.message);
    }

    // write back something interesting to the user:
    res.write(typeof data);
    res.end();
  })
})

    // 向用户回写一些有趣的信息
    res.write(typeof data);
    res.end();
  })
})

server.listen(1337);

server.listen(1337);

// $ curl localhost:1337 -d &apos;{}&apos;
// object
// $ curl localhost:1337 -d &apos;&quot;foo&quot;&apos;
// string
// $ curl localhost:1337 -d &apos;not json&apos;
// 错误: Unexpected token o</code></pre>
<h3>类: stream.Readable<span><a href="all.html#all_stream_readable" id="all_stream_readable">#</a></span></h3>
<!--type=class-->

<p>The Readable stream interface is the abstraction for a <em>source</em> of
data that you are reading from.  In other words, data comes <em>out</em> of a
Readable stream.

</p>
<p>Readable（可读）流接口是对您正在读取的数据的<em>来源</em>的抽象。换言之，数据<em>出自</em>一个 Readable 流。

</p>
<p>A Readable stream will not start emitting data until you indicate that
you are ready to receive it.

</p>
<p>在您表明您就绪接收之前，Readable 流并不会开始发生数据。

</p>
<p>Readable streams have two &quot;modes&quot;: a <strong>flowing mode</strong> and a <strong>paused
mode</strong>.  When in flowing mode, data is read from the underlying system
and provided to your program as fast as possible.  In paused mode, you
must explicitly call <code>stream.read()</code> to get chunks of data out.
Streams start out in paused mode.

</p>
<p>Readable 流有两种“模式”：<strong>流动模式</strong>和<strong>暂停模式</strong>。当处于流动模式时，数据由底层系统读出，并尽可能快地提供给您的程序；当处于暂停模式时，您必须明确地调用 <code>stream.read()</code> 来取出若干数据块。流默认处于暂停模式。

</p>
<p><strong>Note</strong>: If no data event handlers are attached, and there are no
<a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> destinations, and the stream is switched into flowing
mode, then data will be lost.

</p>
<p><strong>注意</strong>：如果没有绑定 data 事件处理器，并且没有 <a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> 目标，同时流被切换到流动模式，那么数据会流失。

</p>
<p>You can switch to flowing mode by doing any of the following:

</p>
<p>您可以通过下面几种做法切换到流动模式：

</p>
<ul>
<li>Adding a <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a> handler to listen for data.</li>
<li>Calling the <a href="all.html#stream_readable_resume"><code>resume()</code></a> method to explicitly open the flow.</li>
<li><p>Calling the <a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> method to send the data to a <a href="all.html#stream_class_stream_writable">Writable</a>.</p>
</li>
<li><p>添加一个 <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>处理器来监听数据。</p>
</li>
<li>调用 <a href="all.html#stream_readable_resume"><code>resume()</code></a> 方法来明确开启数据流。</li>
<li>调用 <a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> 方法将数据发送到一个 <a href="all.html#stream_class_stream_writable">Writable</a>。</li>
</ul>
<p>You can switch back to paused mode by doing either of the following:

</p>
<p>您可以通过下面其中一种做法切换回暂停模式：

</p>
<ul>
<li>If there are no pipe destinations, by calling the <a href="all.html#stream_readable_pause"><code>pause()</code></a>
method.</li>
<li><p>If there are pipe destinations, by removing any <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a>
handlers, and removing all pipe destinations by calling the
<a href="all.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> method.</p>
</li>
<li><p>如果没有导流目标，调用 <a href="all.html#stream_readable_pause"><code>pause()</code></a> 方法。</p>
</li>
<li>如果有导流目标，移除所有 [<code>&apos;data&apos;</code> 事件][] 处理器、调用 <a href="all.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> 方法移除所有导流目标。</li>
</ul>
<p>Note that, for backwards compatibility reasons, removing <code>&apos;data&apos;</code>
event handlers will <strong>not</strong> automatically pause the stream.  Also, if
there are piped destinations, then calling <code>pause()</code> will not
guarantee that the stream will <em>remain</em> paused once those
destinations drain and ask for more data.

</p>
<p>请注意，为了向后兼容考虑，移除 <code>&apos;data&apos;</code> 事件监听器并<strong>不会</strong>自动暂停流。同样的，当有导流目标时，调用 <code>pause()</code> 并不能保证流在那些目标排空并请求更多数据时<em>维持</em>暂停状态。

</p>
<p>Examples of readable streams include:

</p>
<p>一些可读流的例子：

</p>
<ul>
<li><a href="http.html#http_http_incomingmessage">http responses, on the client</a></li>
<li><a href="http.html#http_http_incomingmessage">http requests, on the server</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs read streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdout">child process stdout and stderr</a></li>
<li><a href="process.html#process_process_stdin">process.stdin</a></li>
</ul>
<ul>
<li><a href="http.html#http_http_incomingmessage">客户端上的 HTTP 响应</a></li>
<li><a href="http.html#http_http_incomingmessage">服务器上的 HTTP 请求</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs 读取流</a></li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
<li><a href="net.html#net_class_net_socket">TCP 嵌套字</a></li>
<li><a href="child_process.html#child_process_child_stdout">子进程的 stdout 和 stderr</a></li>
<li><a href="process.html#process_process_stdin">process.stdin</a></li>
</ul>
<h4>事件: &apos;readable&apos;<span><a href="all.html#all_readable" id="all_readable">#</a></span></h4>
<p>When a chunk of data can be read from the stream, it will emit a
<code>&apos;readable&apos;</code> event.

</p>
<p>当一个数据块可以从流中被读出时，它会触发一个 <code>&apos;readable&apos;</code> 事件。

</p>
<p>In some cases, listening for a <code>&apos;readable&apos;</code> event will cause some data
to be read into the internal buffer from the underlying system, if it
hadn&apos;t already.

</p>
<p>在某些情况下，假如未准备好，监听一个 <code>&apos;readable&apos;</code> 事件会使得一些数据从底层系统被读出到内部缓冲区中。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;readable&apos;, function() {
  // 现在有数据可以读了
})</code></pre>
<p>Once the internal buffer is drained, a <code>readable</code> event will fire
again when more data is available.

</p>
<p>当内部缓冲区被排空后，一旦更多数据时，一个 <code>readable</code> 事件会被再次触发。

</p>
<h4>事件: &apos;data&apos;<span><a href="all.html#all_data" id="all_data">#</a></span></h4>
<div><ul>
<li><p><code>chunk</code> <span>Buffer | String</span> The chunk of data.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 数据块。</p>
</li>
</div></ul>
<p>Attaching a <code>data</code> event listener to a stream that has not been
explicitly paused will switch the stream into flowing mode. Data will
then be passed as soon as it is available.

</p>
<p>绑定一个 <code>data</code> 事件监听器到一个未被明确暂停的流会将流切换到流动模式，数据会被尽可能地传递。

</p>
<p>If you just want to get all the data out of the stream as fast as
possible, this is the best way to do so.

</p>
<p>如果您想从流尽快取出所有数据，这是最理想的方式。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
})</code></pre>
<h4>事件: &apos;end&apos;<span><a href="all.html#all_end" id="all_end">#</a></span></h4>
<p>This event fires when no more data will be provided.

</p>
<p>该事件会在没有更多数据能够提供时被触发。

</p>
<p>Note that the <code>end</code> event <strong>will not fire</strong> unless the data is
completely consumed.  This can be done by switching into flowing mode,
or by calling <code>read()</code> repeatedly until you get to the end.

</p>
<p>请注意，<code>end</code> 事件在数据被完全消费之前<strong>不会被触发</strong>。这可通过切换到流动模式，或者在到达末端前不断调用 <code>read()</code> 来实现。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
})
readable.on(&apos;end&apos;, function() {
  console.log(&apos;读取完毕。&apos;);
});</code></pre>
<h4>事件: &apos;close&apos;<span><a href="all.html#all_close" id="all_close">#</a></span></h4>
<p>Emitted when the underlying resource (for example, the backing file
descriptor) has been closed. Not all streams will emit this.

</p>
<p>当底层数据源（比如，源头的文件描述符）被关闭时触发。并不是所有流都会触发这个事件。

</p>
<h4>事件: &apos;error&apos;<span><a href="all.html#all_error_1" id="all_error_1">#</a></span></h4>
<p>Emitted if there was an error receiving data.

</p>
<p>当数据接收时发生错误时触发。

</p>
<h4>readable.read([size])<span><a href="all.html#all_readable_read_size" id="all_readable_read_size">#</a></span></h4>
<div><ul>
<li><code>size</code> <span>Number</span> Optional argument to specify how much data to read.</li>
<li><p>Return <span>String | Buffer | null</span></p>
</li>
<li><p><code>size</code> <span>Number</span> 可选参数，指定要读取多少数据。</p>
</li>
<li>返回 <span>String | Buffer | null</span></li>
</div></ul>
<p>The <code>read()</code> method pulls some data out of the internal buffer and
returns it.  If there is no data available, then it will return
<code>null</code>.

</p>
<p><code>read()</code> 方法从内部缓冲区中拉取并返回若干数据。当没有更多数据可用时，它会返回 <code>null</code>。

</p>
<p>If you pass in a <code>size</code> argument, then it will return that many
bytes.  If <code>size</code> bytes are not available, then it will return <code>null</code>.

</p>
<p>若您传入了一个 <code>size</code> 参数，那么它会返回相当字节的数据；当 <code>size</code> 字节不可用时，它则返回 <code>null</code>。

</p>
<p>If you do not specify a <code>size</code> argument, then it will return all the
data in the internal buffer.

</p>
<p>若您没有指定 <code>size</code> 参数，那么它会返回内部缓冲区中的所有数据。

</p>
<p>This method should only be called in paused mode.  In flowing mode,
this method is called automatically until the internal buffer is
drained.

</p>
<p>该方法仅应在暂停模式时被调用。在流动模式中，该方法会被自动调用直到内部缓冲区排空。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;readable&apos;, function() {
  var chunk;
  while (null !== (chunk = readable.read())) {
    console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
  }
});</code></pre>
<p>If this method returns a data chunk, then it will also trigger the
emission of a <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a>.

</p>
<p>当该方法返回了一个数据块，它同时也会触发 <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>。

</p>
<h4>readable.setEncoding(encoding)<span><a href="all.html#all_readable_setencoding_encoding" id="all_readable_setencoding_encoding">#</a></span></h4>
<div><ul>
<li><code>encoding</code> <span>String</span> The encoding to use.</li>
<li><p>Return: <code>this</code></p>
</li>
<li><p><code>encoding</code> <span>String</span> 要使用的编码。</p>
</li>
<li>返回: <code>this</code></li>
</div></ul>
<p>Call this function to cause the stream to return strings of the
specified encoding instead of Buffer objects.  For example, if you do
<code>readable.setEncoding(&apos;utf8&apos;)</code>, then the output data will be
interpreted as UTF-8 data, and returned as strings.  If you do
<code>readable.setEncoding(&apos;hex&apos;)</code>, then the data will be encoded in
hexadecimal string format.

</p>
<p>调用此函数会使得流返回指定编码的字符串而不是 Buffer 对象。比如，当您 <code>readable.setEncoding(&apos;utf8&apos;)</code>，那么输出数据会被作为 UTF-8 数据解析，并以字符串返回。如果您 <code>readable.setEncoding(&apos;hex&apos;)</code>，那么数据会被编码成十六进制字符串格式。

</p>
<p>This properly handles multi-byte characters that would otherwise be
potentially mangled if you simply pulled the Buffers directly and
called <code>buf.toString(encoding)</code> on them.  If you want to read the data
as strings, always use this method.

</p>
<p>该方法能正确处理多字节字符。假如您不这么做，仅仅直接取出 Buffer 并对它们调用 <code>buf.toString(encoding)</code>，很可能会导致字节错位。因此如果您打算以字符串读取数据，请总是使用这个方法。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.setEncoding(&apos;utf8&apos;);
readable.on(&apos;data&apos;, function(chunk) {
  assert.equal(typeof chunk, &apos;string&apos;);
  console.log(&apos;得到了 %d 个字符的字符串数据&apos;, chunk.length);
})</code></pre>
<h4>readable.resume()<span><a href="all.html#all_readable_resume" id="all_readable_resume">#</a></span></h4>
<div><ul>
<li><p>Return: <code>this</code></p>
</li>
<li><p>返回: <code>this</code></p>
</li>
</div></ul>
<p>This method will cause the readable stream to resume emitting <code>data</code>
events.

</p>
<p>该方法让可读流继续触发 <code>data</code> 事件。

</p>
<p>This method will switch the stream into flowing mode.  If you do <em>not</em>
want to consume the data from a stream, but you <em>do</em> want to get to
its <code>end</code> event, you can call <a href="all.html#stream_readable_resume"><code>readable.resume()</code></a> to open the flow of
data.

</p>
<p>该方法会将流切换到流动模式。如果您<em>不想</em>从流中消费数据，但您<em>想</em>得到它的 <code>end</code> 事件，您可以调用 <a href="all.html#stream_readable_resume"><code>readable.resume()</code></a> 来启动数据流。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.resume();
readable.on(&apos;end&apos;, function(chunk) {
  console.log(&apos;到达末端，但并未读取任何东西&apos;);
})</code></pre>
<h4>readable.pause()<span><a href="all.html#all_readable_pause" id="all_readable_pause">#</a></span></h4>
<div><ul>
<li><p>Return: <code>this</code></p>
</li>
<li><p>返回: <code>this</code></p>
</li>
</div></ul>
<p>This method will cause a stream in flowing mode to stop emitting
<code>data</code> events, switching out of flowing mode.  Any data that becomes
available will remain in the internal buffer.

</p>
<p>该方法会使一个处于流动模式的流停止触发 <code>data</code> 事件，切换到非流动模式，并让后续可用数据留在内部缓冲区中。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;取得 %d 字节数据&apos;, chunk.length);
  readable.pause();
  console.log(&apos;接下来 1 秒内不会有数据&apos;);
  setTimeout(function() {
    console.log(&apos;现在数据会再次开始流动&apos;);
    readable.resume();
  }, 1000);
})</code></pre>
<h4>readable.pipe(destination, [options])<span><a href="all.html#all_readable_pipe_destination_options" id="all_readable_pipe_destination_options">#</a></span></h4>
<div><ul>
<li><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> The destination for writing data</li>
<li><p><code>options</code> <span>Object</span> Pipe options</p>
<ul>
<li><code>end</code> <span>Boolean</span> End the writer when the reader ends. Default = <code>true</code></li>
</ul>
</li>
<li><p><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> 写入数据的目标</p>
</li>
<li><code>options</code> <span>Object</span> 导流选项<ul>
<li><code>end</code> <span>Boolean</span> 在读取者结束时结束写入者。缺省为 <code>true</code></li>
</ul>
</li>
</div></ul>
<p>This method pulls all the data out of a readable stream, and writes it
to the supplied destination, automatically managing the flow so that
the destination is not overwhelmed by a fast readable stream.

</p>
<p>该方法从可读流中拉取所有数据，并写入到所提供的目标。该方法能自动控制流量以避免目标被快速读取的可读流所淹没。

</p>
<p>Multiple destinations can be piped to safely.

</p>
<p>可以导流到多个目标。

</p>
<pre><code>var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&apos;file.txt&apos;);
// 所有来自 readable 的数据会被写入到 &apos;file.txt&apos;
readable.pipe(writable);</code></pre>
<p>This function returns the destination stream, so you can set up pipe
chains like so:

</p>
<p>该函数返回目标流，因此您可以建立导流链：

</p>
<pre><code>var r = fs.createReadStream(&apos;file.txt&apos;);
var z = zlib.createGzip();
var w = fs.createWriteStream(&apos;file.txt.gz&apos;);
r.pipe(z).pipe(w);</code></pre>
<p>For example, emulating the Unix <code>cat</code> command:

</p>
<p>例如，模拟 Unix 的 <code>cat</code> 命令：

</p>
<pre><code>process.stdin.pipe(process.stdout);</code></pre>
<p>By default <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> is called on the destination when the source stream
emits <code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end:
false }</code> as <code>options</code> to keep the destination stream open.

</p>
<p>缺省情况下当来源流触发 <code>end</code> 时目标的 <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 会被调用，所以此时 <code>destination</code> 不再可写。传入 <code>{ end: false }</code> 作为 <code>options</code> 可以让目标流保持开启状态。

</p>
<p>This keeps <code>writer</code> open so that &quot;Goodbye&quot; can be written at the
end.

</p>
<p>这将让 <code>writer</code> 保持开启，因此最后可以写入 &quot;Goodbye&quot;。

</p>
<pre><code>reader.pipe(writer, { end: false });
reader.on(&apos;end&apos;, function() {
  writer.end(&apos;Goodbye\n&apos;);
});</code></pre>
<p>Note that <code>process.stderr</code> and <code>process.stdout</code> are never closed until
the process exits, regardless of the specified options.

</p>
<p>请注意 <code>process.stderr</code> 和 <code>process.stdout</code> 在进程结束前都不会被关闭，无论是否指定选项。

</p>
<h4>readable.unpipe([destination])<span><a href="all.html#all_readable_unpipe_destination" id="all_readable_unpipe_destination">#</a></span></h4>
<div><ul>
<li><p><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> Optional specific stream to unpipe</p>
</li>
<li><p><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> 可选，指定解除导流的流</p>
</li>
</div></ul>
<p>This method will remove the hooks set up for a previous <code>pipe()</code> call.

</p>
<p>该方法会移除之前调用 <code>pipe()</code> 所设定的钩子。

</p>
<p>If the destination is not specified, then all pipes are removed.

</p>
<p>如果不指定目标，所有导流都会被移除。

</p>
<p>If the destination is specified, but no pipe is set up for it, then
this is a no-op.

</p>
<p>如果指定了目标，但并没有与之建立导流，则什么事都不会发生。

</p>
<pre><code>var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&apos;file.txt&apos;);
// 来自 readable 的所有数据都会被写入 &apos;file.txt&apos;,
// 但仅发生在第 1 秒
readable.pipe(writable);
setTimeout(function() {
  console.log(&apos;停止写入到 file.txt&apos;);
  readable.unpipe(writable);
  console.log(&apos;自行关闭文件流&apos;);
  writable.end();
}, 1000);</code></pre>
<h4>readable.unshift(chunk)<span><a href="all.html#all_readable_unshift_chunk" id="all_readable_unshift_chunk">#</a></span></h4>
<div><ul>
<li><p><code>chunk</code> <span>Buffer | String</span> Chunk of data to unshift onto the read queue</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要插回读取队列开头的数据块</p>
</li>
</div></ul>
<p>This is useful in certain cases where a stream is being consumed by a
parser, which needs to &quot;un-consume&quot; some data that it has
optimistically pulled out of the source, so that the stream can be
passed on to some other party.

</p>
<p>该方法在许多场景中都很有用，比如一个流正在被一个解析器消费，解析器可能需要将某些刚拉取出的数据“逆消费”回来源，以便流能将它传递给其它消费者。

</p>
<p>If you find that you must often call <code>stream.unshift(chunk)</code> in your
programs, consider implementing a <a href="all.html#stream_class_stream_transform">Transform</a> stream instead.  (See API
for Stream Implementors, below.)

</p>
<p>如果您发现您需要在您的程序中频繁调用 <code>stream.unshift(chunk)</code>，请考虑实现一个 <a href="all.html#stream_class_stream_transform">Transform</a> 流。（详见下文面向流实现者的 API。）

</p>
<pre><code>// 取出以 \n\n 分割的头部并将多余部分 unshift() 回去
// callback 以 (error, header, stream) 形式调用
var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;
function parseHeader(stream, callback) {
  stream.on(&apos;error&apos;, callback);
  stream.on(&apos;readable&apos;, onReadable);
  var decoder = new StringDecoder(&apos;utf8&apos;);
  var header = &apos;&apos;;
  function onReadable() {
    var chunk;
    while (null !== (chunk = stream.read())) {
      var str = decoder.write(chunk);
      if (str.match(/\n\n/)) {
        // 找到头部边界
        var split = str.split(/\n\n/);
        header += split.shift();
        var remaining = split.join(&apos;\n\n&apos;);
        var buf = new Buffer(remaining, &apos;utf8&apos;);
        if (buf.length)
          stream.unshift(buf);
        stream.removeListener(&apos;error&apos;, callback);
        stream.removeListener(&apos;readable&apos;, onReadable);
        // 现在可以从流中读取消息的主体了
        callback(null, header, stream);
      } else {
        // 仍在读取头部
        header += str;
      }
    }
  }
}</code></pre>
<h4>readable.wrap(stream)<span><a href="all.html#all_readable_wrap_stream" id="all_readable_wrap_stream">#</a></span></h4>
<div><ul>
<li><p><code>stream</code> <span>Stream</span> An &quot;old style&quot; readable stream</p>
</li>
<li><p><code>stream</code> <span>Stream</span> 一个“旧式”可读流</p>
</li>
</div></ul>
<p>Versions of Node prior to v0.10 had streams that did not implement the
entire Streams API as it is today.  (See &quot;Compatibility&quot; below for
more information.)

</p>
<p>Node v0.10 版本之前的流并未实现现今所有流 API。（更多信息详见下文“兼容性”章节。）

</p>
<p>If you are using an older Node library that emits <code>&apos;data&apos;</code> events and
has a <a href="all.html#stream_readable_pause"><code>pause()</code></a> method that is advisory only, then you can use the
<code>wrap()</code> method to create a <a href="all.html#stream_class_stream_readable">Readable</a> stream that uses the old stream
as its data source.

</p>
<p>如果您正在使用早前版本的 Node 库，它触发 <code>&apos;data&apos;</code> 事件并且有一个仅作查询用途的 <a href="all.html#stream_readable_pause"><code>pause()</code></a> 方法，那么您可以使用 <code>wrap()</code> 方法来创建一个使用旧式流作为数据源的 <a href="all.html#stream_class_stream_readable">Readable</a> 流。

</p>
<p>You will very rarely ever need to call this function, but it exists
as a convenience for interacting with old Node programs and libraries.

</p>
<p>您可能很少需要用到这个函数，但它会作为与旧 Node 程序和库交互的简便方法存在。

</p>
<p>For example:

</p>
<p>例如：

</p>
<pre><code>myReader.on(&apos;readable&apos;, function() {
myReader.read(); // etc.
});</code></pre>
<h3>类: stream.Writable<span><a href="all.html#all_stream_writable" id="all_stream_writable">#</a></span></h3>
<!--type=class-->

<p>The Writable stream interface is an abstraction for a <em>destination</em>
that you are writing data <em>to</em>.

</p>
<p>Writable（可写）流接口是对您正在写入数据<em>至一个目标</em>的抽象。

</p>
<p>Examples of writable streams include:

</p>
<p>一些可写流的例子：

</p>
<ul>
<li><a href="http.html#http_class_http_clientrequest">http requests, on the client</a></li>
<li><a href="http.html#http_class_http_serverresponse">http responses, on the server</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="process.html#process_process_stdout">process.stdout</a>, <a href="process.html#process_process_stderr">process.stderr</a></li>
</ul>
<ul>
<li><a href="http.html#http_class_http_clientrequest">http requests, on the client</a></li>
<li><a href="http.html#http_class_http_serverresponse">http responses, on the server</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="process.html#process_process_stdout">process.stdout</a>, <a href="process.html#process_process_stderr">process.stderr</a></li>
</ul>
<h4>writable.write(chunk, [encoding], [callback])<span><a href="all.html#all_writable_write_chunk_encoding_callback" id="all_writable_write_chunk_encoding_callback">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>String | Buffer</span> The data to write</li>
<li><code>encoding</code> <span>String</span> The encoding, if <code>chunk</code> is a String</li>
<li><code>callback</code> <span>Function</span> Callback for when this chunk of data is flushed</li>
<li>Returns: <span>Boolean</span> True if the data was handled completely.</li>
</div></ul>
<ul>
<li><code>chunk</code> {String | Buffer} 要写入的数据</li>
<li><code>encoding</code> {String} 编码，假如 <code>chunk</code> 是一个字符串</li>
<li><code>callback</code> {Function} 数据块写入后的回调</li>
<li>返回: {Boolean} 如果数据已被全部处理则 <code>true</code>。</li>
</ul>
<p>This method writes some data to the underlying system, and calls the
supplied callback once the data has been fully handled.

</p>
<p>该方法向底层系统写入数据，并在数据被处理完毕后调用所给的回调。

</p>
<p>The return value indicates if you should continue writing right now.
If the data had to be buffered internally, then it will return
<code>false</code>.  Otherwise, it will return <code>true</code>.

</p>
<p>返回值表明您是否应该立即继续写入。如果数据需要滞留在内部，则它会返回 <code>false</code>；否则，返回 <code>true</code>。

</p>
<p>This return value is strictly advisory.  You MAY continue to write,
even if it returns <code>false</code>.  However, writes will be buffered in
memory, so it is best not to do this excessively.  Instead, wait for
the <code>drain</code> event before writing more data.

</p>
<p>返回值所表示的状态仅供参考，您【可以】在即便返回 <code>false</code> 的时候继续写入。但是，写入的数据会被滞留在内存中，所以最好不要过分地这么做。最好的做法是等待 <code>drain</code> 事件发生后再继续写入更多数据。

</p>
<h4>事件: &apos;drain&apos;<span><a href="all.html#all_drain" id="all_drain">#</a></span></h4>
<p>If a <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> call returns false, then the <code>drain</code>
event will indicate when it is appropriate to begin writing more data
to the stream.

</p>
<p>如果一个 <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> 调用返回 <code>false</code>，那么 <code>drain</code> 事件则表明可以继续向流写入更多数据。

</p>
<pre><code>// 向所给可写流写入 1000000 次数据。
// 注意后端压力。
function writeOneMillionTimes(writer, data, encoding, callback) {
  var i = 1000000;
  write();
  function write() {
    var ok = true;
    do {
      i -= 1;
      if (i === 0) {
        // 最后一次！
        writer.write(data, encoding, callback);
      } else {
        // 检查我们应该继续还是等待
        // 不要传递回调，因为我们还没完成。
        ok = writer.write(data, encoding);
      }
    } while (i &gt; 0 &amp;&amp; ok);
    if (i &gt; 0) {
      // 不得不提前停止！
      // 一旦它排空，继续写入数据
      writer.once(&apos;drain&apos;, write);
    }
  }
}</code></pre>
<h4>writable.cork()<span><a href="all.html#all_writable_cork" id="all_writable_cork">#</a></span></h4>
<p>Forces buffering of all writes.

</p>
<p>强行滞留所有写入。

</p>
<p>Buffered data will be flushed either at <code>.uncork()</code> or at <code>.end()</code> call.

</p>
<p>滞留的数据会在 <code>.uncork()</code> 或 <code>.end()</code> 调用时被写入。

</p>
<h4>writable.uncork()<span><a href="all.html#all_writable_uncork" id="all_writable_uncork">#</a></span></h4>
<p>Flush all data, buffered since <code>.cork()</code> call.

</p>
<p>写入所有 <code>.cork()</code> 调用之后滞留的数据。

</p>
<h4>writable.end([chunk], [encoding], [callback])<span><a href="all.html#all_writable_end_chunk_encoding_callback" id="all_writable_end_chunk_encoding_callback">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>String | Buffer</span> Optional data to write</li>
<li><code>encoding</code> <span>String</span> The encoding, if <code>chunk</code> is a String</li>
<li><p><code>callback</code> <span>Function</span> Optional callback for when the stream is finished</p>
</li>
<li><p><code>chunk</code> <span>String | Buffer</span> 可选，要写入的数据</p>
</li>
<li><code>encoding</code> <span>String</span> 编码，假如 chunk 是一个字符串</li>
<li><code>callback</code> <span>Function</span> 可选，流结束后的回调</li>
</div></ul>
<p>Call this method when no more data will be written to the stream.  If
supplied, the callback is attached as a listener on the <code>finish</code> event.

</p>
<p>当没有更多数据会被写入到流时调用此方法。如果给出，回调会被用作 <code>finish</code> 事件的监听器。

</p>
<p>Calling <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> after calling <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> will raise an error.

</p>
<p>在调用 <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 后调用 <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> 会产生错误。

</p>
<pre><code>// 写入 &apos;hello, &apos; 然后以 &apos;world!&apos; 结束
http.createServer(function (req, res) {
  res.write(&apos;hello, &apos;);
  res.end(&apos;world!&apos;);
  // 现在不允许继续写入了
});</code></pre>
<h4>事件: &apos;finish&apos;<span><a href="all.html#all_finish" id="all_finish">#</a></span></h4>
<p>When the <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> method has been called, and all data has been flushed
to the underlying system, this event is emitted.

</p>
<p>当 <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 方法被调用，并且所有数据已被写入到底层系统，此事件会被触发。

</p>
<pre><code>var writer = getWritableStreamSomehow();
for (var i = 0; i &lt; 100; i ++) {
  writer.write(&apos;hello, #&apos; + i + &apos;!\n&apos;);
}
writer.end(&apos;this is the end\n&apos;);
write.on(&apos;finish&apos;, function() {
  console.error(&apos;已完成所有写入。&apos;);
});</code></pre>
<h4>事件: &apos;pipe&apos;<span><a href="all.html#all_pipe" id="all_pipe">#</a></span></h4>
<div><ul>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> source stream that is piping to this writable</p>
</li>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> 导流到本可写流的来源流</p>
</li>
</div></ul>
<p>This is emitted whenever the <code>pipe()</code> method is called on a readable
stream, adding this writable to its set of destinations.

</p>
<p>该事件发生于可读流的 <code>pipe()</code> 方法被调用并添加本可写流作为它的目标时。

</p>
<pre><code>var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&apos;pipe&apos;, function(src) {
  console.error(&apos;某些东西正被导流到 writer&apos;);
  assert.equal(src, reader);
});
reader.pipe(writer);</code></pre>
<h4>事件: &apos;unpipe&apos;<span><a href="all.html#all_unpipe" id="all_unpipe">#</a></span></h4>
<div><ul>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> The source stream that <a href="all.html#stream_readable_unpipe_destination">unpiped</a> this writable</p>
</li>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> <a href="all.html#stream_readable_unpipe_destination">unpiped</a> 本可写流的来源流</p>
</li>
</div></ul>
<p>This is emitted whenever the <a href="all.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> method is called on a
readable stream, removing this writable from its set of destinations.

</p>
<p>该事件发生于可读流的 <code>unpipe()</code> 方法被调用并将本可写流从它的目标移除时。

</p>
<pre><code>var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&apos;unpipe&apos;, function(src) {
  console.error(&apos;某写东西停止导流到 writer 了&apos;);
  assert.equal(src, reader);
});
reader.pipe(writer);
reader.unpipe(writer);</code></pre>
<h3>类: stream.Duplex<span><a href="all.html#all_stream_duplex" id="all_stream_duplex">#</a></span></h3>
<p>Duplex streams are streams that implement both the <a href="all.html#stream_class_stream_readable">Readable</a> and
<a href="all.html#stream_class_stream_writable">Writable</a> interfaces.  See above for usage.

</p>
<p>双工（Duplex）流同时实现了 <a href="all.html#stream_class_stream_readable">Readable</a> 和 <a href="all.html#stream_class_stream_writable">Writable</a> 的接口。详见下文用例。

</p>
<p>Examples of Duplex streams include:

</p>
<p>一些双工流的例子：

</p>
<ul>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><p><a href="crypto.html">crypto streams</a></p>
</li>
<li><p><a href="net.html#net_class_net_socket">TCP 嵌套字</a></p>
</li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h3>类: stream.Transform<span><a href="all.html#all_stream_transform" id="all_stream_transform">#</a></span></h3>
<p>Transform streams are <a href="all.html#stream_class_stream_duplex">Duplex</a> streams where the output is in some way
computed from the input.  They implement both the <a href="all.html#stream_class_stream_readable">Readable</a> and
<a href="all.html#stream_class_stream_writable">Writable</a> interfaces.  See above for usage.

</p>
<p>转换（Transform）流是一种输出由输入计算所得的<a href="all.html#stream_class_stream_duplex">双工</a>流。它们同时实现了 <a href="all.html#stream_class_stream_readable">Readable</a> 和 <a href="all.html#stream_class_stream_writable">Writable</a> 的接口。详见下文用例。

</p>
<p>Examples of Transform streams include:

</p>
<p>一些转换流的例子：

</p>
<ul>
<li><a href="zlib.html">zlib streams</a></li>
<li><p><a href="crypto.html">crypto streams</a></p>
</li>
<li><p><a href="zlib.html">zlib 流</a></p>
</li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h2>面向流实现者的 API<span><a href="all.html#all_api_1" id="all_api_1">#</a></span></h2>
<!--type=misc-->

<p>To implement any sort of stream, the pattern is the same:

</p>
<p>无论实现任何形式的流，模式都是一样的：

</p>
<ol>
<li>Extend the appropriate parent class in your own subclass.  (The
<a href="util.html#util_util_inherits_constructor_superconstructor"><code>util.inherits</code></a> method is particularly helpful for this.)</li>
<li>Call the appropriate parent class constructor in your constructor,
to be sure that the internal mechanisms are set up properly.</li>
<li><p>Implement one or more specific methods, as detailed below.</p>
</li>
<li><p>在您的子类中扩充适合的父类。（<a href="util.html#util_util_inherits_constructor_superconstructor"><code>util.inherits</code></a> 方法对此很有帮助。）</p>
</li>
<li>在您的构造函数中调用父类的构造函数，以确保内部的机制被正确初始化。</li>
<li>实现一个或多个特定的方法，参见下面的细节。</li>
</ol>
<p>The class to extend and the method(s) to implement depend on the sort
of stream class you are writing:

</p>
<p>所扩充的类和要实现的方法取决于您要编写的流类的形式：

</p>
<table>
  <thead>
    <tr>
      <th>
        <p>Use-case</p>
      </th>
      <th>
        <p>Class</p>
      </th>
      <th>
        <p>Method(s) to implement</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>Reading only</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_readable_1">Readable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Writing only</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_writable_1">Writable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Reading and writing</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_duplex_1">Duplex</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code>, <code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Operate on written data, then read the result</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_transform_1">Transform</a></p>
    </td>
    <td>
      <p><code>_transform</code>, <code>_flush</code></p>
    </td>
  </tr>
</table>

<table>
  <thead>
    <tr>
      <th>
        <p>使用情景</p>
      </th>
      <th>
        <p>类</p>
      </th>
      <th>
        <p>要实现的方法</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>只读</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_readable_1">Readable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>只写</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_writable_1">Writable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>读写</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_duplex_1">Duplex</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code>, <code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>操作被写入数据，然后读出结果</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_transform_1">Transform</a></p>
    </td>
    <td>
      <p><code>_transform</code>, <code>_flush</code></p>
    </td>
  </tr>
</table>

<p>In your implementation code, it is very important to never call the
methods described in <a href="all.html#stream_api_for_stream_consumers">API for Stream Consumers</a> above.  Otherwise, you
can potentially cause adverse side effects in programs that consume
your streaming interfaces.

</p>
<p>在您的实现代码中，十分重要的一点是绝对不要调用上文<a href="all.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 中所描述的方法，否则可能在消费您的流接口的程序中产生潜在的副作用。

</p>
<h3>类: stream.Readable<span><a href="all.html#all_stream_readable_1" id="all_stream_readable_1">#</a></span></h3>
<!--type=class-->

<p><code>stream.Readable</code> is an abstract class designed to be extended with an
underlying implementation of the <a href="all.html#stream_readable_read_size_1"><code>_read(size)</code></a> method.

</p>
<p><code>stream.Readable</code> 是一个可被扩充的、实现了底层方法 <a href="all.html#stream_readable_read_size_1"><code>_read(size)</code></a> 的抽象类。

</p>
<p>Please see above under <a href="all.html#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
streams in your programs.  What follows is an explanation of how to
implement Readable streams in your programs.

</p>
<p>请阅读前文<a href="all.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 章节了解如何在您的程序中消费流。文将解释如何在您的程序中自己实现 Readable 流。

</p>
<h4>例子: 一个计数流<span><a href="all.html#all_18" id="all_18">#</a></span></h4>
<!--type=example-->

<p>This is a basic example of a Readable stream.  It emits the numerals
from 1 to 1,000,000 in ascending order, and then ends.

</p>
<p>这是一个 Readable 流的基本例子。它将从 1 至 1,000,000 递增地触发数字，然后结束。

</p>
<pre><code>var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);
util.inherits(Counter, Readable);

function Counter(opt) {
  Readable.call(this, opt);
  this._max = 1000000;
  this._index = 1;
}

function Counter(opt) {
  Readable.call(this, opt);
  this._max = 1000000;
  this._index = 1;
}

Counter.prototype._read = function() {
  var i = this._index++;
  if (i &gt; this._max)
    this.push(null);
  else {
    var str = &apos;&apos; + i;
    var buf = new Buffer(str, &apos;ascii&apos;);
    this.push(buf);
  }
};</code></pre>
<h4>例子: SimpleProtocol v1 (Sub-optimal)<span><a href="all.html#all_simpleprotocol_v1_sub_optimal" id="all_simpleprotocol_v1_sub_optimal">#</a></span></h4>
<p>This is similar to the <code>parseHeader</code> function described above, but
implemented as a custom stream.  Also, note that this implementation
does not convert the incoming data to a string.

</p>
<p>这个有点类似上文提到的 <code>parseHeader</code> 函数，但它被实现成一个自定义流。同样地，请注意这个实现并未将传入数据转换成字符串。

</p>
<p>However, this would be better implemented as a <a href="all.html#stream_class_stream_transform">Transform</a> stream.  See
below for a better implementation.

</p>
<p>实际上，更好的办法是将它实现成一个 <a href="all.html#stream_class_stream_transform">Transform</a> 流。更好的实现详见下文。

</p>
<pre><code>// 简易数据协议的解析器。
// “header”是一个 JSON 对象，后面紧跟 2 个 \n 字符，以及
// 消息主体。
//
// 注意: 使用 Transform 流能更简单地实现这个功能！
// 直接使用 Readable 并不是最佳方式，详见 Transform
// 章节下的备选例子。

var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);

var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);

util.inherits(SimpleProtocol, Readable);

util.inherits(SimpleProtocol, Readable);

function SimpleProtocol(source, options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

function SimpleProtocol(source, options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

  Readable.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;

  Readable.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;

  // source is a readable stream, such as a socket or file
  this._source = source;

  // source 是一个可读流，比如嵌套字或文件
  this._source = source;

  var self = this;
  source.on(&apos;end&apos;, function() {
    self.push(null);
  });

  var self = this;
  source.on(&apos;end&apos;, function() {
    self.push(null);
  });

  // give it a kick whenever the source is readable
  // read(0) will not consume any bytes
  source.on(&apos;readable&apos;, function() {
    self.read(0);
  });

  // 当 source 可读时做点什么
  // read(0) 不会消费任何字节
  source.on(&apos;readable&apos;, function() {
    self.read(0);
  });

  this._rawHeader = [];
  this.header = null;
}

  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._read = function(n) {
  if (!this._inBody) {
    var chunk = this._source.read();

SimpleProtocol.prototype._read = function(n) {
  if (!this._inBody) {
    var chunk = this._source.read();

    if (split === -1) {
      // 继续等待 \n\n
      // 暂存数据块，并再次尝试
      this._rawHeader.push(chunk);
      this.push(&apos;&apos;);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
        return;
      }
      // 现在，我们得到了一些多余的数据，所以需要 unshift
      // 将多余的数据放回读取队列以便我们的消费者能够读取
      var b = chunk.slice(split);
      this.unshift(b);

      // and let them know that we are done parsing the header.
      this.emit(&apos;header&apos;, this.header);
    }
  } else {
    // from there on, just provide the data to our consumer.
    // careful not to push(null), since that would indicate EOF.
    var chunk = this._source.read();
    if (chunk) this.push(chunk);
  }
};

      // 并让它们知道我们完成了头部解析。
      this.emit(&apos;header&apos;, this.header);
    }
  } else {
    // 从现在开始，仅需向我们的消费者提供数据。
    // 注意不要 push(null)，因为它表明 EOF。
    var chunk = this._source.read();
    if (chunk) this.push(chunk);
  }
};

// 用法:
// var parser = new SimpleProtocol(source);
// 现在 parser 是一个会触发 &apos;header&apos; 事件并提供已解析
// 的头部的可读流。</code></pre>
<h4>new stream.Readable([options])<span><a href="all.html#all_new_stream_readable_options" id="all_new_stream_readable_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> The maximum number of bytes to store in
the internal buffer before ceasing to read from the underlying
resource.  Default=16kb, or 16 for <code>objectMode</code> streams</li>
<li><code>encoding</code> <span>String</span> If specified, then buffers will be decoded to
strings using the specified encoding.  Default=null</li>
<li><code>objectMode</code> <span>Boolean</span> Whether this stream should behave
as a stream of objects. Meaning that stream.read(n) returns
a single value instead of a Buffer of size n</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> 停止从底层资源读取前内部缓冲区最多能存放的字节数。缺省为 16kb，对于 objectMode 流则是 16</li>
<li><code>encoding</code> <span>String</span> 若给出，则 Buffer 会被解码成所给编码的字符串。缺省为 <code>null</code></li>
<li><code>objectMode</code> <span>Boolean</span> 该流是否应该表现为对象的流。意思是说 <code>stream.read(n)</code> 返回一个单独的对象，而不是大小为 n 的 Buffer</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Readable class, make sure to call the
Readable constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Readable 类的类中调用 Readable 构造函数以便缓冲设定能被正确初始化。

</p>
<h4>readable._read(size)<span><a href="all.html#all_readable_read_size_1" id="all_readable_read_size_1">#</a></span></h4>
<div><ul>
<li><p><code>size</code> <span>Number</span> Number of bytes to read asynchronously</p>
</li>
<li><p><code>size</code> <span>Number</span> 异步读取的字节数</p>
</li>
</div></ul>
<p>Note: <strong>Implement this function, but do NOT call it directly.</strong>

</p>
<p>注意：<strong>实现这个函数，但【不要】直接调用它。</strong>

</p>
<p>This function should NOT be called directly.  It should be implemented
by child classes, and only called by the internal Readable class
methods.

</p>
<p>这个函数【不应该】被直接调用。它应该被子类所实现，并仅被 Readable 类内部方法所调用。

</p>
<p>All Readable stream implementations must provide a <code>_read</code> method to
fetch data from the underlying resource.

</p>
<p>所有 Readable 流的实现都必须提供一个 <code>_read</code> 方法来从底层资源抓取数据。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<p>When data is available, put it into the read queue by calling
<code>readable.push(chunk)</code>.  If <code>push</code> returns false, then you should stop
reading.  When <code>_read</code> is called again, you should start pushing more
data.

</p>
<p>当数据可用时，调用 <code>readable.push(chunk)</code> 将它加入到读取队列。如果 <code>push</code> 返回 <code>false</code>，那么您应该停止读取。当 <code>_read</code> 被再次调用，您应该继续推出更多数据。

</p>
<p>The <code>size</code> argument is advisory.  Implementations where a &quot;read&quot; is a
single call that returns data can use this to know how much data to
fetch.  Implementations where that is not relevant, such as TCP or
TLS, may ignore this argument, and simply provide data whenever it
becomes available.  There is no need, for example to &quot;wait&quot; until
<code>size</code> bytes are available before calling <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.

</p>
<p>参数 <code>size</code> 仅作查询。“read”调用返回数据的实现可以通过这个参数来知道应当抓取多少数据；其余与之无关的实现，比如 TCP 或 TLS，则可忽略这个参数，并在可用时返回数据。例如，没有必要“等到” <code>size</code> 个字节可用时才调用 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>。

</p>
<h4>readable.push(chunk, [encoding])<span><a href="all.html#all_readable_push_chunk_encoding" id="all_readable_push_chunk_encoding">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | null | String</span> Chunk of data to push into the read queue</li>
<li><code>encoding</code> <span>String</span> Encoding of String chunks.  Must be a valid
Buffer encoding, such as <code>&apos;utf8&apos;</code> or <code>&apos;ascii&apos;</code></li>
<li><p>return <span>Boolean</span> Whether or not more pushes should be performed</p>
</li>
<li><p><code>chunk</code> <span>Buffer | null | String</span> 推入读取队列的数据块</p>
</li>
<li><code>encoding</code> <span>String</span> 字符串块的编码。必须是有效的 Buffer 编码，比如 <code>utf8</code> 或 <code>ascii</code></li>
<li>返回 <span>Boolean</span> 是否应该继续推入</li>
</div></ul>
<p>Note: <strong>This function should be called by Readable implementors, NOT
by consumers of Readable streams.</strong>

</p>
<p>注意：<strong>这个函数应该被 Readable 实现者调用，【而不是】Readable 流的消费者。</strong>

</p>
<p>The <code>_read()</code> function will not be called again until at least one
<code>push(chunk)</code> call is made.

</p>
<p>函数 <code>_read()</code> 不会被再次调用，直到至少调用了一次 <code>push(chunk)</code>。

</p>
<p>The <code>Readable</code> class works by putting data into a read queue to be
pulled out later by calling the <code>read()</code> method when the <code>&apos;readable&apos;</code>
event fires.

</p>
<p><code>Readable</code> 类的工作方式是，将数据读入一个队列，当 <code>&apos;readable&apos;</code> 事件发生、调用 <code>read()</code> 方法时，数据会被从队列中取出。

</p>
<p>The <code>push()</code> method will explicitly insert some data into the read
queue.  If it is called with <code>null</code> then it will signal the end of the
data (EOF).

</p>
<p><code>push()</code> 方法会明确地向读取队列中插入一些数据。如果调用它时传入了 <code>null</code> 参数，那么它会触发数据结束信号（EOF）。

</p>
<p>This API is designed to be as flexible as possible.  For example,
you may be wrapping a lower-level source which has some sort of
pause/resume mechanism, and a data callback.  In those cases, you
could wrap the low-level source object by doing something like this:

</p>
<p>这个 API 被设计成尽可能地灵活。比如说，您可以包装一个低级别的具备某种暂停/恢复机制和数据回调的数据源。这种情况下，您可以通过这种方式包装低级别来源对象：

</p>
<pre><code>// source 是一个带 readStop() 和 readStart() 方法的类，
// 以及一个当有数据时会被调用的 `ondata` 成员、一个
// 当数据结束时会被调用的 `onend` 成员。

util.inherits(SourceWrapper, Readable);

util.inherits(SourceWrapper, Readable);

function SourceWrapper(options) {
  Readable.call(this, options);

function SourceWrapper(options) {
  Readable.call(this, options);

  this._source = getLowlevelSourceObject();
  var self = this;

  this._source = getLowlevelSourceObject();
  var self = this;

  // Every time there&apos;s data, we push it into the internal buffer.
  this._source.ondata = function(chunk) {
    // if push() returns false, then we need to stop reading from source
    if (!self.push(chunk))
      self._source.readStop();
  };

  // 每当有数据时，我们将它推入到内部缓冲区中
  this._source.ondata = function(chunk) {
    // 如果 push() 返回 false，我们就需要暂停读取 source
    if (!self.push(chunk))
      self._source.readStop();
  };

  // When the source ends, we push the EOF-signalling `null` chunk
  this._source.onend = function() {
    self.push(null);
  };
}

  // 当来源结束时，我们 push 一个 `null` 块以表示 EOF
  this._source.onend = function() {
    self.push(null);
  };
}

// _read 会在流想要拉取更多数据时被调用
// 本例中忽略 size 参数
SourceWrapper.prototype._read = function(size) {
  this._source.readStart();
};</code></pre>
<h3>类: stream.Writable<span><a href="all.html#all_stream_writable_1" id="all_stream_writable_1">#</a></span></h3>
<!--type=class-->

<p><code>stream.Writable</code> is an abstract class designed to be extended with an
underlying implementation of the <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method.

</p>
<p><code>stream.Writable</code> 是一个可被扩充的、实现了底层方法 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 的抽象类。

</p>
<p>Please see above under <a href="all.html#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
writable streams in your programs.  What follows is an explanation of
how to implement Writable streams in your programs.

</p>
<p>请阅读前文<a href="all.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 章节了解如何在您的程序中消费可读流。下文将解释如何在您的程序中自己实现 Writable 流。

</p>
<h4>new stream.Writable([options])<span><a href="all.html#all_new_stream_writable_options" id="all_new_stream_writable_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> Buffer level when <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> starts
returning false. Default=16kb, or 16 for <code>objectMode</code> streams</li>
<li><code>decodeStrings</code> <span>Boolean</span> Whether or not to decode strings into
Buffers before passing them to <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>.  Default=true</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> 开始返回 <code>false</code> 的缓冲级别。缺省为 16kb，对于 <code>objectMode</code> 流则是 16</li>
<li><code>decodeStrings</code> <span>Boolean</span> 是否在传递给 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 前将字符串解码成 Buffer。缺省为 <code>true</code></li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Writable class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Writable 类的类中调用构造函数以便缓冲设定能被正确初始化。

</p>
<h4>writable._write(chunk, encoding, callback)<span><a href="all.html#all_writable_write_chunk_encoding_callback_1" id="all_writable_write_chunk_encoding_callback_1">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | String</span> The chunk to be written.  Will always
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <span>String</span> If the chunk is a string, then this is the
encoding type.  Ignore if chunk is a buffer.  Note that chunk will
<strong>always</strong> be a buffer unless the <code>decodeStrings</code> option is
explicitly set to <code>false</code>.</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要被写入的数据块。总会是一个 Buffer，除非 <code>decodeStrings</code> 选项被设定为 <code>false</code>。</p>
</li>
<li><code>encoding</code> <span>String</span> 如果数据块是字符串，则这里指定它的编码类型。如果数据块是 Buffer 则忽略此设定。请注意数据块<strong>总会是</strong>一个 Buffer，除非 <code>decodeStrings</code> 选项被明确设定为 <code>false</code>。</li>
<li><code>callback</code> <span>Function</span> 当您处理完所给数据块时调用此函数（可选地可附上一个错误参数）。</li>
</div></ul>
<p>All Writable stream implementations must provide a <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>
method to send data to the underlying resource.

</p>
<p>所有 Writable 流的实现必须提供一个 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 方法来将数据发送到底层资源。

</p>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Writable 内部方法所调用。

</p>
<p>Call the callback using the standard <code>callback(error)</code> pattern to
signal that the write completed successfully or with an error.

</p>
<p>使用标准的 <code>callback(error)</code> 形式来调用回调以表明写入成功完成或遇到错误。

</p>
<p>If the <code>decodeStrings</code> flag is set in the constructor options, then
<code>chunk</code> may be a string rather than a Buffer, and <code>encoding</code> will
indicate the sort of string that it is.  This is to support
implementations that have an optimized handling for certain string
data encodings.  If you do not explicitly set the <code>decodeStrings</code>
option to <code>false</code>, then you can safely ignore the <code>encoding</code> argument,
and assume that <code>chunk</code> will always be a Buffer.

</p>
<p>如果构造函数选项中设定了 <code>decodeStrings</code> 标志，则 <code>chunk</code> 可能会是字符串而不是 Buffer，并且 <code>encoding</code> 表明了字符串的格式。这种设计是为了支持对某些字符串数据编码提供优化处理的实现。如果您没有明确地将 <code>decodeStrings</code> 选项设定为 <code>false</code>，那么您可以安全地忽略 <code>encoding</code> 参数，并假定 <code>chunk</code> 总是一个 Buffer。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h3>writable._writev(chunks, callback)<span><a href="all.html#all_writable_writev_chunks_callback" id="all_writable_writev_chunks_callback">#</a></span></h3>
<div><ul>
<li><code>chunks</code> <span>Array</span> The chunks to be written.  Each chunk has following
format: <code>&lt;span class=&quot;type&quot;&gt; chunk: ..., encoding: ... &lt;/span&gt;</code>.</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunks.</p>
</li>
<li><p><code>chunks</code> <span>Array</span> 要写入的块。每个块都遵循这种格式：<code>{ chunk: ..., encoding: ... }</code>。</p>
</li>
<li><code>callback</code> <span>Function</span> 当您处理完所给数据块时调用此函数（可选地可附上一个错误参数）。</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It may be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Writable 内部方法所调用。

</p>
<p>This function is completely optional to implement. In most cases it is
unnecessary.  If implemented, it will be called with all the chunks
that are buffered in the write queue.

</p>
<p>该函数的实现完全是可选的，在大多数情况下都是不必要的。如果实现，它会被以所有滞留在写入队列中的数据块调用。

</p>
<h3>类: stream.Duplex<span><a href="all.html#all_stream_duplex_1" id="all_stream_duplex_1">#</a></span></h3>
<!--type=class-->

<p>A &quot;duplex&quot; stream is one that is both Readable and Writable, such as a
TCP socket connection.

</p>
<p>“双工”（duplex）流同时兼具可读和可写特性，比如一个 TCP 嵌套字连接。

</p>
<p>Note that <code>stream.Duplex</code> is an abstract class designed to be extended
with an underlying implementation of the <code>_read(size)</code> and
<a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> methods as you would with a
Readable or Writable stream class.

</p>
<p>值得注意的是，<code>stream.Duplex</code> 是一个可以像 Readable 或 Writable 一样被扩充、实现了底层方法 <code>_read(sise)</code> 和 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 的抽象类。

</p>
<p>Since JavaScript doesn&apos;t have multiple prototypal inheritance, this
class prototypally inherits from Readable, and then parasitically from
Writable.  It is thus up to the user to implement both the lowlevel
<code>_read(n)</code> method as well as the lowlevel
<a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method on extension duplex classes.

</p>
<p>由于 JavaScript 并不具备多原型继承能力，这个类实际上继承自 Readable，并寄生自 Writable，从而让用户在双工类的扩充中能同时实现低级别的 <code>_read(n)</code> 方法和 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 方法。

</p>
<h4>new stream.Duplex(options)<span><a href="all.html#all_new_stream_duplex_options" id="all_new_stream_duplex_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors. Also has the following fields:</p>
<ul>
<li><code>allowHalfOpen</code> <span>Boolean</span> Default=true.  If set to <code>false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors. Also has the following fields:</p>
<ul>
<li><code>allowHalfOpen</code> <span>Boolean</span> Default=true.  If set to <code>false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Duplex class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Duplex 类的类中调用构造函数以便缓冲设定能被正确初始化。

</p>
<h3>类: stream.Transform<span><a href="all.html#all_stream_transform_1" id="all_stream_transform_1">#</a></span></h3>
<p>A &quot;transform&quot; stream is a duplex stream where the output is causally
connected in some way to the input, such as a <a href="zlib.html">zlib</a> stream or a
<a href="crypto.html">crypto</a> stream.

</p>
<p>“转换”（transform）流实际上是一个输出与输入存在因果关系的双工流，比如 <a href="zlib.html">zlib</a> 流或 <a href="crypto.html">crypto</a> 流。

</p>
<p>There is no requirement that the output be the same size as the input,
the same number of chunks, or arrive at the same time.  For example, a
Hash stream will only ever have a single chunk of output which is
provided when the input is ended.  A zlib stream will produce output
that is either much smaller or much larger than its input.

</p>
<p>输入和输出并无要求相同大小、相同块数或同时到达。举个例子，一个 Hash 流只会在输入结束时产生一个数据块的输出；一个 zlib 流会产生比输入小得多或大得多的输出。

</p>
<p>Rather than implement the <a href="all.html#stream_readable_read_size_1"><code>_read()</code></a> and <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> methods, Transform
classes must implement the <code>_transform()</code> method, and may optionally
also implement the <code>_flush()</code> method.  (See below.)

</p>
<p>转换类必须实现 <code>_transform()</code> 方法，而不是 <a href="all.html#stream_readable_read_size_1"><code>_read()</code></a> 和 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 方法。可选的，也可以实现 <code>_flush()</code> 方法。（详见下文。）

</p>
<h4>new stream.Transform([options])<span><a href="all.html#all_new_stream_transform_options" id="all_new_stream_transform_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors.</p>
</li>
<li><p><code>options</code> <span>Object</span> 传递给 Writable 和 Readable 构造函数。</p>
</li>
</div></ul>
<p>In classes that extend the Transform class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Transform 类的类中调用了构造函数，以使得缓冲设定能被正确初始化。

</p>
<h4>transform._transform(chunk, encoding, callback)<span><a href="all.html#all_transform_transform_chunk_encoding_callback" id="all_transform_transform_chunk_encoding_callback">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | String</span> The chunk to be transformed.  Will always
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <span>String</span> If the chunk is a string, then this is the
encoding type.  (Ignore if <code>decodeStrings</code> chunk is a buffer.)</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要被转换的数据块。总是 Buffer，除非 <code>decodeStrings</code> 选项被设定为 <code>false</code>。</p>
</li>
<li><code>encoding</code> <span>String</span> 如果数据块是一个字符串，那么这就是它的编码类型。（数据块是 Buffer 则会忽略此参数。）</li>
<li><code>callback</code> <span>Function</span> 当您处理完所提供的数据块时调用此函数（可选地附上一个错误参数）。</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Transform
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Transform 内部方法所调用。

</p>
<p>All Transform stream implementations must provide a <code>_transform</code>
method to accept input and produce output.

</p>
<p>所有转换流的实现都必须提供一个 <code>_transform</code> 方法来接受输入并产生输出。

</p>
<p><code>_transform</code> should do whatever has to be done in this specific
Transform class, to handle the bytes being written, and pass them off
to the readable portion of the interface.  Do asynchronous I/O,
process things, and so on.

</p>
<p><code>_transform</code> 应当承担特定 Transform 类中所有处理被写入的字节、并将它们丢给接口的可写端的职责，进行异步 I/O，处理其它事情等等。

</p>
<p>Call <code>transform.push(outputChunk)</code> 0 or more times to generate output
from this input chunk, depending on how much data you want to output
as a result of this chunk.

</p>
<p>调用 <code>transform.push(outputChunk)</code> 0 或多次来从输入块生成输出，取决于您想从这个数据块输出多少数据。

</p>
<p>Call the callback function only when the current chunk is completely
consumed.  Note that there may or may not be output as a result of any
particular input chunk.

</p>
<p>仅当当前数据块被完全消费时调用回调函数。注意，任何特定的输入块都有可能或可能不会产生输出。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h4>transform._flush(callback)<span><a href="all.html#all_transform_flush_callback" id="all_transform_flush_callback">#</a></span></h4>
<div><ul>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done flushing any remaining data.</p>
</li>
<li><p><code>callback</code> <span>Function</span> 当您写入完毕剩下的数据后调用此函数（可选地可附上一个错误对象）。</p>
</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It MAY be implemented
by child classes, and if so, will be called by the internal Transform
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它【可以】被子类所实现，并且如果实现，仅被 Transform 内部方法所调用。

</p>
<p>In some cases, your transform operation may need to emit a bit more
data at the end of the stream.  For example, a <code>Zlib</code> compression
stream will store up some internal state so that it can optimally
compress the output.  At the end, however, it needs to do the best it
can with what is left, so that the data will be complete.

</p>
<p>在一些情景中，您的转换操作可能需要在流的末尾多发生一点点数据。例如，一个 <code>Zlib</code> 压缩流会储存一些内部状态以便更好地压缩输出，但在最后它需要尽可能好地处理剩下的东西以使数据完整。

</p>
<p>In those cases, you can implement a <code>_flush</code> method, which will be
called at the very end, after all the written data is consumed, but
before emitting <code>end</code> to signal the end of the readable side.  Just
like with <code>_transform</code>, call <code>transform.push(chunk)</code> zero or more
times, as appropriate, and call <code>callback</code> when the flush operation is
complete.

</p>
<p>在这种情况中，您可以实现一个 <code>_flush</code> 方法，它会在最后被调用，在所有写入数据被消费、但在触发 <code>end</code> 表示可读端到达末尾之前。和 <code>_transform</code> 一样，只需在写入操作完成时适当地调用 <code>transform.push(chunk)</code> 零或多次。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h4>例子: <code>SimpleProtocol</code> 解析器 v2<span><a href="all.html#all_simpleprotocol_v2" id="all_simpleprotocol_v2">#</a></span></h4>
<p>The example above of a simple protocol parser can be implemented
simply by using the higher level <a href="all.html#stream_class_stream_transform">Transform</a> stream class, similar to
the <code>parseHeader</code> and <code>SimpleProtocol v1</code> examples above.

</p>
<p>上文的简易协议解析器例子能够很简单地使用高级别 <a href="all.html#stream_class_stream_transform">Transform</a> 流类实现，类似于前文 <code>parseHeader</code> 和 <code>SimpleProtocal v1</code> 示例。

</p>
<p>In this example, rather than providing the input as an argument, it
would be piped into the parser, which is a more idiomatic Node stream
approach.

</p>
<p>在这个示例中，输入会被导流到解析器中，而不是作为参数提供。这种做法更符合 Node 流的惯例。

</p>
<pre><code>var util = require(&apos;util&apos;);
var Transform = require(&apos;stream&apos;).Transform;
util.inherits(SimpleProtocol, Transform);

function SimpleProtocol(options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

function SimpleProtocol(options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

  Transform.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;
  this._rawHeader = [];
  this.header = null;
}

  Transform.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;
  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._transform = function(chunk, encoding, done) {
  if (!this._inBody) {
    // check if the chunk has a \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &apos;\n&apos;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

SimpleProtocol.prototype._transform = function(chunk, encoding, done) {
  if (!this._inBody) {
    // 检查数据块是否有 \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &apos;\n&apos;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

    if (split === -1) {
      // 仍旧等待 \n\n
      // 暂存数据块并重试。
      this._rawHeader.push(chunk);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
        return;
      }
      // 并让它们知道我们完成了头部解析。
      this.emit(&apos;header&apos;, this.header);

      // now, because we got some extra data, emit this first.
      this.push(chunk.slice(split));
    }
  } else {
    // from there on, just provide the data to our consumer as-is.
    this.push(chunk);
  }
  done();
};

      // 现在，由于我们获得了一些额外的数据，先触发这个。
      this.push(chunk.slice(split));
    }
  } else {
    // 之后，仅需向我们的消费者原样提供数据。
    this.push(chunk);
  }
  done();
};

// 用法:
// var parser = new SimpleProtocol();
// source.pipe(parser)
// 现在 parser 是一个会触发 &apos;header&apos; 并带上解析后的
// 头部数据的可读流。</code></pre>
<h3>类: stream.PassThrough<span><a href="all.html#all_stream_passthrough" id="all_stream_passthrough">#</a></span></h3>
<p>This is a trivial implementation of a <a href="all.html#stream_class_stream_transform">Transform</a> stream that simply
passes the input bytes across to the output.  Its purpose is mainly
for examples and testing, but there are occasionally use cases where
it can come in handy as a building block for novel sorts of streams.

</p>
<p>这是 <a href="all.html#stream_class_stream_transform">Transform</a> 流的一个简单实现，将输入的字节简单地传递给输出。它的主要用途是演示和测试，但偶尔要构建某种特殊流的时候也能派上用场。

</p>
<h2>流：内部细节<span><a href="all.html#all_19" id="all_19">#</a></span></h2>
<!--type=misc-->

<h3>缓冲<span><a href="all.html#all_20" id="all_20">#</a></span></h3>
<!--type=misc-->

<p>Both Writable and Readable streams will buffer data on an internal
object called <code>_writableState.buffer</code> or <code>_readableState.buffer</code>,
respectively.

</p>
<p>无论 Writable 或 Readable 流都会在内部分别叫做 <code>_writableState.buffer</code> 和 <code>_readableState.buffer</code> 的对象中缓冲数据。

</p>
<p>The amount of data that will potentially be buffered depends on the
<code>highWaterMark</code> option which is passed into the constructor.

</p>
<p>被缓冲的数据量取决于传递给构造函数的 <code>highWaterMark</code>（最高水位线）选项。

</p>
<p>Buffering in Readable streams happens when the implementation calls
<a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.  If the consumer of the Stream does not call
<code>stream.read()</code>, then the data will sit in the internal queue until it
is consumed.

</p>
<p>Readable 流的滞留发生于当实现调用 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a> 的时候。如果流的消费者没有调用 <code>stream.read()</code>，那么数据将会一直待在内部队列，直到它被消费。

</p>
<p>Buffering in Writable streams happens when the user calls
<a href="all.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> repeatedly, even when <code>write()</code> returns <code>false</code>.

</p>
<p>Writable 流的滞留发生于当用户重复调用 <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> 即便此时 <code>write()</code> 返回 <code>false</code> 时。

</p>
<p>The purpose of streams, especially with the <code>pipe()</code> method, is to
limit the buffering of data to acceptable levels, so that sources and
destinations of varying speed will not overwhelm the available memory.

</p>
<p>流，尤其是 <code>pipe()</code> 方法的初衷，是将数据的滞留量限制到一个可接受的水平，以使得不同速度的来源和目标不会淹没可用内存。

</p>
<h3><code>stream.read(0)</code><span><a href="all.html#all_stream_read_0" id="all_stream_read_0">#</a></span></h3>
<p>There are some cases where you want to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data.  In that case, you can call <code>stream.read(0)</code>, which will always
return null.

</p>
<p>在某写情景中，您可能需要触发底层可读流机制的刷新，但不真正消费任何数据。在这中情况下，您可以调用 <code>stream.read(0)</code>，它总会返回 <code>null</code>。

</p>
<p>If the internal read buffer is below the <code>highWaterMark</code>, and the
stream is not currently reading, then calling <code>read(0)</code> will trigger
a low-level <code>_read</code> call.

</p>
<p>如果内部读取缓冲低于 <code>highWaterMark</code> 水位线，并且流当前不在读取状态，那么调用 <code>read(0)</code> 会触发一个低级 <code>_read</code> 调用。

</p>
<p>There is almost never a need to do this.  However, you will see some
cases in Node&apos;s internals where this is done, particularly in the
Readable stream class internals.

</p>
<p>虽然几乎没有必要这么做，但您可以在 Node 内部的某些地方看到它确实这么做了，尤其是在 Readable 流类的内部。

</p>
<h3><code>stream.push(&apos;&apos;)</code><span><a href="all.html#all_stream_push" id="all_stream_push">#</a></span></h3>
<p>Pushing a zero-byte string or Buffer (when not in <a href="all.html#stream_object_mode">Object mode</a>) has an
interesting side effect.  Because it <em>is</em> a call to
<a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push()</code></a>, it will end the <code>reading</code> process.  However, it
does <em>not</em> add any data to the readable buffer, so there&apos;s nothing for
a user to consume.

</p>
<p>推入一个零字节字符串或 Buffer（当不在 <a href="all.html#stream_object_mode">对象模式</a> 时）有一个有趣的副作用。因为<em>它是</em>一个对 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push()</code></a> 的调用，它会结束 <code>reading</code> 进程。然而，它<em>没有</em>添加任何数据到可读缓冲中，所以没有东西可以被用户消费。

</p>
<p>Very rarely, there are cases where you have no data to provide now,
but the consumer of your stream (or, perhaps, another bit of your own
code) will know when to check again, by calling <code>stream.read(0)</code>.  In
those cases, you <em>may</em> call <code>stream.push(&apos;&apos;)</code>.

</p>
<p>在极少数情况下，您当时没有数据提供，但您的流的消费者（或您的代码的其它部分）会通过调用 <code>stream.read(0)</code> 得知何时再次检查。在这中情况下，您<em>可以</em>调用 <code>stream.push(&apos;&apos;)</code>。

</p>
<p>So far, the only use case for this functionality is in the
<a href="tls.html#tls_class_cryptostream">tls.CryptoStream</a> class, which is deprecated in Node v0.12.  If you
find that you have to use <code>stream.push(&apos;&apos;)</code>, please consider another
approach, because it almost certainly indicates that something is
horribly wrong.

</p>
<p>到目前为止，这个功能唯一一个使用情景是在 <a href="tls.html#tls_class_cryptostream">tls.CryptoStream</a> 类中，但它将在 Node v0.12 中被废弃。如果您发现您不得不使用 <code>stream.push(&apos;&apos;)</code>，请考虑另一种方式，因为几乎可以明确表明这是某种可怕的错误。

</p>
<h3>与 Node 早期版本的兼容性<span><a href="all.html#all_node" id="all_node">#</a></span></h3>
<!--type=misc-->

<p>In versions of Node prior to v0.10, the Readable stream interface was
simpler, but also less powerful and less useful.

</p>
<p>在 v0.10 之前版本的 Node 中，Readable 流的接口较为简单，同时功能和实用性也较弱。

</p>
<ul>
<li>Rather than waiting for you to call the <code>read()</code> method, <code>&apos;data&apos;</code>
events would start emitting immediately.  If you needed to do some
I/O to decide how to handle data, then you had to store the chunks
in some kind of buffer so that they would not be lost.</li>
<li><p>The <a href="all.html#stream_readable_pause"><code>pause()</code></a> method was advisory, rather than guaranteed.  This
meant that you still had to be prepared to receive <code>&apos;data&apos;</code> events
even when the stream was in a paused state.</p>
</li>
<li><p><code>&apos;data&apos;</code> 事件会开始立即开始发生，而不会等待您调用 <code>read()</code> 方法。如果您需要进行某些 I/O 来决定如何处理数据，那么您只能将数据块储存到某种缓冲区中以防它们流失。</p>
</li>
<li><a href="all.html#stream_readable_pause"><code>pause()</code></a> 方法仅起提议作用，而不保证生效。这意味着，即便当流处于暂停状态时，您仍然需要准备接收 <code>&apos;data&apos;</code> 事件。</li>
</ul>
<p>In Node v0.10, the Readable class described below was added.  For
backwards compatibility with older Node programs, Readable streams
switch into &quot;flowing mode&quot; when a <code>&apos;data&apos;</code> event handler is added, or
when the <a href="all.html#stream_readable_resume"><code>resume()</code></a> method is called.  The effect is that, even if
you are not using the new <code>read()</code> method and <code>&apos;readable&apos;</code> event, you
no longer have to worry about losing <code>&apos;data&apos;</code> chunks.

</p>
<p>在 Node v0.10 中，下文所述的 Readable 类被加入进来。为了向后兼容考虑，Readable 流会在添加了 <code>&apos;data&apos;</code> 事件监听器、或 <a href="all.html#stream_readable_resume"><code>resume()</code></a> 方法被调用时切换至“流动模式”。其作用是，即便您不使用新的 <code>read()</code> 方法和 <code>&apos;readable&apos;</code> 事件，您也不必担心丢失 <code>&apos;data&apos;</code> 数据块。

</p>
<p>Most programs will continue to function normally.  However, this
introduces an edge case in the following conditions:

</p>
<p>大多数程序会维持正常功能，然而，这也会在下列条件下引入一种边界情况：

</p>
<ul>
<li>No <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a> handler is added.</li>
<li>The <a href="all.html#stream_readable_resume"><code>resume()</code></a> method is never called.</li>
<li><p>The stream is not piped to any writable destination.</p>
</li>
<li><p>没有添加 <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>处理器。</p>
</li>
<li><a href="all.html#stream_readable_resume"><code>resume()</code></a> 方法从未被调用。</li>
<li>流未被导流到任何可写目标。</li>
</ul>
<p>For example, consider the following code:

</p>
<p>举个例子，请留意下面代码：

</p>
<pre><code>// 警告！不能用！
net.createServer(function(socket) {

  // we add an &apos;end&apos; method, but never consume the data
  socket.on(&apos;end&apos;, function() {
    // It will never get here.
    socket.end(&apos;I got your message (but didnt read it)\n&apos;);
  });

  // 我们添加了一个 &apos;end&apos; 事件，但从未消费数据
  socket.on(&apos;end&apos;, function() {
    // 它永远不会到达这里
    socket.end(&apos;我收到了您的来信（但我没看它）\n&apos;);
  });

}).listen(1337);</code></pre>
<p>In versions of node prior to v0.10, the incoming message data would be
simply discarded.  However, in Node v0.10 and beyond, the socket will
remain paused forever.

</p>
<p>在 Node v0.10 之前的版本中，传入消息数据会被简单地丢弃。然而在 Node v0.10 及之后，socket 会一直保持暂停。

</p>
<p>The workaround in this situation is to call the <code>resume()</code> method to
start the flow of data:

</p>
<p>对于这种情形的妥协方式是调用 <code>resume()</code> 方法来开启数据流：

</p>
<pre><code>// 妥协
net.createServer(function(socket) {

  socket.on(&apos;end&apos;, function() {
    socket.end(&apos;I got your message (but didnt read it)\n&apos;);
  });

  socket.on(&apos;end&apos;, function() {
    socket.end(&apos;我收到了您的来信（但我没看它）\n&apos;);
  });

  // start the flow of data, discarding it.
  socket.resume();

  // 开启数据流，并丢弃它们。
  socket.resume();

}).listen(1337);</code></pre>
<p>In addition to new Readable streams switching into flowing mode,
pre-v0.10 style streams can be wrapped in a Readable class using the
<code>wrap()</code> method.

</p>
<p>额外的，对于切换到流动模式的新 Readable 流，v0.10 之前风格的流可以通过 <code>wrap()</code> 方法被包装成 Readable 类。

</p>
<h3>对象模式<span><a href="all.html#all_21" id="all_21">#</a></span></h3>
<!--type=misc-->

<p>Normally, Streams operate on Strings and Buffers exclusively.

</p>
<p>通常情况下，流只操作字符串和 Buffer。

</p>
<p>Streams that are in <strong>object mode</strong> can emit generic JavaScript values
other than Buffers and Strings.

</p>
<p>处于<strong>对象模式</strong>的流除了 Buffer 和字符串外还能读出普通的 JavaScript 值。

</p>
<p>A Readable stream in object mode will always return a single item from
a call to <code>stream.read(size)</code>, regardless of what the size argument
is.

</p>
<p>一个处于对象模式的 Readable 流调用 <code>stream.read(size)</code> 时总会返回单个项目，无论传入什么 size 参数。

</p>
<p>A Writable stream in object mode will always ignore the <code>encoding</code>
argument to <code>stream.write(data, encoding)</code>.

</p>
<p>一个处于对象模式的 Writable 流总是会忽略传给 <code>stream.write(data, encoding)</code> 的 <code>encoding</code> 参数。

</p>
<p>The special value <code>null</code> still retains its special value for object
mode streams.  That is, for object mode readable streams, <code>null</code> as a
return value from <code>stream.read()</code> indicates that there is no more
data, and <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(null)</code></a> will signal the end of stream data
(<code>EOF</code>).

</p>
<p>特殊值 <code>null</code> 在对象模式流中依旧保持它的特殊性。也就说，对于对象模式的可读流，<code>stream.read()</code> 返回 <code>null</code> 意味着没有更多数据，同时 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(null)</code></a> 会告知流数据到达末端（<code>EOF</code>）。

</p>
<p>No streams in Node core are object mode streams.  This pattern is only
used by userland streaming libraries.

</p>
<p>Node 核心不存在对象模式的流，这种设计只被某些用户态流式库所使用。

</p>
<p>You should set <code>objectMode</code> in your stream child class constructor on
the options object.  Setting <code>objectMode</code> mid-stream is not safe.

</p>
<p>您应该在您的流子类构造函数的选项对象中设置 <code>objectMode</code>。在流的过程中设置 <code>objectMode</code> 是不安全的。

</p>
<h3>状态对象<span><a href="all.html#all_22" id="all_22">#</a></span></h3>
<p><a href="all.html#stream_class_stream_readable">Readable</a> streams have a member object called <code>_readableState</code>.
<a href="all.html#stream_class_stream_writable">Writable</a> streams have a member object called <code>_writableState</code>.
<a href="all.html#stream_class_stream_duplex">Duplex</a> streams have both.

</p>
<p><a href="all.html#stream_class_stream_readable">Readable</a> 流有一个成员对象叫作 <code>_readableState</code>。
<a href="all.html#stream_class_stream_writable">Writable</a> 流有一个成员对象叫作 <code>_writableState</code>。
<a href="all.html#stream_class_stream_duplex">Duplex</a> 流二者兼备。

</p>
<p><strong>These objects should generally not be modified in child classes.</strong>
However, if you have a Duplex or Transform stream that should be in
<code>objectMode</code> on the readable side, and not in <code>objectMode</code> on the
writable side, then you may do this in the constructor by setting the
flag explicitly on the appropriate state object.

</p>
<p><strong>这些对象通常不应该被子类所更改。</strong>然而，如果您有一个 Duplex 或 Transform 流，它的可读端应该是 <code>objectMode</code>，但可写端却又不是 <code>objectMode</code>，那么您可以在构造函数里明确地设定合适的状态对象的标记来达到此目的。

</p>
<pre><code>var util = require(&apos;util&apos;);
var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;
var Transform = require(&apos;stream&apos;).Transform;
util.inherits(JSONParseStream, Transform);

// Gets \n-delimited JSON string data, and emits the parsed objects
function JSONParseStream(options) {
  if (!(this instanceof JSONParseStream))
    return new JSONParseStream(options);

// 获取以 \n 分隔的 JSON 字符串数据，并丢出解析后的对象
function JSONParseStream(options) {
  if (!(this instanceof JSONParseStream))
    return new JSONParseStream(options);

  Transform.call(this, options);
  this._writableState.objectMode = false;
  this._readableState.objectMode = true;
  this._buffer = &apos;&apos;;
  this._decoder = new StringDecoder(&apos;utf8&apos;);
}

  Transform.call(this, options);
  this._writableState.objectMode = false;
  this._readableState.objectMode = true;
  this._buffer = &apos;&apos;;
  this._decoder = new StringDecoder(&apos;utf8&apos;);
}

JSONParseStream.prototype._transform = function(chunk, encoding, cb) {
  this._buffer += this._decoder.write(chunk);
  // split on newlines
  var lines = this._buffer.split(/\r?\n/);
  // keep the last partial line buffered
  this._buffer = lines.pop();
  for (var l = 0; l &lt; lines.length; l++) {
    var line = lines[l];
    try {
      var obj = JSON.parse(line);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // push the parsed object out to the readable consumer
    this.push(obj);
  }
  cb();
};

JSONParseStream.prototype._transform = function(chunk, encoding, cb) {
  this._buffer += this._decoder.write(chunk);
  // 以新行分割
  var lines = this._buffer.split(/\r?\n/);
  // 保留最后一行被缓冲
  this._buffer = lines.pop();
  for (var l = 0; l &lt; lines.length; l++) {
    var line = lines[l];
    try {
      var obj = JSON.parse(line);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // 推出解析后的对象到可读消费者
    this.push(obj);
  }
  cb();
};

JSONParseStream.prototype._flush = function(cb) {
  // 仅仅处理剩下的东西
  var rem = this._buffer.trim();
  if (rem) {
    try {
      var obj = JSON.parse(rem);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // 推出解析后的对象到可读消费者
    this.push(obj);
  }
  cb();
};</code></pre>
<p>The state objects contain other useful information for debugging the
state of streams in your programs.  It is safe to look at them, but
beyond setting option flags in the constructor, it is <strong>not</strong> safe to
modify them.

</p>
<p>状态对象包含了其它调试您的程序的流的状态时有用的信息。读取它们是可以的，但越过构造函数的选项来更改它们是<strong>不安全的</strong>。

</p>
<h1>加密（Crypto）<span><a href="all.html#all_crypto" id="all_crypto">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定；正在讨论未来版本的API变动。会尽量减少重大变动的发生。详见下文。</code></pre>
<p>Use <code>require(&apos;crypto&apos;)</code> to access this module.

</p>
<p>使用 <code>require(&apos;crypto&apos;)</code> 来调用该模块。

</p>
<p>The crypto module offers a way of encapsulating secure credentials to be
used as part of a secure HTTPS net or http connection.

</p>
<p>crypto模块提供在HTTPS或HTTP连接中封装安全凭证的方法.

</p>
<p>It also offers a set of wrappers for OpenSSL&apos;s hash, hmac, cipher,
decipher, sign and verify methods.

</p>
<p>它提供OpenSSL中的一系列哈希方法，包括hmac、cipher、decipher、签名和验证等方法的封装。

</p>
<h2>crypto.getCiphers()<span><a href="all.html#all_crypto_getciphers" id="all_crypto_getciphers">#</a></span></h2>
<p>Returns an array with the names of the supported ciphers.

</p>
<p>返回一个数组，包含支持的加密算法的名字。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var ciphers = crypto.getCiphers();
console.log(ciphers); // [&apos;AES-128-CBC&apos;, &apos;AES-128-CBC-HMAC-SHA1&apos;, ...]</code></pre>
<h2>crypto.getHashes()<span><a href="all.html#all_crypto_gethashes" id="all_crypto_gethashes">#</a></span></h2>
<p>Returns an array with the names of the supported hash algorithms.

</p>
<p>返回一个包含所支持的哈希算法的数组。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var hashes = crypto.getHashes();
console.log(hashes); // [&apos;sha&apos;, &apos;sha1&apos;, &apos;sha1WithRSAEncryption&apos;, ...]</code></pre>
<h2>crypto.createCredentials(details)<span><a href="all.html#all_crypto_createcredentials_details" id="all_crypto_createcredentials_details">#</a></span></h2>
<p>Creates a credentials object, with the optional details being a
dictionary with keys:

</p>
<p>创建一个加密凭证对象，接受一个可选的参数对象：

</p>
<ul>
<li><code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private
key, certificate and CA certificates</li>
<li><code>key</code> : A string holding the PEM encoded private key</li>
<li><code>passphrase</code> : A string of passphrase for the private key or pfx</li>
<li><code>cert</code> : A string holding the PEM encoded certificate</li>
<li><code>ca</code> : Either a string or list of strings of PEM encoded CA
certificates to trust.</li>
<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs
(Certificate Revocation List)</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude.
Consult
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
for details on the format.</p>
</li>
<li><p><code>pfx</code> : 一个字符串或者buffer对象，代表经PFX或者PKCS12编码产生的私钥、证书以及CA证书</p>
</li>
<li><code>key</code> : 一个字符串，代表经PEM编码产生的私钥</li>
<li><code>passphrase</code> : 私钥或者pfx的密码</li>
<li><code>cert</code> : 一个字符串，代表经PEM编码产生的证书</li>
<li><code>ca</code> : 一个字符串或者字符串数组，表示可信任的经PEM编码产生的CA证书列表</li>
<li><code>crl</code> : 一个字符串或者字符串数组，表示经PEM编码产生的CRL（证书吊销列表 Certificate Revocation List）</li>
<li><code>ciphers</code>: 一个字符串，表示需要使用或者排除的加密算法
可以在
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
查看更多关于加密算法格式的资料。</li>
</ul>
<p>If no &apos;ca&apos; details are given, then node.js will use the default
publicly trusted list of CAs as given in
</p>
<p><a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.

</p>
<p>如果没有指定<code>ca</code>，node.js会使用<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>提供的公共可信任的CA列表。

</p>
<h2>crypto.createHash(algorithm)<span><a href="all.html#all_crypto_createhash_algorithm" id="all_crypto_createhash_algorithm">#</a></span></h2>
<p>Creates and returns a hash object, a cryptographic hash with the given
algorithm which can be used to generate hash digests.

</p>
<p>创建并返回一个哈希对象，一个使用所给算法的用于生成摘要的加密哈希。

</p>
<p><code>algorithm</code> is dependent on the available algorithms supported by the
version of OpenSSL on the platform. Examples are <code>&apos;sha1&apos;</code>, <code>&apos;md5&apos;</code>,
<code>&apos;sha256&apos;</code>, <code>&apos;sha512&apos;</code>, etc.  On recent releases, <code>openssl
list-message-digest-algorithms</code> will display the available digest
algorithms.

</p>
<p><code>algorithm</code> 取决与平台上所安装的 OpenSSL 版本所支持的算法。比如 <code>&apos;sha1&apos;</code>、<code>&apos;md5&apos;</code>、<code>&apos;sha256&apos;</code>、<code>&apos;sha512&apos;</code> 等等。在最近的发行版本中，<code>openssl list-message-digest-algorithms</code> 会显示可用的摘要算法。

</p>
<p>Example: this program that takes the sha1 sum of a file

</p>
<p>例子：这段程序会计算出一个文件的 sha1 摘要值。

</p>
<pre><code>s.on(&apos;end&apos;, function() {
  var d = shasum.digest(&apos;hex&apos;);
  console.log(d + &apos;  &apos; + filename);
});</code></pre>
<h2>类: Hash<span><a href="all.html#all_hash" id="all_hash">#</a></span></h2>
<p>The class for creating hash digests of data.

</p>
<p>创建数据哈希摘要的类。

</p>
<p>It is a <a href="stream.html">stream</a> that is both readable and writable.  The
written data is used to compute the hash.  Once the writable side of
the stream is ended, use the <code>read()</code> method to get the computed hash
digest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.

</p>
<p>它是一个既可读又可写的<a href="stream.html">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。

</p>
<p>Returned by <code>crypto.createHash</code>.

</p>
<p>通过 <code>crypto.createHash</code> 返回。

</p>
<h3>hash.update(data, [input_encoding])<span><a href="all.html#all_hash_update_data_input_encoding" id="all_hash_update_data_input_encoding">#</a></span></h3>
<p>Updates the hash content with the given <code>data</code>, the encoding of which
is given in <code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or
<code>&apos;binary&apos;</code>.  If no encoding is provided, then a buffer is expected.

</p>
<p>通过提供的数据更新哈希对象，可以通过<code>input_encoding</code>指定编码为<code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>或者
<code>&apos;binary&apos;</code>。如果没有指定编码，将作为二进制数据（buffer）处理。

</p>
<p>This can be called many times with new data as it is streamed.

</p>
<p>因为它是流式数据，所以可以使用不同的数据调用很多次。

</p>
<h3>hash.digest([encoding])<span><a href="all.html#all_hash_digest_encoding" id="all_hash_digest_encoding">#</a></span></h3>
<p>Calculates the digest of all of the passed data to be hashed.  The
<code>encoding</code> can be <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> or <code>&apos;base64&apos;</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>计算传入的所有数据的摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。

</p>
<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method has been
called.

</p>
<p>注意：<code>hash</code> 对象在 <code>digest()</code> 方法被调用后将不可用。

</p>
<h2>crypto.createHmac(algorithm, key)<span><a href="all.html#all_crypto_createhmac_algorithm_key" id="all_crypto_createhmac_algorithm_key">#</a></span></h2>
<p>Creates and returns a hmac object, a cryptographic hmac with the given
algorithm and key.

</p>
<p>创建并返回一个hmac对象，也就是通过给定的加密算法和密钥生成的加密图谱（cryptographic）。

</p>
<p>It is a <a href="stream.html">stream</a> that is both readable and writable.  The
written data is used to compute the hmac.  Once the writable side of
the stream is ended, use the <code>read()</code> method to get the computed
digest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.

</p>
<p>它是一个既可读又可写的流（<a href="stream.html">stream</a>）。写入的数据会被用于计算hmac。写入终止后，可以使用<code>read()</code>方法获取计算后的摘要值。之前版本的<code>update</code>和<code>digest</code>方法仍然支持。

</p>
<p><code>algorithm</code> is dependent on the available algorithms supported by
OpenSSL - see createHash above.  <code>key</code> is the hmac key to be used.

</p>
<p><code>algorithm</code>在OpenSSL支持的算法列表中被抛弃了——见上方createHash部分。<code>key</code>是hmac算法用到的密钥。

</p>
<h2>Class: Hmac<span><a href="all.html#all_class_hmac" id="all_class_hmac">#</a></span></h2>
<p>Class for creating cryptographic hmac content.

</p>
<p>用于创建hmac加密图谱（cryptographic）的类。

</p>
<p>Returned by <code>crypto.createHmac</code>.

</p>
<p>由<code>crypto.createHmac</code>返回。

</p>
<h3>hmac.update(data)<span><a href="all.html#all_hmac_update_data" id="all_hmac_update_data">#</a></span></h3>
<p>Update the hmac content with the given <code>data</code>.  This can be called
many times with new data as it is streamed.

</p>
<p>通过提供的数据更新hmac对象。因为它是流式数据，所以可以使用新数据调用很多次。

</p>
<h3>hmac.digest([encoding])<span><a href="all.html#all_hmac_digest_encoding" id="all_hmac_digest_encoding">#</a></span></h3>
<p>Calculates the digest of all of the passed data to the hmac.  The
<code>encoding</code> can be <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> or <code>&apos;base64&apos;</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>计算传入的所有数据的hmac摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。

</p>
<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method has been
called.

</p>
<p>注意： <code>hmac</code>对象在调用<code>digest()</code>之后就不再可用了。

</p>
<h2>crypto.createCipher(algorithm, password)<span><a href="all.html#all_crypto_createcipher_algorithm_password" id="all_crypto_createcipher_algorithm_password">#</a></span></h2>
<p>Creates and returns a cipher object, with the given algorithm and
password.

</p>
<p>用给定的算法和密码，创建并返回一个cipher加密算法的对象。（译者：cipher 就是加密算法的意思， ssl 的 cipher 主要是对称加密算法和不对称加密算法的组合。）

</p>
<p><code>algorithm</code> is dependent on OpenSSL, examples are <code>&apos;aes192&apos;</code>, etc.  On
recent releases, <code>openssl list-cipher-algorithms</code> will display the
available cipher algorithms.  <code>password</code> is used to derive key and IV,
which must be a <code>&apos;binary&apos;</code> encoded string or a <a href="buffer.html">buffer</a>.

</p>
<p><code>algorithm</code>算法是依赖OpenSSL库的, 例如: <code>&apos;aes192&apos;</code>算法等。在最近发布的版本， 执行命令 <code>openssl list-cipher-algorithms</code> 就会显示出所有可用的加密算法，<code>password</code>是用来派生key和IV的，它必须是一个 <code>&apos;binary&apos;</code> 2进制格式的字符串或者是一个<a href="buffer.html">buffer</a>。（译者：key表示密钥，IV表示向量在加密过程和解密过程都要使用）

</p>
<p>It is a <a href="stream.html">stream</a> that is both readable and writable.  The
written data is used to compute the hash.  Once the writable side of
the stream is ended, use the <code>read()</code> method to get the computed hash
digest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.

</p>
<p>它是一个既可读又可写的<a href="stream.html">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。

</p>
<h2>crypto.createCipheriv(algorithm, key, iv)<span><a href="all.html#all_crypto_createcipheriv_algorithm_key_iv" id="all_crypto_createcipheriv_algorithm_key_iv">#</a></span></h2>
<p>Creates and returns a cipher object, with the given algorithm, key and
iv.

</p>
<p>用给定的算法、密码和向量，创建并返回一个cipher加密算法的对象。

</p>
<p><code>algorithm</code> is the same as the argument to <code>createCipher()</code>.  <code>key</code> is
the raw key used by the algorithm.  <code>iv</code> is an <a href="http://en.wikipedia.org/wiki/Initialization_vector">initialization
vector</a>.

</p>
<p><code>algorithm</code>算法和<code>createCipher()</code> 方法的参数相同.  <code>key</code>密钥是一个被算法使用的原始密钥，<code>iv</code>是一个<a href="http://en.wikipedia.org/wiki/Initialization_vector">初始化向量</a>。

</p>
<p><code>key</code> and <code>iv</code> must be <code>&apos;binary&apos;</code> encoded strings or
<a href="buffer.html">buffers</a>.

</p>
<p><code>key</code>密钥和<code>iv</code>向量必须是<code>&apos;binary&apos;</code>2进制格式的字符串或<a href="buffer.html">buffers</a>.

</p>
<h2>Class: Cipher<span><a href="all.html#all_class_cipher" id="all_class_cipher">#</a></span></h2>
<p>Class for encrypting data.

</p>
<p>这个类是用来加密数据的。

</p>
<p>Returned by <code>crypto.createCipher</code> and <code>crypto.createCipheriv</code>.

</p>
<p>这个类由 <code>crypto.createCipher</code> 和 <code>crypto.createCipheriv</code> 返回。

</p>
<p>Cipher objects are <a href="stream.html">streams</a> that are both readable and
writable.  The written plain text data is used to produce the
encrypted data on the readable side.  The legacy <code>update</code> and <code>final</code>
methods are also supported.

</p>
<p>Cipher加密对象是 <a href="stream.html">streams</a>，他是具有 readable 可读和 writable 可写的。写入的纯文本数据是用来在可读流一侧加密数据的。
以前版本的<code>update</code> 和<code>final</code>方法也还是支持的。

</p>
<h3>cipher.update(data, [input_encoding], [output_encoding])<span><a href="all.html#all_cipher_update_data_input_encoding_output_encoding" id="all_cipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Updates the cipher with <code>data</code>, the encoding of which is given in
<code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code>.  If no
encoding is provided, then a buffer is expected.

</p>
<p>用<code>data</code>参数更新cipher加密对象, 它的编码<code>input_encoding</code>必须是下列给定编码的 <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code> 中一种。如果没有编码参数，那么打他参数必须是一个buffer。

</p>
<p>The <code>output_encoding</code> specifies the output format of the enciphered
data, and can be <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>参数 <code>output_encoding</code>输出编码指定了加密数据的输出格式，可以是<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或者<code>&apos;hex&apos;</code>，如果没有提供这个参数，buffer将会返回。

</p>
<p>Returns the enciphered contents, and can be called many times with new
data as it is streamed.

</p>
<p>返回加密内容，并且Returns the enciphered contents, 用新数据作为流的话，它可以被调用多次。

</p>
<h3>cipher.final([output_encoding])<span><a href="all.html#all_cipher_final_output_encoding" id="all_cipher_final_output_encoding">#</a></span></h3>
<p>Returns any remaining enciphered contents, with <code>output_encoding</code>
being one of: <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>中的任意一个。 如果没有提供编码格式，则返回一个buffer对象。

</p>
<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method has been
called.

</p>
<p>注: 调用<code>final()</code>函数后<code>cipher</code> 对象不能被使用。

</p>
<h3>cipher.setAutoPadding(auto_padding=true)<span><a href="all.html#all_cipher_setautopadding_auto_padding_true" id="all_cipher_setautopadding_auto_padding_true">#</a></span></h3>
<p>You can disable automatic padding of the input data to block size. If
<code>auto_padding</code> is false, the length of the entire input data must be a
multiple of the cipher&apos;s block size or <code>final</code> will fail.  Useful for
non-standard padding, e.g. using <code>0x0</code> instead of PKCS padding. You
must call this before <code>cipher.final</code>.

</p>
<p>对于将输入数据自动填充到块大小的功能，你可以将其禁用。如果<code>auto_padding</code>是false， 那么整个输入数据的长度必须是加密器的块大小的整倍数，否则<code>final</code>会失败。这对非标准的填充很有用，例如使用<code>0x0</code>而不是PKCS的填充。这个函数必须在<code>cipher.final</code>之前调用。

</p>
<h2>crypto.createDecipher(algorithm, password)<span><a href="all.html#all_crypto_createdecipher_algorithm_password" id="all_crypto_createdecipher_algorithm_password">#</a></span></h2>
<p>Creates and returns a decipher object, with the given algorithm and
key.  This is the mirror of the <a href="all.html#crypto_crypto_createcipher_algorithm_password">createCipher()</a> above.

</p>
<p>根据给定的算法和密钥，创建并返回一个解密器对象。这是上述<a href="all.html#crypto_crypto_createcipher_algorithm_password">createCipher()</a>的一个镜像。

</p>
<h2>crypto.createDecipheriv(algorithm, key, iv)<span><a href="all.html#all_crypto_createdecipheriv_algorithm_key_iv" id="all_crypto_createdecipheriv_algorithm_key_iv">#</a></span></h2>
<p>Creates and returns a decipher object, with the given algorithm, key
and iv.  This is the mirror of the <a href="all.html#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a> above.

</p>
<p>Creates and returns a decipher object, with the given algorithm, key
and iv.  This is the mirror of the <a href="all.html#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a> above.
根据给定的算法，密钥和初始化向量，创建并返回一个解密器对象。这是上述<a href="all.html#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a>的一个镜像。


</p>
<h2>Class: Decipher<span><a href="all.html#all_class_decipher" id="all_class_decipher">#</a></span></h2>
<p>Class for decrypting data.

</p>
<p>解密数据的类。

</p>
<p>Returned by <code>crypto.createDecipher</code> and <code>crypto.createDecipheriv</code>.

</p>
<p>由<code>crypto.createDecipher</code>和<code>crypto.createDecipheriv</code>返回。

</p>
<p>Decipher objects are <a href="stream.html">streams</a> that are both readable and
writable.  The written enciphered data is used to produce the
plain-text data on the the readable side.  The legacy <code>update</code> and
<code>final</code> methods are also supported.

</p>
<p>解密器对象是可读写的<a href="stream.html">流</a>对象。用被写入的加密数据生成可读的平文数据。解码器对象也支持The legacy <code>update</code>和
<code>final</code>函数。

</p>
<h3>decipher.update(data, [input_encoding], [output_encoding])<span><a href="all.html#all_decipher_update_data_input_encoding_output_encoding" id="all_decipher_update_data_input_encoding_output_encoding">#</a></span></h3>
<p>Updates the decipher with <code>data</code>, which is encoded in <code>&apos;binary&apos;</code>,
<code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is provided, then a buffer is
expected.

</p>
<p>用<code>data</code>来更新解密器，其中<code>data</code>以<code>&apos;binary&apos;</code>,
<code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>进行编码。如果没有指明编码方式，则默认<code>data</code>是一个buffer对象。

</p>
<p>The <code>output_decoding</code> specifies in what format to return the
deciphered plaintext: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>.  If no
encoding is provided, then a buffer is returned.

</p>
<p><code>output_decoding</code>指明了用以下哪种编码方式返回解密后的平文：<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>decipher.final([output_encoding])<span><a href="all.html#all_decipher_final_output_encoding" id="all_decipher_final_output_encoding">#</a></span></h3>
<p>Returns any remaining plaintext which is deciphered, with
<code>output_encoding</code> being one of: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>.  If
no encoding is provided, then a buffer is returned.

</p>
<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>中的任意一个。如果没有指明编码方式，则返回一个buffer对象。

</p>
<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method has been
called.

</p>
<p>注: 调用<code>final()</code>函数后不能使用<code>decipher</code> 对象。

</p>
<h3>decipher.setAutoPadding(auto_padding=true)<span><a href="all.html#all_decipher_setautopadding_auto_padding_true" id="all_decipher_setautopadding_auto_padding_true">#</a></span></h3>
<p>You can disable auto padding if the data has been encrypted without
standard block padding to prevent <code>decipher.final</code> from checking and
removing it. Can only work if the input data&apos;s length is a multiple of
the ciphers block size. You must call this before streaming data to
<code>decipher.update</code>.

</p>
<p>如果数据以非标准的块填充方式被加密，那么你可以禁用自动填充来防止<code>decipher.final</code>对数据进行检查和移除。这只有在输入数据的长度是加密器块大小的整倍数时才有效。这个函数必须在将数据流传递给<code>decipher.update</code>之前调用。

</p>
<h2>crypto.createSign(algorithm)<span><a href="all.html#all_crypto_createsign_algorithm" id="all_crypto_createsign_algorithm">#</a></span></h2>
<p>Creates and returns a signing object, with the given algorithm.  On
recent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will
display the available signing algorithms. Examples are <code>&apos;RSA-SHA256&apos;</code>.

</p>
<p>根据给定的算法，创建并返回一个signing对象。在最近的OpenSSL发布版本中，<code>openssl list-public-key-algorithms</code>会列出可用的签名算法，例如<code>&apos;RSA-SHA256&apos;</code>。

</p>
<h2>Class: Sign<span><a href="all.html#all_class_sign" id="all_class_sign">#</a></span></h2>
<p>Class for generating signatures.

</p>
<p>生成数字签名的类

</p>
<p>Returned by <code>crypto.createSign</code>.

</p>
<p>由<code>crypto.createSign</code>返回。

</p>
<p>Sign objects are writable <a href="stream.html">streams</a>.  The written data is
used to generate the signature.  Once all of the data has been
written, the <code>sign</code> method will return the signature.  The legacy
<code>update</code> method is also supported.

</p>
<p>Sign对象是可写的<a href="stream.html">流</a>对象。被写入的数据用来生成数字签名。当所有的数据都被写入后，<code>sign</code> 函数会返回数字签名。Sign对象也支持The legacy
<code>update</code>函数。

</p>
<h3>sign.update(data)<span><a href="all.html#all_sign_update_data" id="all_sign_update_data">#</a></span></h3>
<p>Updates the sign object with data.  This can be called many times
with new data as it is streamed.

</p>
<p>用<code>data</code>来更新sign对象。 This can be called many times
with new data as it is streamed.

</p>
<h3>sign.sign(private_key, [output_format])<span><a href="all.html#all_sign_sign_private_key_output_format" id="all_sign_sign_private_key_output_format">#</a></span></h3>
<p>Calculates the signature on all the updated data passed through the
sign.  <code>private_key</code> is a string containing the PEM encoded private
key for signing.

</p>
<p>根据所有传送给sign的更新数据来计算电子签名。<code>private_key</code>是一个包含了签名私钥的字符串，而该私钥是用PEM编码的。

</p>
<p>Returns the signature in <code>output_format</code> which can be <code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is
returned.

</p>
<p>返回一个数字签名，该签名的格式可以是<code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>. 如果没有指明编码方式，则返回一个buffer对象。

</p>
<p>Note: <code>sign</code> object can not be used after <code>sign()</code> method has been
called.

</p>
<p>注：调用<code>sign()</code>后不能使用<code>sign</code>对象。

</p>
<h2>crypto.createVerify(algorithm)<span><a href="all.html#all_crypto_createverify_algorithm" id="all_crypto_createverify_algorithm">#</a></span></h2>
<p>Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.

</p>
<p>根据指明的算法，创建并返回一个验证器对象。这是上述签名器对象的镜像。

</p>
<h2>Class: Verify<span><a href="all.html#all_class_verify" id="all_class_verify">#</a></span></h2>
<p>Class for verifying signatures.

</p>
<p>用来验证数字签名的类。

</p>
<p>Returned by <code>crypto.createVerify</code>.

</p>
<p>由 <code>crypto.createVerify</code>返回。

</p>
<p>Verify objects are writable <a href="stream.html">streams</a>.  The written data
is used to validate against the supplied signature.  Once all of the
data has been written, the <code>verify</code> method will return true if the
supplied signature is valid.  The legacy <code>update</code> method is also
supported.

</p>
<p>验证器对象是可写的<a href="stream.html">流</a>对象.  被写入的数据会被用来验证提供的数字签名。在所有的数据被写入后，如果提供的数字签名有效，<code>verify</code>函数会返回真。验证器对象也支持 The legacy <code>update</code>函数。

</p>
<h3>verifier.update(data)<span><a href="all.html#all_verifier_update_data" id="all_verifier_update_data">#</a></span></h3>
<p>Updates the verifier object with data.  This can be called many times
with new data as it is streamed.

</p>
<p>用数据更新验证器对象。This can be called many times
with new data as it is streamed.

</p>
<h3>verifier.verify(object, signature, [signature_format])<span><a href="all.html#all_verifier_verify_object_signature_signature_format" id="all_verifier_verify_object_signature_signature_format">#</a></span></h3>
<p>Verifies the signed data by using the <code>object</code> and <code>signature</code>.
<code>object</code> is  a string containing a PEM encoded object, which can be
one of RSA public key, DSA public key, or X.509 certificate.
<code>signature</code> is the previously calculated signature for the data, in
the <code>signature_format</code> which can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>.
If no encoding is specified, then a buffer is expected.

</p>
<p>用<code>object</code>和<code>signature</code>来验证被签名的数据。
<code>object</code>是一个字符串，这个字符串包含了一个被PEM编码的对象，这个对象可以是RSA公钥，DSA公钥或者X.509 证书。
<code>signature</code>是之前计算出来的数字签名，其中的 <code>signature_format</code>可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>.
如果没有指明编码方式，那么默认是一个buffer对象。

</p>
<p>Returns true or false depending on the validity of the signature for
the data and public key.

</p>
<p>根据数字签名对于数据和公钥的有效性，返回true或false。

</p>
<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method has been
called.

</p>
<p>注: 调用<code>verify()</code>函数后不能使用<code>verifier</code>对象。

</p>
<h2>crypto.createDiffieHellman(prime_length)<span><a href="all.html#all_crypto_creatediffiehellman_prime_length" id="all_crypto_creatediffiehellman_prime_length">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object and generates a prime of
the given bit length. The generator used is <code>2</code>.

</p>
<p>创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象，并根据给定的位长度生成一个质数。所用的生成器是<code>s</code>。

</p>
<h2>crypto.createDiffieHellman(prime, [encoding])<span><a href="all.html#all_crypto_creatediffiehellman_prime_encoding" id="all_crypto_creatediffiehellman_prime_encoding">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object using the supplied prime.
The generator used is <code>2</code>. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or
<code>&apos;base64&apos;</code>.  If no encoding is specified, then a buffer is expected.

</p>
<p>根据给定的质数创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象。
所用的生成器是<code>2</code>。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或
<code>&apos;base64&apos;</code>。如果没有指明编码方式，则默认是一个buffer对象。

</p>
<h2>Class: DiffieHellman<span><a href="all.html#all_class_diffiehellman" id="all_class_diffiehellman">#</a></span></h2>
<p>The class for creating Diffie-Hellman key exchanges.

</p>
<p>创建迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)的类。

</p>
<p>Returned by <code>crypto.createDiffieHellman</code>.

</p>
<p>由<code>crypto.createDiffieHellman</code>返回。

</p>
<h3>diffieHellman.generateKeys([encoding])<span><a href="all.html#all_diffiehellman_generatekeys_encoding" id="all_diffiehellman_generatekeys_encoding">#</a></span></h3>
<p>Generates private and public Diffie-Hellman key values, and returns
the public key in the specified encoding. This key should be
transferred to the other party. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,
or <code>&apos;base64&apos;</code>.  If no encoding is provided, then a buffer is returned.

</p>
<p>生成迪菲－赫尔曼(Diffie-Hellman)算法的公钥和私钥，并根据指明的编码方式返回公钥。这个公钥可以转交给第三方。编码方式可以是 <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>.  如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])<span><a href="all.html#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding" id="all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding">#</a></span></h3>
<p>Computes the shared secret using <code>other_public_key</code> as the other
party&apos;s public key and returns the computed shared secret. Supplied
key is interpreted using specified <code>input_encoding</code>, and secret is
encoded using specified <code>output_encoding</code>. Encodings can be
<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If the input encoding is not
provided, then a buffer is expected.

</p>
<p>以<code>other_public_key</code>作为第三方公钥来计算共享秘密，并返回这个共享秘密。参数中的密钥会以<code>input_encoding</code>编码方式来解读，而共享密钥则会用<code>output_encoding</code>进行编码。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>。如果没有提供输入的编码方式，则默认为一个buffer对象。

</p>
<p>If no output encoding is given, then a buffer is returned.

</p>
<p>如果没有指明输出的编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getPrime([encoding])<span><a href="all.html#all_diffiehellman_getprime_encoding" id="all_diffiehellman_getprime_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getGenerator([encoding])<span><a href="all.html#all_diffiehellman_getgenerator_encoding" id="all_diffiehellman_getgenerator_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getPublicKey([encoding])<span><a href="all.html#all_diffiehellman_getpublickey_encoding" id="all_diffiehellman_getpublickey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman public key in the specified encoding, which
can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)公钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。 如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getPrivateKey([encoding])<span><a href="all.html#all_diffiehellman_getprivatekey_encoding" id="all_diffiehellman_getprivatekey_encoding">#</a></span></h3>
<p>Returns the Diffie-Hellman private key in the specified encoding,
which can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is
provided, then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)私钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.setPublicKey(public_key, [encoding])<span><a href="all.html#all_diffiehellman_setpublickey_public_key_encoding" id="all_diffiehellman_setpublickey_public_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman public key. Key encoding can be <code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<p>设置迪菲－赫尔曼(Diffie-Hellman)公钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.setPrivateKey(private_key, [encoding])<span><a href="all.html#all_diffiehellman_setprivatekey_private_key_encoding" id="all_diffiehellman_setprivatekey_private_key_encoding">#</a></span></h3>
<p>Sets the Diffie-Hellman private key. Key encoding can be <code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<p>设置迪菲－赫尔曼(Diffie-Hellman)私钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h2>crypto.getDiffieHellman(group_name)<span><a href="all.html#all_crypto_getdiffiehellman_group_name" id="all_crypto_getdiffiehellman_group_name">#</a></span></h2>
<p>Creates a predefined Diffie-Hellman key exchange object.  The
supported groups are: <code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code> (defined in <a href="http://www.rfc-editor.org/rfc/rfc2412.txt">RFC
2412</a>) and <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>,
<code>&apos;modp18&apos;</code> (defined in <a href="http://www.rfc-editor.org/rfc/rfc3526.txt">RFC 3526</a>).  The returned object mimics the
interface of objects created by <a href="all.html#crypto_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman()</a>
above, but will not allow to change the keys (with
<a href="all.html#crypto_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey()</a> for example).  The advantage of using
this routine is that the parties don&apos;t have to generate nor exchange
group modulus beforehand, saving both processor and communication
time.

</p>
<p>创建一个预定义的迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)对象。支持以下的D-H组：<code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code> (在<a href="http://www.rfc-editor.org/rfc/rfc2412.txt">RFC
2412</a>中定义) 和 <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>,
<code>&apos;modp18&apos;</code> (在 <a href="http://www.rfc-editor.org/rfc/rfc3526.txt">RFC 3526</a>中定义)。返回的对象模仿了上述 <a href="all.html#crypto_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman()</a>方法所创建的对象的接口，但不会晕允许密钥交换
(例如像
<a href="all.html#crypto_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey()</a>那样)。执行这套流程的好处是双方不需要事先生成或交换组余数，节省了处理和通信时间。

</p>
<p>Example (obtaining a shared secret):

</p>
<p>例子 (获取一个共享秘密):

</p>
<pre><code>/* alice_secret和 bob_secret应该是一样的 */
console.log(alice_secret == bob_secret);</code></pre>
<h2>crypto.pbkdf2(password, salt, iterations, keylen, callback)<span><a href="all.html#all_crypto_pbkdf2_password_salt_iterations_keylen_callback" id="all_crypto_pbkdf2_password_salt_iterations_keylen_callback">#</a></span></h2>
<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive
a key of given length from the given password, salt and iterations.
The callback gets two arguments <code>(err, derivedKey)</code>.

</p>
<p>异步PBKDF2提供了一个伪随机函数 HMAC-SHA1，根据给定密码的长度，salt和iterations来得出一个密钥。回调函数得到两个参数 <code>(err, derivedKey)</code>。

</p>
<h2>crypto.pbkdf2Sync(password, salt, iterations, keylen)<span><a href="all.html#all_crypto_pbkdf2sync_password_salt_iterations_keylen" id="all_crypto_pbkdf2sync_password_salt_iterations_keylen">#</a></span></h2>
<p>Synchronous PBKDF2 function.  Returns derivedKey or throws error.

</p>
<p>同步 PBKDF2 函数。返回derivedKey或抛出一个错误。

</p>
<h2>crypto.randomBytes(size, [callback])<span><a href="all.html#all_crypto_randombytes_size_callback" id="all_crypto_randombytes_size_callback">#</a></span></h2>
<p>Generates cryptographically strong pseudo-random data. Usage:

</p>
<p>生成密码学强度的伪随机数据。用法：

</p>
<pre><code>// 同步
try {
  var buf = crypto.randomBytes(256);
  console.log(&apos;有 %d 字节的随机数据： %s&apos;, buf.length, buf);
} catch (ex) {
  // handle error
}</code></pre>
<h2>crypto.pseudoRandomBytes(size, [callback])<span><a href="all.html#all_crypto_pseudorandombytes_size_callback" id="all_crypto_pseudorandombytes_size_callback">#</a></span></h2>
<p>Generates <em>non</em>-cryptographically strong pseudo-random data. The data
returned will be unique if it is sufficiently long, but is not
necessarily unpredictable. For this reason, the output of this
function should never be used where unpredictability is important,
such as in the generation of encryption keys.

</p>
<p>生成<em>非</em>密码学强度的伪随机数据。如果数据足够长的话会返回一个唯一的数据，但这个返回值不一定是不可预料的。基于这个原因，当不可预料性很重要时，这个函数的返回值永远都不应该被使用，例如在生成加密的密钥时。

</p>
<p>Usage is otherwise identical to <code>crypto.randomBytes</code>.

</p>
<p>用法与 <code>crypto.randomBytes</code>一模一样。

</p>
<h2>crypto.DEFAULT_ENCODING<span><a href="all.html#all_crypto_default_encoding" id="all_crypto_default_encoding">#</a></span></h2>
<p>The default encoding to use for functions that can take either strings
or buffers.  The default value is <code>&apos;buffer&apos;</code>, which makes it default
to using Buffer objects.  This is here to make the crypto module more
easily compatible with legacy programs that expected <code>&apos;binary&apos;</code> to be
the default encoding.

</p>
<p>对于可以接受字符串或buffer对象的函数的默认编码方式。默认值是<code>&apos;buffer&apos;</code>，所以默认使用Buffer对象。这是为了让crypto模块与默认<code>&apos;binary&apos;</code>为编码方式的遗留程序更容易兼容。

</p>
<p>Note that new programs will probably expect buffers, so only use this
as a temporary measure.

</p>
<p>要注意，新的程序会期待buffer对象，所以使用这个时请只作为暂时的手段。

</p>
<h2>Recent API Changes<span><a href="all.html#all_recent_api_changes" id="all_recent_api_changes">#</a></span></h2>
<p>The Crypto module was added to Node before there was the concept of a
unified Stream API, and before there were Buffer objects for handling
binary data.

</p>
<p>早在统一的流API概念出现，以及引入Buffer对象来处理二进制数据之前，Crypto模块就被添加到Node。

</p>
<p>As such, the streaming classes don&apos;t have the typical methods found on
other Node classes, and many methods accepted and returned
Binary-encoded strings by default rather than Buffers.  This was
changed to use Buffers by default instead.

</p>
<p>因为这样，与流有关的类中并没有其它Node类的典型函数，而且很多函数接受和返回默认的二进制编码的字符串，而不是Buffer对象。在最近的修改中，这些函数都被改成默认使用Buffer对象。

</p>
<p>This is a breaking change for some use cases, but not all.

</p>
<p>这对于某些(但不是全部)使用场景来讲是重大的改变。

</p>
<p>For example, if you currently use the default arguments to the Sign
class, and then pass the results to the Verify class, without ever
inspecting the data, then it will continue to work as before.  Where
you once got a binary string and then presented the binary string to
the Verify object, you&apos;ll now get a Buffer, and present the Buffer to
the Verify object.

</p>
<p>例如，如果你现在使用Sign类的默认参数，然后在没有检查数据的情况下，将结果传递给Verify类，那么程序会照常工作。在以前，你会拿到一个二进制字符串，然后它传递给Verify对象；而现在，你会得到一个Buffer对象，然后把它传递给Verify对象。

</p>
<p>However, if you were doing things with the string data that will not
work properly on Buffers (such as, concatenating them, storing in
databases, etc.), or you are passing binary strings to the crypto
functions without an encoding argument, then you will need to start
providing encoding arguments to specify which encoding you&apos;d like to
use.  To switch to the previous style of using binary strings by
default, set the <code>crypto.DEFAULT_ENCODING</code> field to &apos;binary&apos;.  Note
that new programs will probably expect buffers, so only use this as a
temporary measure.

</p>
<p>但是，如果你以前是使用那些在Buffer对象上不能正常工作的字符串数据，或者以默认编码方式将二进制数据传递给加密函数的话，那你就要开始提供编码方式参数来指明你想使用的编码方式了。如果想准换回旧的风格默认使用二进制字符串，那么你需要把<code>crypto.DEFAULT_ENCODING</code>字段设为&apos;binary&apos;。但请注意，因为新的程序很可能会期望buffer对象，所以仅将此当做临时手段。

</p>
<h1>TLS (SSL)<span><a href="all.html#all_tls_ssl" id="all_tls_ssl">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Use <code>require(&apos;tls&apos;)</code> to access this module.

</p>
<p>使用 <code>require(&apos;tls&apos;)</code> 来访问此模块。

</p>
<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.

</p>
<p><code>tls</code> 模块使用 OpenSSL 来提供传输层安全协议（Transport Layer Security）和/或安全套接层（Secure Socket Layer）：加密过的流通讯。

</p>
<p>TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this

</p>
<p>TLS/SSL 是一种公钥/私钥架构。每个客户端和服务器都必有一个私钥。一个私钥使用类似的方式创建：

</p>
<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>
<p>All severs and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a &quot;Certificate Signing Request&quot; (CSR)
file. This is done with:

</p>
<p>所有服务器和某些客户端需要具备证书。证书是证书办法机构签发或自签发的公钥。获取证书的第一步是创建一个“证书签发申请”（CSR）文件。使用这条命令完成：

</p>
<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p>To create a self-signed certificate with the CSR, do this:

</p>
<p>像这样使用 CSR 创建一个自签名证书：

</p>
<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p>Alternatively you can send the CSR to a Certificate Authority for signing.

</p>
<p>又或者你可以将 CSR 发送给一个数字证书认证机构请求签名。

</p>
<p>(TODO: docs on creating a CA, for now interested users should just look at
<code>test/fixtures/keys/Makefile</code> in the Node source code)

</p>
<p>To create .pfx or .p12, do this:

</p>
<p>像这样创建 .pfx 或 .p12：

</p>
<pre><code>openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \
    -certfile ca-cert.pem -out agent5.pfx</code></pre>
<ul>
<li><code>in</code>:  certificate</li>
<li><code>inkey</code>: private key</li>
<li><p><code>certfile</code>: all CA certs concatenated in one file like
<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></p>
</li>
<li><p><code>in</code>:  certificate</p>
</li>
<li><code>inkey</code>: private key</li>
<li><code>certfile</code>: all CA certs concatenated in one file like
<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>
<h2>Client-initiated renegotiation attack mitigation<span><a href="all.html#all_client_initiated_renegotiation_attack_mitigation" id="all_client_initiated_renegotiation_attack_mitigation">#</a></span></h2>
<!-- type=misc -->

<p>The TLS protocol lets the client renegotiate certain aspects of the TLS session.
Unfortunately, session renegotiation requires a disproportional amount of
server-side resources, which makes it a potential vector for denial-of-service
attacks.

</p>
<p>TLS协议会令客户端可以重新协商TLS会话的某些方面。但是，会话的重新协商是需要相应量的服务器端资源的，所以导致其变成一个阻断服务攻击（denial-of-service）的潜在媒介。

</p>
<p>To mitigate this, renegotiations are limited to three times every 10 minutes. An
error is emitted on the <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a> instance when the threshold is
exceeded. The limits are configurable:

</p>
<p>为了减低这种情况的发生，重新协商被限制在每10分钟三次。如果超过这个数目，那么在<a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>实例上就会分发一个错误。这个限制是可设置的：

</p>
<ul>
<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: renegotiation limit, default is 3.</p>
</li>
<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: 重新协商的次数限制，默认为3。</p>
</li>
<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: renegotiation window in seconds, default is
10 minutes.</p>
</li>
<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: 重新协商窗口的秒数，默认为600（10分钟）。</p>
</li>
</ul>
<p>Don&apos;t change the defaults unless you know what you are doing.

</p>
<p>除非你完全理解整个机制和清楚自己要干什么，否则不要改变这个默认值。

</p>
<p>To test your server, connect to it with <code>openssl s_client -connect address:port</code>
and tap <code>R&lt;CR&gt;</code> (that&apos;s the letter <code>R</code> followed by a carriage return) a few
times.

</p>
<p>要测试你的服务器的话，用命令 <code>openssl s_client -connect 地址:端口</code>连接上服务器，然后敲击<code>R&lt;CR&gt;</code>（字母键<code>R</code>加回车键）几次。

</p>
<h2>NPN 和 SNI<span><a href="all.html#all_npn_sni" id="all_npn_sni">#</a></span></h2>
<!-- type=misc -->

<p>NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS
handshake extensions allowing you:

</p>
<ul>
<li>NPN - to use one TLS server for multiple protocols (HTTP, SPDY)</li>
<li>SNI - to use one TLS server for multiple hostnames with different SSL
certificates.</li>
</ul>
<h2>tls.getCiphers()<span><a href="all.html#all_tls_getciphers" id="all_tls_getciphers">#</a></span></h2>
<p>Returns an array with the names of the supported SSL ciphers.

</p>
<p>返回一个数组，其中包含了所支持的SSL加密器的名字。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var ciphers = tls.getCiphers();
console.log(ciphers); // [&apos;AES128-SHA&apos;, &apos;AES256-SHA&apos;, ...]</code></pre>
<h2>tls.createServer(options, [secureConnectionListener])<span><a href="all.html#all_tls_createserver_options_secureconnectionlistener" id="all_tls_createserver_options_secureconnectionlistener">#</a></span></h2>
<p>Creates a new <a href="all.html#tls_class_tls_server">tls.Server</a>.  The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="all.html#tls_event_secureconnection">secureConnection</a> event.  The
<code>options</code> object has these possibilities:

</p>
<p>新建一个新的 <a href="all.html#tls_class_tls_server">tls.Server</a>.  The <code>connectionListener</code> 参数会自动设置为 <a href="all.html#tls_event_secureconnection">secureConnection</a> 事件的监听器. 这个 <code>options</code> 对象有这些可能性:

</p>
<ul>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and
CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with
the <code>key</code>, <code>cert</code> and <code>ca</code> options.)</p>
</li>
<li><p><code>pfx</code>: 一个String 或<code>Buffer</code>包含了私钥, 证书和CA certs, 一般是 PFX 或者 PKCS12 格式. (Mutually exclusive with
the <code>key</code>, <code>cert</code> and <code>ca</code> options.)</p>
</li>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. (Required)</p>
</li>
<li><p><code>key</code>: 一个字符串或 <code>Buffer</code>对象，其中包含了PEF格式的服务器的私钥。 (必需)</p>
</li>
<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code>passphrase</code>: 私钥或pfx密码的字符串。</p>
</li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in
PEM format. (Required)</p>
</li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known &quot;root&quot; CAs will be used, like VeriSign.
These are used to authorize connections.</p>
</li>
<li><p><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate
Revocation List)</p>
</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude.</p>
<p><strong>NOTE</strong>: Previous revisions of this section suggested <code>AES256-SHA</code> as an
acceptable cipher. Unfortunately, <code>AES256-SHA</code> is a CBC cipher and therefore
susceptible to BEAST attacks. Do <em>not</em> use it.</p>
</li>
<li><p><code>handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not
finish in this many milliseconds. The default is 120 seconds.</p>
<p>A <code>&apos;clientError&apos;</code> is emitted on the <code>tls.Server</code> object whenever a handshake
times out.</p>
</li>
<li><p><code>honorCipherOrder</code> : When choosing a cipher, use the server&apos;s preferences
instead of the client preferences.</p>
<p>Although, this option is disabled by default, it is <em>recommended</em> that you
use this option in conjunction with the <code>ciphers</code> option to mitigate
BEAST attacks.</p>
</li>
<li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code>false</code>.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p>
</li>
<li><p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols
should be ordered by their priority).</p>
</li>
<li><p><code>SNICallback(servername, cb)</code>: A function that will be called if client
supports SNI TLS extension. Two argument will be passed to it: <code>servername</code>,
and <code>cb</code>. <code>SNICallback</code> should invoke <code>cb(null, ctx)</code>, where <code>ctx</code> is a
SecureContext instance.
(You can use <code>crypto.createCredentials(...).context</code> to get proper
SecureContext). If <code>SNICallback</code> wasn&apos;t provided - default callback with
high-level API will be used (see below).</p>
</li>
<li><p><code>sessionTimeout</code>: An integer specifying the seconds after which TLS
session identifiers and TLS session tickets created by the server are
timed out. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html">SSL_CTX_set_timeout</a> for more details.</p>
</li>
<li><p><code>sessionIdContext</code>: A string containing a opaque identifier for session
resumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value
generated from command-line. Otherwise, the default is not provided.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
</ul>
<p>Here is a simple example echo server:

</p>
<p>这是一个简单的应答服务器例子：

</p>
<pre><code>var server = tls.createServer(options, function(socket) {
  console.log(&apos;服务器已连接&apos;,
              socket.authorized ? &apos;已授权&apos; : &apos;未授权&apos;);
  socket.write(&quot;欢迎！\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;server bound&apos;);
});</code></pre>
<p>Or

</p>
<p>或者

</p>
<pre><code>};

var server = tls.createServer(options, function(socket) {
  console.log(&apos;server connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  socket.write(&quot;welcome!\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;server bound&apos;);
});</code></pre>
<p>You can test this server by connecting to it with <code>openssl s_client</code>:

</p>
<pre><code>var server = tls.createServer(options, function(socket) {
  console.log(&apos;服务器已连接&apos;,
              socket.authorized ? &apos;已授权&apos; : &apos;未授权&apos;);
  socket.write(&quot;欢迎！\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;服务器已绑定&apos;);
});</code></pre>
<p>您可以使用 <code>openssl s_client</code> 连接这个服务器来测试：

</p>
<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
<h2>tls.connect(options, [callback])<span><a href="all.html#all_tls_connect_options_callback" id="all_tls_connect_options_callback">#</a></span></h2>
<h2>tls.connect(port, [host], [options], [callback])<span><a href="all.html#all_tls_connect_port_host_options_callback" id="all_tls_connect_port_host_options_callback">#</a></span></h2>
<h2>tls.connect(options, [callback])<span><a href="all.html#all_tls_connect_options_callback_1" id="all_tls_connect_options_callback_1">#</a></span></h2>
<h2>tls.connect(port, [host], [options], [callback])<span><a href="all.html#all_tls_connect_port_host_options_callback_1" id="all_tls_connect_port_host_options_callback_1">#</a></span></h2>
<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or
<code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to
<code>localhost</code>.) <code>options</code> should be an object which specifies:

</p>
<ul>
<li><p><code>host</code>: Host the client should connect to</p>
</li>
<li><p><code>port</code>: Port the client should connect to</p>
</li>
<li><p><code>socket</code>: Establish secure connection on a given socket rather than
creating a new socket. If this option is specified, <code>host</code> and <code>port</code>
are ignored.</p>
</li>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and
CA certs of the server in PFX or PKCS12 format.</p>
</li>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in
PEM format.</p>
</li>
<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code>passphrase</code>: 私钥或pfx密码的字符串。</p>
</li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in
PEM format.</p>
</li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known &quot;root&quot; CAs will be used, like VeriSign.
These are used to authorize connections.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against
the list of supplied CAs. An <code>&apos;error&apos;</code> event is emitted if verification
fails. Default: <code>true</code>.</p>
</li>
<li><p><code>NPNProtocols</code>: An array of string or <code>Buffer</code> containing supported NPN
protocols. <code>Buffer</code> should have following format: <code>0x05hello0x05world</code>,
where first byte is next protocol name&apos;s length. (Passing array should
usually be much simpler: <code>[&apos;hello&apos;, &apos;world&apos;]</code>.)</p>
</li>
<li><p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
</ul>
<p>The <code>callback</code> parameter will be added as a listener for the
<a href="all.html#tls_event_secureconnect">&apos;secureConnect&apos;</a> event.

</p>
<p><code>callback</code>参数会被作为监听器添加到<a href="all.html#tls_event_secureconnect">&apos;secureConnect&apos;</a>事件。

</p>
<p><code>tls.connect()</code> returns a <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a> object.

</p>
<p><code>tls.connect()</code>返回一个<a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>对象。

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<p>下面是一个上述应答服务器的客户端的例子：

</p>
<pre><code>var socket = tls.connect(8000, options, function() {
  console.log(&apos;client connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&apos;utf8&apos;);
socket.on(&apos;data&apos;, function(data) {
  console.log(data);
});
socket.on(&apos;end&apos;, function() {
  server.close();
});</code></pre>
<p>Or

</p>
<p>或者

</p>
<pre><code>var socket = tls.connect(8000, options, function() {
  console.log(&apos;client connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&apos;utf8&apos;);
socket.on(&apos;data&apos;, function(data) {
  console.log(data);
});
socket.on(&apos;end&apos;, function() {
  server.close();
});</code></pre>
<h2>类: tls.TLSSocket<span><a href="all.html#all_tls_tlssocket" id="all_tls_tlssocket">#</a></span></h2>
<p>Wrapper for instance of <a href="net.html#net_class_net_socket">net.Socket</a>, replaces internal socket read/write
routines to perform transparent encryption/decryption of incoming/outgoing data.

</p>
<h2>new tls.TLSSocket(socket, options)<span><a href="all.html#all_new_tls_tlssocket_socket_options" id="all_new_tls_tlssocket_socket_options">#</a></span></h2>
<p>Construct a new TLSSocket object from existing TCP socket.

</p>
<p><code>socket</code> is an instance of <a href="net.html#net_class_net_socket">net.Socket</a>

</p>
<p><code>socket</code>是一个<a href="net.html#net_class_net_socket">net.Socket</a>示例。

</p>
<p><code>options</code> is an object that might contain following properties:

</p>
<p><code>options</code>是一个可能包含以下属性的对象：

</p>
<ul>
<li><p><code>credentials</code>: An optional credentials object from
 <code>crypto.createCredentials( ... )</code></p>
</li>
<li><p><code>isServer</code>: If true - TLS socket will be instantiated in server-mode</p>
</li>
<li><p><code>server</code>: An optional <a href="net.html#net_class_net_server">net.Server</a> instance</p>
</li>
<li><p><code>server</code>: 一个可选的<a href="net.html#net_class_net_server">net.Server</a>实例</p>
</li>
<li><p><code>requestCert</code>: Optional, see <a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>requestCert</code>: 可选的，见<a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>rejectUnauthorized</code>: Optional, see <a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>rejectUnauthorized</code>: 可选的，见<a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>NPNProtocols</code>: Optional, see <a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>NPNProtocols</code>: 可选的，见<a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>SNICallback</code>: Optional, see <a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>SNICallback</code>: 可选的，见<a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
</ul>
<h2>tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])<span><a href="all.html#all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized" id="all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">#</a></span></h2>
<pre><code>稳定性: 0 - 已废弃。使用 tls.TLSSocket 替代。</code></pre>
<p>Creates a new secure pair object with two streams, one of which reads/writes
encrypted data, and one reads/writes cleartext data.
Generally the encrypted one is piped to/from an incoming encrypted data stream,
and the cleartext one is used as a replacement for the initial encrypted stream.

</p>
<ul>
<li><p><code>credentials</code>: A credentials object from crypto.createCredentials( ... )</p>
</li>
<li><p><code>isServer</code>: A boolean indicating whether this tls connection should be
opened as a server or a client.</p>
</li>
<li><p><code>requestCert</code>: A boolean indicating whether a server should request a
certificate from a connecting client. Only applies to server connections.</p>
</li>
<li><p><code>rejectUnauthorized</code>: A boolean indicating whether a server should
automatically reject clients with invalid certificates. Only applies to
servers with <code>requestCert</code> enabled.</p>
</li>
</ul>
<p><code>tls.createSecurePair()</code> returns a SecurePair object with <code>cleartext</code> and
<code>encrypted</code> stream properties.

</p>
<p>NOTE: <code>cleartext</code> has the same APIs as <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>

</p>
<h2>类: SecurePair<span><a href="all.html#all_securepair" id="all_securepair">#</a></span></h2>
<p>Returned by tls.createSecurePair.

</p>
<p>由tls.createSecurePair返回。

</p>
<h3>事件: &apos;secure&apos;<span><a href="all.html#all_secure" id="all_secure">#</a></span></h3>
<p>The event is emitted from the SecurePair once the pair has successfully
established a secure connection.

</p>
<p>Similarly to the checking for the server &apos;secureConnection&apos; event,
pair.cleartext.authorized should be checked to confirm whether the certificate
used properly authorized.

</p>
<h2>类: tls.Server<span><a href="all.html#all_tls_server" id="all_tls_server">#</a></span></h2>
<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.

</p>
<h3>事件: &apos;secureConnection&apos;<span><a href="all.html#all_secureconnection" id="all_secureconnection">#</a></span></h3>
<p><code>function (tlsSocket) {}</code>

</p>
<p><code>function (tlsSocket) {}</code>

</p>
<p>This event is emitted after a new connection has been successfully
handshaked. The argument is a instance of <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>. It has all the
common stream methods and events.

</p>
<p><code>socket.authorized</code> is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If <code>socket.authorized</code> is false, then
<code>socket.authorizationError</code> is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.
<code>socket.npnProtocol</code> is a string containing selected NPN protocol.
<code>socket.servername</code> is a string containing servername requested with
SNI.

</p>
<h3>Event: &apos;clientError&apos;<span><a href="all.html#all_event_clienterror" id="all_event_clienterror">#</a></span></h3>
<p><code>function (exception, tlsSocket) { }</code>

</p>
<p><code>function (exception, tlsSocket) { }</code>

</p>
<p>When a client connection emits an &apos;error&apos; event before secure connection is
established - it will be forwarded here.

</p>
<p><code>tlsSocket</code> is the <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a> that the error originated from.

</p>
<h3>事件: &apos;newSession&apos;<span><a href="all.html#all_newsession" id="all_newsession">#</a></span></h3>
<p><code>function (sessionId, sessionData) { }</code>

</p>
<p><code>function (sessionId, sessionData) { }</code>

</p>
<p>Emitted on creation of TLS session. May be used to store sessions in external
storage.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
<h3>事件: &apos;resumeSession&apos;<span><a href="all.html#all_resumesession" id="all_resumesession">#</a></span></h3>
<p><code>function (sessionId, callback) { }</code>

</p>
<p><code>function (sessionId, callback) { }</code>

</p>
<p>Emitted when client wants to resume previous TLS session. Event listener may
perform lookup in external storage using given <code>sessionId</code>, and invoke
<code>callback(null, sessionData)</code> once finished. If session can&apos;t be resumed
(i.e. doesn&apos;t exist in storage) one may call <code>callback(null, null)</code>. Calling
<code>callback(err)</code> will terminate incoming connection and destroy socket.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
<h3>server.listen(port, [host], [callback])<span><a href="all.html#all_server_listen_port_host_callback" id="all_server_listen_port_host_callback">#</a></span></h3>
<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.

</p>
<p>See <code>net.Server</code> for more information.

</p>
<p>更多信息见<code>net.Server</code>。

</p>
<h3>server.close()<span><a href="all.html#all_server_close" id="all_server_close">#</a></span></h3>
<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>&apos;close&apos;</code>
event.

</p>
<h3>server.address()<span><a href="all.html#all_server_address" id="all_server_address">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
server as reported by the operating system.  See <a href="net.html#net_server_address">net.Server.address()</a> for
more information.

</p>
<h3>server.addContext(hostname, credentials)<span><a href="all.html#all_server_addcontext_hostname_credentials" id="all_server_addcontext_hostname_credentials">#</a></span></h3>
<p>Add secure context that will be used if client request&apos;s SNI hostname is
matching passed <code>hostname</code> (wildcards can be used). <code>credentials</code> can contain
<code>key</code>, <code>cert</code> and <code>ca</code>.

</p>
<h3>server.maxConnections<span><a href="all.html#all_server_maxconnections" id="all_server_maxconnections">#</a></span></h3>
<p>Set this property to reject connections when the server&apos;s connection count
gets high.

</p>
<h3>server.connections<span><a href="all.html#all_server_connections" id="all_server_connections">#</a></span></h3>
<p>The number of concurrent connections on the server.

</p>
<p>服务器的并发连接数.

</p>
<h2>类: CryptoStream<span><a href="all.html#all_cryptostream" id="all_cryptostream">#</a></span></h2>
<pre><code>稳定性: 0 - 已废弃。使用 tls.TLSSocket 替代。</code></pre>
<p>This is an encrypted stream.

</p>
<p>这是一个被加密的流。

</p>
<h3>cryptoStream.bytesWritten<span><a href="all.html#all_cryptostream_byteswritten" id="all_cryptostream_byteswritten">#</a></span></h3>
<p>A proxy to the underlying socket&apos;s bytesWritten accessor, this will return
the total bytes written to the socket, <em>including the TLS overhead</em>.

</p>
<h2>类: tls.TLSSocket<span><a href="all.html#all_tls_tlssocket_1" id="all_tls_tlssocket_1">#</a></span></h2>
<p>This is a wrapped version of <a href="net.html#net_class_net_socket">net.Socket</a> that does transparent encryption
of written data and all required TLS negotiation.

</p>
<p>This instance implements a duplex <a href="stream.html#stream_stream">Stream</a> interfaces.  It has all the
common stream methods and events.

</p>
<h3>事件: &apos;secureConnect&apos;<span><a href="all.html#all_secureconnect" id="all_secureconnect">#</a></span></h3>
<p>This event is emitted after a new connection has been successfully handshaked.
The listener will be called no matter if the server&apos;s certificate was
authorized or not. It is up to the user to test <code>tlsSocket.authorized</code>
to see if the server certificate was signed by one of the specified CAs.
If <code>tlsSocket.authorized === false</code> then the error can be found in
<code>tlsSocket.authorizationError</code>. Also if NPN was used - you can check
<code>tlsSocket.npnProtocol</code> for negotiated protocol.

</p>
<h3>tlsSocket.authorized<span><a href="all.html#all_tlssocket_authorized" id="all_tlssocket_authorized">#</a></span></h3>
<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the
specified CAs, otherwise <code>false</code>

</p>
<h3>tlsSocket.authorizationError<span><a href="all.html#all_tlssocket_authorizationerror" id="all_tlssocket_authorizationerror">#</a></span></h3>
<p>The reason why the peer&apos;s certificate has not been verified. This property
becomes available only when <code>tlsSocket.authorized === false</code>.

</p>
<h3>tlsSocket.getPeerCertificate()<span><a href="all.html#all_tlssocket_getpeercertificate" id="all_tlssocket_getpeercertificate">#</a></span></h3>
<p>Returns an object representing the peer&apos;s certificate. The returned object has
some properties corresponding to the field of the certificate.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>{ subject: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  issuer: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  valid_from: &apos;Nov 11 09:52:22 2009 GMT&apos;,
  valid_to: &apos;Nov  6 09:52:22 2029 GMT&apos;,
  fingerprint: &apos;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&apos; }</code></pre>
<p>If the peer does not provide a certificate, it returns <code>null</code> or an empty
object.

</p>
<h3>tlsSocket.getCipher()<span><a href="all.html#all_tlssocket_getcipher" id="all_tlssocket_getcipher">#</a></span></h3>
<p>Returns an object representing the cipher name and the SSL/TLS
protocol version of the current connection.

</p>
<p>Example:
{ name: &apos;AES256-SHA&apos;, version: &apos;TLSv1/SSLv3&apos; }

</p>
<p>Example:
{ name: &apos;AES256-SHA&apos;, version: &apos;TLSv1/SSLv3&apos; }

</p>
<p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in
<a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS">http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS</a> for more
information.

</p>
<h3>tlsSocket.renegotiate(options, callback)<span><a href="all.html#all_tlssocket_renegotiate_options_callback" id="all_tlssocket_renegotiate_options_callback">#</a></span></h3>
<p>Initiate TLS renegotiation process. The <code>options</code> may contain the following
fields: <code>rejectUnauthorized</code>, <code>requestCert</code> (See <a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a>
for details). <code>callback(err)</code> will be executed with <code>null</code> as <code>err</code>,
once the renegotiation is successfully completed.

</p>
<p>NOTE: Can be used to request peer&apos;s certificate after the secure connection
has been established.

</p>
<p>ANOTHER NOTE: When running as the server, socket will be destroyed
with an error after <code>handshakeTimeout</code> timeout.

</p>
<h3>tlsSocket.address()<span><a href="all.html#all_tlssocket_address" id="all_tlssocket_address">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
underlying socket as reported by the operating system. Returns an
object with three properties, e.g.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<h3>tlsSocket.remoteAddress<span><a href="all.html#all_tlssocket_remoteaddress" id="all_tlssocket_remoteaddress">#</a></span></h3>
<p>The string representation of the remote IP address. For example,
<code>&apos;74.125.127.100&apos;</code> or <code>&apos;2001:4860:a005::68&apos;</code>.

</p>
<p>远程IP地址的字符串表示。例如，<code>&apos;74.125.127.100&apos;</code>或 <code>&apos;2001:4860:a005::68&apos;</code>。

</p>
<h3>tlsSocket.remotePort<span><a href="all.html#all_tlssocket_remoteport" id="all_tlssocket_remoteport">#</a></span></h3>
<p>The numeric representation of the remote port. For example, <code>443</code>.

</p>
<p>远程端口的数值表示。例如， <code>443</code>。

</p>
<h3>tlsSocket.localAddress<span><a href="all.html#all_tlssocket_localaddress" id="all_tlssocket_localaddress">#</a></span></h3>
<p>The string representation of the local IP address.

</p>
<p>本地IP地址的字符串表达。

</p>
<h3>tlsSocket.localPort<span><a href="all.html#all_tlssocket_localport" id="all_tlssocket_localport">#</a></span></h3>
<p>The numeric representation of the local port.

</p>
<p>本地端口的数值表示。

</p>
<h1>字符串解码器<span><a href="all.html#all_23" id="all_23">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>To use this module, do <code>require(&apos;string_decoder&apos;)</code>. StringDecoder decodes a
buffer to a string. It is a simple interface to <code>buffer.toString()</code> but provides
additional support for utf8.

</p>
<p>通过 <code>require(&apos;string_decoder&apos;)</code> 使用这个模块。这个模块将一个 Buffer 解码成一个字符串。他是 <code>buffer.toString()</code> 的一个简单接口，但提供对 utf8 的支持。

</p>
<pre><code>var euro = new Buffer([0xE2, 0x82, 0xAC]);
console.log(decoder.write(euro));</code></pre>
<h2>类: StringDecoder<span><a href="all.html#all_stringdecoder" id="all_stringdecoder">#</a></span></h2>
<p>Accepts a single argument, <code>encoding</code> which defaults to <code>utf8</code>.

</p>
<p>接受 <code>encoding</code> 一个参数，默认是 <code>utf8</code>。

</p>
<h3>decoder.write(buffer)<span><a href="all.html#all_decoder_write_buffer" id="all_decoder_write_buffer">#</a></span></h3>
<p>Returns a decoded string.

</p>
<p>返回解码后的字符串。

</p>
<h3>decoder.end()<span><a href="all.html#all_decoder_end" id="all_decoder_end">#</a></span></h3>
<p>Returns any trailing bytes that were left in the buffer.


</p>
<p>返回 Buffer 中剩下的末尾字节。
</p>
<h1>File System<span><a href="all.html#all_file_system" id="all_file_system">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!--name=fs-->

<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code>require(&apos;fs&apos;)</code>. All the methods have asynchronous and
synchronous forms.

</p>
<p>文件系统模块是一个简单包装的标准 POSIX 文件 I/O 操作方法集。您可以通过调用<code>require(&apos;fs&apos;)</code>来获取该模块。文件系统模块中的所有方法均有异步和同步版本。 

</p>
<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.

</p>
<p>文件系统模块中的异步方法需要一个完成时的回调函数作为最后一个传入形参。
回调函数的构成由您调用的异步方法所决定，通常情况下回调函数的第一个形参为返回的错误信息。
如果异步操作执行正确并返回，该错误形参则为<code>null</code>或者<code>undefined</code>。

</p>
<p>When using the synchronous form any exceptions are immediately thrown.
You can use try/catch to handle exceptions or allow them to bubble up.

</p>
<p>如果您使用的是同步版本的操作方法，则一旦出现错误，会以通常的抛出错误的形式返回错误。
你可以用<code>try</code>和<code>catch</code>等语句来拦截错误并使程序继续进行。

</p>
<p>Here is an example of the asynchronous version:

</p>
<p>这里是一个异步版本的例子：

</p>
<pre><code>fs.unlink(&apos;/tmp/hello&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;successfully deleted /tmp/hello&apos;);
});</code></pre>
<p>Here is the synchronous version:

</p>
<p>这是同步版本的例子:

</p>
<pre><code>fs.unlinkSync(&apos;/tmp/hello&apos;)
console.log(&apos;successfully deleted /tmp/hello&apos;);</code></pre>
<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:

</p>
<p>当使用异步版本时不能保证执行顺序,因此下面这个例子很容易出错:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;renamed complete&apos;);
});
fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
  if (err) throw err;
  console.log(&apos;stats: &apos; + JSON.stringify(stats));
});</code></pre>
<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.
The correct way to do this is to chain the callbacks.

</p>
<p><code>fs.stat</code>有可能在<code>fs.rename</code>前执行.要等到正确的执行顺序应该用下面的方法:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
    if (err) throw err;
    console.log(&apos;stats: &apos; + JSON.stringify(stats));
  });
});</code></pre>
<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.

</p>
<p>在繁重的任务中,<em>强烈推荐</em>使用这些函数的异步版本.同步版本会阻塞进程,直到完成处理,也就是说会暂停所有的连接.

</p>
<p>Relative path to filename can be used, remember however that this path will be
relative to <code>process.cwd()</code>.

</p>
<p>可以使用文件名的相对路径, 但是记住这个路径是相对于<code>process.cwd()</code>的.

</p>
<p>Most fs functions let you omit the callback argument. If you do, a default
callback is used that rethrows errors. To get a trace to the original call
site, set the NODE_DEBUG environment variable:

</p>
<p>大部分的文件系统(fs)函数可以忽略回调函数(callback)这个参数.如果忽略它,将会由一个默认回调函数(callback)来重新抛出(rethrow)错误.要获得原调用点的堆栈跟踪(trace)信息,需要在环境变量里设置NODE_DEBUG.

</p>
<pre><code>$ env NODE_DEBUG=fs node script.js
fs.js:66
        throw err;
              ^
Error: EISDIR, read
    at rethrow (fs.js:61:21)
    at maybeCallback (fs.js:79:42)
    at Object.fs.readFile (fs.js:153:18)
    at bad (/path/to/script.js:2:17)
    at Object.&lt;anonymous&gt; (/path/to/script.js:5:1)
    &lt;etc.&gt;</code></pre>
<h2>fs.rename(oldPath, newPath, callback)<span><a href="all.html#all_fs_rename_oldpath_newpath_callback" id="all_fs_rename_oldpath_newpath_callback">#</a></span></h2>
<p>Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的rename函数(2).完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.renameSync(oldPath, newPath)<span><a href="all.html#all_fs_renamesync_oldpath_newpath" id="all_fs_renamesync_oldpath_newpath">#</a></span></h2>
<p>Synchronous rename(2).

</p>
<p>同步版本的rename(2).

</p>
<h2>fs.ftruncate(fd, len, callback)<span><a href="all.html#all_fs_ftruncate_fd_len_callback" id="all_fs_ftruncate_fd_len_callback">#</a></span></h2>
<p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<p>异步版本的ftruncate(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.ftruncateSync(fd, len)<span><a href="all.html#all_fs_ftruncatesync_fd_len" id="all_fs_ftruncatesync_fd_len">#</a></span></h2>
<p>Synchronous ftruncate(2).

</p>
<p>同步版本的ftruncate(2).

</p>
<h2>fs.truncate(path, len, callback)<span><a href="all.html#all_fs_truncate_path_len_callback" id="all_fs_truncate_path_len_callback">#</a></span></h2>
<p>Asynchronous truncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<p>异步版本的truncate(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.truncateSync(path, len)<span><a href="all.html#all_fs_truncatesync_path_len" id="all_fs_truncatesync_path_len">#</a></span></h2>
<p>Synchronous truncate(2).

</p>
<p>同步版本的truncate(2).

</p>
<p>异步版本的chown.完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<p>Asynchronous chown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的chown(2).完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.chownSync(path, uid, gid)<span><a href="all.html#all_fs_chownsync_path_uid_gid" id="all_fs_chownsync_path_uid_gid">#</a></span></h2>
<p>Synchronous chown(2).

</p>
<p>同步版本的chown(2).

</p>
<h2>fs.fchown(fd, uid, gid, callback)<span><a href="all.html#all_fs_fchown_fd_uid_gid_callback" id="all_fs_fchown_fd_uid_gid_callback">#</a></span></h2>
<p>Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的fchown(2)。回调函数的参数除了出现错误时有一个错误对象外，没有其它参数。

</p>
<h2>fs.fchownSync(fd, uid, gid)<span><a href="all.html#all_fs_fchownsync_fd_uid_gid" id="all_fs_fchownsync_fd_uid_gid">#</a></span></h2>
<p>Synchronous fchown(2).

</p>
<p>同步版本的fchown(2).

</p>
<h2>fs.lchown(path, uid, gid, callback)<span><a href="all.html#all_fs_lchown_path_uid_gid_callback" id="all_fs_lchown_path_uid_gid_callback">#</a></span></h2>
<p>Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的lchown(2)。完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.lchownSync(path, uid, gid)<span><a href="all.html#all_fs_lchownsync_path_uid_gid" id="all_fs_lchownsync_path_uid_gid">#</a></span></h2>
<p>Synchronous lchown(2).

</p>
<p>同步版本的lchown(2).

</p>
<h2>fs.chmod(path, mode, callback)<span><a href="all.html#all_fs_chmod_path_mode_callback" id="all_fs_chmod_path_mode_callback">#</a></span></h2>
<p>Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 chmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.chmodSync(path, mode)<span><a href="all.html#all_fs_chmodsync_path_mode" id="all_fs_chmodsync_path_mode">#</a></span></h2>
<p>Synchronous chmod(2).

</p>
<p>同步版的 chmod(2).

</p>
<h2>fs.fchmod(fd, mode, callback)<span><a href="all.html#all_fs_fchmod_fd_mode_callback" id="all_fs_fchmod_fd_mode_callback">#</a></span></h2>
<p>Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<p>异步版的 fchmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.fchmodSync(fd, mode)<span><a href="all.html#all_fs_fchmodsync_fd_mode" id="all_fs_fchmodsync_fd_mode">#</a></span></h2>
<p>Synchronous fchmod(2).

</p>
<p>同步版的 fchmod(2).

</p>
<h2>fs.lchmod(path, mode, callback)<span><a href="all.html#all_fs_lchmod_path_mode_callback" id="all_fs_lchmod_path_mode_callback">#</a></span></h2>
<p>Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<p>异步版的 lchmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<p>Only available on Mac OS X.

</p>
<p>仅在 Mac OS X 系统下可用。

</p>
<h2>fs.lchmodSync(path, mode)<span><a href="all.html#all_fs_lchmodsync_path_mode" id="all_fs_lchmodsync_path_mode">#</a></span></h2>
<p>Synchronous lchmod(2).

</p>
<p>同步版的 lchmod(2).

</p>
<h2>fs.stat(path, callback)<span><a href="all.html#all_fs_stat_path_callback" id="all_fs_stat_path_callback">#</a></span></h2>
<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <a href="all.html#fs_class_fs_stats">fs.Stats</a> object.  See the <a href="all.html#fs_class_fs_stats">fs.Stats</a>
section below for more information.

</p>
<p>异步版的 stat(2). 回调函数（callback） 接收两个参数： <code>(err, stats)</code> ，其中
<code>stats</code> 是一个 <a href="all.html#fs_class_fs_stats">fs.Stats</a> 对象。 详情请参考 <a href="all.html#fs_class_fs_stats">fs.Stats</a>

</p>
<h2>fs.lstat(path, callback)<span><a href="all.html#all_fs_lstat_path_callback" id="all_fs_lstat_path_callback">#</a></span></h2>
<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>lstat()</code> is identical to <code>stat()</code>, except that if
<code>path</code> is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.

</p>
<p>异步版的 lstat(2). 回调函数（callback）接收两个参数： <code>(err, stats)</code> 其中
<code>stats</code> 是一个 <code>fs.Stats</code> 对象。 <code>lstat()</code> 与 <code>stat()</code> 相同，区别在于：
若 <code>path</code> 是一个符号链接时（symbolic link）,读取的是该符号链接本身，而不是它所
链接到的文件。

</p>
<h2>fs.fstat(fd, callback)<span><a href="all.html#all_fs_fstat_fd_callback" id="all_fs_fstat_fd_callback">#</a></span></h2>
<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>fstat()</code> is identical to <code>stat()</code>, except that
the file to be stat-ed is specified by the file descriptor <code>fd</code>.

</p>
<p>异步版的 fstat(2). 回调函数（callback）接收两个参数： <code>(err, stats)</code> 其中
<code>stats</code> 是一个 <code>fs.Stats</code> 对象。 <code>fstat()</code> 与 <code>stat()</code> 相同，区别在于：
要读取的文件（译者注：即第一个参数）是一个文件描述符（file descriptor） <code>fd</code> 。

</p>
<h2>fs.statSync(path)<span><a href="all.html#all_fs_statsync_path" id="all_fs_statsync_path">#</a></span></h2>
<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 stat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.lstatSync(path)<span><a href="all.html#all_fs_lstatsync_path" id="all_fs_lstatsync_path">#</a></span></h2>
<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 lstat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.fstatSync(fd)<span><a href="all.html#all_fs_fstatsync_fd" id="all_fs_fstatsync_fd">#</a></span></h2>
<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 fstat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.link(srcpath, dstpath, callback)<span><a href="all.html#all_fs_link_srcpath_dstpath_callback" id="all_fs_link_srcpath_dstpath_callback">#</a></span></h2>
<p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.

</p>
<p>异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。

</p>
<h2>fs.linkSync(srcpath, dstpath)<span><a href="all.html#all_fs_linksync_srcpath_dstpath" id="all_fs_linksync_srcpath_dstpath">#</a></span></h2>
<p>Synchronous link(2).

</p>
<p>同步版的 link(2).

</p>
<h2>fs.symlink(srcpath, dstpath, [type], callback)<span><a href="all.html#all_fs_symlink_srcpath_dstpath_type_callback" id="all_fs_symlink_srcpath_dstpath_type_callback">#</a></span></h2>
<p>Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.
<code>type</code> argument can be either <code>&apos;dir&apos;</code>, <code>&apos;file&apos;</code>, or <code>&apos;junction&apos;</code> (default is <code>&apos;file&apos;</code>).  It is only 
used on Windows (ignored on other platforms).
Note that Windows junction points require the destination path to be absolute.  When using
<code>&apos;junction&apos;</code>, the <code>destination</code> argument will automatically be normalized to absolute path.

</p>
<p>异步版的 symlink(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。
<code>type</code> 可以是 <code>&apos;dir&apos;</code>, <code>&apos;file&apos;</code>, 或者<code>&apos;junction&apos;</code> (默认是 <code>&apos;file&apos;</code>)，此参数仅用于
Windows 系统（其他系统平台会被忽略）。
注意： Windows 系统要求目标路径（译者注：即 <code>dstpath</code> 参数）必须是一个绝对路径，当使用
<code>&apos;junction&apos;</code> 时，<code>dstpath</code> 参数会自动转换为绝对路径。

</p>
<h2>fs.symlinkSync(srcpath, dstpath, [type])<span><a href="all.html#all_fs_symlinksync_srcpath_dstpath_type" id="all_fs_symlinksync_srcpath_dstpath_type">#</a></span></h2>
<p>Synchronous symlink(2).

</p>
<p>同步版的 symlink(2).

</p>
<h2>fs.readlink(path, callback)<span><a href="all.html#all_fs_readlink_path_callback" id="all_fs_readlink_path_callback">#</a></span></h2>
<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,
linkString)</code>.

</p>
<p>异步版的 readlink(2). 回调函数（callback）接收两个参数： <code>(err,
linkString)</code>.

</p>
<h2>fs.readlinkSync(path)<span><a href="all.html#all_fs_readlinksync_path" id="all_fs_readlinksync_path">#</a></span></h2>
<p>Synchronous readlink(2). Returns the symbolic link&apos;s string value.

</p>
<p>同步版的 readlink(2). 返回符号链接（symbolic link）的字符串值。

</p>
<h2>fs.realpath(path, [cache], callback)<span><a href="all.html#all_fs_realpath_path_cache_callback" id="all_fs_realpath_path_cache_callback">#</a></span></h2>
<p>Asynchronous realpath(2). The <code>callback</code> gets two arguments <code>(err,
resolvedPath)</code>. May use <code>process.cwd</code> to resolve relative paths. <code>cache</code> is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional <code>fs.stat</code> calls for known real paths.

</p>
<p>异步版的 realpath(2). 回调函数（callback）接收两个参数： <code>(err,
resolvedPath)</code>. May use <code>process.cwd</code> to resolve relative paths. <code>cache</code> is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional <code>fs.stat</code> calls for known real paths.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var cache = {&apos;/etc&apos;:&apos;/private/etc&apos;};
fs.realpath(&apos;/etc/passwd&apos;, cache, function (err, resolvedPath) {
  if (err) throw err;
  console.log(resolvedPath);
});</code></pre>
<h2>fs.realpathSync(path, [cache])<span><a href="all.html#all_fs_realpathsync_path_cache" id="all_fs_realpathsync_path_cache">#</a></span></h2>
<p>Synchronous realpath(2). Returns the resolved path.

</p>
<p>realpath(2) 的同步版本。返回解析出的路径。

</p>
<h2>fs.unlink(path, callback)<span><a href="all.html#all_fs_unlink_path_callback" id="all_fs_unlink_path_callback">#</a></span></h2>
<p>Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 unlink(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息.

</p>
<h2>fs.unlinkSync(path)<span><a href="all.html#all_fs_unlinksync_path" id="all_fs_unlinksync_path">#</a></span></h2>
<p>Synchronous unlink(2).

</p>
<p>同步版的 unlink(2).

</p>
<h2>fs.rmdir(path, callback)<span><a href="all.html#all_fs_rmdir_path_callback" id="all_fs_rmdir_path_callback">#</a></span></h2>
<p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 rmdir(2). 异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。

</p>
<h2>fs.rmdirSync(path)<span><a href="all.html#all_fs_rmdirsync_path" id="all_fs_rmdirsync_path">#</a></span></h2>
<p>Synchronous rmdir(2).

</p>
<p>同步版的 rmdir(2).

</p>
<h2>fs.mkdir(path, [mode], callback)<span><a href="all.html#all_fs_mkdir_path_mode_callback" id="all_fs_mkdir_path_mode_callback">#</a></span></h2>
<p>Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback. <code>mode</code> defaults to <code>0777</code>.

</p>
<p>异步版的 mkdir(2)。 异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。文件 <code>mode</code> 默认为 <code>0777</code>。

</p>
<h2>fs.mkdirSync(path, [mode])<span><a href="all.html#all_fs_mkdirsync_path_mode" id="all_fs_mkdirsync_path_mode">#</a></span></h2>
<p>Synchronous mkdir(2).

</p>
<p>同步版的 mkdir(2)。

</p>
<h2>fs.readdir(path, callback)<span><a href="all.html#all_fs_readdir_path_callback" id="all_fs_readdir_path_callback">#</a></span></h2>
<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>&apos;.&apos;</code> and <code>&apos;..&apos;</code>.

</p>
<p>异步版的 readdir(3)。 读取 path 路径所在目录的内容。 回调函数 (callback) 接受两个参数 <code>(err, files)</code> 其中 <code>files</code> 是一个存储目录中所包含的文件名称的数组，数组中不包括 <code>&apos;.&apos;</code> 和 <code>&apos;..&apos;</code>。

</p>
<h2>fs.readdirSync(path)<span><a href="all.html#all_fs_readdirsync_path" id="all_fs_readdirsync_path">#</a></span></h2>
<p>Synchronous readdir(3). Returns an array of filenames excluding <code>&apos;.&apos;</code> and
<code>&apos;..&apos;</code>.

</p>
<p>同步版的 readdir(3). 返回文件名数组，其中不包括 <code>&apos;.&apos;</code> 和 <code>&apos;..&apos;</code> 目录.

</p>
<h2>fs.close(fd, callback)<span><a href="all.html#all_fs_close_fd_callback" id="all_fs_close_fd_callback">#</a></span></h2>
<p>Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版 close(2).  完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.closeSync(fd)<span><a href="all.html#all_fs_closesync_fd" id="all_fs_closesync_fd">#</a></span></h2>
<p>Synchronous close(2).

</p>
<p>同步版的 close(2).

</p>
<h2>fs.open(path, flags, [mode], callback)<span><a href="all.html#all_fs_open_path_flags_mode_callback" id="all_fs_open_path_flags_mode_callback">#</a></span></h2>
<p>Asynchronous file open. See open(2). <code>flags</code> can be:

</p>
<p>异步版的文件打开. 详见 open(2). <code>flags</code> 可以是:

</p>
<ul>
<li><p><code>&apos;r&apos;</code> - Open file for reading.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code>&apos;r&apos;</code>  - 以【只读】的方式打开文件. 当文件不存在时产生异常.</p>
</li>
<li><p><code>&apos;r+&apos;</code> - Open file for reading and writing.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code>&apos;r+&apos;</code> - 以【读写】的方式打开文件. 当文件不存在时产生异常.</p>
</li>
<li><p><code>&apos;rs&apos;</code> - Open file for reading in synchronous mode. Instructs the operating
system to bypass the local file system cache.</p>
</li>
<li><p><code>&apos;rs&apos;</code> - 同步模式下，以【只读】的方式打开文件. 指令绕过操作系统的本地文件系统缓存.</p>
<p>This is primarily useful for opening files on NFS mounts as it allows you to
skip the potentially stale local cache. It has a very real impact on I/O
performance so don&apos;t use this flag unless you need it.</p>
</li>
</ul>
<p>该功能主要用于打开 NFS 挂载的文件, 因为它可以让你跳过默认使用的过时本地缓存. 但这实际上非常影响 I/O 操作的性能, 因此除非你确实有这样的需求, 否则请不要使用该标志.

</p>
<p>  Note that this doesn&apos;t turn <code>fs.open()</code> into a synchronous blocking call.
  If that&apos;s what you want then you should be using <code>fs.openSync()</code>

</p>
<p> 注意: 这并不意味着 <code>fs.open()</code> 变成了一个同步阻塞的请求. 如果你想要一个同步阻塞的请求你应该使用 <code>fs.openSync()</code>.

</p>
<ul>
<li><p><code>&apos;rs+&apos;</code> - Open file for reading and writing, telling the OS to open it
synchronously. See notes for <code>&apos;rs&apos;</code> about using this with caution.</p>
</li>
<li><p><code>&apos;rs+&apos;</code> - 同步模式下, 以【读写】的方式打开文件. 请谨慎使用该方式, 详细请查看 <code>&apos;rs&apos;</code> 的注释.</p>
</li>
<li><p><code>&apos;w&apos;</code> - Open file for writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code>&apos;w&apos;</code> - 以【只写】的形式打开文件. 文件会被创建 (如果文件不存在) 或者覆盖 (如果存在).</p>
</li>
<li><p><code>&apos;wx&apos;</code> - Like <code>&apos;w&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;wx&apos;</code> - 类似 <code>&apos;w&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;w+&apos;</code> - Open file for reading and writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code>&apos;w+&apos;</code> - 以【读写】的方式打开文件. 文件会被创建 (如果文件不存在) 或者覆盖 (如果存在).</p>
</li>
<li><p><code>&apos;wx+&apos;</code> - Like <code>&apos;w+&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;wx+&apos;</code> - 类似 <code>&apos;w+&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;a&apos;</code> - Open file for appending.
The file is created if it does not exist.</p>
</li>
<li><p><code>&apos;a&apos;</code> - 以【附加】的形式打开文件，即新写入的数据会附加在原来的文件内容之后. 如果文件不存在则会默认创建.</p>
</li>
<li><p><code>&apos;ax&apos;</code> - Like <code>&apos;a&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;ax&apos;</code> - 类似 <code>&apos;a&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;a+&apos;</code> - Open file for reading and appending.
The file is created if it does not exist.</p>
</li>
<li><p><code>&apos;a+&apos;</code> - 以【读取】和【附加】的形式打开文件. 如果文件不存在则会默认创建.</p>
</li>
<li><p><code>&apos;ax+&apos;</code> - Like <code>&apos;a+&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;ax+&apos;</code> - 类似 <code>&apos;a+&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
</ul>
<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the file was
created. It defaults to <code>0666</code>, readable and writeable.

</p>
<p>参数 <code>mode</code> 用于设置文件模式 (permission and sticky bits), 不过前提是这个文件是已存在的. 默认情况下是 <code>0666</code>, 有可读和可写权限.

</p>
<p>The callback gets two arguments <code>(err, fd)</code>.

</p>
<p>该 callback 接收两个参数 <code>(err, fd)</code>.

</p>
<p>The exclusive flag <code>&apos;x&apos;</code> (<code>O_EXCL</code> flag in open(2)) ensures that <code>path</code> is newly
created. On POSIX systems, <code>path</code> is considered to exist even if it is a symlink
to a non-existent file. The exclusive flag may or may not work with network file
systems.

</p>
<p>排除 (exclusive) 标识 <code>&apos;x&apos;</code> （对应 open(2) 的 <code>O_EXCL</code> 标识） 保证 <code>path</code> 是一个新建的文件。
POSIX 操作系统上，即使 <code>path</code> 是一个指向不存在位置的符号链接，也会被认定为文件存在。
排除标识在网络文件系统不能确定是否有效。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.openSync(path, flags, [mode])<span><a href="all.html#all_fs_opensync_path_flags_mode" id="all_fs_opensync_path_flags_mode">#</a></span></h2>
<p>Synchronous version of <code>fs.open()</code>.

</p>
<p><code>fs.open()</code> 的同步版.

</p>
<h2>fs.utimes(path, atime, mtime, callback)<span><a href="all.html#all_fs_utimes_path_atime_mtime_callback" id="all_fs_utimes_path_atime_mtime_callback">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a href="all.html#all_fs_utimessync_path_atime_mtime" id="all_fs_utimessync_path_atime_mtime">#</a></span></h2>
<h2>fs.utimes(path, atime, mtime, callback)<span><a href="all.html#all_fs_utimes_path_atime_mtime_callback_1" id="all_fs_utimes_path_atime_mtime_callback_1">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a href="all.html#all_fs_utimessync_path_atime_mtime_1" id="all_fs_utimessync_path_atime_mtime_1">#</a></span></h2>
<p>Change file timestamps of the file referenced by the supplied path.

</p>
<p>更改 path 所指向的文件的时间戳。

</p>
<h2>fs.futimes(fd, atime, mtime, callback)<span><a href="all.html#all_fs_futimes_fd_atime_mtime_callback" id="all_fs_futimes_fd_atime_mtime_callback">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a href="all.html#all_fs_futimessync_fd_atime_mtime" id="all_fs_futimessync_fd_atime_mtime">#</a></span></h2>
<h2>fs.futimes(fd, atime, mtime, callback)<span><a href="all.html#all_fs_futimes_fd_atime_mtime_callback_1" id="all_fs_futimes_fd_atime_mtime_callback_1">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a href="all.html#all_fs_futimessync_fd_atime_mtime_1" id="all_fs_futimessync_fd_atime_mtime_1">#</a></span></h2>
<p>Change the file timestamps of a file referenced by the supplied file
descriptor.

</p>
<p>更改文件描述符 (file discriptor) 所指向的文件的时间戳。

</p>
<h2>fs.fsync(fd, callback)<span><a href="all.html#all_fs_fsync_fd_callback" id="all_fs_fsync_fd_callback">#</a></span></h2>
<p>Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的 fsync(2)。回调函数仅含有一个异常 (exception) 参数。

</p>
<h2>fs.fsyncSync(fd)<span><a href="all.html#all_fs_fsyncsync_fd" id="all_fs_fsyncsync_fd">#</a></span></h2>
<p>Synchronous fsync(2).

</p>
<p>fsync(2) 的同步版本。

</p>
<h2>fs.write(fd, buffer, offset, length[, position], callback)<span><a href="all.html#all_fs_write_fd_buffer_offset_length_position_callback" id="all_fs_write_fd_buffer_offset_length_position_callback">#</a></span></h2>
<p>Write <code>buffer</code> to the file specified by <code>fd</code>.

</p>
<p>通过文件标识<code>fd</code>，向指定的文件中写入<code>buffer</code>。

</p>
<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.

</p>
<p><code>offset</code> 和<code>length</code> 可以确定从哪个位置开始写入buffer。

</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &apos;number&apos;</code>, the data will be written
at the current position. See pwrite(2).

</p>
<p><code>position</code> 是参考当前文档光标的位置，然后从该处写入数据。如果<code>typeof position !== &apos;number&apos;</code>，那么数据会从当前文档位置写入，请看pwrite(2)。

</p>
<p>The callback will be given three arguments <code>(err, written, buffer)</code> where
<code>written</code> specifies how many <em>bytes</em> were written from <code>buffer</code>.

</p>
<p>回调中会给出三个参数 <code>(err, written, buffer)</code>，<code>written</code> 说明从<code>buffer</code>写入的字节数。

</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.

</p>
<p>注意，<code>fs.write</code>多次地在同一个文件中使用而没有等待回调是不安全的。在这种情况下，强烈推荐使用<code>fs.createWriteStream</code>。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.write(fd, data[, position[, encoding]], callback)<span><a href="all.html#all_fs_write_fd_data_position_encoding_callback" id="all_fs_write_fd_data_position_encoding_callback">#</a></span></h2>
<p>Write <code>data</code> to the file specified by <code>fd</code>.  If <code>data</code> is not a Buffer instance
then the value will be coerced to a string.

</p>
<p>把<code>data</code>写入到文档中通过指定的<code>fd</code>,如果<code>data</code>不是buffer对象的实例则会把值强制转化成一个字符串。

</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &apos;number&apos;</code> the data will be written at
the current position. See pwrite(2).

</p>
<p><code>position</code> 是参考当前文档光标的位置，然后从该处写入数据。如果<code>typeof position !== &apos;number&apos;</code>，那么数据会从当前文档位置写入，请看pwrite(2)。

</p>
<p><code>encoding</code> is the expected string encoding.

</p>
<p><code>encoding</code> 是预期得到一个字符串编码

</p>
<p>The callback will receive the arguments <code>(err, written, string)</code> where <code>written</code>
specifies how many <em>bytes</em> the passed string required to be written. Note that
bytes written is not the same as string characters. See
<a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">Buffer.byteLength</a>.

</p>
<p>回调会得到这些参数 <code>(err, written, string)</code>，<code>written</code>表明传入的<code>string</code>需要写入的字符串长度。注意字节的写入跟字符串写入是不一样的。请看<a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">Buffer.byteLength</a>.

</p>
<p>Unlike when writing <code>buffer</code>, the entire string must be written. No substring
may be specified. This is because the byte offset of the resulting data may not
be the same as the string offset.

</p>
<p>与写入<code>buffer</code>不同，必须写入完整的字符串，截取字符串不是符合规定的。这是因为返回的字节的位移跟字符串的位移是不一样的。

</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.

</p>
<p>注意，<code>fs.write</code>多次地在同一个文件中使用而没有等待回调是不安全的。在这种情况下，强烈推荐使用<code>fs.createWriteStream</code>。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.writeSync(fd, buffer, offset, length[, position])<span><a href="all.html#all_fs_writesync_fd_buffer_offset_length_position" id="all_fs_writesync_fd_buffer_offset_length_position">#</a></span></h2>
<h2>fs.writeSync(fd, data[, position[, encoding]])<span><a href="all.html#all_fs_writesync_fd_data_position_encoding" id="all_fs_writesync_fd_data_position_encoding">#</a></span></h2>
<p>Synchronous versions of <code>fs.write()</code>. Returns the number of bytes written.

</p>
<p>同步版本的<code>fs.write()</code>。返回写入的字节数。

</p>
<h2>fs.read(fd, buffer, offset, length, position, callback)<span><a href="all.html#all_fs_read_fd_buffer_offset_length_position_callback" id="all_fs_read_fd_buffer_offset_length_position_callback">#</a></span></h2>
<p>Read data from the file specified by <code>fd</code>.

</p>
<p>从指定的文档标识符<code>fd</code>读取文件数据。

</p>
<p><code>buffer</code> is the buffer that the data will be written to.

</p>
<p><code>buffer</code> 是缓冲区，数据将会写入这里。

</p>
<p><code>offset</code> is the offset in the buffer to start writing at.

</p>
<p><code>offset</code> 是开始向缓冲区 <code>buffer</code> 写入的偏移量。

</p>
<p><code>length</code> is an integer specifying the number of bytes to read.

</p>
<p><code>length</code> 是一个整形值，指定了读取的字节数。

</p>
<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.

</p>
<p><code>position</code> 是一个整形值，指定了从哪里开始读取文件，如果<code>position</code>为<code>null</code>，将会从文件当前的位置读取数据。

</p>
<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)</code>.

</p>
<p>回调函数给定了三个参数， <code>(err, bytesRead, buffer)</code>， 分别为错误，读取的字节和缓冲区。

</p>
<h2>fs.readSync(fd, buffer, offset, length, position)<span><a href="all.html#all_fs_readsync_fd_buffer_offset_length_position" id="all_fs_readsync_fd_buffer_offset_length_position">#</a></span></h2>
<p>Synchronous version of <code>fs.read</code>. Returns the number of <code>bytesRead</code>.

</p>
<p> <code>fs.read</code> 函数的同步版本。 返回<code>bytesRead</code>的个数。

</p>
<h2>fs.readFile(filename, [options], callback)<span><a href="all.html#all_fs_readfile_filename_options_callback" id="all_fs_readfile_filename_options_callback">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>null</code></li>
<li><code>flag</code> <span>String</span> default = <code>&apos;r&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>null</code></li>
<li><code>flag</code> <span>String</span> default = <code>&apos;r&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously reads the entire contents of a file. Example:

</p>
<p>异步读取一个文件的全部内容。举例：

</p>
<pre><code>fs.readFile(&apos;/etc/passwd&apos;, function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.

</p>
<p>回调函数传递了两个参数 <code>(err, data)</code>,  <code>data</code> 就是文件的内容。

</p>
<p>If no encoding is specified, then the raw buffer is returned.

</p>
<p>如果未指定编码方式，原生buffer就会被返回。

</p>
<h2>fs.readFileSync(filename, [options])<span><a href="all.html#all_fs_readfilesync_filename_options" id="all_fs_readfilesync_filename_options">#</a></span></h2>
<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.

</p>
<p> <code>fs.readFile</code>的同步版本。 返回文件名为 <code>filename</code> 的文件内容。

</p>
<p>If the <code>encoding</code> option is specified then this function returns a
string. Otherwise it returns a buffer.

</p>
<p>如果 <code>encoding</code> 选项被指定， 那么这个函数返回一个字符串。如果未指定，则返回一个原生buffer。

</p>
<h2>fs.writeFile(filename, data, [options], callback)<span><a href="all.html#all_fs_writefile_filename_data_options_callback" id="all_fs_writefile_filename_data_options_callback">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;w&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;w&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer.

</p>
<p>异步的将数据写入一个文件, 如果文件原先存在，会被替换。
<code>data</code> 可以是一个string，也可以是一个原生buffer。

</p>
<p>The <code>encoding</code> option is ignored if <code>data</code> is a buffer. It defaults
to <code>&apos;utf8&apos;</code>.

</p>
<p><code>encoding</code> 选项会被忽视如果 <code>data</code> 不是string而是原生buffer。<code>encoding</code>缺省为 <code>&apos;utf8&apos;</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;It\&apos;s saved!&apos;); //文件被保存
});</code></pre>
<h2>fs.writeFileSync(filename, data, [options])<span><a href="all.html#all_fs_writefilesync_filename_data_options" id="all_fs_writefilesync_filename_data_options">#</a></span></h2>
<p>The synchronous version of <code>fs.writeFile</code>.

</p>
<p><code>fs.writeFile</code>的同步版本。

</p>
<h2>fs.appendFile(filename, data, [options], callback)<span><a href="all.html#all_fs_appendfile_filename_data_options_callback" id="all_fs_appendfile_filename_data_options_callback">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;a&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;a&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously append data to a file, creating the file if it not yet exists.
<code>data</code> can be a string or a buffer.

</p>
<p>异步的将数据添加到一个文件的尾部，如果文件不存在，会创建一个新的文件。
<code>data</code> 可以是一个string，也可以是原生buffer。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>fs.appendFile(&apos;message.txt&apos;, &apos;data to append&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;The &quot;data to append&quot; was appended to file!&apos;); //数据被添加到文件的尾部
});</code></pre>
<h2>fs.appendFileSync(filename, data, [options])<span><a href="all.html#all_fs_appendfilesync_filename_data_options" id="all_fs_appendfilesync_filename_data_options">#</a></span></h2>
<p>The synchronous version of <code>fs.appendFile</code>.

</p>
<p><code>fs.appendFile</code>的同步版本。

</p>
<h2>fs.watchFile(filename, [options], listener)<span><a href="all.html#all_fs_watchfile_filename_options_listener" id="all_fs_watchfile_filename_options_listener">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定.   尽可能的话推荐使用 fs.watch 来代替。</code></pre>
<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each
time the file is accessed.

</p>
<p>监视<code>filename</code>指定的文件的改变. 回调函数 <code>listener</code> 会在文件每一次被访问时被调用。

</p>
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing two members a boolean, <code>persistent</code>, and <code>interval</code>. <code>persistent</code>
indicates whether the process should continue to run as long as files are
being watched. <code>interval</code> indicates how often the target should be polled,
in milliseconds. The default is <code>{ persistent: true, interval: 5007 }</code>.

</p>
<p>第二个参数是可选的。 如果提供此参数，<code>options</code> 应该是包含两个成员<code>persistent</code>和<code>interval</code>的对象，其中<code>persistent</code>值为boolean类型。<code>persistent</code>指定进程是否应该在文件被监视（watch）时继续运行，<code>interval</code>指定了目标文件被查询的间隔，以毫秒为单位。缺省值为<code>{ persistent: true, interval: 5007 }</code>。

</p>
<p>The <code>listener</code> gets two arguments the current stat object and the previous
stat object:

</p>
<p><code>listener</code> 有两个参数，第一个为文件现在的状态，第二个为文件的前一个状态。

</p>
<pre><code>fs.watchFile(&apos;message.text&apos;, function (curr, prev) {
  console.log(&apos;the current mtime is: &apos; + curr.mtime);
  console.log(&apos;the previous mtime was: &apos; + prev.mtime);
});</code></pre>
<p>These stat objects are instances of <code>fs.Stat</code>.

</p>
<p><code>listener</code>中的文件状态对象类型为<code>fs.Stat</code>。

</p>
<p>If you want to be notified when the file was modified, not just accessed
you need to compare <code>curr.mtime</code> and <code>prev.mtime</code>.

</p>
<p>如果你只想在文件被修改时被告知，而不是仅仅在被访问时就告知，你应当在<code>listener</code>回调函数中比较下两个状态对象的<code>mtime</code>属性。即<code>curr.mtime</code> 和 <code>prev.mtime</code>.

</p>
<h2>fs.unwatchFile(filename, [listener])<span><a href="all.html#all_fs_unwatchfile_filename_listener" id="all_fs_unwatchfile_filename_listener">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定.   尽可能的话推荐使用 fs.watch 来代替。</code></pre>
<p>Stop watching for changes on <code>filename</code>. If <code>listener</code> is specified, only that
particular listener is removed. Otherwise, <em>all</em> listeners are removed and you
have effectively stopped watching <code>filename</code>.

</p>
<p>停止监视文件名为 <code>filename</code>的文件. 如果 <code>listener</code> 参数被指定, 会移除在<code>fs.watchFile</code>函数中指定的那一个listener回调函数。 否则, <em>所有的</em> 回调函数都会被移除，你将彻底停止监视<code>filename</code>文件。

</p>
<p>Calling <code>fs.unwatchFile()</code> with a filename that is not being watched is a
no-op, not an error.

</p>
<p>调用 <code>fs.unwatchFile()</code> 时，传递的文件名为未被监视的文件时，不会发生错误，而会发生一个no-op。

</p>
<h2>fs.watch(filename, [options], [listener])<span><a href="all.html#all_fs_watch_filename_options_listener" id="all_fs_watch_filename_options_listener">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定的</code></pre>
<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a
directory.  The returned object is a <a href="all.html#fs_class_fs_fswatcher">fs.FSWatcher</a>.

</p>
<p>观察指定路径的改变，<code>filename</code> 路径可以是文件或者目录。改函数返回的对象是 <a href="all.html#fs_class_fs_fswatcher">fs.FSWatcher</a>。

</p>
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing a boolean member <code>persistent</code>, which indicates whether the process
should continue to run as long as files are being watched. The default is
<code>{ persistent: true }</code>.

</p>
<p>第二个参数是可选的. 如果 <code>options</code> 选项被提供那么它应当是一个只包含成员<code>persistent</code>得对象，
<code>persistent</code>为boolean类型。<code>persistent</code>指定了进程是否“只要文件被监视就继续执行”缺省值为
<code>{ persistent: true }</code>.

</p>
<p>The listener callback gets two arguments <code>(event, filename)</code>.  <code>event</code> is either
&apos;rename&apos; or &apos;change&apos;, and <code>filename</code> is the name of the file which triggered
the event.

</p>
<p>监听器的回调函数得到两个参数 <code>(event, filename)</code>。其中 <code>event</code> 是 &apos;rename&apos;（重命名）或者 &apos;change&apos;（改变），而 <code>filename</code> 则是触发事件的文件名。

</p>
<h3>注意事项<span><a href="all.html#all_24" id="all_24">#</a></span></h3>
<!--type=misc-->

<p>The <code>fs.watch</code> API is not 100% consistent across platforms, and is
unavailable in some situations.

</p>
<p><code>fs.watch</code> 不是完全跨平台的，且在某些情况下不可用。

</p>
<h4>可用性<span><a href="all.html#all_25" id="all_25">#</a></span></h4>
<!--type=misc-->

<p>This feature depends on the underlying operating system providing a way
to be notified of filesystem changes.

</p>
<p>此功能依赖于操作系统底层提供的方法来监视文件系统的变化。

</p>
<ul>
<li>On Linux systems, this uses <code>inotify</code>.</li>
<li>On BSD systems (including OS X), this uses <code>kqueue</code>.</li>
<li>On SunOS systems (including Solaris and SmartOS), this uses <code>event ports</code>.</li>
<li><p>On Windows systems, this feature depends on <code>ReadDirectoryChangesW</code>.</p>
</li>
<li><p>在 Linux 操作系统上，使用 <code>inotify</code>。</p>
</li>
<li>在 BSD 操作系统上 (包括 OS X)，使用 <code>kqueue</code>。</li>
<li>在 SunOS 操作系统上 (包括 Solaris 和 SmartOS)，使用 <code>event ports</code>。</li>
<li>在 Windows 操作系统上，该特性依赖于 <code>ReadDirectoryChangesW</code>。</li>
</ul>
<p>If the underlying functionality is not available for some reason, then
<code>fs.watch</code> will not be able to function.  For example, watching files or
directories on network file systems (NFS, SMB, etc.) often doesn&apos;t work
reliably or at all.

</p>
<p>如果系统底层函数出于某些原因不可用，那么 <code>fs.watch</code> 也就无法工作。例如，监视网络文件系统(如 NFS, SMB 等)的文件或者目录，就时常不能稳定的工作，有时甚至完全不起作用。

</p>
<p>You can still use <code>fs.watchFile</code>, which uses stat polling, but it is slower and
less reliable.

</p>
<p>你仍然可以调用使用了文件状态调查的 <code>fs.watchFile</code>，但是会比较慢而且比较不可靠。

</p>
<h4>文件名参数<span><a href="all.html#all_26" id="all_26">#</a></span></h4>
<!--type=misc-->

<p>Providing <code>filename</code> argument in the callback is not supported
on every platform (currently it&apos;s only supported on Linux and Windows).  Even
on supported platforms <code>filename</code> is not always guaranteed to be provided.
Therefore, don&apos;t assume that <code>filename</code> argument is always provided in the
callback, and have some fallback logic if it is null.

</p>
<p>在回调函数中提供的 <code>filename</code> 参数不是在每一个操作系统中都被支持（当下仅在Linux和Windows上支持）。
即便是在支持的系统中，<code>filename</code>也不能保证在每一次回调都被提供。因此，不要假设<code>filename</code>参数总会会在
回调函数中提供，在回调函数中添加检测<code>filename</code>是否为null的if判断语句。

</p>
<pre><code>fs.watch(&apos;somedir&apos;, function (event, filename) {
  console.log(&apos;event is: &apos; + event);
  if (filename) {
    console.log(&apos;filename provided: &apos; + filename);
  } else {
    console.log(&apos;filename not provided&apos;);
  }
});</code></pre>
<h2>fs.exists(path, callback)<span><a href="all.html#all_fs_exists_path_callback" id="all_fs_exists_path_callback">#</a></span></h2>
<p>Test whether or not the given path exists by checking with the file system.
Then call the <code>callback</code> argument with either true or false.  Example:

</p>
<p>检查指定路径的文件或者目录是否存在。接着通过 <code>callback</code> 传入的参数指明存在 (true) 或者不存在 (false)。示例:

</p>
<pre><code>fs.exists(&apos;/etc/passwd&apos;, function (exists) {
  util.debug(exists ? &quot;存在&quot; : &quot;不存在!&quot;);
});</code></pre>
<h2>fs.existsSync(path)<span><a href="all.html#all_fs_existssync_path" id="all_fs_existssync_path">#</a></span></h2>
<p>Synchronous version of <code>fs.exists</code>.

</p>
<p><code>fs.exists</code> 函数的同步版。

</p>
<h2>Class: fs.Stats<span><a href="all.html#all_class_fs_stats" id="all_class_fs_stats">#</a></span></h2>
<p>Objects returned from <code>fs.stat()</code>, <code>fs.lstat()</code> and <code>fs.fstat()</code> and their
synchronous counterparts are of this type.

</p>
<p><code>fs.stat()</code>, <code>fs.lstat()</code> 和 <code>fs.fstat()</code> 以及他们对应的同步版本返回的对象。

</p>
<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li>
<li><code>stats.isFIFO()</code></li>
<li><p><code>stats.isSocket()</code></p>
</li>
<li><p><code>stats.isFile()</code></p>
</li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (仅在与 <code>fs.lstat()</code>一起使用时合法)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<p>For a regular file <code>util.inspect(stats)</code> would return a string very
similar to this:

</p>
<p>对于一个普通文件使用 <code>util.inspect(stats)</code> 将会返回一个类似如下输出的字符串：

</p>
<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>
<p>Please note that <code>atime</code>, <code>mtime</code>, <code>birthtime</code>, and <code>ctime</code> are
instances of <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> object and to compare the values of
these objects you should use appropriate methods. For most general
uses <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> will return the number of
milliseconds elapsed since <em>1 January 1970 00:00:00 UTC</em> and this
integer should be sufficient for any comparison, however there
additional methods which can be used for displaying fuzzy information.
More details can be found in the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a>
page.

</p>
<p>请注意 <code>atime</code>, <code>mtime</code>, <code>birthtime</code>, and <code>ctime</code> 是
 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> 对象的实例。而且在比较这些对象的值时你应当使用合适的方法。
大部分情况下，使用 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> 将会返回自 <em>1 January 1970 00:00:00 UTC</em> 以来逝去的毫秒数，
而且这个整形值应该能满足任何比较的使用条件。但是仍然还有一些额外的方法可以用来显示一些模糊的信息。更多细节请查看
 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> 页面。

</p>
<h3>Stat Time Values<span><a href="all.html#all_stat_time_values" id="all_stat_time_values">#</a></span></h3>
<p>The times in the stat object have the following semantics:

</p>
<p>在状态对象（stat object）中的时间有以下语义：

</p>
<ul>
<li><code>atime</code> &quot;Access Time&quot; - Time when file data last accessed.  Changed
by the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>read(2)</code> system calls.</li>
<li><code>mtime</code> &quot;Modified Time&quot; - Time when file data last modified.
Changed by the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>write(2)</code> system calls.</li>
<li><code>ctime</code> &quot;Change Time&quot; - Time when file status was last changed
(inode data modification).  Changed by the <code>chmod(2)</code>, <code>chown(2)</code>,
<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>,
<code>read(2)</code>, and <code>write(2)</code> system calls.</li>
<li><p><code>birthtime</code> &quot;Birth Time&quot; -  Time of file creation. Set once when the
file is created.  On filesystems where birthtime is not available,
this field may instead hold either the <code>ctime</code> or
<code>1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code>0</code>).  On Darwin and
other FreeBSD variants, also set if the <code>atime</code> is explicitly set to
an earlier value than the current <code>birthtime</code> using the <code>utimes(2)</code>
system call.</p>
</li>
<li><p><code>atime</code> &quot;Access Time&quot; - 文件数据上次被访问的时间.<br>会被 <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>read(2)</code> 等系统调用改变。</p>
</li>
<li><code>mtime</code> &quot;Modified Time&quot; - 文件上次被修改的时间。
会被 <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>write(2)</code> 等系统调用改变。</li>
<li><code>ctime</code> &quot;Change Time&quot; - 文件状态上次改变的时间。
(inode data modification).  会被 <code>chmod(2)</code>, <code>chown(2)</code>,
<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>,
<code>read(2)</code>, and <code>write(2)</code> 等系统调用改变。</li>
<li><code>birthtime</code> &quot;Birth Time&quot; -  文件被创建的时间。 会在文件被创建时生成。
在一些不提供文件<code>birthtime</code>的文件系统中,
这个字段会被 <code>ctime</code> 或
<code>1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code>0</code>)来填充。  在 Darwin 和其他
 FreeBSD 系统变体中, 也将 <code>atime</code> 显式地设置成比它现在的 <code>birthtime</code> 更早的一个时间值，这个过程使用了<code>utimes(2)</code>系统调用。</li>
</ul>
<p>Prior to Node v0.12, the <code>ctime</code> held the <code>birthtime</code> on Windows
systems.  Note that as of v0.12, <code>ctime</code> is not &quot;creation time&quot;, and
on Unix systems, it never was.

</p>
<p>在Node v0.12版本之前, <code>ctime</code> 持有Windows系统的 <code>birthtime</code> 值. 注意在v.0.12版本中, <code>ctime</code> 不再是&quot;creation time&quot;, 而且在Unix系统中，他从来都不是。

</p>
<h2>fs.createReadStream(path, [options])<span><a href="all.html#all_fs_createreadstream_path_options" id="all_fs_createreadstream_path_options">#</a></span></h2>
<p>Returns a new ReadStream object (See <code>Readable Stream</code>).

</p>
<p>返回一个新的 ReadStream 对象 (详见 <code>Readable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ flags: &apos;r&apos;,
  encoding: null,
  fd: null,
  mode: 0666,
  autoClose: true
}</code></pre>
<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and
start at 0. The <code>encoding</code> can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.

</p>
<p><code>options</code> 可以提供 <code>start</code> 和 <code>end</code> 值用于读取文件内的特定范围而非整个文件。
<code>start</code> 和 <code>end</code> 都是包含在范围内的（inclusive, 可理解为闭区间）并且以 0 开始。
<code>encoding</code> 可选为 <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> 或者 <code>&apos;base64&apos;</code>。

</p>
<p>If <code>autoClose</code> is false, then the file descriptor won&apos;t be closed, even if
there&apos;s an error.  It is your responsibility to close it and make sure
there&apos;s no file descriptor leak.  If <code>autoClose</code> is set to true (default
behavior), on <code>error</code> or <code>end</code> the file descriptor will be closed
automatically.

</p>
<p>如果 <code>autoClose</code> 为 false 则即使在发生错误时也不会关闭文件描述符 (file descriptor)。
此时你需要负责关闭文件，避免文件描述符泄露 (leak)。
如果 <code>autoClose</code> 为 true （缺省值），
当发生 <code>error</code> 或者 <code>end</code> 事件时，文件描述符会被自动释放。

</p>
<p>An example to read the last 10 bytes of a file which is 100 bytes long:

</p>
<p>一个从100字节的文件中读取最后10字节的例子：

</p>
<pre><code>fs.createReadStream(&apos;sample.txt&apos;, {start: 90, end: 99});</code></pre>
<h2>Class: fs.ReadStream<span><a href="all.html#all_class_fs_readstream" id="all_class_fs_readstream">#</a></span></h2>
<p><code>ReadStream</code> is a <a href="stream.html#stream_class_stream_readable">Readable Stream</a>.

</p>
<p><code>ReadStream</code> 是一个可读的流<a href="stream.html#stream_class_stream_readable">(Readable Stream)</a>.

</p>
<h3>事件: &apos;open&apos;<span><a href="all.html#all_open" id="all_open">#</a></span></h3>
<div><ul>
<li><p><code>fd</code> <span>Integer</span> file descriptor used by the ReadStream.</p>
</li>
<li><p><code>fd</code> <span>整形</span> ReadStream 所使用的文件描述符。</p>
</li>
</div></ul>
<p>Emitted when the ReadStream&apos;s file is opened.

</p>
<p>当文件的 ReadStream 被创建时触发。

</p>
<h2>fs.createWriteStream(path, [options])<span><a href="all.html#all_fs_createwritestream_path_options" id="all_fs_createwritestream_path_options">#</a></span></h2>
<p>Returns a new WriteStream object (See <code>Writable Stream</code>).

</p>
<p>返回一个新的 WriteStream 对象 (详见 <code>Writable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ flags: &apos;w&apos;,
  encoding: null,
  mode: 0666 }</code></pre>
<p><code>options</code> may also include a <code>start</code> option to allow writing data at
some position past the beginning of the file.  Modifying a file rather
than replacing it may require a <code>flags</code> mode of <code>r+</code> rather than the
default mode <code>w</code>.

</p>
<p><code>options</code> 也可以包含一个 <code>start</code> 选项用于指定在文件中开始写入数据的位置。
修改而不替换文件需要 <code>flags</code> 的模式指定为 <code>r+</code> 而不是默值的 <code>w</code>.

</p>
<h2>Class: fs.WriteStream<span><a href="all.html#all_class_fs_writestream" id="all_class_fs_writestream">#</a></span></h2>
<p><code>WriteStream</code> is a <a href="stream.html#stream_class_stream_writable">Writable Stream</a>.

</p>
<p><code>WriteStream</code> 是一个可写的流<a href="stream.html#stream_class_stream_writable">(Writable Stream)</a>.

</p>
<h3>事件: &apos;open&apos;<span><a href="all.html#all_open_1" id="all_open_1">#</a></span></h3>
<div><ul>
<li><p><code>fd</code> <span>Integer</span> file descriptor used by the WriteStream.</p>
</li>
<li><p><code>fd</code> <span>整形</span> WriteStream 所使用的文件描述符。</p>
</li>
</div></ul>
<p>Emitted when the WriteStream&apos;s file is opened.

</p>
<p>当 WriteStream 创建时触发。

</p>
<h3>file.bytesWritten<span><a href="all.html#all_file_byteswritten" id="all_file_byteswritten">#</a></span></h3>
<p>The number of bytes written so far. Does not include data that is still queued
for writing.

</p>
<p>已写的字节数。不包含仍在队列中准备写入的数据。

</p>
<h2>Class: fs.FSWatcher<span><a href="all.html#all_class_fs_fswatcher" id="all_class_fs_fswatcher">#</a></span></h2>
<p>Objects returned from <code>fs.watch()</code> are of this type.

</p>
<p><code>fs.watch()</code> 返回的对象类型。

</p>
<h3>watcher.close()<span><a href="all.html#all_watcher_close" id="all_watcher_close">#</a></span></h3>
<p>Stop watching for changes on the given <code>fs.FSWatcher</code>.

</p>
<p>停止观察 <code>fs.FSWatcher</code> 对象中的更改。

</p>
<h3>事件: &apos;change&apos;<span><a href="all.html#all_change" id="all_change">#</a></span></h3>
<div><ul>
<li><code>event</code> <span>String</span> The type of fs change</li>
<li><p><code>filename</code> <span>String</span> The filename that changed (if relevant/available)</p>
</li>
<li><p><code>event</code> <span>字符串</span> fs 改变的类型</p>
</li>
<li><code>filename</code> <span>字符串</span> 改变的文件名 (if relevant/available)</li>
</div></ul>
<p>Emitted when something changes in a watched directory or file.
See more details in <a href="all.html#fs_fs_watch_filename_options_listener">fs.watch</a>.

</p>
<p>当正在观察的目录或文件发生变动时触发。更多细节，详见 <a href="all.html#fs_fs_watch_filename_options_listener">fs.watch</a>。

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_2" id="all_error_2">#</a></span></h3>
<div><ul>
<li><p><code>error</code> <span>Error object</span></p>
</li>
<li><p><code>error</code> <span>Error 对象</span></p>
</li>
</div></ul>
<p>Emitted when an error occurs.


</p>
<p>当产生错误时触发
</p>
<h1>路径 (Path)<span><a href="all.html#all_path" id="all_path">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>This module contains utilities for handling and transforming file
paths.  Almost all these methods perform only string transformations.
The file system is not consulted to check whether paths are valid.

</p>
<p>本模块包含一套用于处理和转换文件路径的工具集。几乎所有的方法仅对字符串进行转换，
文件系统是不会检查路径是否真实有效的。

</p>
<p>Use <code>require(&apos;path&apos;)</code> to use this module.  The following methods are provided:

</p>
<p>通过 <code>require(&apos;path&apos;)</code> 来加载此模块。以下是本模块所提供的方法：

</p>
<h2>path.normalize(p)<span><a href="all.html#all_path_normalize_p" id="all_path_normalize_p">#</a></span></h2>
<p>Normalize a string path, taking care of <code>&apos;..&apos;</code> and <code>&apos;.&apos;</code> parts.

</p>
<p>规范化字符串路径，注意 <code>&apos;..&apos;</code> 和 `&apos;.&apos; 部分

</p>
<p>When multiple slashes are found, they&apos;re replaced by a single one;
when the path contains a trailing slash, it is preserved.
On Windows backslashes are used.

</p>
<p>当发现有多个连续的斜杠时，会替换成一个；
当路径末尾包含斜杠时，会保留；
在 Windows 系统会使用反斜杠。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.join([path1], [path2], [...])<span><a href="all.html#all_path_join_path1_path2" id="all_path_join_path1_path2">#</a></span></h2>
<p>Join all arguments together and normalize the resulting path.

</p>
<p>组合参数中的所有路径，返回规范化后的路径。

</p>
<p>Arguments must be strings.  In v0.8, non-string arguments were
silently ignored.  In v0.10 and up, an exception is thrown.

</p>
<p>参数必须是字符串。在 v0.8 版本非字符串参数会被悄悄忽略。
在 v0.10 及以后版本将会抛出一个异常。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.join(&apos;foo&apos;, {}, &apos;bar&apos;)
// 抛出异常
TypeError: Arguments to path.join must be strings</code></pre>
<h2>path.resolve([from ...], to)<span><a href="all.html#all_path_resolve_from_to" id="all_path_resolve_from_to">#</a></span></h2>
<p>Resolves <code>to</code> to an absolute path.

</p>
<p>将 <code>to</code> 参数解析为一个绝对路径。

</p>
<p>If <code>to</code> isn&apos;t already absolute <code>from</code> arguments are prepended in right to left
order, until an absolute path is found. If after using all <code>from</code> paths still
no absolute path is found, the current working directory is used as well. The
resulting path is normalized, and trailing slashes are removed unless the path
gets resolved to the root directory. Non-string arguments are ignored.

</p>
<p>如果<code>to</code>不是一个相对于<code>from</code> 参数的绝对路径，<code>to</code>会被添加到<code>from</code>的右边，直到找出一个绝对路径为止。如果使用<code>from</code>路径且仍没有找到绝对路径时，使用当时路径作为目录。返回的结果已经规范化，得到的路径会去掉结尾的斜杠，除非得到的当前路径为root目录。非字符串参数将被忽略。

</p>
<p>Another way to think of it is as a sequence of <code>cd</code> commands in a shell.

</p>
<p>另一种思考方式就是像在shell里面用一系列的‘cd’命令一样.

</p>
<pre><code>path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</code></pre>
<p>Is similar to:

</p>
<p>相当于:

</p>
<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>
<p>The difference is that the different paths don&apos;t need to exist and may also be
files.

</p>
<p>不同的是，不同的路径不需要存在的，也可能是文件。

</p>
<p>Examples:

</p>
<p>示例:

</p>
<pre><code>path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)
// 如果当前工作目录为 /home/myself/node，它返回：
&apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos;</code></pre>
<h2>path.isAbsolute(path)<span><a href="all.html#all_path_isabsolute_path" id="all_path_isabsolute_path">#</a></span></h2>
<p>Determines whether <code>path</code> is an absolute path. An absolute path will always
resolve to the same location, regardless of the working directory.

</p>
<p>判定<code>path</code>是否为绝对路径。一个绝对路径总是指向一个相同的位置，无论当前工作目录是在哪里。

</p>
<p>Posix examples:

</p>
<p>Posix 示例:

</p>
<pre><code>path.isAbsolute(&apos;/foo/bar&apos;) // true
path.isAbsolute(&apos;/baz/..&apos;)  // true
path.isAbsolute(&apos;qux/&apos;)     // false
path.isAbsolute(&apos;.&apos;)        // false</code></pre>
<p>Windows examples:

</p>
<p>Windows 示例:

</p>
<pre><code>path.isAbsolute(&apos;//server&apos;)  // true
path.isAbsolute(&apos;C:/foo/..&apos;) // true
path.isAbsolute(&apos;bar\\baz&apos;)   // false
path.isAbsolute(&apos;.&apos;)         // false</code></pre>
<h2>path.relative(from, to)<span><a href="all.html#all_path_relative_from_to" id="all_path_relative_from_to">#</a></span></h2>
<p>Solve the relative path from <code>from</code> to <code>to</code>.

</p>
<p>解决从<code>from</code>到<code>to</code>的相对路径。

</p>
<p>At times we have two absolute paths, and we need to derive the relative
path from one to the other.  This is actually the reverse transform of
<code>path.resolve</code>, which means we see that:

</p>
<p>有时我们有2个绝对路径, 我们需要从中找出相对目录的起源目录。这完全是<code>path.resolve</code>的相反实现,我们可以看看是什么意思:

</p>
<pre><code>path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>
<p>Examples:

</p>
<p>示例:

</p>
<pre><code>path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;)
// 返回
&apos;../../impl/bbb&apos;</code></pre>
<h2>path.dirname(p)<span><a href="all.html#all_path_dirname_p" id="all_path_dirname_p">#</a></span></h2>
<p>Return the directory name of a path.  Similar to the Unix <code>dirname</code> command.

</p>
<p>返回路径中文件夹的名称.  类似于Unix的<code>dirname</code> 命令.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.dirname(&apos;/foo/bar/baz/asdf/quux&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.basename(p, [ext])<span><a href="all.html#all_path_basename_p_ext" id="all_path_basename_p_ext">#</a></span></h2>
<p>Return the last portion of a path.  Similar to the Unix <code>basename</code> command.

</p>
<p>返回路径中的最后哦一部分.  类似于Unix 的 <code>basename</code> 命令.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;, &apos;.html&apos;)
// returns
&apos;quux&apos;</code></pre>
<h2>path.extname(p)<span><a href="all.html#all_path_extname_p" id="all_path_extname_p">#</a></span></h2>
<p>Return the extension of the path, from the last &apos;.&apos; to end of string
in the last portion of the path.  If there is no &apos;.&apos; in the last portion
of the path or the first character of it is &apos;.&apos;, then it returns
an empty string.  Examples:

</p>
<p>返回路径中文件的扩展名, 在从最后一部分中的最后一个&apos;.&apos;到字符串的末尾。
如果在路径的最后一部分没有&apos;.&apos;，或者第一个字符是&apos;.&apos;，就返回一个
空字符串。 例子：

</p>
<pre><code>path.extname(&apos;index&apos;)
// returns
&apos;&apos;</code></pre>
<h2>path.sep<span><a href="all.html#all_path_sep" id="all_path_sep">#</a></span></h2>
<p>The platform-specific file separator. <code>&apos;\\&apos;</code> or <code>&apos;/&apos;</code>.

</p>
<p>特定平台的文件分隔工具. <code>&apos;\\&apos;</code> 或者 <code>&apos;/&apos;</code>.

</p>
<p>An example on *nix:

</p>
<p>*nix 上的例子:

</p>
<pre><code>&apos;foo/bar/baz&apos;.split(path.sep)
// returns
[&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]</code></pre>
<p>An example on Windows:

</p>
<p>Windows 上的例子:

</p>
<pre><code>&apos;foo\\bar\\baz&apos;.split(path.sep)
// returns
[&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]</code></pre>
<h2>path.delimiter<span><a href="all.html#all_path_delimiter" id="all_path_delimiter">#</a></span></h2>
<p>The platform-specific path delimiter, <code>;</code> or <code>&apos;:&apos;</code>.

</p>
<p>特定平台的路径分隔符, <code>;</code> 或者 <code>&apos;:&apos;</code>.

</p>
<p>An example on *nix:

</p>
<p>*nix 上的例子:

</p>
<pre><code>process.env.PATH.split(path.delimiter)
// returns
[&apos;/usr/bin&apos;, &apos;/bin&apos;, &apos;/usr/sbin&apos;, &apos;/sbin&apos;, &apos;/usr/local/bin&apos;]</code></pre>
<p>An example on Windows:

</p>
<p>Windows 上的例子:

</p>
<pre><code>console.log(process.env.PATH)
// &apos;C:\Windows\system32;C:\Windows;C:\Program Files\nodejs\&apos;

process.env.PATH.split(path.delimiter)
// returns
[&apos;C:\Windows\system32&apos;, &apos;C:\Windows&apos;, &apos;C:\Program Files\nodejs\&apos;]


process.env.PATH.split(path.delimiter)
// returns
[&apos;C:\Windows\system32&apos;, &apos;C:\Windows&apos;, &apos;C:\Program Files\nodejs\&apos;]</code></pre>
<h1>网络<span><a href="all.html#all_27" id="all_27">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include
this module with <code>require(&apos;net&apos;);</code>

</p>
<p><code>net</code> 模块封装了异步网络功能，提供了一些方法来创建服务器和客户端（称之为流）。您可以用 <code>require(&apos;net&apos;)</code> 来引入这个模块。

</p>
<h2>net.createServer([options], [connectionListener])<span><a href="all.html#all_net_createserver_options_connectionlistener" id="all_net_createserver_options_connectionlistener">#</a></span></h2>
<p>Creates a new TCP server. The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="all.html#net_event_connection">&apos;connection&apos;</a> event.

</p>
<p>创建一个新的 TCP 服务器。参数 <code>connectionListener</code> 会被自动作为 <a href="all.html#net_event_connection">&apos;connection&apos;</a> 事件的监听器。

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ allowHalfOpen: false
}</code></pre>
<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won&apos;t automatically send a FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the <code>end()</code> method explicitly.
See <a href="all.html#net_event_end">&apos;end&apos;</a> event for more information.

</p>
<p>如果允许半开连接 <code>allowHalfOpen</code> 被设置为 <code>true</code>，则当另一端的套接字发送 FIN 报文时套接字并不会自动发送 FIN 报文。套接字会变为不可读，但仍然可写。您应当明确地调用 <code>end()</code> 方法。详见 <a href="all.html#net_event_end">&apos;end&apos;</a> 事件。

</p>
<p>Here is an example of an echo server which listens for connections
on port 8124:

</p>
<p>下面是一个监听 8124 端口连接的应答服务器的例子：

</p>
<pre><code>var net = require(&apos;net&apos;);
var server = net.createServer(function(c) { // &apos;connection&apos; 监听器
  console.log(&apos;服务器已连接&apos;);
  c.on(&apos;end&apos;, function() {
    console.log(&apos;服务器已断开&apos;);
  });
  c.write(&apos;hello\r\n&apos;);
  c.pipe(c);
});
server.listen(8124, function() { // &apos;listening&apos; 监听器
  console.log(&apos;服务器已绑定&apos;);
});</code></pre>
<p>Test this by using <code>telnet</code>:

</p>
<p>使用 <code>telnet</code> 测试：

</p>
<pre><code>telnet localhost 8124</code></pre>
<p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would
just be changed to

</p>
<p>要监听套接字 <code>/tmp/echo.sock</code> 仅需更改倒数第三行代码：

</p>
<pre><code>server.listen(&apos;/tmp/echo.sock&apos;, function() { // &apos;listening&apos; 监听器</code></pre>
<p>Use <code>nc</code> to connect to a UNIX domain socket server:

</p>
<p>使用 <code>nc</code> 连接到一个 UNIX domain 套接字服务器：

</p>
<pre><code>nc -U /tmp/echo.sock</code></pre>
<h2>net.connect(options, [connectionListener])<span><a href="all.html#all_net_connect_options_connectionlistener" id="all_net_connect_options_connectionlistener">#</a></span></h2>
<h2>net.createConnection(options, [connectionListener])<span><a href="all.html#all_net_createconnection_options_connectionlistener" id="all_net_createconnection_options_connectionlistener">#</a></span></h2>
<h2>net.connect(options, [connectionListener])<span><a href="all.html#all_net_connect_options_connectionlistener_1" id="all_net_connect_options_connectionlistener_1">#</a></span></h2>
<h2>net.createConnection(options, [connectionListener])<span><a href="all.html#all_net_createconnection_options_connectionlistener_1" id="all_net_createconnection_options_connectionlistener_1">#</a></span></h2>
<p>Constructs a new socket object and opens the socket to the given location.
When the socket is established, the <a href="all.html#net_event_connect">&apos;connect&apos;</a> event will be emitted.

</p>
<p>构建一个新的套接字对象并打开所给位置的套接字。当套接字就绪时会触发 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件。

</p>
<p>For TCP sockets, <code>options</code> argument should be an object which specifies:

</p>
<p>对于 TCP 套接字，选项 <code>options</code> 参数应为一个指定下列参数的对象：

</p>
<ul>
<li><p><code>port</code>: Port the client should connect to (Required).</p>
</li>
<li><p><code>port</code>：客户端连接到的端口（必须）</p>
</li>
<li><p><code>host</code>: Host the client should connect to. Defaults to <code>&apos;localhost&apos;</code>.</p>
</li>
<li><p><code>host</code>：客户端连接到的主机，缺省为 <code>&apos;localhost&apos;</code></p>
</li>
<li><p><code>localAddress</code>: Local interface to bind to for network connections.</p>
</li>
<li><p><code>localAddress</code>：网络连接绑定的本地接口</p>
</li>
<li><p><code>family</code> : Version of IP stack. Defaults to <code>4</code>.</p>
</li>
<li><p><code>family</code>：IP 栈版本，缺省为 <code>4</code></p>
</li>
</ul>
<p>For UNIX domain sockets, <code>options</code> argument should be an object which specifies:

</p>
<p>对于 UNIX domain 套接字，选项 <code>options</code> 参数应当为一个指定下列参数的对象：

</p>
<ul>
<li><p><code>path</code>: Path the client should connect to (Required).</p>
</li>
<li><p><code>path</code>：客户端连接到的路径（必须）</p>
</li>
</ul>
<p>Common options are:

</p>
<p>通用选项：

</p>
<ul>
<li><p><code>allowHalfOpen</code>: if <code>true</code>, the socket won&apos;t automatically send
a FIN packet when the other end of the socket sends a FIN packet.
Defaults to <code>false</code>.  See <a href="all.html#net_event_end">&apos;end&apos;</a> event for more information.</p>
</li>
<li><p><code>allowHalfOpen</code>：允许半开连接，如果被设置为 <code>true</code>，则当另一端的套接字发送 FIN 报文时套接字并不会自动发送 FIN 报文。缺省为 <code>false</code>。详见 <a href="all.html#net_event_end">&apos;end&apos;</a> 事件。</p>
</li>
</ul>
<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p> <code>connectListener</code> 用于 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<p>下面是一个上述应答服务器的客户端的例子：

</p>
<pre><code>var net = require(&apos;net&apos;);
var client = net.connect({port: 8124},
    function() { //&apos;connect&apos; 监听器
  console.log(&apos;client connected&apos;);
  client.write(&apos;world!\r\n&apos;);
});
client.on(&apos;data&apos;, function(data) {
  console.log(data.toString());
  client.end();
});
client.on(&apos;end&apos;, function() {
  console.log(&apos;客户端断开连接&apos;);
});</code></pre>
<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be
changed to

</p>
<p>要连接到套接字 <code>/tmp/echo.sock</code>，仅需将第二行改为

</p>
<pre><code>var client = net.connect({path: &apos;/tmp/echo.sock&apos;},</code></pre>
<h2>net.connect(port, [host], [connectListener])<span><a href="all.html#all_net_connect_port_host_connectlistener" id="all_net_connect_port_host_connectlistener">#</a></span></h2>
<h2>net.createConnection(port, [host], [connectListener])<span><a href="all.html#all_net_createconnection_port_host_connectlistener" id="all_net_createconnection_port_host_connectlistener">#</a></span></h2>
<h2>net.connect(port, [host], [connectListener])<span><a href="all.html#all_net_connect_port_host_connectlistener_1" id="all_net_connect_port_host_connectlistener_1">#</a></span></h2>
<h2>net.createConnection(port, [host], [connectListener])<span><a href="all.html#all_net_createconnection_port_host_connectlistener_1" id="all_net_createconnection_port_host_connectlistener_1">#</a></span></h2>
<p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted,
<code>&apos;localhost&apos;</code> will be assumed.
The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p>创建一个 <code>host</code> 主机 <code>port</code> 端口的 TCP 连接。如果省略 <code>host</code> 则假定为 <code>&apos;localhost&apos;</code>。<code>connectListener</code> 参数会被用作 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器。

</p>
<h2>net.connect(path, [connectListener])<span><a href="all.html#all_net_connect_path_connectlistener" id="all_net_connect_path_connectlistener">#</a></span></h2>
<h2>net.createConnection(path, [connectListener])<span><a href="all.html#all_net_createconnection_path_connectlistener" id="all_net_createconnection_path_connectlistener">#</a></span></h2>
<h2>net.connect(path, [connectListener])<span><a href="all.html#all_net_connect_path_connectlistener_1" id="all_net_connect_path_connectlistener_1">#</a></span></h2>
<h2>net.createConnection(path, [connectListener])<span><a href="all.html#all_net_createconnection_path_connectlistener_1" id="all_net_createconnection_path_connectlistener_1">#</a></span></h2>
<p>Creates unix socket connection to <code>path</code>.
The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p>创建一个到路径 <code>path</code> 的 UNIX 套接字连接。<code>connectListener</code> 参数会被用作 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器。

</p>
<h2>类: net.Server<span><a href="all.html#all_net_server" id="all_net_server">#</a></span></h2>
<p>This class is used to create a TCP or UNIX server.
A server is a <code>net.Socket</code> that can listen for new incoming connections.

</p>
<p>该类用于创建一个 TCP 或 UNIX 服务器。服务器本质上是一个可监听传入连接的 <code>net.Socket</code>。

</p>
<h3>server.listen(port, [host], [backlog], [callback])<span><a href="all.html#all_server_listen_port_host_backlog_callback" id="all_server_listen_port_host_backlog_callback">#</a></span></h3>
<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>). A port value of zero will assign a random port.

</p>
<p>在指定端口 <code>port</code> 和主机 <code>host</code> 上开始接受连接。如果省略 <code>host</code> 则服务器会接受来自所有 IPv4 地址（<code>INADDR_ANY</code>）的连接；端口为 0 则会使用分随机分配的端口。

</p>
<p>Backlog is the maximum length of the queue of pending connections.
The actual length will be determined by your OS through sysctl settings such as
<code>tcp_max_syn_backlog</code> and <code>somaxconn</code> on linux. The default value of this
parameter is 511 (not 512).

</p>
<p>积压量 <code>backlog</code> 为连接等待队列的最大长度。实际长度由您的操作系统通过 sysctl 设置决定，比如 Linux 上的 <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。该参数缺省值为 511（不是 512）。

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="net.html#net_event_listening">&apos;listening&apos;</a> event will be emitted.  The last parameter <code>callback</code>
will be added as an listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.

</p>
<p>这是一个异步函数。当服务器已被绑定时会触发 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件。最后一个参数 <code>callback</code> 会被用作 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件的监听器。

</p>
<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. This means that
another server is already running on the requested port. One way of handling this
would be to wait a second and then try again. This can be done with

</p>
<p>有些用户会遇到的情况是遇到 &apos;EADDINUSE&apos; 错误。这表示另一个服务器已经运行在所请求的端口上。一个处理这种情况的方法是等待一段时间再重试

</p>
<pre><code>server.on(&apos;error&apos;, function (e) {
  if (e.code == &apos;EADDRINUSE&apos;) {
    console.log(&apos;地址被占用，重试中...&apos;);
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>
<p>(Note: All sockets in Node set <code>SO_REUSEADDR</code> already)

</p>
<p>（注意：Node 中的所有套接字已设置了 <code>SO_REUSEADDR</code>）

</p>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback" id="all_server_listen_path_callback">#</a></span></h3>
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.

</p>
<p>启动一个 UNIX 套接字服务器在所给路径 <code>path</code> 上监听连接。

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="net.html#net_event_listening">&apos;listening&apos;</a> event will be emitted.  The last parameter <code>callback</code>
will be added as an listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.

</p>
<p>这是一个异步函数。当服务器已被绑定时会触发 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件。最后一个参数 <code>callback</code> 会被用作 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件的监听器。

</p>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback" id="all_server_listen_handle_callback">#</a></span></h3>
<div><ul>
<li><code>handle</code> <span>Object</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>handle</code>处理器 <span>Object</span></p>
</li>
<li><code>callback</code>回调函数 <span>Function</span></li>
</div></ul>
<p>The <code>handle</code> object can be set to either a server or socket (anything
with an underlying <code>_handle</code> member), or a <code>{fd: &lt;n&gt;}</code> object.

</p>
<p><code>handle</code> 变量可以被设置为server 或者 socket(任一以下划线开头的成员 <code>_handle</code>), 或者一个 <code>{fd: &lt;n&gt;}</code> 对象

</p>
<p>This will cause the server to accept connections on the specified
handle, but it is presumed that the file descriptor or handle has
already been bound to a port or domain socket.

</p>
<p>这将使服务器用指定的句柄接受连接，但它假设文件描述符或者句柄已经被绑定在特定的端口或者域名套接字。

</p>
<p>Listening on a file descriptor is not supported on Windows.

</p>
<p>Windows 不支持监听一个文件描述符。

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="all.html#event_listening_">&apos;listening&apos;</a> event will be emitted.
the last parameter <code>callback</code> will be added as an listener for the
<a href="all.html#event_listening_">&apos;listening&apos;</a> event.

</p>
<p>这是一个异步函数。当服务器已被绑定时会触发 <a href="all.html#event_listening_">&apos;listening&apos;</a> 事件。最后一个参数 <code>callback</code> 会被用作 <a href="all.html#event_listening_">&apos;listening&apos;</a> 事件的监听器。

</p>
<h3>server.close([callback])<span><a href="all.html#all_server_close_callback" id="all_server_close_callback">#</a></span></h3>
<p>Stops the server from accepting new connections and keeps existing
connections. This function is asynchronous, the server is finally
closed when all connections are ended and the server emits a <code>&apos;close&apos;</code>
event. Optionally, you can pass a callback to listen for the <code>&apos;close&apos;</code>
event.

</p>
<p>用于停止服务器接受新连接，但保持已存在的连接。这是一个异步函数，
服务器将在所有的连接都结束后关闭，并且服务器发送 <code>&apos;close&apos;</code>事件
你可以有选择的传入回调函数来监听 <code>&apos;close&apos;</code>事件。

</p>
<h3>server.address()<span><a href="all.html#all_server_address_1" id="all_server_address_1">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the server
as reported by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address.
Returns an object with three properties, e.g.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<p>返回操作系统报告的绑定的地址，协议族和端口。
对查找操作系统分配的地址哪个端口已被分配非常有用， 如.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 获得随机端口
server.listen(function() {
  address = server.address();
  console.log(&quot;opened server on %j&quot;, address);
});</code></pre>
<p>Don&apos;t call <code>server.address()</code> until the <code>&apos;listening&apos;</code> event has been emitted.

</p>
<p>在 <code>&apos;listening&apos;</code> 事件发生前请勿调用 <code>server.address()</code>。

</p>
<h3>server.unref()<span><a href="all.html#all_server_unref" id="all_server_unref">#</a></span></h3>
<p>Calling <code>unref</code> on a server will allow the program to exit if this is the only
active server in the event system. If the server is already <code>unref</code>d calling
<code>unref</code> again will have no effect.

</p>
<p>如果这是事件系统中唯一一个活动的服务器，调用 <code>unref</code> 将允许程序退出。如果服务器已被 <code>unref</code>，则再次调用 <code>unref</code> 并不会产生影响。

</p>
<h3>server.ref()<span><a href="all.html#all_server_ref" id="all_server_ref">#</a></span></h3>
<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d server will <em>not</em>
let the program exit if it&apos;s the only server left (the default behavior). If
the server is <code>ref</code>d calling <code>ref</code> again will have no effect.

</p>
<p>与 <code>unref</code> 相反，如果这是仅剩的服务器，在一个之前被 <code>unref</code> 了的服务器上调用 <code>ref</code> 将不会让程序退出（缺省行为）。如果服务器已经被 <code>ref</code>，则再次调用 <code>ref</code> 并不会产生影响。

</p>
<h3>server.maxConnections<span><a href="all.html#all_server_maxconnections_1" id="all_server_maxconnections_1">#</a></span></h3>
<p>Set this property to reject connections when the server&apos;s connection count gets
high.

</p>
<p>设置这个选项能在当服务器连接数超过数量时拒绝连接。

</p>
<p>It is not recommended to use this option once a socket has been sent to a child
with <code>child_process.fork()</code>.

</p>
<p>这个选项不推荐使用在套接字已经用 <code>child_process.fork()</code>发送给子进程。

</p>
<h3>server.connections<span><a href="all.html#all_server_connections_1" id="all_server_connections_1">#</a></span></h3>
<p>This function is <strong>deprecated</strong>; please use [server.getConnections()][] instead.
The number of concurrent connections on the server.

</p>
<p>这个函数已被 <strong>废弃</strong>; 请用 [server.getConnections()][] 代替.
服务器的当前活动连接的数量。

</p>
<p>This becomes <code>null</code> when sending a socket to a child with
<code>child_process.fork()</code>. To poll forks and get current number of active
connections use asynchronous <code>server.getConnections</code> instead.

</p>
<p>当用<code>child_process.fork()</code>发送一个套接字给子进程时，它将是 <code>null</code> 。
要轮询子进程来获取当前活动的连接请用 <code>server.getConnections</code> 代替.

</p>
<p><code>net.Server</code> is an <a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<p><code>net.Server</code> 是一个包含下列事件的 <a href="events.html#events_class_events_eventemitter">EventEmitter</a> :

</p>
<h3>server.getConnections(callback)<span><a href="all.html#all_server_getconnections_callback" id="all_server_getconnections_callback">#</a></span></h3>
<p>Asynchronously get the number of concurrent connections on the server. Works
when sockets were sent to forks.

</p>
<p>异步获取服务器当前活跃的连接数. 
用于套接字呗发送给子进程。

</p>
<p>Callback should take two arguments <code>err</code> and <code>count</code>.

</p>
<p>回调函数需要两个参数 <code>err</code> 和 <code>count</code>.

</p>
<h3>事件: &apos;listening&apos;<span><a href="all.html#all_listening" id="all_listening">#</a></span></h3>
<p>Emitted when the server has been bound after calling <code>server.listen</code>.

</p>
<p>在服务器调用 <code>server.listen</code>绑定后触发。

</p>
<h3>事件: &apos;connection&apos;<span><a href="all.html#all_connection" id="all_connection">#</a></span></h3>
<div><ul>
<li><p><span>Socket object</span> The connection object</p>
</li>
<li><p><span>Socket object</span> 连接对象</p>
</li>
</div></ul>
<p>Emitted when a new connection is made. <code>socket</code> is an instance of
<code>net.Socket</code>.

</p>
<p>在一个新连接被创建时触发。 <code>socket</code> 是一个<code>net.Socket</code>的实例。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_1" id="all_close_1">#</a></span></h3>
<p>Emitted when the server closes. Note that if connections exist, this
event is not emitted until all connections are ended.

</p>
<p>当服务被关闭时触发. 注意：如果当前仍有活动连接，他个事件将等到所有连接都结束后才触发。

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_3" id="all_error_3">#</a></span></h3>
<div><ul>
<li><p><span>Error Object</span></p>
</li>
<li><p><span>Error Object</span></p>
</li>
</div></ul>
<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly
following this event.  See example in discussion of <code>server.listen</code>.

</p>
<p>当一个错误发生时触发。  <code>&apos;close&apos;</code> 事件将直接被下列时间调用。
请查看讨论 <code>server.listen</code>的例子。

</p>
<h2>类: net.Socket<span><a href="all.html#all_net_socket" id="all_net_socket">#</a></span></h2>
<p>This object is an abstraction of a TCP or UNIX socket.  <code>net.Socket</code>
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Node
and passed to the user through the <code>&apos;connection&apos;</code> event of a server.

</p>
<p>这个对象是一个TCP或UNIX套接字的抽象。  <code>net.Socket</code>
实例实现了一个双工流接口。 他们可以被用户使用在客户端(使用 <code>connect()</code>) 
或者它们可以由 Node创建，并通过 <code>&apos;connection&apos;</code>服务器事件传递给用户。

</p>
<h3>new net.Socket([options])<span><a href="all.html#all_new_net_socket_options" id="all_new_net_socket_options">#</a></span></h3>
<p>Construct a new socket object.

</p>
<p>构造一个新的套接字对象。

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ fd: null
  type: null
  allowHalfOpen: false
}</code></pre>
<p><code>fd</code> allows you to specify the existing file descriptor of socket. <code>type</code>
specified underlying protocol. It can be <code>&apos;tcp4&apos;</code>, <code>&apos;tcp6&apos;</code>, or <code>&apos;unix&apos;</code>.
About <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>&apos;end&apos;</code> event.

</p>
<p><code>fd</code> 允许你指定一个存在的文件描述符和套接字。
 <code>type</code> 指定一个优先的协议。 他可以是 <code>&apos;tcp4&apos;</code>, <code>&apos;tcp6&apos;</code>, 或 <code>&apos;unix&apos;</code>.
关于 <code>allowHalfOpen</code>, 参见 <code>createServer()</code> 和 <code>&apos;end&apos;</code> 事件。

</p>
<h3>socket.connect(port, [host], [connectListener])<span><a href="all.html#all_socket_connect_port_host_connectlistener" id="all_socket_connect_port_host_connectlistener">#</a></span></h3>
<h3>socket.connect(path, [connectListener])<span><a href="all.html#all_socket_connect_path_connectlistener" id="all_socket_connect_path_connectlistener">#</a></span></h3>
<h3>socket.connect(port, [host], [connectListener])<span><a href="all.html#all_socket_connect_port_host_connectlistener_1" id="all_socket_connect_port_host_connectlistener_1">#</a></span></h3>
<h3>socket.connect(path, [connectListener])<span><a href="all.html#all_socket_connect_path_connectlistener_1" id="all_socket_connect_path_connectlistener_1">#</a></span></h3>
<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,
then the socket will be opened as a TCP socket, if <code>host</code> is omitted,
<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be
opened as a unix socket to that path.

</p>
<p>使用传入的套接字打开一个连接 如果 <code>port</code> 和 <code>host</code> 都被传入，
那么套接字将会被已TCP套接字打开，如果 <code>host</code> 被省略,
默认为<code>localhost</code> . 如果 <code>path</code> 被传入,
套接字将会被已指定路径UNIX套接字打开。

</p>
<p>Normally this method is not needed, as <code>net.createConnection</code> opens the
socket. Use this only if you are implementing a custom Socket.

</p>
<p>一般情况下这个函数是不需要使用, 比如用 <code>net.createConnection</code> 打开套接字.
只有在您实现了自定义套接字时候才需要。

</p>
<p>This function is asynchronous. When the <a href="all.html#net_event_connect">&apos;connect&apos;</a> event is emitted the
socket is established. If there is a problem connecting, the <code>&apos;connect&apos;</code> event
will not be emitted, the <code>&apos;error&apos;</code> event will be emitted with the exception.

</p>
<p>这是一个异步函数。 当 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 触发了的套接字是established状态
.或者在连接的时候出现了一个问题, <code>&apos;connect&apos;</code> 事件不会被触发，
而 <code>&apos;error&apos;</code> 事件会触发并发送异常信息。

</p>
<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p> <code>connectListener</code> 用于 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器

</p>
<h3>socket.bufferSize<span><a href="all.html#all_socket_buffersize" id="all_socket_buffersize">#</a></span></h3>
<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to
help users get up and running quickly. The computer cannot always keep up
with the amount of data that is written to a socket - the network connection
simply might be too slow. Node will internally queue up the data written to a
socket and send it out over the wire when it is possible. (Internally it is
polling on the socket&apos;s file descriptor for being writable).

</p>
<p>是一个<code>net.Socket</code> 的属性，用于 <code>socket.write()</code> . 
用于帮助用户获取更快的运行速度。 计算机不能一直处于大量数据被写入状态 ——
网络链接可能会变得过慢。 Node 在内部会排队等候数据被写入套接字并确保传输连接上的数据完好。
(内部实现为：轮询套接字的文件描述符等待它为可写).

</p>
<p>The consequence of this internal buffering is that memory may grow. This
property shows the number of characters currently buffered to be written.
(Number of characters is approximately equal to the number of bytes to be
written, but the buffer may contain strings, and the strings are lazily
encoded, so the exact number of bytes is not known.)

</p>
<p>内部缓冲的可能后果是内存使用会增加。这个属性表示了现在处于缓冲区等待被写入的字符数。（字符的数目约等于要被写入的字节数，但是缓冲区可能包含字符串，而字符串是惰性编码的，所以确切的字节数是未知的。）

</p>
<p>Users who experience large or growing <code>bufferSize</code> should attempt to
&quot;throttle&quot; the data flows in their program with <code>pause()</code> and <code>resume()</code>.

</p>
<p>遇到数值很大或者增长很快的<code>bufferSize</code>的时候，用户应该尝试用<code>pause()</code>和<code>resume()</code>来控制数据流。

</p>
<h3>socket.setEncoding([encoding])<span><a href="all.html#all_socket_setencoding_encoding" id="all_socket_setencoding_encoding">#</a></span></h3>
<p>Set the encoding for the socket as a Readable Stream. See
<a href="stream.html#stream_stream_setencoding_encoding">stream.setEncoding()</a> for more information.

</p>
<p>设置套接字的编码为一个可读流. 
更多信息请查看 <a href="stream.html#stream_stream_setencoding_encoding">stream.setEncoding()</a> 

</p>
<h3>socket.write(data, [encoding], [callback])<span><a href="all.html#all_socket_write_data_encoding_callback" id="all_socket_write_data_encoding_callback">#</a></span></h3>
<p>Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.

</p>
<p>在套接字上发送数据。第二参数指明了使用字符串时的编码方式-默认为UTF8编码。

</p>
<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<p>如果所有数据被成功刷新到内核缓冲区，则返回<code>true</code>。如果所有或部分数据在用户内存里还处于队列中，则返回<code>false</code>。当缓冲区再次被释放时，<code>&apos;drain&apos;</code>事件会被分发。
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<p>The optional <code>callback</code> parameter will be executed when the data is finally
written out - this may not be immediately.

</p>
<p>当数据最终被完整写入时，可选的<code>callback</code>参数会被执行 - 但不一定是马上执行。

</p>
<h3>socket.end([data], [encoding])<span><a href="all.html#all_socket_end_data_encoding" id="all_socket_end_data_encoding">#</a></span></h3>
<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the
server will still send some data.

</p>
<p>半关闭套接字 如., 它发送一个 FIN 包 .可能服务器仍在发送数据。

</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<code>socket.write(data, encoding)</code> followed by <code>socket.end()</code>.

</p>
<p>如果 <code>data</code>被传入, 等同于调用
<code>socket.write(data, encoding)</code> 然后调用 <code>socket.end()</code>.

</p>
<h3>socket.destroy()<span><a href="all.html#all_socket_destroy" id="all_socket_destroy">#</a></span></h3>
<p>Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).

</p>
<p>确保没有I/O活动在这个套接字。
只有在错误发生情况下才需要（处理错误等等）。

</p>
<h3>socket.pause()<span><a href="all.html#all_socket_pause" id="all_socket_pause">#</a></span></h3>
<p>Pauses the reading of data. That is, <code>&apos;data&apos;</code> events will not be emitted.
Useful to throttle back an upload.

</p>
<p>暂停读取数据。 <code>&apos;data&apos;</code> 事件不会被触发。
对于控制上传非常有用。

</p>
<h3>socket.resume()<span><a href="all.html#all_socket_resume" id="all_socket_resume">#</a></span></h3>
<p>Resumes reading after a call to <code>pause()</code>.

</p>
<p>在调用 <code>pause()</code>后恢复读操作。

</p>
<h3>socket.setTimeout(timeout, [callback])<span><a href="all.html#all_socket_settimeout_timeout_callback" id="all_socket_settimeout_timeout_callback">#</a></span></h3>
<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on
the socket. By default <code>net.Socket</code> do not have a timeout.

</p>
<p>如果套接字超过<code>timeout</code>毫秒处于闲置状态，则将套接字设为超时。默认情况下<code>net.Socket</code>不存在超时。

</p>
<p>When an idle timeout is triggered the socket will receive a <code>&apos;timeout&apos;</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the socket.

</p>
<p>当一个闲置超时被触发时，套接字会接收到一个<code>&apos;timeout&apos;</code>事件，但是连接将不会被断开。用户必须手动<code>end()</code>或<code>destroy()</code>这个套接字。

</p>
<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.

</p>
<p>如果<code>timeout</code>为0，那么现有的闲置超时会被禁用。

</p>
<p>The optional <code>callback</code> parameter will be added as a one time listener for the
<code>&apos;timeout&apos;</code> event.

</p>
<p>可选的<code>callback</code>参数将会被添加成为<code>&apos;timeout&apos;</code>事件的一次性监听器。

</p>
<h3>socket.setNoDelay([noDelay])<span><a href="all.html#all_socket_setnodelay_nodelay" id="all_socket_setnodelay_nodelay">#</a></span></h3>
<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>true</code> for
<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.
<code>noDelay</code> defaults to <code>true</code>.

</p>
<p>禁用纳格（Nagle）算法。默认情况下TCP连接使用纳格算法，这些连接在发送数据之前对数据进行缓冲处理。 将<code>noDelay</code>设成<code>true</code>会在每次<code>socket.write()</code>被调用时立刻发送数据。<code>noDelay</code>默认为<code>true</code>。

</p>
<h3>socket.setKeepAlive([enable], [initialDelay])<span><a href="all.html#all_socket_setkeepalive_enable_initialdelay" id="all_socket_setkeepalive_enable_initialdelay">#</a></span></h3>
<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
<code>enable</code> defaults to <code>false</code>.

</p>
<p>禁用/启用长连接功能，并在第一个在闲置套接字上的长连接probe被发送之前，可选地设定初始延时。<code>enable</code>默认为<code>false</code>。

</p>
<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting. Defaults to <code>0</code>.

</p>
<p>设定<code>initialDelay</code> (毫秒)，来设定在收到的最后一个数据包和第一个长连接probe之间的延时。将initialDelay设成0会让值保持不变(默认值或之前所设的值)。默认为<code>0</code>。

</p>
<h3>socket.address()<span><a href="all.html#all_socket_address" id="all_socket_address">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
socket as reported by the operating system. Returns an object with
three properties, e.g.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<p>返回 socket 绑定的IP地址, 协议类型 (family name) 以及 端口号 (port). 具体是一个包含三个属性的对象, 形如 <code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<h3>socket.unref()<span><a href="all.html#all_socket_unref" id="all_socket_unref">#</a></span></h3>
<p>Calling <code>unref</code> on a socket will allow the program to exit if this is the only
active socket in the event system. If the socket is already <code>unref</code>d calling
<code>unref</code> again will have no effect.

</p>
<p>如果这是事件系统中唯一一个活动的套接字，调用 <code>unref</code> 将允许程序退出。如果套接字已被 <code>unref</code>，则再次调用 <code>unref</code> 并不会产生影响。

</p>
<h3>socket.ref()<span><a href="all.html#all_socket_ref" id="all_socket_ref">#</a></span></h3>
<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d socket will <em>not</em>
let the program exit if it&apos;s the only socket left (the default behavior). If
the socket is <code>ref</code>d calling <code>ref</code> again will have no effect.

</p>
<p>与 <code>unref</code> 相反，如果这是仅剩的套接字，在一个之前被 <code>unref</code> 了的套接字上调用 <code>ref</code> 将<em>不会</em>让程序退出（缺省行为）。如果一个套接字已经被 <code>ref</code>，则再次调用 <code>ref</code> 并不会产生影响。

</p>
<h3>socket.remoteAddress<span><a href="all.html#all_socket_remoteaddress" id="all_socket_remoteaddress">#</a></span></h3>
<p>The string representation of the remote IP address. For example,
<code>&apos;74.125.127.100&apos;</code> or <code>&apos;2001:4860:a005::68&apos;</code>.

</p>
<p>远程IP地址的字符串表示。例如，<code>&apos;74.125.127.100&apos;</code>或 <code>&apos;2001:4860:a005::68&apos;</code>。

</p>
<h3>socket.remotePort<span><a href="all.html#all_socket_remoteport" id="all_socket_remoteport">#</a></span></h3>
<p>The numeric representation of the remote port. For example,
<code>80</code> or <code>21</code>.

</p>
<p>远程端口的数值表示。例如，<code>80</code> 或 <code>21</code>。

</p>
<h3>socket.localAddress<span><a href="all.html#all_socket_localaddress" id="all_socket_localaddress">#</a></span></h3>
<p>The string representation of the local IP address the remote client is
connecting on. For example, if you are listening on <code>&apos;0.0.0.0&apos;</code> and the
client connects on <code>&apos;192.168.1.1&apos;</code>, the value would be <code>&apos;192.168.1.1&apos;</code>.

</p>
<p>远程客户端正在连接的本地IP地址的字符串表示。例如，如果你在监听<code>&apos;0.0.0.0&apos;</code>而客户端连接在<code>&apos;192.168.1.1&apos;</code>，这个值就会是 <code>&apos;192.168.1.1&apos;</code>。

</p>
<h3>socket.localPort<span><a href="all.html#all_socket_localport" id="all_socket_localport">#</a></span></h3>
<p>The numeric representation of the local port. For example,
<code>80</code> or <code>21</code>.

</p>
<p>本地端口的数值表示。比如<code>80</code> 或 <code>21</code>。

</p>
<h3>socket.bytesRead<span><a href="all.html#all_socket_bytesread" id="all_socket_bytesread">#</a></span></h3>
<p>The amount of received bytes.

</p>
<p>所接收的字节数。

</p>
<h3>socket.bytesWritten<span><a href="all.html#all_socket_byteswritten" id="all_socket_byteswritten">#</a></span></h3>
<p>The amount of bytes sent.

</p>
<p>所发送的字节数。

</p>
<p><code>net.Socket</code> instances are <a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<p><code>net.Socket</code>实例是带有以下事件的<a href="events.html#events_class_events_eventemitter">EventEmitter</a>对象：

</p>
<h3>事件: &apos;lookup&apos;<span><a href="all.html#all_lookup" id="all_lookup">#</a></span></h3>
<p>Emitted after resolving the hostname but before connecting.
Not applicable to UNIX sockets.

</p>
<p>这个事件在解析主机名之后，连接主机之前被分发。对UNIX套接字不适用。

</p>
<ul>
<li><code>err</code> {Error | Null} The error object.  See [dns.lookup()][].</li>
<li><code>address</code> {String} The IP address.</li>
<li><p><code>family</code> {String | Null} The address type.  See [dns.lookup()][].</p>
</li>
<li><p><code>err</code> {Error | Null} 错误对象。见[dns.lookup()][]。</p>
</li>
<li><code>address</code> {String} IP地址。</li>
<li><code>family</code> {String | Null} 得知类型。见[dns.lookup()][]。</li>
</ul>
<h3>事件: &apos;connect&apos;<span><a href="all.html#all_connect" id="all_connect">#</a></span></h3>
<p>Emitted when a socket connection is successfully established.
See <code>connect()</code>.

</p>
<p>该事件在一个套接字连接成功建立后被分发。见<code>connect()</code>。

</p>
<h3>事件: &apos;data&apos;<span><a href="all.html#all_data_1" id="all_data_1">#</a></span></h3>
<div><ul>
<li><p><span>Buffer object</span></p>
</li>
<li><p><span>Buffer object</span></p>
</li>
</div></ul>
<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or
<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.
(See the <a href="stream.html#stream_readable_stream">Readable Stream</a> section for more information.)

</p>
<p>当收到数据时被分发。<code>data</code>参数会是一个<code>Buffer</code>或<code>String</code>对象。数据的编码方式由<code>socket.setEncoding()</code>设定。
（详见 [可读流][] 章节）

</p>
<p>Note that the <strong>data will be lost</strong> if there is no listener when a <code>Socket</code>
emits a <code>&apos;data&apos;</code> event.

</p>
<p>请注意，如果一个<code>Socket</code>对象分发一个<code>&apos;data&apos;</code>事件时没有任何监听器存在，则 <strong>数据会丢失</strong>。

</p>
<h3>事件: &apos;end&apos;<span><a href="all.html#all_end_1" id="all_end_1">#</a></span></h3>
<p>Emitted when the other end of the socket sends a FIN packet.

</p>
<p>当套接字的另一端发送FIN包时，该事件被分发。

</p>
<p>By default (<code>allowHalfOpen == false</code>) the socket will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting <code>allowHalfOpen == true</code> the socket will not automatically <code>end()</code>
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to <code>end()</code> their side now.

</p>
<p>默认情况下 （<code>allowHalfOpen == false</code>），当套接字完成待写入队列中的任务时，它会destroy文件描述符。然而，如果把<code>allowHalfOpen</code>设成<code>true</code>，那么套接字将不会从它这边自动调用<code>end()</code>，使得用户可以随意写入数据，但同时使得用户自己需要调用<code>end()</code>。

</p>
<h3>事件: &apos;timeout&apos;<span><a href="all.html#all_timeout" id="all_timeout">#</a></span></h3>
<p>Emitted if the socket times out from inactivity. This is only to notify that
the socket has been idle. The user must manually close the connection.

</p>
<p>当套接字因为非活动状态而超时时该事件被分发。这只是用来表明套接字处于空闲状态。用户必须手动关闭这个连接。

</p>
<p>See also: <code>socket.setTimeout()</code>

</p>
<p>参阅：<code>socket.setTimeout()</code>

</p>
<h3>事件: &apos;drain&apos;<span><a href="all.html#all_drain_1" id="all_drain_1">#</a></span></h3>
<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.

</p>
<p>当写入缓冲被清空时产生。可被用于控制上传流量。

</p>
<p>See also: the return values of <code>socket.write()</code>

</p>
<p>参阅：<code>socket.write()</code> 的返回值

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_4" id="all_error_4">#</a></span></h3>
<div><ul>
<li><p><span>Error object</span></p>
</li>
<li><p><span>Error object</span></p>
</li>
</div></ul>
<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly
following this event.

</p>
<p>当一个错误发生时产生。<code>&apos;close&apos;</code> 事件会紧接着该事件被触发。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_2" id="all_close_2">#</a></span></h3>
<div><ul>
<li><p><code>had_error</code> <span>Boolean</span> true if the socket had a transmission error</p>
</li>
<li><p><code>had_error</code> <span>Boolean</span> 如果套接字发生了传输错误则此字段为true</p>
</li>
</div></ul>
<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean
which says if the socket was closed due to a transmission error.

</p>
<p>当套接字完全关闭时该事件被分发。参数<code>had_error</code>是一个布尔值，表示了套接字是否因为一个传输错误而被关闭。

</p>
<h2>net.isIP(input)<span><a href="all.html#all_net_isip_input" id="all_net_isip_input">#</a></span></h2>
<p>Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.

</p>
<p>测试 input 是否 IP 地址。无效字符串返回 0；IP 版本 4 地址返回 4；IP 版本 6 地址返回 6。

</p>
<h2>net.isIPv4(input)<span><a href="all.html#all_net_isipv4_input" id="all_net_isipv4_input">#</a></span></h2>
<p>Returns true if input is a version 4 IP address, otherwise returns false.

</p>
<p>如果 input 为版本 4 地址则返回 true，否则返回 false。

</p>
<h2>net.isIPv6(input)<span><a href="all.html#all_net_isipv6_input" id="all_net_isipv6_input">#</a></span></h2>
<p>Returns true if input is a version 6 IP address, otherwise returns false.

</p>
<p>如果 input 为版本 6 地址则返回 true，否则返回 false。

</p>
<h1>UDP / 数据报套接字<span><a href="all.html#all_udp" id="all_udp">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!-- name=dgram -->

<p>Datagram sockets are available through <code>require(&apos;dgram&apos;)</code>.

</p>
<p>数据报套接字通过 <code>require(&apos;dgram&apos;)</code> 提供。

</p>
<p>Important note: the behavior of <code>dgram.Socket#bind()</code> has changed in v0.10
and is always asynchronous now.  If you have code that looks like this:

</p>
<p>重要提醒：<code>dgram.Socket#bind()</code> 的行为在 v0.10 中已改变，并且现在它总是异步的。如果您的代码看起来像这样：

</p>
<pre><code>var s = dgram.createSocket(&apos;udp4&apos;);
s.bind(1234);
s.addMembership(&apos;224.0.0.114&apos;);</code></pre>
<p>You have to change it to this:

</p>
<p>您需要将它改成这样：

</p>
<pre><code>var s = dgram.createSocket(&apos;udp4&apos;);
s.bind(1234, function() {
  s.addMembership(&apos;224.0.0.114&apos;);
});</code></pre>
<h2>dgram.createSocket(type, [callback])<span><a href="all.html#all_dgram_createsocket_type_callback" id="all_dgram_createsocket_type_callback">#</a></span></h2>
<div><ul>
<li><code>type</code> String. Either &apos;udp4&apos; or &apos;udp6&apos;</li>
<li><code>callback</code> Function. Attached as a listener to <code>message</code> events.
Optional</li>
<li><p>Returns: Socket object</p>
</li>
<li><p><code>type</code> String 可以是 &apos;udp4&apos; 或 &apos;udp6&apos;</p>
</li>
<li><code>callback</code> Function 可选，会被作为 <code>message</code> 事件的监听器。</li>
<li>返回：Socket 对象</li>
</div></ul>
<p>Creates a datagram Socket of the specified types.  Valid types are <code>udp4</code>
and <code>udp6</code>.

</p>
<p>创建一个指定类型的数据报 Socket。有效类型包括 <code>udp4</code> 和 <code>udp6</code>。

</p>
<p>Takes an optional callback which is added as a listener for <code>message</code> events.

</p>
<p>接受一个可选的回调，会被添加为 <code>message</code> 事件的监听器。

</p>
<p>Call <code>socket.bind</code> if you want to receive datagrams. <code>socket.bind()</code> will bind
to the &quot;all interfaces&quot; address on a random port (it does the right thing for
both <code>udp4</code> and <code>udp6</code> sockets). You can then retrieve the address and port
with <code>socket.address().address</code> and <code>socket.address().port</code>.

</p>
<p>如果您想接收数据报则可调用 <code>socket.bind</code>。<code>socket.bind()</code> 会绑定到“所有网络接口”地址的一个随机端口（<code>udp4</code> 和 <code>udp6</code> 皆是如此）。然后您可以通过 <code>socket.address().address</code> 和 <code>socket.address().port</code> 来取得地址和端口。

</p>
<h2>类: dgram.Socket<span><a href="all.html#all_dgram_socket" id="all_dgram_socket">#</a></span></h2>
<p>The dgram Socket class encapsulates the datagram functionality.  It
should be created via <code>dgram.createSocket(type, [callback])</code>.

</p>
<p>dgram Socket 类封装了数据报功能，可以通过 <code>dgram.createSocket(type, [callback])</code> 创建。

</p>
<h3>事件: &apos;message&apos;<span><a href="all.html#all_message" id="all_message">#</a></span></h3>
<div><ul>
<li><code>msg</code> Buffer object. The message</li>
<li><p><code>rinfo</code> Object. Remote address information</p>
</li>
<li><p><code>msg</code> Buffer 对象，消息</p>
</li>
<li><code>rinfo</code> Object，远程地址信息</li>
</div></ul>
<p>Emitted when a new datagram is available on a socket.  <code>msg</code> is a <code>Buffer</code> and
<code>rinfo</code> is an object with the sender&apos;s address information:

</p>
<p>当套接字中有新的数据报时发生。<code>msg</code> 是一个 <code>Buffer</code>，<code>rinfo</code> 是一个包含了发送者地址信息的对象：

</p>
<pre><code>socket.on(&apos;message&apos;, function(msg, rinfo) {
  console.log(&apos;收到 %d 字节，来自 %s:%d\n&apos;,
              msg.length, rinfo.address, rinfo.port);
});</code></pre>
<h3>事件: &apos;listening&apos;<span><a href="all.html#all_listening_1" id="all_listening_1">#</a></span></h3>
<p>Emitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets
are created.

</p>
<p>当一个套接字开始监听数据报时产生。它会在 UDP 套接字被创建时发生。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_3" id="all_close_3">#</a></span></h3>
<p>Emitted when a socket is closed with <code>close()</code>.  No new <code>message</code> events will be emitted
on this socket.

</p>
<p>当一个套接字被 <code>close()</code> 关闭时产生。之后这个套接字上不会再有 <code>message</code> 事件发生。

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_5" id="all_error_5">#</a></span></h3>
<div><ul>
<li><p><code>exception</code> Error object</p>
</li>
<li><p><code>exception</code> Error 对象</p>
</li>
</div></ul>
<p>Emitted when an error occurs.

</p>
<p>当发生错误时产生。

</p>
<h3>socket.send(buf, offset, length, port, address, [callback])<span><a href="all.html#all_socket_send_buf_offset_length_port_address_callback" id="all_socket_send_buf_offset_length_port_address_callback">#</a></span></h3>
<div><ul>
<li><code>buf</code> Buffer object.  Message to be sent</li>
<li><code>offset</code> Integer. Offset in the buffer where the message starts.</li>
<li><code>length</code> Integer. Number of bytes in the message.</li>
<li><code>port</code> Integer. destination port</li>
<li><code>address</code> String. destination IP</li>
<li><p><code>callback</code> Function. Callback when message is done being delivered.
Optional.</p>
</li>
<li><p><code>buf</code> Buffer 对象，要发送的消息</p>
</li>
<li><code>offset</code> Integer，Buffer 中消息起始偏移值。</li>
<li><code>length</code> Integer，消息的字节数。</li>
<li><code>port</code> Integer，目标端口</li>
<li><code>address</code> String，目标 IP</li>
<li><code>callback</code> Function，可选，当消息被投递后的回调。</li>
</div></ul>
<p>For UDP sockets, the destination port and IP address must be specified.  A string
may be supplied for the <code>address</code> parameter, and it will be resolved with DNS.  An
optional callback may be specified to detect any DNS errors and when <code>buf</code> may be
re-used.  Note that DNS lookups will delay the time that a send takes place, at
least until the next tick.  The only way to know for sure that a send has taken place
is to use the callback.

</p>
<p>对于 UDP 套接字，必须指定目标端口和 IP 地址。<code>address</code> 参数可以是一个字符串，它会被 DNS 解析。可选地可以指定一个回调以用于发现任何 DNS 错误或当 <code>buf</code> 可被重用。请注意 DNS 查询会将发送的时间推迟到至少下一个事件循环。确认发送完毕的唯一已知方法是使用回调。

</p>
<p>If the socket has not been previously bound with a call to <code>bind</code>, it&apos;s
assigned a random port number and bound to the &quot;all interfaces&quot; address
(0.0.0.0 for <code>udp4</code> sockets, ::0 for <code>udp6</code> sockets).

</p>
<p>如果套接字之前并未被调用 <code>bind</code> 绑定，则它会被分配一个随机端口并绑定到“所有网络接口”地址（<code>udp4</code> 套接字是 0.0.0.0；<code>udp6</code> 套接字是 ::0）。

</p>
<p>Example of sending a UDP packet to a random port on <code>localhost</code>;

</p>
<p>向 <code>localhost</code> 随机端口发送 UDP 报文的例子：

</p>
<pre><code>var dgram = require(&apos;dgram&apos;);
var message = new Buffer(&quot;Some bytes&quot;);
var client = dgram.createSocket(&quot;udp4&quot;);
client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err) {
  client.close();
});</code></pre>
<p><strong>A Note about UDP datagram size</strong>

</p>
<p><strong>关于 UDP 数据报大小的注意事项</strong>

</p>
<p>The maximum size of an <code>IPv4/v6</code> datagram depends on the <code>MTU</code> (<em>Maximum Transmission Unit</em>)
and on the <code>Payload Length</code> field size.

</p>
<p>一个 <code>IPv4/v6</code> 数据报的最大大小取决与 <code>MTU</code>（<em>最大传输单位</em>）和 <code>Payload Length</code> 字段大小。

</p>
<ul>
<li><p>The <code>Payload Length</code> field is <code>16 bits</code> wide, which means that a normal payload
cannot be larger than 64K octets including internet header and data
(65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header);
this is generally true for loopback interfaces, but such long datagrams
are impractical for most hosts and networks.</p>
</li>
<li><p><code>Payload Length</code> 字段宽 <code>16 bits</code>，意味着正常负载包括网络头和数据不能大于 64K（65,507 字节 = 65,535 − 8 字节 UDP 头 − 20 字节 IP 头）；这对环回接口通常是真的，但如此大的数据报对大多数主机和网络来说是不切实际的。</p>
</li>
<li><p>The <code>MTU</code> is the largest size a given link layer technology can support for datagrams.
For any link, <code>IPv4</code> mandates a minimum <code>MTU</code> of <code>68</code> octets, while the recommended <code>MTU</code>
for IPv4 is <code>576</code> (typically recommended as the <code>MTU</code> for dial-up type applications),
whether they arrive whole or in fragments.</p>
</li>
<li><p><code>MTU</code> 是一个给定的数据链路层技术能为数据报提供支持的最大大小。对于任何连接，<code>IPv4</code> 允许最小 <code>68</code> 字节的 <code>MTU</code>，而 IPv4 所推荐的 <code>MTU</code> 为 <code>576</code>（通常作为拨号类应用的推荐 <code>MTU</code>），无论它们是完整接收还是分片。</p>
<p>For <code>IPv6</code>, the minimum <code>MTU</code> is <code>1280</code> octets, however, the mandatory minimum
fragment reassembly buffer size is <code>1500</code> octets.
The value of <code>68</code> octets is very small, since most current link layer technologies have
a minimum <code>MTU</code> of <code>1500</code> (like Ethernet).</p>
<p>对于 <code>IPv6</code>，最小的 <code>MTU</code> 为 <code>1280</code> 字节，但所允许的最小碎片重组缓冲大小为 <code>1500</code> 字节。
<code>68</code> 的值是非常小的，因为现在大多数数据链路层技术有都具有 <code>1500</code> 的最小 <code>MTU</code>（比如以太网）。</p>
</li>
</ul>
<p>Note that it&apos;s impossible to know in advance the MTU of each link through which
a packet might travel, and that generally sending a datagram greater than
the (receiver) <code>MTU</code> won&apos;t work (the packet gets silently dropped, without
informing the source that the data did not reach its intended recipient).

</p>
<p>请注意我们不可能提前得知一个报文可能经过的每一个连接 MTU，因此通常情况下不能发送一个大于（接收者的）<code>MTU</code> 的数据报（报文会被悄悄地丢掉，而不会将数据没有到达它意图的接收者的消息告知来源）。

</p>
<h3>socket.bind(port, [address], [callback])<span><a href="all.html#all_socket_bind_port_address_callback" id="all_socket_bind_port_address_callback">#</a></span></h3>
<div><ul>
<li><code>port</code> Integer</li>
<li><code>address</code> String, Optional</li>
<li><p><code>callback</code> Function with no parameters, Optional. Callback when
binding is done.</p>
</li>
<li><p><code>port</code> Integer</p>
</li>
<li><code>address</code> String，可选</li>
<li><code>callback</code> 没有参数的 Function，可选，当绑定完成时被调用。</li>
</div></ul>
<p>For UDP sockets, listen for datagrams on a named <code>port</code> and optional
<code>address</code>. If <code>address</code> is not specified, the OS will try to listen on
all addresses.  After binding is done, a &quot;listening&quot; event is emitted
and the <code>callback</code>(if specified) is called. Specifying both a
&quot;listening&quot; event listener and <code>callback</code> is not harmful but not very
useful.

</p>
<p>对于 UDP 套接字，在一个具名端口 <code>port</code> 和可选的地址 <code>address</code> 上监听数据报。如果 <code>address</code> 未指定，则操作系统会尝试监听所有地址。当绑定完成后，一个 &quot;listening&quot; 事件会发生，并且回调 <code>callback</code>（如果指定）会被调用。同时指定 &quot;listening&quot; 事件监听器和 <code>callback</code> 并不会产生副作用，但也没什么用。

</p>
<p>A bound datagram socket keeps the node process running to receive
datagrams.

</p>
<p>一个绑定了的数据报套接字会保持 node 进程运行来接收数据报。

</p>
<p>If binding fails, an &quot;error&quot; event is generated. In rare case (e.g.
binding a closed socket), an <code>Error</code> may be thrown by this method.

</p>
<p>如果绑定失败，则一个 &quot;error&quot; 事件会被产生。在极少情况下（比如绑定一个已关闭的套接字），该方法会抛出一个 <code>Error</code>。

</p>
<p>Example of a UDP server listening on port 41234:

</p>
<p>一个监听端口 41234 的 UDP 服务器的例子：

</p>
<pre><code>server.bind(41234);
// 服务器正在监听 0.0.0.0:41234</code></pre>
<h3>socket.close()<span><a href="all.html#all_socket_close" id="all_socket_close">#</a></span></h3>
<p>Close the underlying socket and stop listening for data on it.

</p>
<p>关闭底层套接字并停止监听数据。

</p>
<h3>socket.address()<span><a href="all.html#all_socket_address_1" id="all_socket_address_1">#</a></span></h3>
<p>Returns an object containing the address information for a socket.  For UDP sockets,
this object will contain <code>address</code> , <code>family</code> and <code>port</code>.

</p>
<p>返回一个包含了套接字地址信息的对象。对于 UDP 套接字，该对象会包含地址 <code>address</code>、地址族 <code>family</code> 和端口号 <code>port</code>。

</p>
<h3>socket.setBroadcast(flag)<span><a href="all.html#all_socket_setbroadcast_flag" id="all_socket_setbroadcast_flag">#</a></span></h3>
<div><ul>
<li><p><code>flag</code> Boolean</p>
</li>
<li><p><code>flag</code> Boolean</p>
</li>
</div></ul>
<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When this option is set, UDP packets
may be sent to a local interface&apos;s broadcast address.

</p>
<p>设置或清除 <code>SO_BROADCAST</code> 套接字选项。当该选项被设置，则 UDP 报文可能被发送到一个本地接口的广播地址。

</p>
<h3>socket.setTTL(ttl)<span><a href="all.html#all_socket_setttl_ttl" id="all_socket_setttl_ttl">#</a></span></h3>
<div><ul>
<li><p><code>ttl</code> Integer</p>
</li>
<li><p><code>ttl</code> Integer</p>
</li>
</div></ul>
<p>Sets the <code>IP_TTL</code> socket option.  TTL stands for &quot;Time to Live,&quot; but in this context it
specifies the number of IP hops that a packet is allowed to go through.  Each router or
gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a
router, it will not be forwarded.  Changing TTL values is typically done for network
probes or when multicasting.

</p>
<p>设置 <code>IP_TTL</code> 套接字选项。TTL 表示“Time to Live”（生存时间），但在此上下文中它指的是报文允许通过的 IP 跃点数。各个转发报文的路由器或网关都会递减 TTL。如果 TTL 被一个路由器递减到 0，则它将不会被转发。改变 TTL 值通常被用于网络探测器或多播。

</p>
<p>The argument to <code>setTTL()</code> is a number of hops between 1 and 255.  The default on most
systems is 64.

</p>
<p><code>setTTL()</code> 的参数为介于 1 至 255 的跃点数。在大多数系统上缺省值为 64。

</p>
<h3>socket.setMulticastTTL(ttl)<span><a href="all.html#all_socket_setmulticastttl_ttl" id="all_socket_setmulticastttl_ttl">#</a></span></h3>
<div><ul>
<li><p><code>ttl</code> Integer</p>
</li>
<li><p><code>ttl</code> Integer</p>
</li>
</div></ul>
<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  TTL stands for &quot;Time to Live,&quot; but in this
context it specifies the number of IP hops that a packet is allowed to go through,
specifically for multicast traffic.  Each router or gateway that forwards a packet
decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.

</p>
<p>设置 <code>IP_MULTICAST_TTL</code> 套接字选项。TTL 表示“Time to Live”（生存时间），但在此上下文中它指的是报文允许通过的 IP 跃点数，特别是组播流量。各个转发报文的路由器或网关都会递减 TTL。如果 TTL 被一个路由器递减到 0，则它将不会被转发。

</p>
<p>The argument to <code>setMulticastTTL()</code> is a number of hops between 0 and 255.  The default on most
systems is 1.

</p>
<p><code>setMulticastTTL()</code> 的参数为介于 1 至 255 的跃点数。在大多数系统上缺省值为 1。

</p>
<h3>socket.setMulticastLoopback(flag)<span><a href="all.html#all_socket_setmulticastloopback_flag" id="all_socket_setmulticastloopback_flag">#</a></span></h3>
<div><ul>
<li><p><code>flag</code> Boolean</p>
</li>
<li><p><code>flag</code> Boolean</p>
</li>
</div></ul>
<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option.  When this option is set, multicast
packets will also be received on the local interface.

</p>
<p>设置或清除 <code>IP_MULTICAST_LOOP</code> 套接字选项。当该选项被设置时，组播报文也会被本地接口收到。

</p>
<h3>socket.addMembership(multicastAddress, [multicastInterface])<span><a href="all.html#all_socket_addmembership_multicastaddress_multicastinterface" id="all_socket_addmembership_multicastaddress_multicastinterface">#</a></span></h3>
<div><ul>
<li><code>multicastAddress</code> String</li>
<li><p><code>multicastInterface</code> String, Optional</p>
</li>
<li><p><code>multicastAddress</code> String</p>
</li>
<li><code>multicastInterface</code> String，可选</li>
</div></ul>
<p>Tells the kernel to join a multicast group with <code>IP_ADD_MEMBERSHIP</code> socket option.

</p>
<p>以 <code>IP_ADD_MEMBERSHIP</code> 套接字选项告诉内核加入一个组播分组。

</p>
<p>If <code>multicastInterface</code> is not specified, the OS will try to add membership to all valid
interfaces.

</p>
<p>如果未指定 <code>multicastInterface</code>，则操作系统会尝试向所有有效接口添加关系。

</p>
<h3>socket.dropMembership(multicastAddress, [multicastInterface])<span><a href="all.html#all_socket_dropmembership_multicastaddress_multicastinterface" id="all_socket_dropmembership_multicastaddress_multicastinterface">#</a></span></h3>
<div><ul>
<li><code>multicastAddress</code> String</li>
<li><p><code>multicastInterface</code> String, Optional</p>
</li>
<li><p><code>multicastAddress</code> String</p>
</li>
<li><code>multicastInterface</code> String，可选</li>
</div></ul>
<p>Opposite of <code>addMembership</code> - tells the kernel to leave a multicast group with
<code>IP_DROP_MEMBERSHIP</code> socket option. This is automatically called by the kernel
when the socket is closed or process terminates, so most apps will never need to call
this.

</p>
<p>与 <code>addMembership</code> 相反，以 <code>IP_DROP_MEMBERSHIP</code> 套接字选项告诉内核退出一个组播分组。当套接字被关闭或进程结束时内核会自动调用，因此大多数应用都没必要调用它。

</p>
<p>If <code>multicastInterface</code> is not specified, the OS will try to drop membership to all valid
interfaces.

</p>
<p>如果未指定 <code>multicastInterface</code>，则操作系统会尝试向所有有效接口移除关系。

</p>
<h3>socket.unref()<span><a href="all.html#all_socket_unref_1" id="all_socket_unref_1">#</a></span></h3>
<p>Calling <code>unref</code> on a socket will allow the program to exit if this is the only
active socket in the event system. If the socket is already <code>unref</code>d calling
<code>unref</code> again will have no effect.

</p>
<p>如果这是事件系统中唯一一个活动的套接字，调用 <code>unref</code> 将允许程序退出。如果套接字已被 <code>unref</code>，则再次调用 <code>unref</code> 并不会产生影响。

</p>
<h3>socket.ref()<span><a href="all.html#all_socket_ref_1" id="all_socket_ref_1">#</a></span></h3>
<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d socket will <em>not</em>
let the program exit if it&apos;s the only socket left (the default behavior). If
the socket is <code>ref</code>d calling <code>ref</code> again will have no effect.


</p>
<p>与 <code>unref</code> 相反，如果这是仅剩的套接字，在一个之前被 <code>unref</code> 了的套接字上调用 <code>ref</code> 将<em>不会</em>让程序退出（缺省行为）。如果一个套接字已经被 <code>ref</code>，则再次调用 <code>ref</code> 并不会产生影响。
</p>
<h1>DNS<span><a href="all.html#all_dns" id="all_dns">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Use <code>require(&apos;dns&apos;)</code> to access this module. All methods in the dns module
use C-Ares except for <code>dns.lookup</code> which uses <code>getaddrinfo(3)</code> in a thread
pool. C-Ares is much faster than <code>getaddrinfo</code> but the system resolver is
more constant with how other programs operate. When a user does
<code>net.connect(80, &apos;google.com&apos;)</code> or <code>http.get({ host: &apos;google.com&apos; })</code> the
<code>dns.lookup</code> method is used. Users who need to do a large number of lookups
quickly should use the methods that go through C-Ares.

</p>
<p>使用 <code>require(&apos;dns&apos;)</code> 引入此模块。dns 模块中的所有方法都使用了 C-Ares，除了 <code>dns.lookup</code> 使用了线程池中的 <code>getaddrinfo(3)</code>。C-Ares 比 <code>getaddrinfo</code> 要快得多，但系统解析器相对于其它程序的操作要更固定。当一个用户使用 <code>net.connect(80, &apos;google.com&apos;)</code> 或 <code>http.get({ host: &apos;google.com&apos; })</code> 时会使用 <code>dns.lookup</code> 方法。如果用户需要进行大量的快速查询，则最好使用 C-Ares 提供的方法。

</p>
<p>Here is an example which resolves <code>&apos;www.google.com&apos;</code> then reverse
resolves the IP addresses which are returned.

</p>
<p>下面是一个解析 <code>&apos;www.google.com&apos;</code> 并反向解析所返回 IP 地址的例子。

</p>
<pre><code>      console.log(&apos;反向解析 &apos; + a + &apos;: &apos; + JSON.stringify(domains));
    });
  });
});</code></pre>
<h2>dns.lookup(domain, [family], callback)<span><a href="all.html#all_dns_lookup_domain_family_callback" id="all_dns_lookup_domain_family_callback">#</a></span></h2>
<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into the first found A (IPv4) or
AAAA (IPv6) record.
The <code>family</code> can be the integer <code>4</code> or <code>6</code>. Defaults to <code>null</code> that indicates
both Ip v4 and v6 address family.

</p>
<p>将一个域名（比如 <code>&apos;google.com&apos;</code>）解析为第一个找到的 A 记录（IPv4）或 AAAA 记录（IPv6）。地址族 <code>family</code> 可以是数字 <code>4</code> 或 <code>6</code>，缺省为 <code>null</code> 表示同时允许 IPv4 和 IPv6 地址族。

</p>
<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument
is a string representation of a IP v4 or v6 address. The <code>family</code> argument
is either the integer 4 or 6 and denotes the family of <code>address</code> (not
necessarily the value initially passed to <code>lookup</code>).

</p>
<p>回调参数为 <code>(err, address, family)</code>。地址 <code>address</code> 参数为一个代表 IPv4 或 IPv6 地址的字符串。地址族 <code>family</code> 参数为数字 4 或 6，地表 <code>address</code> 的地址族（不一定是之前传入 <code>lookup</code> 的值）。

</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is the error code.
Keep in mind that <code>err.code</code> will be set to <code>&apos;ENOENT&apos;</code> not only when
the domain does not exist but also when the lookup fails in other ways
such as no available file descriptors.

</p>
<p>当错误发生时，<code>err</code> 为一个 <code>Error</code> 对象，其中 <code>err.code</code> 为错误代码。请记住 <code>err.code</code> 被设定为 <code>&apos;ENOENT&apos;</code> 的情况不仅是域名不存在，也可能是查询在其它途径出错，比如没有可用文件描述符时。

</p>
<h2>dns.resolve(domain, [rrtype], callback)<span><a href="all.html#all_dns_resolve_domain_rrtype_callback" id="all_dns_resolve_domain_rrtype_callback">#</a></span></h2>
<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into an array of the record types
specified by rrtype. Valid rrtypes are <code>&apos;A&apos;</code> (IPV4 addresses, default),
<code>&apos;AAAA&apos;</code> (IPV6 addresses), <code>&apos;MX&apos;</code> (mail exchange records), <code>&apos;TXT&apos;</code> (text
records), <code>&apos;SRV&apos;</code> (SRV records), <code>&apos;PTR&apos;</code> (used for reverse IP lookups),
<code>&apos;NS&apos;</code> (name server records) and <code>&apos;CNAME&apos;</code> (canonical name records).

</p>
<p>将一个域名（比如 <code>&apos;google.com&apos;</code>）解析为一个 <code>rrtype</code> 指定记录类型的数组。有效 <code>rrtypes</code> 取值有 <code>&apos;A&apos;</code>（IPv4 地址，缺省）、<code>&apos;AAAA&apos;</code>（IPv6 地址）、<code>&apos;MX&apos;</code>（邮件交换记录）、<code>&apos;TXT&apos;</code>（文本记录）、<code>&apos;SRV&apos;</code>（SRV 记录）、<code>&apos;PTR&apos;</code>（用于 IP 反向查找）、<code>&apos;NS&apos;</code>（域名服务器记录）和 <code>&apos;CNAME&apos;</code>（别名记录）。

</p>
<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item
in <code>addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.

</p>
<p>回调参数为 <code>(err, addresses)</code>。其中 <code>addresses</code> 中每一项的类型取决于记录类型，详见下文对应的查找方法。

</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is
one of the error codes listed below.

</p>
<p>当出错时，<code>err</code> 参数为一个 <code>Error</code> 对象，其中 <code>err.code</code> 为下文所列出的错误代码之一。

</p>
<h2>dns.resolve4(domain, callback)<span><a href="all.html#all_dns_resolve4_domain_callback" id="all_dns_resolve4_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).
<code>addresses</code> is an array of IPv4 addresses (e.g.
<code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>).

</p>
<p>于 <code>dns.resolve()</code> 一样，但只用于查询 IPv4（<code>A</code> 记录）。<code>addresses</code> 是一个 IPv4 地址的数组（比如 <code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>）。

</p>
<h2>dns.resolve6(domain, callback)<span><a href="all.html#all_dns_resolve6_domain_callback" id="all_dns_resolve6_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).

</p>
<p>类似于 <code>dns.resolve4()</code>，但用于 IPv6（<code>AAAA</code>）查询。

</p>
<h2>dns.resolveMx(domain, callback)<span><a href="all.html#all_dns_resolvemx_domain_callback" id="all_dns_resolvemx_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).

</p>
<p>类似于 <code>dns.resolve()</code>，但用于邮件交换查询（<code>MX</code> 记录）。

</p>
<p><code>addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>).

</p>
<p><code>addresses</code> 为一个 MX 记录的数组，每一项包含优先级和交换属性（比如 <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>）。

</p>
<h2>dns.resolveTxt(domain, callback)<span><a href="all.html#all_dns_resolvetxt_domain_callback" id="all_dns_resolvetxt_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).
<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,
<code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>).

</p>
<p>与 <code>dns.resolve()</code> 相似，但用于文本查询（<code>TXT</code> 记录）。<code>addresses</code> 为 <code>domain</code> 可用文本记录的数组（比如 <code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>）。

</p>
<h2>dns.resolveSrv(domain, callback)<span><a href="all.html#all_dns_resolvesrv_domain_callback" id="all_dns_resolvesrv_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).
<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties
of SRV records are priority, weight, port, and name (e.g.,
<code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>).

</p>
<p>查询 SRV 记录，与 <code>dns.resolve()</code> 相似。
<code>addresses</code> 是域名 <code>domain</code> 可用的 SRV 记录数组，
每一条记录都包含优先级（priority）、权重（weight）、端口号（port）、服务名称（name）等属性
(比如：  <code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>)。

</p>
<h2>dns.resolveNs(domain, callback)<span><a href="all.html#all_dns_resolvens_domain_callback" id="all_dns_resolvens_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for name server records (<code>NS</code> records).
<code>addresses</code> is an array of the name server records available for <code>domain</code>
(e.g., <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>).

</p>
<p>查询 NS 记录，与 <code>dns.resolve()</code> 相似。
<code>addresses</code> 是域名 <code>domain</code> 可用的 NS 记录数组，
(比如： <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>).

</p>
<h2>dns.resolveCname(domain, callback)<span><a href="all.html#all_dns_resolvecname_domain_callback" id="all_dns_resolvecname_domain_callback">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for canonical name records (<code>CNAME</code>
records). <code>addresses</code> is an array of the canonical name records available for
<code>domain</code> (e.g., <code>[&apos;bar.example.com&apos;]</code>).

</p>
<p>查询 CNAME 记录，与 <code>dns.resolve()</code> 相似。
<code>addresses</code> 是域名 <code>domain</code> 可用的 CNAME 记录数组，
(比如： <code>[&apos;bar.example.com&apos;]</code>).

</p>
<h2>dns.reverse(ip, callback)<span><a href="all.html#all_dns_reverse_ip_callback" id="all_dns_reverse_ip_callback">#</a></span></h2>
<p>Reverse resolves an ip address to an array of domain names.

</p>
<p>反向解析 IP 地址，返回指向该 IP 地址的域名数组。

</p>
<p>The callback has arguments <code>(err, domains)</code>.

</p>
<p>回调函数接收两个参数： <code>(err, domains)</code>.

</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is
one of the error codes listed below.

</p>
<p>当出错时，<code>err</code> 参数为一个 <code>Error</code> 对象，其中 <code>err.code</code> 为下文所列出的错误代码之一。

</p>
<h2>dns.getServers()<span><a href="all.html#all_dns_getservers" id="all_dns_getservers">#</a></span></h2>
<p>Returns an array of IP addresses as strings that are currently being used for
resolution

</p>
<p>已字符串返回一个当前用于解析的 IP 地址的数组。

</p>
<h2>dns.setServers(servers)<span><a href="all.html#all_dns_setservers_servers" id="all_dns_setservers_servers">#</a></span></h2>
<p>Given an array of IP addresses as strings, set them as the servers to use for
resolving

</p>
<p>指定一个 IP 地址字符串数组，将它们作为解析所用的服务器。

</p>
<p>If you specify a port with the address it will be stripped, as the underlying
library doesn&apos;t support that.

</p>
<p>如果您在地址中指定了端口，则端口会被忽略，因为底层库并不支持。

</p>
<p>This will throw if you pass invalid input.

</p>
<p>如果您传入无效参数，则会抛出异常。

</p>
<h2>错误代码<span><a href="all.html#all_28" id="all_28">#</a></span></h2>
<p>Each DNS query can return one of the following error codes:

</p>
<p>每个 DNS 查询都可能返回下列错误代码之一：

</p>
<ul>
<li><code>dns.NODATA</code>: DNS server returned answer with no data.</li>
<li><code>dns.FORMERR</code>: DNS server claims query was misformatted.</li>
<li><code>dns.SERVFAIL</code>: DNS server returned general failure.</li>
<li><code>dns.NOTFOUND</code>: Domain name not found.</li>
<li><code>dns.NOTIMP</code>: DNS server does not implement requested operation.</li>
<li><code>dns.REFUSED</code>: DNS server refused query.</li>
<li><code>dns.BADQUERY</code>: Misformatted DNS query.</li>
<li><code>dns.BADNAME</code>: Misformatted domain name.</li>
<li><code>dns.BADFAMILY</code>: Unsupported address family.</li>
<li><code>dns.BADRESP</code>: Misformatted DNS reply.</li>
<li><code>dns.CONNREFUSED</code>: Could not contact DNS servers.</li>
<li><code>dns.TIMEOUT</code>: Timeout while contacting DNS servers.</li>
<li><code>dns.EOF</code>: End of file.</li>
<li><code>dns.FILE</code>: Error reading file.</li>
<li><code>dns.NOMEM</code>: Out of memory.</li>
<li><code>dns.DESTRUCTION</code>: Channel is being destroyed.</li>
<li><code>dns.BADSTR</code>: Misformatted string.</li>
<li><code>dns.BADFLAGS</code>: Illegal flags specified.</li>
<li><code>dns.NONAME</code>: Given hostname is not numeric.</li>
<li><code>dns.BADHINTS</code>: Illegal hints flags specified.</li>
<li><code>dns.NOTINITIALIZED</code>: c-ares library initialization not yet performed.</li>
<li><code>dns.LOADIPHLPAPI</code>: Error loading iphlpapi.dll.</li>
<li><code>dns.ADDRGETNETWORKPARAMS</code>: Could not find GetNetworkParams function.</li>
<li><p><code>dns.CANCELLED</code>: DNS query cancelled.</p>
</li>
<li><p><code>dns.NODATA</code>: DNS 服务器返回无数据应答。</p>
</li>
<li><code>dns.FORMERR</code>: DNS 声称查询格式错误。</li>
<li><code>dns.SERVFAIL</code>: DNS 服务器返回一般失败。</li>
<li><code>dns.NOTFOUND</code>: 域名未找到。</li>
<li><code>dns.NOTIMP</code>: DNS 服务器未实现所请求操作。</li>
<li><code>dns.REFUSED</code>: DNS 服务器拒绝查询。</li>
<li><code>dns.BADQUERY</code>: DNS 查询格式错误。</li>
<li><code>dns.BADNAME</code>: 域名格式错误。</li>
<li><code>dns.BADFAMILY</code>: 不支持的地址类型。</li>
<li><code>dns.BADRESP</code>: DNS 答复格式错误。</li>
<li><code>dns.CONNREFUSED</code>: 无法联系 DNS 服务器。</li>
<li><code>dns.TIMEOUT</code>: 联系 DNS 服务器超时。</li>
<li><code>dns.EOF</code>: 文件末端。</li>
<li><code>dns.FILE</code>: 读取文件错误。</li>
<li><code>dns.NOMEM</code>: 超出内存。</li>
<li><code>dns.DESTRUCTION</code>: 通道正在被销毁。</li>
<li><code>dns.BADSTR</code>: 字符串格式错误。</li>
<li><code>dns.BADFLAGS</code>: 指定了非法标记。</li>
<li><code>dns.NONAME</code>: 所给主机名非数字。</li>
<li><code>dns.BADHINTS</code>: 指定了非法提示标记。</li>
<li><code>dns.NOTINITIALIZED</code>: c-ares 库初始化尚未进行。</li>
<li><code>dns.LOADIPHLPAPI</code>: 加载 iphlpapi.dll 出错。</li>
<li><code>dns.ADDRGETNETWORKPARAMS</code>: 无法找到 GetNetworkParams 函数。</li>
<li><p><code>dns.CANCELLED</code>: DNS 查询取消。</p>
<h1>HTTP<span><a href="all.html#all_http" id="all_http">#</a></span></h1>
<p>  稳定度: 3 - 稳定</p>
</li>
</ul>
<p>To use the HTTP server and client one must <code>require(&apos;http&apos;)</code>.

</p>
<p>要使用HTTP服务或客户端功能，需引用此模块<code>require(&apos;http&apos;)</code>.

</p>
<p>The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.

</p>
<p>Node中的HTTP接口的设计支持许多这个协议中原本用起来很困难的特性.特别是对于很大的或者块编码的消息.这些接口很谨慎,它从来不会完全缓存整个请求(request)或响应(response),这样用户可以在请求(request)或响应(response)中使用数据流.

</p>
<p>HTTP message headers are represented by an object like this:

</p>
<p>HTTP 的消息头(Headers)通过如下对象来表示:

</p>
<pre><code>{ &apos;content-length&apos;: &apos;123&apos;,
  &apos;content-type&apos;: &apos;text/plain&apos;,
  &apos;connection&apos;: &apos;keep-alive&apos;,
  &apos;host&apos;: &apos;mysite.com&apos;,
  &apos;accept&apos;: &apos;*/*&apos; }</code></pre>
<p>Keys are lowercased. Values are not modified.

</p>
<p>其中键为小写字母，值是不能修改的。

</p>
<p>In order to support the full spectrum of possible HTTP applications, Node&apos;s
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.

</p>
<p>为了能更加全面地支持HTTP应用，Node的HTTP API是很接近底层，它是可以处理数据流还有只转化消息。它把一个消息写到报文头和报文体，但是它并没有解析报文头或报文体。

</p>
<p>Defined headers that allow multiple values are concatenated with a <code>,</code>
character, except for the <code>set-cookie</code> and <code>cookie</code> headers which are
represented as an array of values.  Headers such as <code>content-length</code>
which can only have a single value are parsed accordingly, and only a
single value is represented on the parsed object.

</p>
<p>定义好的消息头允许多个值以<code>,</code>分割, 除了<code>set-cookie</code>和<code>cookie</code>,因为他们表示值的数组. 消息头,比如 <code>content-length</code>只能有单个值, 并且单个值表示解析好的对象.

</p>
<p>The raw headers as they were received are retained in the <code>rawHeaders</code>
property, which is an array of <code>[key, value, key2, value2, ...]</code>.  For
example, the previous message header object might have a <code>rawHeaders</code>
list like the following:

</p>
<p>接收到的原始头信息以数组形式 <code>[key, value, key2, value2, ...]</code> 保存在 <code>rawHeaders</code> 属性中. 例如, 前面提到的消息对象会有 <code>rawHeaders</code> 列表如下:

</p>
<pre><code>[ &apos;ConTent-Length&apos;, &apos;123456&apos;,
  &apos;content-LENGTH&apos;, &apos;123&apos;,
  &apos;content-type&apos;, &apos;text/plain&apos;,
  &apos;CONNECTION&apos;, &apos;keep-alive&apos;,
  &apos;Host&apos;, &apos;mysite.com&apos;,
  &apos;accepT&apos;, &apos;*/*&apos; ]</code></pre>
<h2>http.STATUS_CODES<span><a href="all.html#all_http_status_codes" id="all_http_status_codes">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>A collection of all the standard HTTP response status codes, and the
short description of each.  For example, <code>http.STATUS_CODES[404] === &apos;Not
Found&apos;</code>.

</p>
<p>所以标准HTTP响应码的集合,以及每个响应码的简短描述.例如:<code>http.STATUS_CODES[404]===&apos;Not Found&apos;</code>.

</p>
<h2>http.createServer([requestListener])<span><a href="all.html#all_http_createserver_requestlistener" id="all_http_createserver_requestlistener">#</a></span></h2>
<p>Returns a new web server object.

</p>
<p>返回一个新的web服务器对象

</p>
<p>The <code>requestListener</code> is a function which is automatically
added to the <code>&apos;request&apos;</code> event.

</p>
<p>参数 <code>requestListener</code> 是一个函数,它将会自动加入到 <code>&apos;request&apos;</code> 事件的监听队列.

</p>
<h2>http.createClient([port], [host])<span><a href="all.html#all_http_createclient_port_host" id="all_http_createclient_port_host">#</a></span></h2>
<p>This function is <strong>deprecated</strong>; please use <a href="http.html#http_http_request_options_callback">http.request()</a> instead.
Constructs a new HTTP client. <code>port</code> and <code>host</code> refer to the server to be
connected to.

</p>
<p>该函数已<strong>弃用</strong>,请用<a href="http.html#http_http_request_options_callback">http.request()</a>代替.
创建一个新的HTTP客户端. <code>port</code> 和<code>host</code> 表示所连接的服务器.

</p>
<h2>Class: http.Server<span><a href="all.html#all_class_http_server" id="all_class_http_server">#</a></span></h2>
<p>This is an <a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<p>这是一个包含下列事件的<a href="events.html#events_class_events_eventemitter">EventEmitter</a>:

</p>
<h3>Event: &apos;request&apos;<span><a href="all.html#all_event_request" id="all_event_request">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p><code>function (request, response) { }</code>

</p>
<p>Emitted each time there is a request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).
<code>request</code> is an instance of <code>http.IncomingMessage</code> and <code>response</code> is
an instance of <code>http.ServerResponse</code>

</p>
<p>每次收到一个请求时触发.注意每个连接又可能有多个请求(在<code>keep-alive</code>的连接中).<code>request</code>是<code>http.IncomingMessage</code>的一个实例.<code>response</code>是<code>http.ServerResponse</code>的一个实例

</p>
<h3>事件: &apos;connection&apos;<span><a href="all.html#all_connection_1" id="all_connection_1">#</a></span></h3>
<p><code>function (socket) { }</code>

</p>
<p><code>function (socket) { }</code>

</p>
<p>When a new TCP stream is established. <code>socket</code> is an object of type
<code>net.Socket</code>. Usually users will not want to access this event. In
particular, the socket will not emit <code>readable</code> events because of how
the protocol parser attaches to the socket. The <code>socket</code> can also be
accessed at <code>request.connection</code>.

</p>
<p>新的TCP流建立时出发。 <code>socket</code>是一个<code>net.Socket</code>对象。
通常用户无需处理该事件。
特别注意，协议解析器绑定套接字时采用的方式使套接字不会出发<code>readable</code>事件。
还可以通过<code>request.connection</code>访问<code>socket</code>。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_4" id="all_close_4">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Emitted when the server closes.

</p>
<p>当此服务器关闭时触发

</p>
<h3>Event: &apos;checkContinue&apos;<span><a href="all.html#all_event_checkcontinue" id="all_event_checkcontinue">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p><code>function (request, response) { }</code>

</p>
<p>Emitted each time a request with an http Expect: 100-continue is received.
If this event isn&apos;t listened for, the server will automatically respond
with a 100 Continue as appropriate.

</p>
<p>每当收到Expect: 100-continue的http请求时触发。
如果未监听该事件，服务器会酌情自动发送100 Continue响应。

</p>
<p>Handling this event involves calling <code>response.writeContinue</code> if the client
should continue to send the request body, or generating an appropriate HTTP
response (e.g., 400 Bad Request) if the client should not continue to send the
request body.

</p>
<p>处理该事件时，如果客户端可以继续发送请求主体则调用<code>response.writeContinue</code>，
如果不能则生成合适的HTTP响应（例如，400 请求无效）。

</p>
<p>Note that when this event is emitted and handled, the <code>request</code> event will
not be emitted.

</p>
<p>需要注意到, 当这个事件触发并且被处理后, <code>request</code> 时间将不再会触发.

</p>
<h3>事件: &apos;connect&apos;<span><a href="all.html#all_connect_1" id="all_connect_1">#</a></span></h3>
<p><code>function (request, socket, head) { }</code>

</p>
<p><code>function (request, socket, head) { }</code>

</p>
<p>Emitted each time a client requests a http CONNECT method. If this event isn&apos;t
listened for, then clients requesting a CONNECT method will have their
connections closed.

</p>
<p>每当客户端发起CONNECT请求时出发。如果未监听该事件，客户端发起CONNECT请求时连接会被关闭。

</p>
<ul>
<li><code>request</code> is the arguments for the http request, as it is in the request
event.</li>
<li><code>socket</code> is the network socket between the server and client.</li>
<li><p><code>head</code> is an instance of Buffer, the first packet of the tunneling stream,
this may be empty.</p>
</li>
<li><p><code>request</code> 是该HTTP请求的参数，与request事件中的相同。</p>
</li>
<li><code>socket</code> 是服务端与客户端之间的网络套接字。</li>
<li><code>head</code> 是一个Buffer实例，隧道流的第一个包，该参数可能为空。</li>
</ul>
<p>After this event is emitted, the request&apos;s socket will not have a <code>data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.

</p>
<p>在这个事件被分发后，请求的套接字将不会有<code>data</code>事件监听器，也就是说你将需要绑定一个监听器到<code>data</code>事件，来处理在套接字上被发送到服务器的数据。

</p>
<h3>Event: &apos;upgrade&apos;<span><a href="all.html#all_event_upgrade" id="all_event_upgrade">#</a></span></h3>
<p><code>function (request, socket, head) { }</code>

</p>
<p><code>function (request, socket, head) { }</code>

</p>
<p>Emitted each time a client requests a http upgrade. If this event isn&apos;t
listened for, then clients requesting an upgrade will have their connections
closed.

</p>
<p>每当一个客户端请求http升级时，该事件被分发。如果这个事件没有被监听，那么这些请求升级的客户端的连接将会被关闭。

</p>
<ul>
<li><code>request</code> is the arguments for the http request, as it is in the request
event.</li>
<li><code>socket</code> is the network socket between the server and client.</li>
<li><p><code>head</code> is an instance of Buffer, the first packet of the upgraded stream,
this may be empty.</p>
</li>
<li><p><code>request</code> 是该HTTP请求的参数，与request事件中的相同。</p>
</li>
<li><code>socket</code> 是服务端与客户端之间的网络套接字。</li>
<li><code>head</code> 是一个Buffer实例，升级后流的第一个包，该参数可能为空。</li>
</ul>
<p>After this event is emitted, the request&apos;s socket will not have a <code>data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.

</p>
<p>在这个事件被分发后，请求的套接字将不会有<code>data</code>事件监听器，也就是说你将需要绑定一个监听器到<code>data</code>事件，来处理在套接字上被发送到服务器的数据。

</p>
<h3>Event: &apos;clientError&apos;<span><a href="all.html#all_event_clienterror_1" id="all_event_clienterror_1">#</a></span></h3>
<p><code>function (exception, socket) { }</code>

</p>
<p><code>function (exception, socket) { }</code>

</p>
<p>If a client connection emits an &apos;error&apos; event - it will forwarded here.

</p>
<p>如果一个客户端连接触发了一个 &apos;error&apos; 事件, 它就会转发到这里.

</p>
<p><code>socket</code> is the <code>net.Socket</code> object that the error originated from.

</p>
<p><code>socket</code> 是导致错误的 <code>net.Socket</code> 对象。

</p>
<h3>server.listen(port, [hostname], [backlog], [callback])<span><a href="all.html#all_server_listen_port_hostname_backlog_callback" id="all_server_listen_port_hostname_backlog_callback">#</a></span></h3>
<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
<p>开始在指定的主机名和端口接收连接。如果省略主机名，服务器会接收指向任意IPv4地址的链接（<code>INADDR_ANY</code>）。

</p>
<p>To listen to a unix socket, supply a filename instead of port and hostname.

</p>
<p>监听一个 unix socket, 需要提供一个文件名而不是端口号和主机名。

</p>
<p>Backlog is the maximum length of the queue of pending connections.
The actual length will be determined by your OS through sysctl settings such as
<code>tcp_max_syn_backlog</code> and <code>somaxconn</code> on linux. The default value of this
parameter is 511 (not 512).

</p>
<p>积压量 <code>backlog</code> 为连接等待队列的最大长度。实际长度由您的操作系统通过 sysctl 设置决定，比如 Linux 上的 <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。该参数缺省值为 511（不是 512）。

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.  See also <a href="net.html#net_server_listen_port_host_backlog_callback">net.Server.listen(port)</a>.

</p>
<p>这个函数是异步的。最后一个参数<code>callback</code>会被作为事件监听器添加到 <a href="net.html#net_event_listening">&apos;listening&apos;</a>事件。另见<a href="net.html#net_server_listen_port_host_backlog_callback">net.Server.listen(port)</a>。

</p>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback_1" id="all_server_listen_path_callback_1">#</a></span></h3>
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.

</p>
<p>启动一个 UNIX 套接字服务器在所给路径 <code>path</code> 上监听连接。

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.  See also <a href="net.html#net_server_listen_path_callback">net.Server.listen(path)</a>.

</p>
<p>该函数是异步的.最后一个参数<code>callback</code>将会加入到[<code>listening</code>][]事件的监听队列中.又见<a href="net.html#net_server_listen_path_callback">net.Server.listen(path)</a>.

</p>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback_1" id="all_server_listen_handle_callback_1">#</a></span></h3>
<div><ul>
<li><code>handle</code> <span>Object</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>handle</code>处理器 <span>Object</span></p>
</li>
<li><code>callback</code>回调函数 <span>Function</span></li>
</div></ul>
<p>The <code>handle</code> object can be set to either a server or socket (anything
with an underlying <code>_handle</code> member), or a <code>{fd: &lt;n&gt;}</code> object.

</p>
<p><code>handle</code> 变量可以被设置为server 或者 socket(任一以下划线开头的成员 <code>_handle</code>), 或者一个 <code>{fd: &lt;n&gt;}</code> 对象

</p>
<p>This will cause the server to accept connections on the specified
handle, but it is presumed that the file descriptor or handle has
already been bound to a port or domain socket.

</p>
<p>这将使服务器用指定的句柄接受连接，但它假设文件描述符或者句柄已经被绑定在特定的端口或者域名套接字。

</p>
<p>Listening on a file descriptor is not supported on Windows.

</p>
<p>Windows 不支持监听一个文件描述符。

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#event_listening_">&apos;listening&apos;</a> event.
See also <a href="net.html#net_server_listen_handle_callback">net.Server.listen()</a>.

</p>
<p>这个函数是异步的。最后一个参数<code>callback</code>会被作为事件监听器添加到<a href="net.html#event_listening_">&apos;listening&apos;</a>事件。另见<a href="net.html#net_server_listen_handle_callback">net.Server.listen()</a>。

</p>
<h3>server.close([callback])<span><a href="all.html#all_server_close_callback_1" id="all_server_close_callback_1">#</a></span></h3>
<p>Stops the server from accepting new connections.  See <a href="net.html#net_server_close_callback">net.Server.close()</a>.

</p>
<p>禁止服务端接收新的连接. 查看 <a href="net.html#net_server_close_callback">net.Server.close()</a>.

</p>
<h3>server.maxHeadersCount<span><a href="all.html#all_server_maxheaderscount" id="all_server_maxheaderscount">#</a></span></h3>
<p>Limits maximum incoming headers count, equal to 1000 by default. If set to 0 -
no limit will be applied.

</p>
<p>最大请求头数目限制, 默认 1000 个. 如果设置为0, 则代表不做任何限制.

</p>
<h3>server.setTimeout(msecs, callback)<span><a href="all.html#all_server_settimeout_msecs_callback" id="all_server_settimeout_msecs_callback">#</a></span></h3>
<div><ul>
<li><code>msecs</code> <span>Number</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>msecs</code> <span>Number</span></p>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Sets the timeout value for sockets, and emits a <code>&apos;timeout&apos;</code> event on
the Server object, passing the socket as an argument, if a timeout
occurs.

</p>
<p>为套接字设定超时值。如果一个超时发生，那么Server对象上会分发一个<code>&apos;timeout&apos;</code>事件，同时将套接字作为参数传递。

</p>
<p>If there is a <code>&apos;timeout&apos;</code> event listener on the Server object, then it
will be called with the timed-out socket as an argument.

</p>
<p>如果在Server对象上有一个<code>&apos;timeout&apos;</code>事件监听器，那么它将被调用，而超时的套接字会作为参数传递给这个监听器。

</p>
<p>By default, the Server&apos;s timeout value is 2 minutes, and sockets are
destroyed automatically if they time out.  However, if you assign a
callback to the Server&apos;s <code>&apos;timeout&apos;</code> event, then you are responsible
for handling socket timeouts.

</p>
<p>默认情况下，服务器的超时时间是2分钟，超时后套接字会自动销毁。
但是如果为‘timeout’事件指定了回调函数，你需要负责处理套接字超时。

</p>
<h3>server.timeout<span><a href="all.html#all_server_timeout" id="all_server_timeout">#</a></span></h3>
<div><ul>
<li><p><span>Number</span> Default = 120000 (2 minutes)</p>
</li>
<li><p><span>Number</span> 默认 120000 (2 分钟)</p>
</li>
</div></ul>
<p>The number of milliseconds of inactivity before a socket is presumed
to have timed out.

</p>
<p>一个套接字被判断为超时之前的闲置毫秒数。

</p>
<p>Note that the socket timeout logic is set up on connection, so
changing this value only affects <em>new</em> connections to the server, not
any existing connections.

</p>
<p>注意套接字的超时逻辑在连接时被设定，所以更改这个值只会影响<em>新创建的</em>连接，而不会影响到现有连接。

</p>
<p>Set to 0 to disable any kind of automatic timeout behavior on incoming
connections.

</p>
<p>设置为0将阻止之后建立的连接的一切自动超时行为。

</p>
<h2>Class: http.ServerResponse<span><a href="all.html#all_class_http_serverresponse" id="all_class_http_serverresponse">#</a></span></h2>
<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code>&apos;request&apos;</code> event.

</p>
<p>The response implements the <a href="stream.html#stream_writable_stream">Writable Stream</a> interface. This is an
<a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_5" id="all_close_5">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Indicates that the underlying connection was terminated before
<code>response.end()</code> was called or able to flush.

</p>
<h3>response.writeContinue()<span><a href="all.html#all_response_writecontinue" id="all_response_writecontinue">#</a></span></h3>
<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the <a href="all.html#http_event_checkcontinue">&apos;checkContinue&apos;</a> event on <code>Server</code>.

</p>
<h3>response.writeHead(statusCode, [reasonPhrase], [headers])<span><a href="all.html#all_response_writehead_statuscode_reasonphrase_headers" id="all_response_writehead_statuscode_reasonphrase_headers">#</a></span></h3>
<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
Optionally one can give a human-readable <code>reasonPhrase</code> as the second
argument.

</p>
<p>向请求回复响应头. statusCode是一个三位是的HTTP状态码, 例如 <code>404</code>. 
最后一个参数, <code>headers</code>, 是响应头的内容.
可以选择性的，把人类可读的‘原因短句’作为第二个参数。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var body = &apos;hello world&apos;;
response.writeHead(200, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
<p>This method must only be called once on a message and it must
be called before <code>response.end()</code> is called.

</p>
<p>这个方法只能在消息到来后使用一次 而且这必须在<code>response.end()</code>
之后调用。

</p>
<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
implicit/mutable headers will be calculated and call this function for you.

</p>
<p>如果你在调用这之前调用了<code>response.write()</code>或者 <code>response.end()</code> , 
就会调用这个函数，并且 不明/容易混淆 的头将会被使用。

</p>
<p>Note: that Content-Length is given in bytes not characters. The above example
works because the string <code>&apos;hello world&apos;</code> contains only single byte characters.
If the body contains higher coded characters then <code>Buffer.byteLength()</code>
should be used to determine the number of bytes in a given encoding.
And Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.

</p>
<p>注意：Content-Length 是以字节(byte)计，而不是以字符(character)计。之前的例子奏效的原因是字符串&apos;hello world&apos;只包含了单字节的字符。如果body包含了多字节编码的字符，就应当使用Buffer.byteLength()来确定在多字节字符编码情况下字符串的字节数。需要进一步说明的是Node不检查Content-Lenth属性和已传输的body长度是否吻合。

</p>
<h3>response.setTimeout(msecs, callback)<span><a href="all.html#all_response_settimeout_msecs_callback" id="all_response_settimeout_msecs_callback">#</a></span></h3>
<div><ul>
<li><code>msecs</code> <span>Number</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>msecs</code> <span>Number</span></p>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Sets the Socket&apos;s timeout value to <code>msecs</code>.  If a callback is
provided, then it is added as a listener on the <code>&apos;timeout&apos;</code> event on
the response object.

</p>
<p>设定套接字的超时时间为<code>msecs</code>。如果提供了回调函数，会将其添加为响应对象的<code>&apos;timeout&apos;</code>事件的监听器。

</p>
<p>If no <code>&apos;timeout&apos;</code> listener is added to the request, the response, or
the server, then sockets are destroyed when they time out.  If you
assign a handler on the request, the response, or the server&apos;s
<code>&apos;timeout&apos;</code> events, then it is your responsibility to handle timed out
sockets.

</p>
<p>如果请求、响应、服务器均未添加<code>&apos;timeout&apos;</code>事件监听，套接字将在超时时被销毁。
如果监听了请求、响应、服务器之一的<code>&apos;timeout&apos;</code>事件，需要自行处理超时的套接字。

</p>
<h3>response.statusCode<span><a href="all.html#all_response_statuscode" id="all_response_statuscode">#</a></span></h3>
<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property
controls the status code that will be sent to the client when the headers get
flushed.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>response.statusCode = 404;</code></pre>
<p>After response header was sent to the client, this property indicates the
status code which was sent out.

</p>
<h3>response.setHeader(name, value)<span><a href="all.html#all_response_setheader_name_value" id="all_response_setheader_name_value">#</a></span></h3>
<p>Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, its value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.

</p>
<p>为默认或者已存在的头设置一条单独的头内容。如果这个头已经存在于
将被送出的头中，将会覆盖原来的内容。如果我想设置更多的头，
就使用一个相同名字的字符串数组

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
<p>or

</p>
<p>或者

</p>
<pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
<h3>response.headersSent<span><a href="all.html#all_response_headerssent" id="all_response_headerssent">#</a></span></h3>
<p>Boolean (read-only). True if headers were sent, false otherwise.

</p>
<p>Boolean值(只读).如果headers发送完毕,则为true,反之为false

</p>
<h3>response.sendDate<span><a href="all.html#all_response_senddate" id="all_response_senddate">#</a></span></h3>
<p>When true, the Date header will be automatically generated and sent in
the response if it is not already present in the headers. Defaults to true.

</p>
<p>若为true,则当headers里没有Date值时自动生成Date并发送.默认值为true

</p>
<p>This should only be disabled for testing; HTTP requires the Date header
in responses.

</p>
<p>只有在测试环境才禁用它; 因为 HTTP 要求响应包含 <code>Date</code> 头.

</p>
<h3>response.getHeader(name)<span><a href="all.html#all_response_getheader_name" id="all_response_getheader_name">#</a></span></h3>
<p>Reads out a header that&apos;s already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>
<h3>response.removeHeader(name)<span><a href="all.html#all_response_removeheader_name" id="all_response_removeheader_name">#</a></span></h3>
<p>Removes a header that&apos;s queued for implicit sending.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
<h3>response.write(chunk, [encoding])<span><a href="all.html#all_response_write_chunk_encoding" id="all_response_write_chunk_encoding">#</a></span></h3>
<p>If this method is called and <code>response.writeHead()</code> has not been called, it will
switch to implicit header mode and flush the implicit headers.

</p>
<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.

</p>
<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>&apos;utf8&apos;</code>.

</p>
<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.

</p>
<p>The first time <code>response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code>response.write()</code> is called, Node assumes you&apos;re going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.

</p>
<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<p>如果所有数据被成功刷新到内核缓冲区，则返回<code>true</code>。如果所有或部分数据在用户内存里还处于队列中，则返回<code>false</code>。当缓冲区再次被释放时，<code>&apos;drain&apos;</code>事件会被分发。
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<h3>response.addTrailers(headers)<span><a href="all.html#all_response_addtrailers_headers" id="all_response_addtrailers_headers">#</a></span></h3>
<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.

</p>
<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.

</p>
<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,

</p>
<pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,
                          &apos;Trailer&apos;: &apos;Content-MD5&apos; });
response.write(fileData);
response.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();</code></pre>
<h3>response.end([data], [encoding])<span><a href="all.html#all_response_end_data_encoding" id="all_response_end_data_encoding">#</a></span></h3>
<p>This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each
response.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
followed by <code>response.end()</code>.

</p>
<h2>http.request(options, callback)<span><a href="all.html#all_http_request_options_callback" id="all_http_request_options_callback">#</a></span></h2>
<p>Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.

</p>
<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is
automatically parsed with <a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost">url.parse()</a>.

</p>
<p><code>options</code> 可以是一个对象或一个字符串。如果 <code>options</code>是一个字符串, 它将自动的使用<a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost">url.parse()</a>解析。

</p>
<p>Options:

</p>
<p>Options:

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code>&apos;localhost&apos;</code>.</li>
<li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li>
<li><code>port</code>: Port of remote server. Defaults to 80.</li>
<li><code>localAddress</code>: Local interface to bind for network connections.</li>
<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&apos;GET&apos;</code>.</li>
<li><code>path</code>: Request path. Defaults to <code>&apos;/&apos;</code>. Should include query string if any.
E.G. <code>&apos;/index.html?page=12&apos;</code>. An exception is thrown when the request path
contains illegal characters. Currently, only spaces are rejected but that
may change in the future.</li>
<li><code>headers</code>: An object containing request headers.</li>
<li><code>auth</code>: Basic authentication i.e. <code>&apos;user:password&apos;</code> to compute an
Authorization header.</li>
<li><code>agent</code>: Controls <a href="all.html#https_class_https_agent">Agent</a> behavior. When an Agent is used request will
default to <code>Connection: keep-alive</code>. Possible values:<ul>
<li><code>undefined</code> (default): use <a href="all.html#http_http_globalagent">global Agent</a> for this host and port.</li>
<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li>
</ul>
</li>
<li><code>keepAlive</code>: {Boolean} Keep sockets around in a pool to be used
by other requests in the future. Default = <code>false</code></li>
<li><p><code>keepAliveMsecs</code>: {Integer} When using HTTP KeepAlive, how often to
send TCP KeepAlive packets over sockets being kept alive.  Default =
<code>1000</code>.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.</p>
</li>
<li><p><code>host</code>: 要发送请求的服务端域名或IP地址。
默认为<code>&apos;localhost&apos;</code>。</p>
</li>
<li><code>hostname</code>: 要支持<code>url.parse()</code>的话，优先使用<code>hostname</code>而不是<code>host</code></li>
<li><code>port</code>: 远程服务器的端口。默认为80。</li>
<li><code>localAddress</code>: 本地接口，用来绑定网络连接。</li>
<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&apos;GET&apos;</code>.</li>
<li><code>path</code>: Request path. Defaults to <code>&apos;/&apos;</code>. Should include query string if any.
E.G. <code>&apos;/index.html?page=12&apos;</code>. An exception is thrown when the request path
contains illegal characters. Currently, only spaces are rejected but that
may change in the future.</li>
<li><code>headers</code>: An object containing request headers.</li>
<li><code>auth</code>: Basic authentication i.e. <code>&apos;user:password&apos;</code> to compute an
Authorization header.</li>
<li><code>agent</code>: Controls <a href="all.html#https_class_https_agent">Agent</a> behavior. When an Agent is used request will
default to <code>Connection: keep-alive</code>. Possible values:<ul>
<li><code>undefined</code> (default): use <a href="all.html#http_http_globalagent">global Agent</a> for this host and port.</li>
<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li>
</ul>
</li>
<li><code>keepAlive</code>: {Boolean} Keep sockets around in a pool to be used
by other requests in the future. Default = <code>false</code></li>
<li><code>keepAliveMsecs</code>: {Integer} When using HTTP KeepAlive, how often to
send TCP KeepAlive packets over sockets being kept alive.  Default =
<code>1000</code>.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.</li>
</ul>
<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code>
class. The <code>ClientRequest</code> instance is a writable stream. If one needs to
upload a file with a POST request, then write to the <code>ClientRequest</code> object.

</p>
<p><code>http.request()</code> 返回一个 <code>http.ClientRequest</code>类的实例。<code>ClientRequest</code>实例是一个可写流对象。如果需要用POST请求上传一个文件的话，就将其写入到<code>ClientRequest</code>对象。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// write data to request body
req.write(&apos;data\n&apos;);
req.write(&apos;data\n&apos;);
req.end();</code></pre>
<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one
must always call <code>req.end()</code> to signify that you&apos;re done with the request -
even if there is no data being written to the request body.

</p>
<p>注意，例子里的<code>req.end()</code>被调用了。使用<code>http.request()</code>方法时都必须总是调用<code>req.end()</code>以表明这个请求已经完成，即使响应body里没有任何数据。

</p>
<p>If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an <code>&apos;error&apos;</code> event is emitted
on the returned request object.

</p>
<p>There are a few special headers that should be noted.

</p>
<ul>
<li><p>Sending a &apos;Connection: keep-alive&apos; will notify Node that the connection to
the server should be persisted until the next request.</p>
</li>
<li><p>Sending a &apos;Content-length&apos; header will disable the default chunked encoding.</p>
</li>
<li><p>发送 &apos;Content-length&apos; 头将会禁用默认的 chunked 编码.</p>
</li>
<li><p>Sending an &apos;Expect&apos; header will immediately send the request headers.
Usually, when sending &apos;Expect: 100-continue&apos;, you should both set a timeout
and listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more
information.</p>
</li>
<li><p>Sending an Authorization header will override using the <code>auth</code> option
to compute basic authentication.</p>
</li>
</ul>
<h2>http.get(options, callback)<span><a href="all.html#all_http_get_options_callback" id="all_http_get_options_callback">#</a></span></h2>
<p>Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and <code>http.request()</code>
is that it sets the method to GET and calls <code>req.end()</code> automatically.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>http.get(&quot;http://www.google.com/index.html&quot;, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&apos;error&apos;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});</code></pre>
<h2>Class: http.Agent<span><a href="all.html#all_class_http_agent" id="all_class_http_agent">#</a></span></h2>
<p>The HTTP Agent is used for pooling sockets used in HTTP client
requests.

</p>
<p>The HTTP Agent also defaults client requests to using
Connection:keep-alive. If no pending HTTP requests are waiting on a
socket to become free the socket is closed. This means that Node&apos;s
pool has the benefit of keep-alive when under load but still does not
require developers to manually close the HTTP clients using
KeepAlive.

</p>
<p>If you opt into using HTTP KeepAlive, you can create an Agent object
with that flag set to <code>true</code>.  (See the <a href="all.html#http_new_agent_options">constructor
options</a> below.)  Then, the Agent will keep
unused sockets in a pool for later use.  They will be explicitly
marked so as to not keep the Node process running.  However, it is
still a good idea to explicitly <a href="all.html#http_agent_destroy"><code>destroy()</code></a>
KeepAlive agents when they are no longer in use, so that the Sockets
will be shut down.

</p>
<p>Sockets are removed from the agent&apos;s pool when the socket emits either
a &quot;close&quot; event or a special &quot;agentRemove&quot; event. This means that if
you intend to keep one HTTP request open for a long time and don&apos;t
want it to stay in the pool you can do something along the lines of:

</p>
<pre><code>http.get(options, function(res) {
  // Do stuff
}).on(&quot;socket&quot;, function (socket) {
  socket.emit(&quot;agentRemove&quot;);
});</code></pre>
<p>Alternatively, you could just opt out of pooling entirely using
<code>agent:false</code>:

</p>
<pre><code>http.get({
  hostname: &apos;localhost&apos;,
  port: 80,
  path: &apos;/&apos;,
  agent: false  // create a new agent just for this one request
}, function (res) {
  // Do stuff with response
})</code></pre>
<h3>new Agent([options])<span><a href="all.html#all_new_agent_options" id="all_new_agent_options">#</a></span></h3>
<div><ul>
<li><code>options</code> <span>Object</span> Set of configurable options to set on the agent.
Can have the following fields:<ul>
<li><code>keepAlive</code> <span>Boolean</span> Keep sockets around in a pool to be used by
other requests in the future. Default = <code>false</code></li>
<li><code>keepAliveMsecs</code> <span>Integer</span> When using HTTP KeepAlive, how often
to send TCP KeepAlive packets over sockets being kept alive.
Default = <code>1000</code>.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.</li>
<li><code>maxSockets</code> <span>Number</span> Maximum number of sockets to allow per
host.  Default = <code>Infinity</code>.</li>
<li><code>maxFreeSockets</code> <span>Number</span> Maximum number of sockets to leave open
in a free state.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.
Default = <code>256</code>.</li>
</ul>
</li>
</div></ul>
<p>The default <code>http.globalAgent</code> that is used by <code>http.request</code> has all
of these values set to their respective defaults.

</p>
<p>To configure any of them, you must create your own <code>Agent</code> object.

</p>
<p>要配置这些值，你必须创建一个你自己的<code>Agent</code>对象。

</p>
<pre><code>var http = require(&apos;http&apos;);
var keepAliveAgent = new http.Agent({ keepAlive: true });
keepAliveAgent.request(options, onResponseCallback);</code></pre>
<h3>agent.maxSockets<span><a href="all.html#all_agent_maxsockets" id="all_agent_maxsockets">#</a></span></h3>
<p>By default set to Infinity. Determines how many concurrent sockets the
agent can have open per host.

</p>
<h3>agent.maxFreeSockets<span><a href="all.html#all_agent_maxfreesockets" id="all_agent_maxfreesockets">#</a></span></h3>
<p>By default set to 256.  For Agents supporting HTTP KeepAlive, this
sets the maximum number of sockets that will be left open in the free
state.

</p>
<h3>agent.sockets<span><a href="all.html#all_agent_sockets" id="all_agent_sockets">#</a></span></h3>
<p>An object which contains arrays of sockets currently in use by the
Agent.  Do not modify.

</p>
<h3>agent.freeSockets<span><a href="all.html#all_agent_freesockets" id="all_agent_freesockets">#</a></span></h3>
<p>An object which contains arrays of sockets currently awaiting use by
the Agent when HTTP KeepAlive is used.  Do not modify.

</p>
<h3>agent.requests<span><a href="all.html#all_agent_requests" id="all_agent_requests">#</a></span></h3>
<p>An object which contains queues of requests that have not yet been assigned to
sockets. Do not modify.

</p>
<h3>agent.destroy()<span><a href="all.html#all_agent_destroy" id="all_agent_destroy">#</a></span></h3>
<p>Destroy any sockets that are currently in use by the agent.

</p>
<p>销毁被此 agent 正在使用着的所有 sockets.

</p>
<p>It is usually not necessary to do this.  However, if you are using an
agent with KeepAlive enabled, then it is best to explicitly shut down
the agent when you know that it will no longer be used.  Otherwise,
sockets may hang open for quite a long time before the server
terminates them.

</p>
<h3>agent.getName(options)<span><a href="all.html#all_agent_getname_options" id="all_agent_getname_options">#</a></span></h3>
<p>Get a unique name for a set of request options, to determine whether a
connection can be reused.  In the http agent, this returns
<code>host:port:localAddress</code>.  In the https agent, the name includes the
CA, cert, ciphers, and other HTTPS/TLS-specific options that determine
socket reusability.

</p>
<h2>http.globalAgent<span><a href="all.html#all_http_globalagent" id="all_http_globalagent">#</a></span></h2>
<p>Global instance of Agent which is used as the default for all http client
requests.

</p>
<h2>Class: http.ClientRequest<span><a href="all.html#all_class_http_clientrequest" id="all_class_http_clientrequest">#</a></span></h2>
<p>This object is created internally and returned from <code>http.request()</code>.  It
represents an <em>in-progress</em> request whose header has already been queued.  The
header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
<code>removeHeader(name)</code> API.  The actual header will be sent along with the first
data chunk or when closing the connection.

</p>
<p>To get the response, add a listener for <code>&apos;response&apos;</code> to the request object.
<code>&apos;response&apos;</code> will be emitted from the request object when the response
headers have been received.  The <code>&apos;response&apos;</code> event is executed with one
argument which is an instance of <code>http.IncomingMessage</code>.

</p>
<p>During the <code>&apos;response&apos;</code> event, one can add listeners to the
response object; particularly to listen for the <code>&apos;data&apos;</code> event.

</p>
<p>If no <code>&apos;response&apos;</code> handler is added, then the response will be
entirely discarded.  However, if you add a <code>&apos;response&apos;</code> event handler,
then you <strong>must</strong> consume the data from the response object, either by
calling <code>response.read()</code> whenever there is a <code>&apos;readable&apos;</code> event, or
by adding a <code>&apos;data&apos;</code> handler, or by calling the <code>.resume()</code> method.
Until the data is consumed, the <code>&apos;end&apos;</code> event will not fire.  Also, until
the data is read it will consume memory that can eventually lead to a
&apos;process out of memory&apos; error.

</p>
<p>Note: Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.

</p>
<p>The request implements the <a href="stream.html#stream_writable_stream">Writable Stream</a> interface. This is an
<a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<h3>Event &apos;response&apos;<span><a href="all.html#all_event_response" id="all_event_response">#</a></span></h3>
<p><code>function (response) { }</code>

</p>
<p><code>function (response) { }</code>

</p>
<p>Emitted when a response is received to this request. This event is emitted only
once. The <code>response</code> argument will be an instance of <code>http.IncomingMessage</code>.

</p>
<p>Options:

</p>
<p>Options:

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>
<li><code>port</code>: Port of remote server.</li>
<li><p><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</p>
</li>
<li><p><code>host</code>: 请求要发送的域名或服务器的IP地址。</p>
</li>
<li><code>port</code>: 远程服务器的端口。</li>
<li><code>socketPath</code>: Unix Domain Socket （使用host:port或socketPath）</li>
</ul>
<h3>Event: &apos;socket&apos;<span><a href="all.html#all_event_socket" id="all_event_socket">#</a></span></h3>
<p><code>function (socket) { }</code>

</p>
<p><code>function (socket) { }</code>

</p>
<p>Emitted after a socket is assigned to this request.

</p>
<p>当一个套接字被分配到这个请求之后，该事件被分发。

</p>
<h3>事件: &apos;connect&apos;<span><a href="all.html#all_connect_2" id="all_connect_2">#</a></span></h3>
<p><code>function (response, socket, head) { }</code>

</p>
<p><code>function (response, socket, head) { }</code>

</p>
<p>Emitted each time a server responds to a request with a CONNECT method. If this
event isn&apos;t being listened for, clients receiving a CONNECT method will have
their connections closed.

</p>
<p>A client server pair that show you how to listen for the <code>connect</code> event.

</p>
<pre><code>    // make a request over an HTTP tunnel
    socket.write(&apos;GET / HTTP/1.1\r\n&apos; +
                 &apos;Host: www.google.com:80\r\n&apos; +
                 &apos;Connection: close\r\n&apos; +
                 &apos;\r\n&apos;);
    socket.on(&apos;data&apos;, function(chunk) {
      console.log(chunk.toString());
    });
    socket.on(&apos;end&apos;, function() {
      proxy.close();
    });
  });
});</code></pre>
<h3>Event: &apos;upgrade&apos;<span><a href="all.html#all_event_upgrade_1" id="all_event_upgrade_1">#</a></span></h3>
<p><code>function (response, socket, head) { }</code>

</p>
<p><code>function (response, socket, head) { }</code>

</p>
<p>Emitted each time a server responds to a request with an upgrade. If this
event isn&apos;t being listened for, clients receiving an upgrade header will have
their connections closed.

</p>
<p>A client server pair that show you how to listen for the <code>upgrade</code> event.

</p>
<pre><code>  req.on(&apos;upgrade&apos;, function(res, socket, upgradeHead) {
    console.log(&apos;got upgraded!&apos;);
    socket.end();
    process.exit(0);
  });
});</code></pre>
<h3>Event: &apos;continue&apos;<span><a href="all.html#all_event_continue" id="all_event_continue">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Emitted when the server sends a &apos;100 Continue&apos; HTTP response, usually because
the request contained &apos;Expect: 100-continue&apos;. This is an instruction that
the client should send the request body.

</p>
<h3>request.write(chunk, [encoding])<span><a href="all.html#all_request_write_chunk_encoding" id="all_request_write_chunk_encoding">#</a></span></h3>
<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code>[&apos;Transfer-Encoding&apos;, &apos;chunked&apos;]</code> header line when
creating the request.

</p>
<p>The <code>chunk</code> argument should be a <a href="buffer.html#buffer_buffer">Buffer</a> or a string.

</p>
<p><code>chunk</code> 参数必须是 <a href="buffer.html#buffer_buffer">Buffer</a> 或者 string.

</p>
<p>The <code>encoding</code> argument is optional and only applies when <code>chunk</code> is a string.
Defaults to <code>&apos;utf8&apos;</code>.

</p>
<p><code>encoding</code> 参数是可选的, 并且只能在 <code>chunk</code> 是 string 类型的时候才能设置.
默认是 <code>&apos;utf8&apos;</code>.

</p>
<h3>request.end([data], [encoding])<span><a href="all.html#all_request_end_data_encoding" id="all_request_end_data_encoding">#</a></span></h3>
<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>&apos;0\r\n\r\n&apos;</code>.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<code>request.write(data, encoding)</code> followed by <code>request.end()</code>.

</p>
<h3>request.abort()<span><a href="all.html#all_request_abort" id="all_request_abort">#</a></span></h3>
<p>Aborts a request.  (New since v0.3.8.)

</p>
<p>终止一个请求. (从 v0.3.8 开始新加.)

</p>
<h3>request.setTimeout(timeout, [callback])<span><a href="all.html#all_request_settimeout_timeout_callback" id="all_request_settimeout_timeout_callback">#</a></span></h3>
<p>Once a socket is assigned to this request and is connected
<a href="net.html#net_socket_settimeout_timeout_callback">socket.setTimeout()</a> will be called.

</p>
<h3>request.setNoDelay([noDelay])<span><a href="all.html#all_request_setnodelay_nodelay" id="all_request_setnodelay_nodelay">#</a></span></h3>
<p>Once a socket is assigned to this request and is connected
<a href="net.html#net_socket_setnodelay_nodelay">socket.setNoDelay()</a> will be called.

</p>
<h3>request.setSocketKeepAlive([enable], [initialDelay])<span><a href="all.html#all_request_setsocketkeepalive_enable_initialdelay" id="all_request_setsocketkeepalive_enable_initialdelay">#</a></span></h3>
<p>Once a socket is assigned to this request and is connected
<a href="net.html#net_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive()</a> will be called.

</p>
<p>一旦一个套接字被分配到这个请求，而且成功连接，那么<a href="net.html#net_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive()</a>就会被调用。

</p>
<h2>http.IncomingMessage<span><a href="all.html#all_http_incomingmessage" id="all_http_incomingmessage">#</a></span></h2>
<p>An <code>IncomingMessage</code> object is created by <code>http.Server</code> or <code>http.ClientRequest</code>
and passed as the first argument to the <code>&apos;request&apos;</code> and <code>&apos;response&apos;</code> event
respectively. It may be used to access response status, headers and data.

</p>
<p>一个 <code>IncomingMessage</code>对象是由 <code>http.Server</code>或<code>http.ClientRequest</code>创建的，并作为第一参数分别传递给<code>&apos;request&apos;</code>和<code>&apos;response&apos;</code> 事件。它也可以被用来访问应答的状态，头文件和数据。

</p>
<p>It implements the <a href="stream.html#stream_readable_stream">Readable Stream</a> interface, as well as the
following additional events, methods, and properties.

</p>
<p>这个实现了 [可读流][]接口以及以下增加的事件，函数和属性。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_6" id="all_close_6">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Indicates that the underlaying connection was terminated before
<code>response.end()</code> was called or able to flush.

</p>
<p>表示在<code>response.end()</code>被调用或强制刷新之前，底层的连接已经被终止了。

</p>
<p>Just like <code>&apos;end&apos;</code>, this event occurs only once per response. See
[http.ServerResponse][]&apos;s <code>&apos;close&apos;</code> event for more information.

</p>
<p>跟<code>&apos;end&apos;</code>一样，这个事件对于每个应答只会触发一次。详见[http.ServerResponse][]的 <code>&apos;close&apos;</code>事件。

</p>
<h3>message.httpVersion<span><a href="all.html#all_message_httpversion" id="all_message_httpversion">#</a></span></h3>
<p>In case of server request, the HTTP version sent by the client. In the case of
client response, the HTTP version of the connected-to server.
Probably either <code>&apos;1.1&apos;</code> or <code>&apos;1.0&apos;</code>.

</p>
<p>客户端向服务器发出请求时，客户端发送的HTTP版本；或是服务器向客户端返回应答时，服务器的HTTP版本。通常是 <code>&apos;1.1&apos;</code>或<code>&apos;1.0&apos;</code>。

</p>
<p>Also <code>response.httpVersionMajor</code> is the first integer and
<code>response.httpVersionMinor</code> is the second.

</p>
<h3>message.headers<span><a href="all.html#all_message_headers" id="all_message_headers">#</a></span></h3>
<p>The request/response headers object.

</p>
<p>请求/响应 头对象.

</p>
<p>Read only map of header names and values. Header names are lower-cased.
Example:

</p>
<p>只读的头文件名称和值的映射。头文件名称全小写。示例：

</p>
<pre><code>// 输出类似这样：
//
// { &apos;user-agent&apos;: &apos;curl/7.22.0&apos;,
//   host: &apos;127.0.0.1:8000&apos;,
//   accept: &apos;*/*&apos; }
console.log(request.headers);</code></pre>
<h3>message.rawHeaders<span><a href="all.html#all_message_rawheaders" id="all_message_rawheaders">#</a></span></h3>
<p>The raw request/response headers list exactly as they were received.

</p>
<p>Note that the keys and values are in the same list.  It is <em>not</em> a
list of tuples.  So, the even-numbered offsets are key values, and the
odd-numbered offsets are the associated values.

</p>
<p>Header names are not lowercased, and duplicates are not merged.

</p>
<pre><code>// Prints something like:
//
// [ &apos;user-agent&apos;,
//   &apos;this is invalid because there can be only one&apos;,
//   &apos;User-Agent&apos;,
//   &apos;curl/7.22.0&apos;,
//   &apos;Host&apos;,
//   &apos;127.0.0.1:8000&apos;,
//   &apos;ACCEPT&apos;,
//   &apos;*/*&apos; ]
console.log(request.rawHeaders);</code></pre>
<h3>message.trailers<span><a href="all.html#all_message_trailers" id="all_message_trailers">#</a></span></h3>
<p>The request/response trailers object. Only populated at the &apos;end&apos; event.

</p>
<h3>message.rawTrailers<span><a href="all.html#all_message_rawtrailers" id="all_message_rawtrailers">#</a></span></h3>
<p>The raw request/response trailer keys and values exactly as they were
received.  Only populated at the &apos;end&apos; event.

</p>
<h3>message.setTimeout(msecs, callback)<span><a href="all.html#all_message_settimeout_msecs_callback" id="all_message_settimeout_msecs_callback">#</a></span></h3>
<div><ul>
<li><code>msecs</code> <span>Number</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>msecs</code> <span>Number</span></p>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Calls <code>message.connection.setTimeout(msecs, callback)</code>.

</p>
<p>调用message.connection.setTimeout(msecs, callback)

</p>
<h3>message.method<span><a href="all.html#all_message_method" id="all_message_method">#</a></span></h3>
<p><strong>Only valid for request obtained from <code>http.Server</code>.</strong>

</p>
<p><strong>仅对从<code>http.Server</code>获得到的请求(request)有效.</strong>

</p>
<p>The request method as a string. Read only. Example:
<code>&apos;GET&apos;</code>, <code>&apos;DELETE&apos;</code>.

</p>
<p>请求（request）方法如同一个只读的字符串，比如‘GET’、‘DELETE’。

</p>
<h3>message.url<span><a href="all.html#all_message_url" id="all_message_url">#</a></span></h3>
<p><strong>Only valid for request obtained from <code>http.Server</code>.</strong>

</p>
<p><strong>仅对从<code>http.Server</code>获得到的请求(request)有效.</strong>

</p>
<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:

</p>
<p>请求的URL字符串.它仅包含实际HTTP请求中所提供的URL.加入请求如下:

</p>
<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>
<p>Then <code>request.url</code> will be:

</p>
<p>则<code>request.url</code> 为:

</p>
<pre><code>&apos;/status?name=ryan&apos;</code></pre>
<p>If you would like to parse the URL into its parts, you can use
<code>require(&apos;url&apos;).parse(request.url)</code>.  Example:

</p>
<p>如果你想要将URL分解出来,你可以用<code>require(&apos;url&apos;).parse(request.url)</code>.  例如:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: &apos;name=ryan&apos;,
  pathname: &apos;/status&apos; }</code></pre>
<p>If you would like to extract the params from the query string,
you can use the <code>require(&apos;querystring&apos;).parse</code> function, or pass
<code>true</code> as the second argument to <code>require(&apos;url&apos;).parse</code>.  Example:

</p>
<p>如果你想要提取出从请求字符串(query string)中的参数,你可以用<code>require(&apos;querystring&apos;).parse</code>函数, 或者将<code>true</code>作为第二个参数传递给<code>require(&apos;url&apos;).parse</code>.  例如:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;, true)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: { name: &apos;ryan&apos; },
  pathname: &apos;/status&apos; }</code></pre>
<h3>message.statusCode<span><a href="all.html#all_message_statuscode" id="all_message_statuscode">#</a></span></h3>
<p><strong>Only valid for response obtained from <code>http.ClientRequest</code>.</strong>

</p>
<p><strong>仅对从<code>http.ClientRequest</code>获得的响应(response)有效.</strong>

</p>
<p>The 3-digit HTTP response status code. E.G. <code>404</code>.

</p>
<p>三位数的HTTP响应状态码. 例如 <code>404</code>.

</p>
<h3>message.socket<span><a href="all.html#all_message_socket" id="all_message_socket">#</a></span></h3>
<p>The <code>net.Socket</code> object associated with the connection.

</p>
<p>与此连接(connection)关联的<code>net.Socket</code>对象.

</p>
<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client&apos;s
authentication details.

</p>
<p>通过https的支持，使用 request.connection.verifyPeer()方法和request.connection.getPeerCertificate()方法来得到客户端的身份信息。

</p>
<h1>HTTPS<span><a href="all.html#all_https" id="all_https">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a
separate module.

</p>
<p>HTTPS 是建立在 TLS/SSL 之上的 HTTP 协议。在 Node 中被实现为单独的模块。

</p>
<h2>类: https.Server<span><a href="all.html#all_https_server" id="all_https_server">#</a></span></h2>
<p>This class is a subclass of <code>tls.Server</code> and emits events same as
<code>http.Server</code>. See <code>http.Server</code> for more information.

</p>
<p>该类是 <code>tls.Server</code> 的子类，并且发生和 <code>http.Server</code> 一样的事件。更多信息详见 <code>http.Server</code>。

</p>
<h3>server.setTimeout(msecs, callback)<span><a href="all.html#all_server_settimeout_msecs_callback_1" id="all_server_settimeout_msecs_callback_1">#</a></span></h3>
<p>See <a href="http.html#http_server_settimeout_msecs_callback">http.Server#setTimeout()</a>.

</p>
<p>详见 <a href="http.html#http_server_settimeout_msecs_callback">http.Server#setTimeout()</a>。

</p>
<h3>server.timeout<span><a href="all.html#all_server_timeout_1" id="all_server_timeout_1">#</a></span></h3>
<p>See <a href="http.html#http_server_timeout">http.Server#timeout</a>.

</p>
<p>详见 <a href="http.html#http_server_timeout">http.Server#timeout</a>。

</p>
<h2>https.createServer(options, [requestListener])<span><a href="all.html#all_https_createserver_options_requestlistener" id="all_https_createserver_options_requestlistener">#</a></span></h2>
<p>Returns a new HTTPS web server object. The <code>options</code> is similar to
<a href="tls.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer()</a>.  The <code>requestListener</code> is a function which is
automatically added to the <code>&apos;request&apos;</code> event.

</p>
<p>返回一个新的 HTTPS Web 服务器对象。其中 <code>options</code> 类似于 <a href="tls.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer()</a>；<code>requestListener</code> 是一个会被自动添加到 <code>request</code> 事件的函数。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<p>Or

</p>
<p>或者

</p>
<pre><code>https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<h3>server.listen(port, [host], [backlog], [callback])<span><a href="all.html#all_server_listen_port_host_backlog_callback_1" id="all_server_listen_port_host_backlog_callback_1">#</a></span></h3>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback_2" id="all_server_listen_path_callback_2">#</a></span></h3>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback_2" id="all_server_listen_handle_callback_2">#</a></span></h3>
<h3>server.listen(port, [host], [backlog], [callback])<span><a href="all.html#all_server_listen_port_host_backlog_callback_2" id="all_server_listen_port_host_backlog_callback_2">#</a></span></h3>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback_3" id="all_server_listen_path_callback_3">#</a></span></h3>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback_3" id="all_server_listen_handle_callback_3">#</a></span></h3>
<p>See <a href="http.html#http_server_listen_port_hostname_backlog_callback">http.listen()</a> for details.

</p>
<p>详见 <a href="http.html#http_server_listen_port_hostname_backlog_callback">http.listen()</a>。

</p>
<h3>server.close([callback])<span><a href="all.html#all_server_close_callback_2" id="all_server_close_callback_2">#</a></span></h3>
<p>See <a href="http.html#http_server_close_callback">http.close()</a> for details.

</p>
<p>详见 <a href="http.html#http_server_close_callback">http.close()</a>。

</p>
<h2>https.request(options, callback)<span><a href="all.html#all_https_request_options_callback" id="all_https_request_options_callback">#</a></span></h2>
<p>Makes a request to a secure web server.

</p>
<p>向一个安全 Web 服务器发送请求。

</p>
<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is
automatically parsed with <a href="url.html#url.parse">url.parse()</a>.

</p>
<p><code>options</code> 可以是一个对象或字符串。如果 <code>options</code> 是字符串，它会自动被 <a href="url.html#url.parse">url.parse()</a> 解析。

</p>
<p>All options from <a href="http.html#http_http_request_options_callback">http.request()</a> are valid.

</p>
<p>所有来自 <a href="http.html#http_http_request_options_callback">http.request()</a> 的选项都是经过验证的。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>req.on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<p>The options argument has the following options

</p>
<p>options 参数有如下选项

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code>&apos;localhost&apos;</code>.</li>
<li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li>
<li><code>port</code>: Port of remote server. Defaults to 443.</li>
<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&apos;GET&apos;</code>.</li>
<li><code>path</code>: Request path. Defaults to <code>&apos;/&apos;</code>. Should include query string if any.
E.G. <code>&apos;/index.html?page=12&apos;</code></li>
<li><code>headers</code>: An object containing request headers.</li>
<li><code>auth</code>: Basic authentication i.e. <code>&apos;user:password&apos;</code> to compute an
Authorization header.</li>
<li><p><code>agent</code>: Controls <a href="all.html#https_class_https_agent">Agent</a> behavior. When an Agent is used request will
default to <code>Connection: keep-alive</code>. Possible values:</p>
<ul>
<li><code>undefined</code> (default): use <a href="all.html#https_https_globalagent">globalAgent</a> for this host and port.</li>
<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li>
</ul>
</li>
<li><p><code>host</code>：发送请求的服务器的域名或 IP 地址，缺省为 <code>&apos;localhost&apos;</code>。</p>
</li>
<li><code>hostname</code>：为了支持 <code>url.parse()</code>，<code>hostname</code> 优先于 <code>host</code>。</li>
<li><code>port</code>：远程服务器的端口，缺省为 443。</li>
<li><code>method</code>：指定 HTTP 请求方法的字符串，缺省为 `&apos;GET&apos;。</li>
<li><code>path</code>：请求路径，缺省为 <code>&apos;/&apos;</code>。如有查询字串则应包含，比如 <code>&apos;/index.html?page=12&apos;</code>。</li>
<li><code>headers</code>：包含请求头的对象。</li>
<li><code>auth</code>：基本认证，如 <code>&apos;user:password&apos;</code> 来计算 Authorization 头。</li>
<li><code>agent</code>：控制 <a href="all.html#https_class_https_agent">Agent</a> 行为。当使用 Agent 时请求会缺省为 <code>Connection: keep-alive</code>。可选值有：<ul>
<li><code>undefined</code>（缺省）：为该主机和端口使用 <a href="all.html#https_https_globalagent">globalAgent</a>。</li>
<li><code>Agent</code> 对象：明确使用传入的 <code>Agent</code>。</li>
<li><code>false</code>：不使用 Agent 连接池，缺省请求 <code>Connection: close</code>。</li>
</ul>
</li>
</ul>
<p>The following options from <a href="tls.html#tls_tls_connect_options_callback">tls.connect()</a> can also be specified. However, a
<a href="all.html#https_https_globalagent">globalAgent</a> silently ignores these.

</p>
<p>下列来自 <a href="tls.html#tls_tls_connect_options_callback">tls.connect()</a> 的选项也能够被指定，但一个 <a href="all.html#https_https_globalagent">globalAgent</a> 会忽略它们。

</p>
<ul>
<li><code>pfx</code>: Certificate, Private key and CA certificates to use for SSL. Default <code>null</code>.</li>
<li><code>key</code>: Private key to use for SSL. Default <code>null</code>.</li>
<li><code>passphrase</code>: A string of passphrase for the private key or pfx. Default <code>null</code>.</li>
<li><code>cert</code>: Public x509 certificate to use. Default <code>null</code>.</li>
<li><code>ca</code>: An authority certificate or array of authority certificates to check
the remote host against.</li>
<li><code>ciphers</code>: A string describing the ciphers to use or exclude. Consult
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a> for
details on the format.</li>
<li><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against
the list of supplied CAs. An <code>&apos;error&apos;</code> event is emitted if verification
fails. Verification happens at the connection level, <em>before</em> the HTTP
request is sent. Default <code>true</code>.</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
<li><p><code>pfx</code>：证书，SSL 所用的私钥或 CA 证书。缺省为 <code>null</code>。</p>
</li>
<li><code>key</code>：SSL 所用私钥。缺省为 <code>null</code>。</li>
<li><code>passphrase</code>：私钥或 pfx 的口令字符串，缺省为 <code>null</code>。</li>
<li><code>cert</code>：所用公有 x509 证书，缺省为 <code>null</code>。</li>
<li><code>ca</code>：用于检查远程主机的证书颁发机构或包含一系列证书颁发机构的数组。</li>
<li><code>ciphers</code>：描述要使用或排除的密码的字符串，格式请参阅 <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>。</li>
<li><code>rejectUnauthorized</code>：如为 <code>true</code> 则服务器证书会使用所给 CA 列表验证。如果验证失败则会触发 <code>&apos;error&apos;</code> 时间。验证过程发生于连接层，在 HTTP 请求发送<em>之前</em>。缺省为 <code>true</code>。</li>
<li><code>secureProtocol</code>：所用 SSL 方法，比如 <code>SSLv3_method</code> 强制使用 SSL version 3。可取值取决于您安装的 OpenSSL 并被定义在 <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a> 常量。</li>
</ul>
<p>In order to specify these options, use a custom <code>Agent</code>.

</p>
<p>要指定这些选项，使用一个自定义 <code>Agent</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var req = https.request(options, function(res) {
  ...
}</code></pre>
<p>Or does not use an <code>Agent</code>.

</p>
<p>或不使用 <code>Agent</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var req = https.request(options, function(res) {
  ...
}</code></pre>
<h2>https.get(options, callback)<span><a href="all.html#all_https_get_options_callback" id="all_https_get_options_callback">#</a></span></h2>
<p>Like <code>http.get()</code> but for HTTPS.

</p>
<p>类似 <code>http.get()</code> 但为 HTTPS。

</p>
<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is
automatically parsed with <a href="url.html#url.parse">url.parse()</a>.

</p>
<p><code>options</code> 可以是一个对象或字符串。如果 <code>options</code> 是字符串，它会自动被 <a href="url.html#url.parse">url.parse()</a> 解析。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>}).on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<h2>类: https.Agent<span><a href="all.html#all_https_agent" id="all_https_agent">#</a></span></h2>
<p>An Agent object for HTTPS similar to <a href="http.html#http_class_http_agent">http.Agent</a>.  See <a href="all.html#https_https_request_options_callback">https.request()</a>
for more information.

</p>
<p>类似于 <a href="http.html#http_class_http_agent">http.Agent</a> 的 HTTPS Agent 对象。详见 <a href="all.html#https_https_request_options_callback">https.request()</a>。

</p>
<h2>https.globalAgent<span><a href="all.html#all_https_globalagent" id="all_https_globalagent">#</a></span></h2>
<p>Global instance of <a href="all.html#https_class_https_agent">https.Agent</a> for all HTTPS client requests.

</p>
<p>所有 HTTPS 客户端请求的全局 <a href="all.html#https_class_https_agent">https.Agent</a> 实例。

</p>
<h1>URL<span><a href="all.html#all_url" id="all_url">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>This module has utilities for URL resolution and parsing.
Call <code>require(&apos;url&apos;)</code> to use it.

</p>
<p>该模块包含用以 URL 解析的实用函数。
使用 <code>require(&apos;url&apos;)</code> 来调用该模块。

</p>
<p>Parsed URL objects have some or all of the following fields, depending on
whether or not they exist in the URL string. Any parts that are not in the URL
string will not be in the parsed object. Examples are shown for the URL

</p>
<p>不同的 URL 字符串解析后返回的对象会有一些额外的字段信息，仅当该部分出现在 URL 中才会有。以下是一个 URL 例子：

</p>
<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>

</p>
<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>

</p>
<ul>
<li><p><code>href</code>: The full URL that was originally parsed. Both the protocol and host are lowercased.</p>
</li>
<li><p><code>href</code>: 所解析的完整原始 URL。协议名和主机名都已转为小写。</p>
<p>  例如: <code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code></p>
</li>
<li><p><code>protocol</code>: The request protocol, lowercased.</p>
</li>
<li><p><code>protocol</code>: 请求协议，小写</p>
<p>  例如: <code>&apos;http:&apos;</code></p>
</li>
<li><p><code>host</code>: The full lowercased host portion of the URL, including port
information.</p>
</li>
<li><p><code>host</code>: URL主机名已全部转换成小写, 包括端口信息</p>
<p>  例如: <code>&apos;host.com:8080&apos;</code></p>
</li>
<li><p><code>auth</code>: The authentication information portion of a URL.</p>
</li>
<li><p><code>auth</code>:URL中身份验证信息部分</p>
<p>  例如: <code>&apos;user:pass&apos;</code></p>
</li>
<li><p><code>hostname</code>: Just the lowercased hostname portion of the host.</p>
</li>
<li><p><code>hostname</code>:主机的主机名部分, 已转换成小写</p>
<p>  例如: <code>&apos;host.com&apos;</code></p>
</li>
<li><p><code>port</code>: The port number portion of the host.</p>
</li>
<li><p><code>port</code>: 主机的端口号部分</p>
<p>  例如: <code>&apos;8080&apos;</code></p>
</li>
<li><p><code>pathname</code>: The path section of the URL, that comes after the host and
before the query, including the initial slash if present.</p>
</li>
<li><p><code>pathname</code>: URL的路径部分,位于主机名之后请求查询之前, including the initial slash if present.</p>
<p>  例如: <code>&apos;/p/a/t/h&apos;</code></p>
</li>
<li><p><code>search</code>: The &apos;query string&apos; portion of the URL, including the leading
question mark.</p>
</li>
<li><p><code>search</code>: URL 的“查询字符串”部分，包括开头的问号。</p>
<p>  例如: <code>&apos;?query=string&apos;</code></p>
</li>
<li><p><code>path</code>: Concatenation of <code>pathname</code> and <code>search</code>.</p>
</li>
<li><p><code>path</code>: <code>pathname</code> 和 <code>search</code> 连在一起。</p>
<p>  例如: <code>&apos;/p/a/t/h?query=string&apos;</code></p>
</li>
<li><p><code>query</code>: Either the &apos;params&apos; portion of the query string, or a
querystring-parsed object.</p>
</li>
<li><p><code>query</code>: 查询字符串中的参数部分（问号后面部分字符串），或者使用  <code>querystring.parse()</code> 解析后返回的对象。</p>
<p>  例如: <code>&apos;query=string&apos;</code> or <code>{&apos;query&apos;:&apos;string&apos;}</code></p>
</li>
<li><p><code>hash</code>: The &apos;fragment&apos; portion of the URL including the pound-sign.</p>
</li>
<li><p><code>hash</code>: URL 的 “#” 后面部分（包括 # 符号） </p>
<p>  例如: <code>&apos;#hash&apos;</code></p>
</li>
</ul>
<p>The following methods are provided by the URL module:

</p>
<p>以下是 URL 模块提供的方法：

</p>
<h2>url.parse(urlStr, [parseQueryString], [slashesDenoteHost])<span><a href="all.html#all_url_parse_urlstr_parsequerystring_slashesdenotehost" id="all_url_parse_urlstr_parsequerystring_slashesdenotehost">#</a></span></h2>
<p>Take a URL string, and return an object.

</p>
<p>输入 URL 字符串，返回一个对象。

</p>
<p>Pass <code>true</code> as the second argument to also parse
the query string using the <code>querystring</code> module.
Defaults to <code>false</code>.

</p>
<p>将第二个参数设置为 <code>true</code> 则使用 <code>querystring</code> 模块来解析 URL 中德查询字符串部分，默认为 <code>false</code>。

</p>
<p>Pass <code>true</code> as the third argument to treat <code>//foo/bar</code> as
<code>{ host: &apos;foo&apos;, pathname: &apos;/bar&apos; }</code> rather than
<code>{ pathname: &apos;//foo/bar&apos; }</code>. Defaults to <code>false</code>.

</p>
<p>将第三个参数设置为 <code>true</code> 来把诸如 <code>//foo/bar</code> 这样的URL解析为
<code>{ host: &apos;foo&apos;, pathname: &apos;/bar&apos; }</code> 而不是
<code>{ pathname: &apos;//foo/bar&apos; }</code>。 默认为 <code>false</code>。

</p>
<h2>url.format(urlObj)<span><a href="all.html#all_url_format_urlobj" id="all_url_format_urlobj">#</a></span></h2>
<p>Take a parsed URL object, and return a formatted URL string.

</p>
<p>输入一个 URL 对象，返回格式化后的 URL 字符串。

</p>
<ul>
<li><code>href</code> will be ignored.</li>
<li><code>protocol</code>is treated the same with or without the trailing <code>:</code> (colon).<ul>
<li>The protocols <code>http</code>, <code>https</code>, <code>ftp</code>, <code>gopher</code>, <code>file</code> will be
postfixed with <code>://</code> (colon-slash-slash).</li>
<li>All other protocols <code>mailto</code>, <code>xmpp</code>, <code>aim</code>, <code>sftp</code>, <code>foo</code>, etc will
be postfixed with <code>:</code> (colon)</li>
</ul>
</li>
<li><code>auth</code> will be used if present.</li>
<li><code>hostname</code> will only be used if <code>host</code> is absent.</li>
<li><code>port</code> will only be used if <code>host</code> is absent.</li>
<li><code>host</code> will be used in place of <code>hostname</code> and <code>port</code></li>
<li><code>pathname</code> is treated the same with or without the leading <code>/</code> (slash)</li>
<li><code>search</code> will be used in place of <code>query</code></li>
<li><code>query</code> (object; see <code>querystring</code>) will only be used if <code>search</code> is absent.</li>
<li><code>search</code> is treated the same with or without the leading <code>?</code> (question mark)</li>
<li><p><code>hash</code> is treated the same with or without the leading <code>#</code> (pound sign, anchor)</p>
</li>
<li><p><code>href</code> 属性会被忽略处理.</p>
</li>
<li><code>protocol</code>无论是否有末尾的 <code>:</code> (冒号)，会同样的处理<ul>
<li>这些协议包括 <code>http</code>, <code>https</code>, <code>ftp</code>, <code>gopher</code>, <code>file</code> 
后缀是 <code>://</code> (冒号-斜杠-斜杠).</li>
<li>所有其他的协议如 <code>mailto</code>, <code>xmpp</code>, <code>aim</code>, <code>sftp</code>, <code>foo</code>, 等
 会加上后缀 <code>:</code> (冒号)</li>
</ul>
</li>
<li><code>auth</code> 如果有将会出现.</li>
<li><code>hostname</code> 如果 <code>host</code> 属性没被定义，则会使用此属性.</li>
<li><code>port</code> 如果 <code>host</code> 属性没被定义，则会使用此属性.</li>
<li><code>host</code> 优先使用，将会替代 <code>hostname</code> 和<code>port</code></li>
<li><code>pathname</code> 将会同样处理无论结尾是否有<code>/</code> (斜杠)</li>
<li><code>search</code> 将会替代 <code>query</code>属性</li>
<li><code>query</code> (object类型; 详细请看 <code>querystring</code>) 如果没有 <code>search</code>,将会使用此属性.</li>
<li><code>search</code> 无论前面是否有 <code>?</code> (问号)，都会同样的处理</li>
<li><code>hash</code>无论前面是否有<code>#</code> (井号, 锚点)，都会同样处理</li>
</ul>
<h2>url.resolve(from, to)<span><a href="all.html#all_url_resolve_from_to" id="all_url_resolve_from_to">#</a></span></h2>
<p>Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.  Examples:

</p>
<p>给定一个基础URL路径，和一个href URL路径，并且象浏览器那样处理他们可以带上锚点。 例子：

</p>
<pre><code>url.resolve(&apos;/one/two/three&apos;, &apos;four&apos;)         // &apos;/one/two/four&apos;
url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;


url.resolve(&apos;/one/two/three&apos;, &apos;four&apos;)         // &apos;/one/two/four&apos;
url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;</code></pre>
<h1>Query String<span><a href="all.html#all_query_string" id="all_query_string">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!--name=querystring-->

<p>This module provides utilities for dealing with query strings.
It provides the following methods:

</p>
<p>这个模块提供一些处理 query string 的工具。它提供下列方法：

</p>
<h2>querystring.stringify(obj, [sep], [eq])<span><a href="all.html#all_querystring_stringify_obj_sep_eq" id="all_querystring_stringify_obj_sep_eq">#</a></span></h2>
<p>Serialize an object to a query string.
Optionally override the default separator (<code>&apos;&amp;&apos;</code>) and assignment (<code>&apos;=&apos;</code>)
characters.

</p>
<p>序列化一个对象到一个 query string。可以选择是否覆盖默认的分割符（<code>&apos;&amp;&apos;</code>）和分配符（<code>&apos;=&apos;</code>）。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>querystring.stringify({foo: &apos;bar&apos;, baz: &apos;qux&apos;}, &apos;;&apos;, &apos;:&apos;)
// 返回如下字串
&apos;foo:bar;baz:qux&apos;</code></pre>
<h2>querystring.parse(str, [sep], [eq], [options])<span><a href="all.html#all_querystring_parse_str_sep_eq_options" id="all_querystring_parse_str_sep_eq_options">#</a></span></h2>
<p>Deserialize a query string to an object.
Optionally override the default separator (<code>&apos;&amp;&apos;</code>) and assignment (<code>&apos;=&apos;</code>)
characters.

</p>
<p>将一个 query string 反序列化为一个对象。可以选择是否覆盖默认的分割符（<code>&apos;&amp;&apos;</code>）和分配符（<code>&apos;=&apos;</code>）。

</p>
<p>Options object may contain <code>maxKeys</code> property (equal to 1000 by default), it&apos;ll
be used to limit processed keys. Set it to 0 to remove key count limitation.

</p>
<p>options对象可能包含<code>maxKeys</code>属性(默认为1000),它可以用来限制处理过的键(key)的数量.设为0可以去除键(key)的数量限制.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;)
// returns
{ foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; }</code></pre>
<h2>querystring.escape<span><a href="all.html#all_querystring_escape" id="all_querystring_escape">#</a></span></h2>
<p>The escape function used by <code>querystring.stringify</code>,
provided so that it could be overridden if necessary.

</p>
<p>供 <code>querystring.stringify</code> 使用的转意函数，在必要的时候可被重写。

</p>
<h2>querystring.unescape<span><a href="all.html#all_querystring_unescape" id="all_querystring_unescape">#</a></span></h2>
<p>The unescape function used by <code>querystring.parse</code>,
provided so that it could be overridden if necessary.


</p>
<p>供 <code>querystring.parse</code> 使用的反转意函数，在必要的时候可被重写。

</p>
<h1>punycode<span><a href="all.html#all_punycode" id="all_punycode">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p><a href="http://mths.be/punycode">Punycode.js</a> is bundled with Node.js v0.6.2+. Use
<code>require(&apos;punycode&apos;)</code> to access it. (To use it with other Node.js versions,
use npm to install the <code>punycode</code> module first.)

</p>
<p><a href="http://mths.be/punycode">Punycode.js</a> 自 Node.js v0.6.2+ 开始被内置，通过 <code>require(&apos;punycode&apos;)</code> 引入。（要在其它 Node.js 版本中使用它，请先使用 npm 安装 <code>punycode</code> 模块。）

</p>
<h2>punycode.decode(string)<span><a href="all.html#all_punycode_decode_string" id="all_punycode_decode_string">#</a></span></h2>
<p>Converts a Punycode string of ASCII-only symbols to a string of Unicode symbols.

</p>
<p>将一个纯 ASCII 符号的 Punycode 字符串转换为 Unicode 符号的字符串。

</p>
<pre><code>// 解码域名部分
punycode.decode(&apos;maana-pta&apos;); // &apos;mañana&apos;
punycode.decode(&apos;--dqo34k&apos;); // &apos;☃-⌘&apos;</code></pre>
<h2>punycode.encode(string)<span><a href="all.html#all_punycode_encode_string" id="all_punycode_encode_string">#</a></span></h2>
<p>Converts a string of Unicode symbols to a Punycode string of ASCII-only symbols.

</p>
<p>将一个 Unicode 符号的字符串转换为纯 ASCII 符号的 Punycode 字符串。

</p>
<pre><code>// 编码域名部分
punycode.encode(&apos;mañana&apos;); // &apos;maana-pta&apos;
punycode.encode(&apos;☃-⌘&apos;); // &apos;--dqo34k&apos;</code></pre>
<h2>punycode.toUnicode(domain)<span><a href="all.html#all_punycode_tounicode_domain" id="all_punycode_tounicode_domain">#</a></span></h2>
<p>Converts a Punycode string representing a domain name to Unicode. Only the
Punycoded parts of the domain name will be converted, i.e. it doesn&apos;t matter if
you call it on a string that has already been converted to Unicode.

</p>
<p>将一个表示域名的 Punycode 字符串转换为 Unicode。只有域名中的 Punycode 部分会转换，也就是说您在一个已经转换为 Unicode 的字符串上调用它也是没问题的。

</p>
<pre><code>// 解码域名
punycode.toUnicode(&apos;xn--maana-pta.com&apos;); // &apos;mañana.com&apos;
punycode.toUnicode(&apos;xn----dqo34k.com&apos;); // &apos;☃-⌘.com&apos;</code></pre>
<h2>punycode.toASCII(domain)<span><a href="all.html#all_punycode_toascii_domain" id="all_punycode_toascii_domain">#</a></span></h2>
<p>Converts a Unicode string representing a domain name to Punycode. Only the
non-ASCII parts of the domain name will be converted, i.e. it doesn&apos;t matter if
you call it with a domain that&apos;s already in ASCII.

</p>
<p>将一个表示域名的 Unicode 字符串转换为 Punycode。只有域名的非 ASCII 部分会被转换，也就是说您在一个已经是 ASCII 的域名上调用它也是没问题的。

</p>
<pre><code>// 编码域名
punycode.toASCII(&apos;mañana.com&apos;); // &apos;xn--maana-pta.com&apos;
punycode.toASCII(&apos;☃-⌘.com&apos;); // &apos;xn----dqo34k.com&apos;</code></pre>
<h2>punycode.ucs2<span><a href="all.html#all_punycode_ucs2" id="all_punycode_ucs2">#</a></span></h2>
<h3>punycode.ucs2.decode(string)<span><a href="all.html#all_punycode_ucs2_decode_string" id="all_punycode_ucs2_decode_string">#</a></span></h3>
<p>Creates an array containing the numeric code point values of each Unicode
symbol in the string. While <a href="http://mathiasbynens.be/notes/javascript-encoding">JavaScript uses UCS-2
internally</a>, this function
will convert a pair of surrogate halves (each of which UCS-2 exposes as
separate characters) into a single code point, matching UTF-16.

</p>
<p>创建一个数组，包含字符串中每个 Unicode 符号的数字编码点。由于 <a href="http://mathiasbynens.be/notes/javascript-encoding">JavaScript 在内部使用 UCS-2</a>，
该函数会按照 UTF-16 将一对代半数（UCS-2 暴露的单独的字符）转换为单独一个编码点。

</p>
<pre><code>punycode.ucs2.decode(&apos;abc&apos;); // [0x61, 0x62, 0x63]
// surrogate pair for U+1D306 tetragram for centre:
punycode.ucs2.decode(&apos;\uD834\uDF06&apos;); // [0x1D306]</code></pre>
<h3>punycode.ucs2.encode(codePoints)<span><a href="all.html#all_punycode_ucs2_encode_codepoints" id="all_punycode_ucs2_encode_codepoints">#</a></span></h3>
<p>Creates a string based on an array of numeric code point values.

</p>
<p>以数字编码点的值的数组创建一个字符串。

</p>
<pre><code>punycode.ucs2.encode([0x61, 0x62, 0x63]); // &apos;abc&apos;
punycode.ucs2.encode([0x1D306]); // &apos;\uD834\uDF06&apos;</code></pre>
<h2>punycode.version<span><a href="all.html#all_punycode_version" id="all_punycode_version">#</a></span></h2>
<p>A string representing the current Punycode.js version number.


</p>
<p>表示当前 Punycode.js 版本号的字符串。
</p>
<h1>Readline<span><a href="all.html#all_readline" id="all_readline">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p>To use this module, do <code>require(&apos;readline&apos;)</code>. Readline allows reading of a
stream (such as <code>process.stdin</code>) on a line-by-line basis.

</p>
<p>要使用此模块，需要<code>require(&apos;readline&apos;)</code>.Readline程序允许逐行读取一个流内容(例如<code>process.stdin</code>).

</p>
<p>Note that once you&apos;ve invoked this module, your node program will not
terminate until you&apos;ve closed the interface. Here&apos;s how to allow your
program to gracefully exit:

</p>
<p>需要注意的是你一旦调用了这个模块，你的node程序将不会终止直到你关闭此接口。下面是如何让你的程序正常退出的方法:

</p>
<pre><code>  rl.close();
});</code></pre>
<h2>readline.createInterface(options)<span><a href="all.html#all_readline_createinterface_options" id="all_readline_createinterface_options">#</a></span></h2>
<p>Creates a readline <code>Interface</code> instance. Accepts an &quot;options&quot; Object that takes
the following values:

</p>
<p>创建一个readline的接口实例. 接受一个Object类型参数，可传递以下几个值:

</p>
<ul>
<li><p><code>input</code> - the readable stream to listen to (Required).</p>
</li>
<li><p><code>input</code> - 要监听的可读流 (必需).</p>
</li>
<li><p><code>output</code> - the writable stream to write readline data to (Required).</p>
</li>
<li><p><code>output</code> - 要写入 readline 的可写流 (必须).</p>
</li>
<li><p><code>completer</code> - an optional function that is used for Tab autocompletion. See
below for an example of using this.</p>
</li>
<li><p><code>completer</code> - 用于 Tab 自动补全的可选函数。见下面使用的例子。</p>
</li>
<li><p><code>terminal</code> - pass <code>true</code> if the <code>input</code> and <code>output</code> streams should be
treated like a TTY, and have ANSI/VT100 escape codes written to it.
Defaults to checking <code>isTTY</code> on the <code>output</code> stream upon instantiation.</p>
</li>
<li><p><code>terminal</code> - 如果希望 <code>input</code> 和 <code>output</code> 流像 TTY 一样对待，那么传递参数 <code>true</code> ，并且经由 ANSI/VT100 转码。
默认情况下检查 <code>isTTY</code> 是否在 <code>output</code> 流上实例化。</p>
</li>
</ul>
<p>The <code>completer</code> function is given a the current line entered by the user, and
is supposed to return an Array with 2 entries:

</p>
<p>通过用户 <code>completer</code> 函数给定了一个当前行入口，并且期望返回一个包含两个条目的数组：

</p>
<ol>
<li><p>An Array with matching entries for the completion.</p>
</li>
<li><p>一个匹配当前输入补全的字符串数组.</p>
</li>
<li><p>The substring that was used for the matching.</p>
</li>
<li><p>一个用于匹配的子字符串。</p>
</li>
</ol>
<p>Which ends up looking something like:
<code>[[substr1, substr2, ...], originalsubstring]</code>.

</p>
<p>最终像这种形式:
<code>[[substr1, substr2, ...], originalsubstring]</code>.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>function completer(line) {
  var completions = &apos;.help .error .exit .quit .q&apos;.split(&apos; &apos;)
  var hits = completions.filter(function(c) { return c.indexOf(line) == 0 })
  // show all completions if none found
  return [hits.length ? hits : completions, line]
}</code></pre>
<p>Also <code>completer</code> can be run in async mode if it accepts two arguments:

</p>
<p><code>completer</code> 也可以运行在异步模式下，此时接受两个参数：

</p>
<pre><code>function completer(linePartial, callback) {
  callback(null, [[&apos;123&apos;], linePartial]);
}</code></pre>
<p><code>createInterface</code> is commonly used with <code>process.stdin</code> and
<code>process.stdout</code> in order to accept user input:

</p>
<p>为了接受用户的输入，<code>createInterface</code> 通常跟 <code>process.stdin</code> 和 <code>process.stdout</code> 一块使用：

</p>
<pre><code>var readline = require(&apos;readline&apos;);
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});</code></pre>
<p>Once you have a readline instance, you most commonly listen for the
<code>&quot;line&quot;</code> event.

</p>
<p>一旦你有一个 readline 实例，你通常会监听 &quot;line&quot; 事件。

</p>
<p>If <code>terminal</code> is <code>true</code> for this instance then the <code>output</code> stream will get
the best compatibility if it defines an <code>output.columns</code> property, and fires
a <code>&quot;resize&quot;</code> event on the <code>output</code> if/when the columns ever change
(<code>process.stdout</code> does this automatically when it is a TTY).

</p>
<p>如果这个实例中<code>terminal</code>为<code>true</code>，而且<code>output</code>流定义了一个<code>output.columns</code>属性，那么<code>output</code>流将获得最好的兼容性，并且，当columns变化时(当它是TTY时，<code>process.stdout</code>会自动这样做)，会在<code>output</code>上触发一个 <code>&quot;resize&quot;</code>事件。

</p>
<h2>类: 接口<span><a href="all.html#all_29" id="all_29">#</a></span></h2>
<p>The class that represents a readline interface with an input and output
stream.

</p>
<p>代表一个有输入输出流的 readline 接口的类。

</p>
<h3>rl.setPrompt(prompt)<span><a href="all.html#all_rl_setprompt_prompt" id="all_rl_setprompt_prompt">#</a></span></h3>
<p>Sets the prompt, for example when you run <code>node</code> on the command line, you see
<code>&gt; </code>, which is node&apos;s prompt.

</p>
<p>设置提示符，例如当你在命令行运行 <code>node</code> 时，你会看到 <code>&gt; </code> ，这就是 node 的提示符。

</p>
<h3>rl.prompt([preserveCursor])<span><a href="all.html#all_rl_prompt_preservecursor" id="all_rl_prompt_preservecursor">#</a></span></h3>
<p>Readies readline for input from the user, putting the current <code>setPrompt</code>
options on a new line, giving the user a new spot to write. Set <code>preserveCursor</code>
to <code>true</code> to prevent the cursor placement being reset to <code>0</code>.

</p>
<p>为用户输入准备好readline，将现有的<code>setPrompt</code>选项放到新的一行，让用户有一个新的地方开始输入。将<code>preserveCursor</code>设为<code>true</code>来防止光标位置被重新设定成<code>0</code>。

</p>
<p>This will also resume the <code>input</code> stream used with <code>createInterface</code> if it has
been paused.

</p>
<p>如果暂停，也会使用 <code>createInterface</code> 重置 <code>input</code> 流。

</p>
<h3>rl.question(query, callback)<span><a href="all.html#all_rl_question_query_callback" id="all_rl_question_query_callback">#</a></span></h3>
<p>Prepends the prompt with <code>query</code> and invokes <code>callback</code> with the user&apos;s
response. Displays the query to the user, and then invokes <code>callback</code>
with the user&apos;s response after it has been typed.

</p>
<p>预处理 <code>query</code>提示 ，用户应答时调用 <code>callback</code> . 当类型被确定后，将查询结果显示给用户, 然后在用户应答时调用 <code>callback</code>.

</p>
<p>This will also resume the <code>input</code> stream used with <code>createInterface</code> if
it has been paused.

</p>
<p>如果暂停，也会使用 <code>createInterface</code> 重置 <code>input</code> 流。

</p>
<p>Example usage:

</p>
<p>使用示例：

</p>
<pre><code>interface.question(&apos;What is your favorite food?&apos;, function(answer) {
  console.log(&apos;Oh, so your favorite food is &apos; + answer);
});</code></pre>
<h3>rl.pause()<span><a href="all.html#all_rl_pause" id="all_rl_pause">#</a></span></h3>
<p>Pauses the readline <code>input</code> stream, allowing it to be resumed later if needed.

</p>
<p>暂停 readline 的输入流 (<code>input</code> stream), 如果有需要稍后还可以恢复。

</p>
<h3>rl.resume()<span><a href="all.html#all_rl_resume" id="all_rl_resume">#</a></span></h3>
<p>Resumes the readline <code>input</code> stream.

</p>
<p>恢复 readline 的输入流 (<code>input</code> stream).

</p>
<h3>rl.close()<span><a href="all.html#all_rl_close" id="all_rl_close">#</a></span></h3>
<p>Closes the <code>Interface</code> instance, relinquishing control on the <code>input</code> and
<code>output</code> streams. The &quot;close&quot; event will also be emitted.

</p>
<p>关闭接口实例 (<code>Interface</code> instance), 放弃控制输入输出流。&quot;close&quot; 事件会被触发。

</p>
<h3>rl.write(data, [key])<span><a href="all.html#all_rl_write_data_key" id="all_rl_write_data_key">#</a></span></h3>
<p>Writes <code>data</code> to <code>output</code> stream. <code>key</code> is an object literal to represent a key
sequence; available if the terminal is a TTY.

</p>
<p>将 <code>data</code> 写入到 <code>output</code> 流。<code>key</code> 是一个代表键序列的对象；当终端是一个 TTY 时可用。

</p>
<p>This will also resume the <code>input</code> stream if it has been paused.

</p>
<p>如果暂停，也会重置 <code>input</code> 流。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>rl.write(&apos;Delete me!&apos;);
// 模仿 ctrl+u快捷键，删除之前所写行 
rl.write(null, {ctrl: true, name: &apos;u&apos;});</code></pre>
<h2>Events<span><a href="all.html#all_events" id="all_events">#</a></span></h2>
<h3>Event: &apos;line&apos;<span><a href="all.html#all_event_line" id="all_event_line">#</a></span></h3>
<p><code>function (line) {}</code>

</p>
<p><code>function (line) {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream receives a <code>\n</code>, usually received when the
user hits enter, or return. This is a good hook to listen for user input.

</p>
<p>在 <code>input</code> 流接受了一个 <code>\n</code> 时触发，通常在用户敲击回车或者返回时接收。
这是一个监听用户输入的利器。

</p>
<p>Example of listening for <code>line</code>:

</p>
<p>监听 <code>line</code> 事件的示例:

</p>
<pre><code>rl.on(&apos;line&apos;, function (cmd) {
  console.log(&apos;You just typed: &apos;+cmd);
});</code></pre>
<h3>事件: &apos;pause&apos;<span><a href="all.html#all_pause" id="all_pause">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream is paused.

</p>
<p>不论何时，只要输入流被暂停就会触发。

</p>
<p>Also emitted whenever the <code>input</code> stream is not paused and receives the
<code>SIGCONT</code> event. (See events <code>SIGTSTP</code> and <code>SIGCONT</code>)

</p>
<p>而在输入流未被暂停，但收到 <code>SIGCONT</code> 信号时也会触发。 (详见 <code>SIGTSTP</code> 和 <code>SIGCONT</code> 事件)

</p>
<p>Example of listening for <code>pause</code>:

</p>
<p>监听 <code>pause</code> 事件的示例：

</p>
<pre><code>rl.on(&apos;pause&apos;, function() {
  console.log(&apos;Readline 输入暂停.&apos;);
});</code></pre>
<h3>事件: &apos;resume&apos;<span><a href="all.html#all_resume" id="all_resume">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream is resumed.

</p>
<p>不论何时，只要输入流重新启用就会触发。

</p>
<p>Example of listening for <code>resume</code>:

</p>
<p>监听 <code>resume</code> 事件的示例：

</p>
<pre><code>rl.on(&apos;resume&apos;, function() {
  console.log(&apos;Readline 恢复.&apos;);
});</code></pre>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_7" id="all_close_7">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted when <code>close()</code> is called.

</p>
<p>当 <code>close()</code> 被调用时触发。

</p>
<p>Also emitted when the <code>input</code> stream receives its &quot;end&quot; event. The <code>Interface</code>
instance should be considered &quot;finished&quot; once this is emitted. For example, when
the <code>input</code> stream receives <code>^D</code>, respectively known as <code>EOT</code>.

</p>
<p>当 <code>input</code>流接收到&quot;结束&quot;事件时也会被触发. 一旦触发，应当认为<code>Interface</code>实例
 &quot;结束&quot; . 例如, 当<code>input</code>流接收到<code>^D</code>时, 分别被认为<code>EOT</code>.

</p>
<p>This event is also called if there is no <code>SIGINT</code> event listener present when
the <code>input</code> stream receives a <code>^C</code>, respectively known as <code>SIGINT</code>.

</p>
<p>当 <code>input</code> 流接收到一个 <code>^C</code> 时，即使没有 <code>SIGINT</code> 监听器，也会触发这个事件，分别被称为 <code>SIGINT</code> 。

</p>
<h3>Event: &apos;SIGINT&apos;<span><a href="all.html#all_event_sigint" id="all_event_sigint">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream receives a <code>^C</code>, respectively known as
<code>SIGINT</code>. If there is no <code>SIGINT</code> event listener present when the <code>input</code>
stream receives a <code>SIGINT</code>, <code>pause</code> will be triggered.

</p>
<p>只要 <code>input</code>流 接收到<code>^C</code>就会被触发, 分别被认为<code>SIGINT</code>.当<code>input</code>流接收到<code>SIGINT</code>时, 
 如果没有 <code>SIGINT</code> 事件监听器，<code>pause</code> 将会被触发.

</p>
<p>Example of listening for <code>SIGINT</code>:

</p>
<p>监听 <code>SIGINT</code> 信号的示例：

</p>
<pre><code>rl.on(&apos;SIGINT&apos;, function() {
  rl.question(&apos;Are you sure you want to exit?&apos;, function(answer) {
    if (answer.match(/^y(es)?$/i)) rl.pause();
  });
});</code></pre>
<h3>Event: &apos;SIGTSTP&apos;<span><a href="all.html#all_event_sigtstp" id="all_event_sigtstp">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p><strong>This does not work on Windows.</strong>

</p>
<p><strong>该功能不支持 windows 操作系统</strong>

</p>
<p>Emitted whenever the <code>input</code> stream receives a <code>^Z</code>, respectively known as
<code>SIGTSTP</code>. If there is no <code>SIGTSTP</code> event listener present when the <code>input</code>
stream receives a <code>SIGTSTP</code>, the program will be sent to the background.

</p>
<p>只要<code>input</code>流接收到<code>^Z</code>时就被触发, 分别被认为<code>SIGTSTP</code>. 当<code>input</code>流接收到
 <code>SIGTSTP</code>时，如果没有<code>SIGTSTP</code> 事件监听器 ,程序会被发送到后台 .

</p>
<p>When the program is resumed with <code>fg</code>, the <code>pause</code> and <code>SIGCONT</code> events will be
emitted. You can use either to resume the stream.

</p>
<p>当程序使用参数 <code>fg</code> 重启，<code>pause</code> 和 <code>SIGCONT</code> 事件将会被触发。
你可以使用两者中任一事件来恢复流。

</p>
<p>The <code>pause</code> and <code>SIGCONT</code> events will not be triggered if the stream was paused
before the program was sent to the background.

</p>
<p>在程序被发送到后台之前，如果流暂停，<code>pause</code> 和 <code>SIGCONT</code> 事件将不会被触发。

</p>
<p>Example of listening for <code>SIGTSTP</code>:

</p>
<p>监听 <code>SIGTSTP</code> 的示例：

</p>
<pre><code>rl.on(&apos;SIGTSTP&apos;, function() {
  // 这将重载 SIGTSTP并防止程序转到
  // 后台.
  console.log(&apos;Caught SIGTSTP.&apos;);
});</code></pre>
<h3>Event: &apos;SIGCONT&apos;<span><a href="all.html#all_event_sigcont" id="all_event_sigcont">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p><strong>This does not work on Windows.</strong>

</p>
<p><strong>该功能不支持 windows 操作系统</strong>

</p>
<p>Emitted whenever the <code>input</code> stream is sent to the background with <code>^Z</code>,
respectively known as <code>SIGTSTP</code>, and then continued with <code>fg(1)</code>. This event
only emits if the stream was not paused before sending the program to the
background.

</p>
<p>一旦 <code>input</code>流中含有 <code>^Z</code>并被发送到后台就会触发,分别被认为
 <code>SIGTSTP</code>, 然后继续执行<code>fg(1)</code>. 这一事件只有在流被发送后台之前没有暂停才会触发.

</p>
<p>Example of listening for <code>SIGCONT</code>:

</p>
<p>监听 <code>SIGCONT</code> 的示例:

</p>
<pre><code>rl.on(&apos;SIGCONT&apos;, function() {
  // `prompt` 将会自动恢复流
  rl.prompt();
});</code></pre>
<h2>示例: Tiny CLI<span><a href="all.html#all_tiny_cli" id="all_tiny_cli">#</a></span></h2>
<p>Here&apos;s an example of how to use all these together to craft a tiny command
line interface:

</p>
<p>这里有一个使用所有方法精心设计的小命令行程序：

</p>
<pre><code>rl.on(&apos;line&apos;, function(line) {
  switch(line.trim()) {
    case &apos;hello&apos;:
      console.log(&apos;world!&apos;);
      break;
    default:
      console.log(&apos;Say what? I might have heard `&apos; + line.trim() + &apos;`&apos;);
      break;
  }
  rl.prompt();
}).on(&apos;close&apos;, function() {
  console.log(&apos;Have a great day!&apos;);
  process.exit(0);
});</code></pre>
<h1>REPL<span><a href="all.html#all_repl" id="all_repl">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and
easily includable in other programs. The REPL provides a way to interactively
run JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.

</p>
<p>一个 Read-Eval-Print-Loop（REPL，读取-执行-输出循环）既可用于独立程序也可很容易地被集成到其它程序中。REPL 提供了一种交互地执行 JavaScript 并查看输出的方式。它可以被用作调试、测试或仅仅尝试某些东西。

</p>
<p>By executing <code>node</code> without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editing.

</p>
<p>在命令行中不带任何参数执行 <code>node</code> 您便会进入 REPL。它提供了一个简单的 Emacs 行编辑。

</p>
<pre><code>mjr:~$ node
Type &apos;.help&apos; for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>
<p>For advanced line-editors, start node with the environmental variable
<code>NODE_NO_READLINE=1</code>. This will start the main and debugger REPL in canonical
terminal settings which will allow you to use with <code>rlwrap</code>.

</p>
<p>若想使用高级的编辑模式，设置环境变量 <code>NODE_NO_READLINE=1</code> 后运行 node。这将在允许你在可以使用 <code>rlwrap</code> 的终端上，启动高级的 REPL 模式 (the main and debugger REPL)。

</p>
<p>For example, you could add this to your bashrc file:

</p>
<p>例如，您可以将下列代码加入到您的 bashrc 文件：

</p>
<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>
<h2>repl.start(options)<span><a href="all.html#all_repl_start_options" id="all_repl_start_options">#</a></span></h2>
<p>Returns and starts a <code>REPLServer</code> instance. Accepts an &quot;options&quot; Object that
takes the following values:

</p>
<p>启动并返回一个 <code>REPLServer</code> 实例。接受一个包含如下内容的 &quot;options&quot; 对象：

</p>
<ul>
<li><p><code>prompt</code> - the prompt and <code>stream</code> for all I/O. Defaults to <code>&gt; </code>.</p>
</li>
<li><p><code>prompt</code> - 所有输入输出的提示符。默认是 <code>&gt; </code>.</p>
</li>
<li><p><code>input</code> - the readable stream to listen to. Defaults to <code>process.stdin</code>.</p>
</li>
<li><p><code>input</code> - 监听的可读流。默认指向标准输入流 <code>process.stdin</code>。</p>
</li>
<li><p><code>output</code> - the writable stream to write readline data to. Defaults to
<code>process.stdout</code>.</p>
</li>
<li><p><code>output</code> - 用来输出数据的可写流。默认指向标准输出流 <code>process.stdout</code>。</p>
</li>
<li><p><code>terminal</code> - pass <code>true</code> if the <code>stream</code> should be treated like a TTY, and
have ANSI/VT100 escape codes written to it. Defaults to checking <code>isTTY</code>
on the <code>output</code> stream upon instantiation.</p>
</li>
<li><p><code>terminal</code> - 如果 <code>stream</code> 应该被当做 TTY 来对待并且有 ANSI/VT100 转义时，则传 <code>true</code>。 默认使用 <code>output</code> 实例的 <code>isTTY</code>来检查。</p>
</li>
<li><p><code>eval</code> - function that will be used to eval each given line. Defaults to
an async wrapper for <code>eval()</code>. See below for an example of a custom <code>eval</code>.</p>
</li>
<li><p><code>eval</code> - 用来对每一行进行求值的函数。 默认为<code>eval()</code>的一个异步包装函数。下面给出一个自定义<code>eval</code>的例子。</p>
</li>
<li><p><code>useColors</code> - a boolean which specifies whether or not the <code>writer</code> function
should output colors. If a different <code>writer</code> function is set then this does
nothing. Defaults to the repl&apos;s <code>terminal</code> value.</p>
</li>
<li><p><code>useColors</code> - 一个布尔值，表明了<code>writer</code>函数是否会输出颜色。如果设定了一个不同的<code>writer</code>函数，那么这不会产生任何影响。默认为repl的<code>terminal</code>值。</p>
</li>
<li><p><code>useGlobal</code> - if set to <code>true</code>, then the repl will use the <code>global</code> object,
instead of running scripts in a separate context. Defaults to <code>false</code>.</p>
</li>
<li><p><code>useGlobal</code> - 如果设定为<code>true</code>，那么repl就会使用<code>global</code>对象而不是在一个独立环境里运行脚本。默认为<code>false</code>。</p>
</li>
<li><p><code>ignoreUndefined</code> - if set to <code>true</code>, then the repl will not output the
return value of command if it&apos;s <code>undefined</code>. Defaults to <code>false</code>.</p>
</li>
<li><p><code>ignoreUndefined</code> - 如果设定为<code>true</code>，那么repl将不会输出未定义命令的返回值。默认为<code>false</code>。</p>
</li>
<li><p><code>writer</code> - the function to invoke for each command that gets evaluated which
returns the formatting (including coloring) to display. Defaults to
<code>util.inspect</code>.</p>
</li>
<li><p><code>writer</code> - 每一个命令被求值时都会调用此函数，而该函数会返回显示的格式（包括颜色）。默认为<code>util.inspect</code>。
<code>util.inspect</code>.</p>
</li>
</ul>
<p>You can use your own <code>eval</code> function if it has following signature:

</p>
<p>你可以使用你自己的<code>eval</code>函数，只有它有如下的签名：

</p>
<pre><code>function eval(cmd, context, filename, callback) {
  callback(null, result);
}</code></pre>
<p>Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.

</p>
<p>多个REPL可以在同一个运行的节点实例上打开。它们共享同一个global对象，但分别有各自的I/O。

</p>
<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:

</p>
<p>以下是通过标准输入流（stdin）、Unix socket 以及 TCP socket 三种情况来启动 REPL 的例子:

</p>
<pre><code>net.createServer(function (socket) {
  connections += 1;
  repl.start({
    prompt: &quot;node via TCP socket&gt; &quot;,
    input: socket,
    output: socket
  }).on(&apos;exit&apos;, function() {
    socket.end();
  });
}).listen(5001);</code></pre>
<p>Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. <code>telnet</code> is useful
for connecting to TCP sockets, and <code>socat</code> can be used to connect to both Unix and
TCP sockets.

</p>
<p>从命令行运行该程序，将会从标准输入流启动 REPL 模式。 其他的 REPL 客户端也可以通过 Unix socket 或者 TCP socket 连接。 <code>telnet</code> 常用于连接 TCP sockets，而 <code>socat</code> 则可以同时用来连接 Unix 和 TCP sockets。

</p>
<p>By starting a REPL from a Unix socket-based server instead of stdin, you can
connect to a long-running node process without restarting it.

</p>
<p>通过从一个Unix的套接字服务器而不是stdin来启动REPL, 你可以连接到一个长久运行的node进程而不不需要重启。

</p>
<p>For an example of running a &quot;full-featured&quot; (<code>terminal</code>) REPL over
a <code>net.Server</code> and <code>net.Socket</code> instance, see: <a href="https://gist.github.com/2209310">https://gist.github.com/2209310</a>

</p>
<p>一个在<code>net.Server</code>和<code>net.Socket</code>实例上运行的&quot;全功能&quot;(<code>terminal</code>)REPL的例子可以查看这里： <a href="https://gist.github.com/2209310">https://gist.github.com/2209310</a>

</p>
<p>For an example of running a REPL instance over <code>curl(1)</code>,
see: <a href="https://gist.github.com/2053342">https://gist.github.com/2053342</a>

</p>
<p>一个在<code>curl(1)</code>上运行的REPL实例的例子可以查看这里： <a href="https://gist.github.com/2053342">https://gist.github.com/2053342</a>

</p>
<h3>事件: &apos;exit&apos;<span><a href="all.html#all_exit_1" id="all_exit_1">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted when the user exits the REPL in any of the defined ways. Namely, typing
<code>.exit</code> at the repl, pressing Ctrl+C twice to signal SIGINT, or pressing Ctrl+D
to signal &quot;end&quot; on the <code>input</code> stream.

</p>
<p>当用户通过任意预定义的方式退出REPL，该事件被分发。比如，在repl里输入<code>.exit</code>，按Ctrl+C两次来发送SIGINT信号，或者在<code>input</code>流上按Ctrl+D来发送&quot;end&quot;。

</p>
<p>Example of listening for <code>exit</code>:

</p>
<p>监听 <code>exit</code> 事件的例子：

</p>
<pre><code>r.on(&apos;exit&apos;, function () {
  console.log(&apos;从 REPL 得到 &quot;exit&quot; 事件！&apos;);
  process.exit();
});</code></pre>
<h3>事件: &apos;reset&apos;<span><a href="all.html#all_reset" id="all_reset">#</a></span></h3>
<p><code>function (context) {}</code>

</p>
<p><code>function (context) {}</code>

</p>
<p>Emitted when the REPL&apos;s context is reset. This happens when you type <code>.clear</code>.
If you start the repl with <code>{ useGlobal: true }</code> then this event will never
be emitted.

</p>
<p>当REPL的上下文被重置时，该事件被分发。当你打<code>.clear</code>命令时这种情况就会发生。如果你以<code>{ useGlobal: true }</code>来启动repl，那么这个事件就永远不会被分发。

</p>
<p>Example of listening for <code>reset</code>:

</p>
<p>监听<code>reset</code>的例子：

</p>
<pre><code>// 当一个新的上下文被创建时，扩充这个上下文。
r.on(&apos;reset&apos;, function (context) {
  console.log(&apos;repl有一个新的上下文&apos;);
  someExtension.extend(context);
});</code></pre>
<h2>REPL 特性<span><a href="all.html#all_repl_1" id="all_repl_1">#</a></span></h2>
<!-- type=misc -->

<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.
Tab completion is supported for both global and local variables.

</p>
<p>在REPL里，Control+D会退出。可以输入多行表达式。对于全局变量和本地变量都支持自动缩进。

</p>
<p>The special variable <code>_</code> (underscore) contains the result of the last expression.

</p>
<p>特殊变量 <code>_</code> (下划线)储存了上一个表达式的结果。

</p>
<pre><code>&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
&gt; _.length
3
&gt; _ += 1
4</code></pre>
<p>The REPL provides access to any variables in the global scope. You can expose
a variable to the REPL explicitly by assigning it to the <code>context</code> object
associated with each <code>REPLServer</code>.  For example:

</p>
<p>REPL提供了访问global域里所有变量的权限。通过将一个变量赋值给与每一个<code>REPLServer</code>关联的<code>context</code>对象，你可以显式地将一个变量暴露给REPL。例如：

</p>
<pre><code>repl.start(&quot;&gt; &quot;).context.m = msg;</code></pre>
<p>Things in the <code>context</code> object appear as local within the REPL:

</p>
<p>在<code>context</code>对象里的东西，会在REPL以本地变量的形式出现。

</p>
<pre><code>mjr:~$ node repl_test.js
&gt; m
&apos;message&apos;</code></pre>
<p>There are a few special REPL commands:

</p>
<p>有几个特殊的REPL命令：

</p>
<ul>
<li><code>.break</code> - While inputting a multi-line expression, sometimes you get lost
or just don&apos;t care about completing it. <code>.break</code> will start over.</li>
<li><code>.clear</code> - Resets the <code>context</code> object to an empty object and clears any
multi-line expression.</li>
<li><code>.exit</code> - Close the I/O stream, which will cause the REPL to exit.</li>
<li><code>.help</code> - Show this list of special commands.</li>
<li><code>.save</code> - Save the current REPL session to a file<blockquote>
<p>.save ./file/to/save.js</p>
</blockquote>
</li>
<li><p><code>.load</code> - Load a file into the current REPL session.</p>
<blockquote>
<p>.load ./file/to/load.js</p>
</blockquote>
</li>
<li><p><code>.break</code> - 当你输入一个多行表达式时，有时你会脑子突然断路或者你不想完成这个表达式了。<code>break</code>让你可以重头再来。</p>
</li>
<li><code>.clear</code> - 重置<code>context</code>对象为一个空对象，并且清除所有的多行表达式。</li>
<li><code>.exit</code> - 关闭I/O流，使得REPL退出。</li>
<li><code>.help</code> - 显示这个特殊命令的列表。</li>
<li><code>.save</code> - 将当前的REPL会话保存到一个文件<blockquote>
<p>.save ./file/to/save.js</p>
</blockquote>
</li>
<li><code>.load</code> - 将一个文件装载到当前的REPL会话。<blockquote>
<p>.load ./file/to/load.js</p>
</blockquote>
</li>
</ul>
<p>The following key combinations in the REPL have these special effects:

</p>
<p>下面的组合键在REPL中有以下效果：

</p>
<ul>
<li><code>&lt;ctrl&gt;C</code> - Similar to the <code>.break</code> keyword.  Terminates the current
command.  Press twice on a blank line to forcibly exit.</li>
<li><p><code>&lt;ctrl&gt;D</code> - Similar to the <code>.exit</code> keyword.</p>
</li>
<li><p><code>&lt;ctrl&gt;C</code> - 与<code>.break</code>关键字类似。终止正在执行的命令。在一个空行连按两次会强制退出。</p>
</li>
<li><p><code>&lt;ctrl&gt;D</code> - 与<code>.exit</code>关键字类似。</p>
<h1>执行 JavaScript<span><a href="all.html#all_javascript" id="all_javascript">#</a></span></h1>
<p>稳定度: 3 - 稳定</p>
</li>
</ul>
<!--name=vm-->

<p>You can access this module with:

</p>
<p>你可以这样引入此模块：

</p>
<pre><code>var vm = require(&apos;vm&apos;);</code></pre>
<p>JavaScript code can be compiled and run immediately or compiled, saved, and run
later.

</p>
<p>JavaScript 代码可以被编译并立即执行，也可以在编译后保存，留到稍后执行。

</p>
<h2>vm.runInThisContext(code, [options])<span><a href="all.html#all_vm_runinthiscontext_code_options" id="all_vm_runinthiscontext_code_options">#</a></span></h2>
<p><code>vm.runInThisContext()</code> compiles <code>code</code>, runs it and returns the result. Running
code does not have access to local scope, but does have access to the current
<code>global</code> object.

</p>
<p><code>vm.runInThisContext()</code> 对 <code>code</code> 进行编译、运行并返回结果。
 被运行的代码没有对本地作用域 (local scope) 的访问权限，但是可以访问当前的 <code>global</code> 对象。

</p>
<p>Example of using <code>vm.runInThisContext</code> and <code>eval</code> to run the same code:

</p>
<p>使用 <code>vm.runInThisContext</code> 和 <code>eval</code> 分别执行相同的代码：

</p>
<pre><code>// vmResult: &apos;vm&apos;, localVar: &apos;initial value&apos;
// evalResult: &apos;eval&apos;, localVar: &apos;eval&apos;</code></pre>
<p><code>vm.runInThisContext</code> does not have access to the local scope, so <code>localVar</code> is
unchanged. <code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.

</p>
<p><code>vm.runInThisContext</code> 无法访问本地作用域，因此 <code>localVar</code> 没有被改变。
<code>eval</code> 可以访问本地作用域，因此 <code>localVar</code> 被改变。

</p>
<p>In this way <code>vm.runInThisContext</code> is much like an <a href="http://es5.github.io/#x10.4.2">indirect <code>eval</code> call</a>,
e.g. <code>(0,eval)(&apos;code&apos;)</code>. However, it also has the following additional options:

</p>
<p>这种情况下 <code>vm.runInThisContext</code> 可以看作一种 <a href="http://es5.github.io/#x10.4.2">间接的 <code>eval</code> 调用</a>，
如 <code>(0,eval)(&apos;code&apos;)</code>。但是 <code>vm.runInThisContext</code> 也提供下面几个额外的参数：

</p>
<ul>
<li><code>filename</code>: allows you to control the filename that shows up in any stack
traces produced.</li>
<li><code>displayErrors</code>: whether or not to print any errors to stderr, with the
line of code that caused them highlighted, before throwing an exception.
Will capture both syntax errors from compiling <code>code</code> and runtime errors
thrown by executing the compiled code. Defaults to <code>true</code>.</li>
<li><p><code>timeout</code>: a number of milliseconds to execute <code>code</code> before terminating
execution. If execution is terminated, an <code>Error</code> will be thrown.</p>
</li>
<li><p><code>filename</code>: 允许您更改显示在站追踪 (stack trace) 中的文件名</p>
</li>
<li><code>displayErrors</code>: 是否在抛出异常前输出带高亮错误代码行的错误信息到 stderr。
将会捕捉所有在编译 <code>code</code> 的过程中产生的语法错误以及执行过程中产生的运行时错误。
默认为 <code>true</code></li>
<li><code>timeout</code>: 以毫秒为单位规定 <code>code</code> 允许执行的时间。在执行过程中被终止时会有 <code>Error</code> 抛出。</li>
</ul>
<h2>vm.createContext([sandbox])<span><a href="all.html#all_vm_createcontext_sandbox" id="all_vm_createcontext_sandbox">#</a></span></h2>
<p>If given a <code>sandbox</code> object, will &quot;contextify&quot; that sandbox so that it can be
used in calls to <code>vm.runInContext</code> or <code>script.runInContext</code>. Inside scripts run
as such, <code>sandbox</code> will be the global object, retaining all its existing
properties but also having the built-in objects and functions any standard
<a href="http://es5.github.io/#x15.1">global object</a> has. Outside of scripts run by the vm module, <code>sandbox</code> will
be unchanged.

</p>
<p>如提供 <code>sandbox</code> 对象则将沙箱 (sandbox) 对象 “上下文化 (contextify)” 供 <code>vm.runInContext</code> 或者 <code>script.runInContext</code> 使用。
以此方式运行的脚本将以 <code>sandbox</code> 作为全局对象，该对象将在保留其所有的属性的基础上拥有标准 <a href="http://es5.github.io/#x15.1">全局对象</a> 所拥有的内置对象和函数。
在由 vm 模块运行的脚本之外的地方 <code>sandbox</code> 将不会被改变。

</p>
<p>If not given a sandbox object, returns a new, empty contextified sandbox object
you can use.

</p>
<p>如果没有提供沙箱对象，则返回一个新建的、没有任何对象被上下文化的可用沙箱。

</p>
<p>This function is useful for creating a sandbox that can be used to run multiple
scripts, e.g. if you were emulating a web browser it could be used to create a
single sandbox representing a window&apos;s global object, then run all <code>&lt;script&gt;</code>
tags together inside that sandbox.

</p>
<p>此函数可用于创建可执行多个脚本的沙箱，
比如，在模拟浏览器的时候可以使用该函数创建一个用于表示 window 全局对象的沙箱，
并将所有 <code>&lt;script&gt;</code> 标签放入沙箱执行。

</p>
<h2>vm.isContext(sandbox)<span><a href="all.html#all_vm_iscontext_sandbox" id="all_vm_iscontext_sandbox">#</a></span></h2>
<p>Returns whether or not a sandbox object has been contextified by calling
<code>vm.createContext</code> on it.

</p>
<p>返回沙箱对象是否已经通过 <code>vm.createContext</code> 上下文化 (contextified)

</p>
<h2>vm.runInContext(code, contextifiedSandbox, [options])<span><a href="all.html#all_vm_runincontext_code_contextifiedsandbox_options" id="all_vm_runincontext_code_contextifiedsandbox_options">#</a></span></h2>
<p><code>vm.runInContext</code> compiles <code>code</code>, then runs it in <code>contextifiedSandbox</code> and
returns the result. Running code does not have access to local scope. The
<code>contextifiedSandbox</code> object must have been previously contextified via
<code>vm.createContext</code>; it will be used as the global object for <code>code</code>.

</p>
<p><code>vm.runInContext</code> 编译 <code>code</code> 放入 <code>contextifiedSandbox</code> 执行并返回执行结果。
被执行的代码对 本地作用域 (local scope) 没有访问权。
<code>contextifiedSandbox</code> 必须在使用前通过 <code>vm.createContext</code> 上下文化，用作 <code>code</code> 的全局对象。

</p>
<p><code>vm.runInContext</code> takes the same options as <code>vm.runInThisContext</code>.

</p>
<p><code>vm.runInContext</code> 使用与 <code>vm.runInThisContext</code> 相同的 选项 (<code>options</code>)

</p>
<p>Example: compile and execute differnt scripts in a single existing context.

</p>
<p>示例：在同一个上下文中编译并执行不同的脚本

</p>
<pre><code>// { globalVar: 1024 }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>vm.runInContext</code> is quite useful, but safely running untrusted code requires a
separate process.

</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>vm.runInContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。

</p>
<h2>vm.runInNewContext(code, [sandbox], [options])<span><a href="all.html#all_vm_runinnewcontext_code_sandbox_options" id="all_vm_runinnewcontext_code_sandbox_options">#</a></span></h2>
<p><code>vm.runInNewContext</code> compiles <code>code</code>, contextifies <code>sandbox</code> if passed or
creates a new contextified sandbox if it&apos;s omitted, and then runs the code with
the sandbox as the global object and returns the result.

</p>
<p><code>vm.runInNewContext</code> 首先编译 <code>code</code>，若提供 <code>sandbox</code> 则将 <code>sandbox</code> 上下文化，若未提供则创建一个新的沙箱并上下文化，
然后将代码放入沙箱作为全局对象的上下文内执行并返回结果。

</p>
<p><code>vm.runInNewContext</code> takes the same options as <code>vm.runInThisContext</code>.

</p>
<p><code>vm.runInNewContext</code> 使用与 <code>vm.runInThisContext</code> 相同的 选项 (<code>options</code>)

</p>
<p>Example: compile and execute code that increments a global variable and sets a
new one. These globals are contained in the sandbox.

</p>
<p>示例: 编译并执行一段“自增一个全局变量然后创建一个全局变量”的代码。这些被操作的全局变量会被保存在沙箱中。

</p>
<pre><code>// { animal: &apos;cat&apos;, count: 3, name: &apos;kitty&apos; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>vm.runInNewContext</code> is quite useful, but safely running untrusted code requires
a separate process.

</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>vm.runInNewContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。

</p>
<h2>类: Script<span><a href="all.html#all_script" id="all_script">#</a></span></h2>
<p>A class for holding precompiled scripts, and running them in specific sandboxes.

</p>
<p>用于存放预编译脚本的类，可将预编译代码放入沙箱执行。

</p>
<h3>new vm.Script(code, options)<span><a href="all.html#all_new_vm_script_code_options" id="all_new_vm_script_code_options">#</a></span></h3>
<p>Creating a new <code>Script</code> compiles <code>code</code> but does not run it. Instead, the
created <code>vm.Script</code> object represents this compiled code. This script can be run
later many times using methods below. The returned script is not bound to any
global object. It is bound before each run, just for that run.

</p>
<p>创建一个新的 <code>Script</code> 用于编译 <code>code</code> 但是不执行。使用被创建的 <code>vm.Script</code> 用来表示完成编译的代码。
这份可以在后面的代码中执行多次。
返回的脚本是未绑定任何全局对象 (上下文 context) 的，全局对象仅在每一次执行的时候被绑定，执行结束后即释放绑定。

</p>
<p>The options when creating a script are:

</p>
<p>创建脚本的选项 (option) 有：

</p>
<ul>
<li><code>filename</code>: allows you to control the filename that shows up in any stack
traces produced from this script.</li>
<li><p><code>displayErrors</code>: whether or not to print any errors to stderr, with the
line of code that caused them highlighted, before throwing an exception.
Applies only to syntax errors compiling the code; errors while running the
code are controlled by the options to the script&apos;s methods.</p>
</li>
<li><p><code>filename</code>: 允许您更改显示在站追踪 (stack trace) 中的文件名</p>
</li>
<li><code>displayErrors</code>: 是否在抛出异常前输出带高亮错误代码行的错误信息到 stderr。
仅捕捉所有在编译过程中产生的语法错误（运行时错误由运行脚本选项控制）。</li>
</ul>
<h3>script.runInThisContext([options])<span><a href="all.html#all_script_runinthiscontext_options" id="all_script_runinthiscontext_options">#</a></span></h3>
<p>Similar to <code>vm.runInThisContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInThisContext</code> runs <code>script</code>&apos;s compiled code and returns the result.
Running code does not have access to local scope, but does have access to the
current <code>global</code> object.

</p>
<p>类似 <code>vm.runInThisContext</code> 只是作为预编译的 <code>Script</code> 对象方法。
<code>script.runInThisContext</code> 执行被编译的 <code>script</code> 并返回结果。
被运行的代码没有对本地作用域 (local scope) 的访问权限，但是可以访问当前的 <code>global</code> 对象。

</p>
<p>Example of using <code>script.runInThisContext</code> to compile code once and run it
multiple times:

</p>
<p>示例: 使用 <code>script.runInThisContext</code> 编译代码并多次执行: 

</p>
<pre><code>// 1000</code></pre>
<p>The options for running a script are:

</p>
<p>运行脚本的选项 (option) 有: 

</p>
<ul>
<li><code>displayErrors</code>: whether or not to print any runtime errors to stderr, with
the line of code that caused them highlighted, before throwing an exception.
Applies only to runtime errors executing the code; it is impossible to create
a <code>Script</code> instance with syntax errors, as the constructor will throw.</li>
<li><p><code>timeout</code>: a number of milliseconds to execute the script before terminating
execution. If execution is terminated, an <code>Error</code> will be thrown.</p>
</li>
<li><p><code>displayErrors</code>: 是否在抛出异常前输出带高亮错误代码行的错误信息到 stderr。
仅捕捉所有执行过程中产生的运行时错误（语法错误会在 <code>Script</code> 示例创建时就发生，因此不可能创建出带语法错误的 <code>Script</code> 对象）。</p>
</li>
<li><code>timeout</code>: 以毫秒为单位规定 <code>code</code> 允许执行的时间。在执行过程中被终止时会有 <code>Error</code> 抛出。</li>
</ul>
<h3>script.runInContext(contextifiedSandbox, [options])<span><a href="all.html#all_script_runincontext_contextifiedsandbox_options" id="all_script_runincontext_contextifiedsandbox_options">#</a></span></h3>
<p>Similar to <code>vm.runInContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInContext</code> runs <code>script</code>&apos;s compiled code in <code>contextifiedSandbox</code>
and returns the result. Running code does not have access to local scope.

</p>
<p>类似 <code>vm.runInContext</code> 只是作为预编译的 <code>Script</code> 对象方法。
<code>script.runInContext</code> 在 <code>contextifiedSandbox</code> 中执行 <code>script</code> 编译出的代码，并返回结果。
被运行的代码没有对本地作用域 (local scope) 的访问权限。

</p>
<p><code>script.runInContext</code> takes the same options as <code>script.runInThisContext</code>.

</p>
<p><code>script.runInContext</code> 使用与 <code>script.runInThisContext</code> 相同的 选项 (option)。

</p>
<p>Example: compile code that increments a global variable and sets one, then
execute the code multiple times. These globals are contained in the sandbox.

</p>
<p>示例: 编译一段“自增一个全局变量然后创建一个全局变量”的代码，然后多次执行此代码，
被操作的全局变量会被保存在沙箱中。

</p>
<pre><code>// { animal: &apos;cat&apos;, count: 12, name: &apos;kitty&apos; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>script.runInContext</code> is quite useful, but safely running untrusted code
requires a separate process.

</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>script.runInContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。

</p>
<h3>script.runInNewContext([sandbox], [options])<span><a href="all.html#all_script_runinnewcontext_sandbox_options" id="all_script_runinnewcontext_sandbox_options">#</a></span></h3>
<p>Similar to <code>vm.runInNewContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInNewContext</code> contextifies <code>sandbox</code> if passed or creates a new
contextified sandbox if it&apos;s omitted, and then runs <code>script</code>&apos;s compiled code
with the sandbox as the global object and returns the result. Running code does
not have access to local scope.

</p>
<p>类似 <code>vm.runInNewContext</code> 但是作为预编译的 <code>Script</code> 对象方法。
若提供 <code>sandbox</code> 则 <code>script.runInNewContext</code> 将 <code>sandbox</code> 上下文化，若未提供，则创建一个新的上下文化的沙箱，
然后将代码放入沙箱作为全局对象的上下文内执行并返回结果。

</p>
<p><code>script.runInNewContext</code> takes the same options as <code>script.runInThisContext</code>.

</p>
<p><code>script.runInNewContext</code> 使用与 <code>script.runInThisContext</code> 相同的 选项 (option)。

</p>
<p>Example: compile code that sets a global variable, then execute the code
multiple times in different contexts. These globals are set on and contained in
the sandboxes.

</p>
<p>示例: 编译一段“写入一个全局变量”的代码，然后将代码放入不同的上下文 (context) 执行，这些被操作的全局变量会被保存在沙箱中。

</p>
<pre><code>// [{ globalVar: &apos;set&apos; }, { globalVar: &apos;set&apos; }, { globalVar: &apos;set&apos; }]</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>script.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.


</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>script.runInNewContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。
</p>
<h1>子进程<span><a href="all.html#all_30" id="all_30">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Node provides a tri-directional <code>popen(3)</code> facility through the
<code>child_process</code> module.

</p>
<p>Node 通过 <code>child_process</code> 模块提供了类似 <code>popen(3)</code> 的处理三向数据流（stdin/stdout/stderr）的功能。

</p>
<p>It is possible to stream data through a child&apos;s <code>stdin</code>, <code>stdout</code>, and
<code>stderr</code> in a fully non-blocking way.  (Note that some programs use
line-buffered I/O internally.  That doesn&apos;t affect node.js but it means
data you send to the child process is not immediately consumed.)

</p>
<p>它能够以完全非阻塞的方式与子进程的 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 以流式传递数据。（请注意，某些程序在内部使用行缓冲 I/O。这不会影响到 node.js，但您发送到子进程的数据不会被立即消费。）

</p>
<p>To create a child process use <code>require(&apos;child_process&apos;).spawn()</code> or
<code>require(&apos;child_process&apos;).fork()</code>.  The semantics of each are slightly
different, and explained below.

</p>
<p>使用 <code>require(&apos;child_process&apos;).spawn()</code> 或 <code>require(&apos;child_process&apos;).fork()</code> 创建子进程。这两种方法的语义有些区别，下文将会解释。

</p>
<h2>类: ChildProcess<span><a href="all.html#all_childprocess" id="all_childprocess">#</a></span></h2>
<p><code>ChildProcess</code> is an <a href="events.html#events_class_events_eventemitter">EventEmitter</a>.

</p>
<p><code>ChildProcess</code> 是一个 <a href="events.html#events_class_events_eventemitter">EventEmitter</a>。

</p>
<p>Child processes always have three streams associated with them. <code>child.stdin</code>,
<code>child.stdout</code>, and <code>child.stderr</code>.  These may be shared with the stdio
streams of the parent process, or they may be separate stream objects
which can be piped to and from.

</p>
<p>子进程有三个与之关联的流：<code>child.stdin</code>、<code>child.stdout</code> 和 <code>child.stderr</code>。它们可以共享父进程的 stdio 流，也可以作为独立的被导流的流对象。

</p>
<p>The ChildProcess class is not intended to be used directly.  Use the
<code>spawn()</code> or <code>fork()</code> methods to create a Child Process instance.

</p>
<p>ChildProcess 类不能直接被使用， 使用 <code>spawn()</code> 或者 <code>fork()</code> 方法创建一个 Child Process 实例。

</p>
<h3>事件:  &apos;error&apos;<span><a href="all.html#all_error_6" id="all_error_6">#</a></span></h3>
<div><ul>
<li><p><code>err</code> <span>Error Object</span> the error.</p>
</li>
<li><p><code>err</code> <span>Error Object</span> 错误。</p>
</li>
</div></ul>
<p>Emitted when:

</p>
<p>发生于：

</p>
<ol>
<li>The process could not be spawned, or</li>
<li>The process could not be killed, or</li>
<li>Sending a message to the child process failed for whatever reason.</li>
</ol>
<ol>
<li>进程不能被创建, 或者</li>
<li>进程不能被终止掉, 或者</li>
<li>由任何原因引起的数据发送到子进程失败.</li>
</ol>
<p>See also <a href="all.html#child_process_child_kill_signal"><code>ChildProcess#kill()</code></a> and
<a href="all.html#child_process_child_send_message_sendhandle"><code>ChildProcess#send()</code></a>.

</p>
<p>参阅 <a href="all.html#child_process_child_kill_signal"><code>ChildProcess#kill()</code></a> 和
<a href="all.html#child_process_child_send_message_sendhandle"><code>ChildProcess#send()</code></a>。

</p>
<h3>事件:  &apos;exit&apos;<span><a href="all.html#all_exit_2" id="all_exit_2">#</a></span></h3>
<div><ul>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the signal passed to kill the child process, if it
was killed by the parent.</p>
</li>
<li><p><code>code</code> <span>Number</span> 假如进程正常退出，则为它的退出代码。</p>
</li>
<li><code>signal</code> <span>String</span> 假如是被父进程终止，则为所传入的终止子进程的信号。</li>
</div></ul>
<p>This event is emitted after the child process ends. If the process terminated
normally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If
the process terminated due to receipt of a signal, <code>signal</code> is the string name
of the signal, otherwise <code>null</code>.

</p>
<p>这个事件是在子进程被结束的时候触发的. 假如进程被正常结束，‘code’就是退出进程的指令代码, 否则为&apos;null&apos;. 假如进程是由于接受到signal结束的, <code>signal</code> 就代表着信号的名称, 否则为<code>null</code>.

</p>
<p>Note that the child process stdio streams might still be open.

</p>
<p>注意子进程的 stdio 流可能仍为开启状态。

</p>
<p>See <code>waitpid(2)</code>.

</p>
<p>参阅<code>waitpid(2)</code>.

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_8" id="all_close_8">#</a></span></h3>
<div><ul>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the signal passed to kill the child process, if it
was killed by the parent.</p>
</li>
<li><p><code>code</code> <span>Number</span> 假如进程正常退出，则为它的退出代码。</p>
</li>
<li><code>signal</code> <span>String</span> 假如是被父进程终止，则为所传入的终止子进程的信号。</li>
</div></ul>
<p>This event is emitted when the stdio streams of a child process have all
terminated.  This is distinct from &apos;exit&apos;, since multiple processes
might share the same stdio streams.

</p>
<p>这个事件会在一个子进程的所有stdio流被终止时触发， 这和&apos;exit&apos;事件有明显的不同，因为多进程有时候会共享同一个stdio流

</p>
<h3>事件: &apos;disconnect&apos;<span><a href="all.html#all_disconnect" id="all_disconnect">#</a></span></h3>
<p>This event is emitted after using the <code>.disconnect()</code> method in the parent or
in the child. After disconnecting it is no longer possible to send messages.
An alternative way to check if you can send messages is to see if the
<code>child.connected</code> property is <code>true</code>.

</p>
<p>在子进程或父进程中使用使用.disconnect()方法后，这个事件会被触发，在断开之后，就不可能再相互发送信息了。可以通过检查子进程的child.connected属性是否为true去检查是否可以发送信息

</p>
<h3>事件: &apos;message&apos;<span><a href="all.html#all_message_1" id="all_message_1">#</a></span></h3>
<div><ul>
<li><code>message</code> <span>Object</span> a parsed JSON object or primitive value</li>
<li><p><code>sendHandle</code> <span>Handle object</span> a Socket or Server object</p>
</li>
<li><p><code>message</code> <span>Object</span> 一个已解析的JSON对象或者原始类型值</p>
</li>
<li><code>sendHandle</code> <span>Handle object</span> 一个socket 或者 server对象</li>
</div></ul>
<p>Messages send by <code>.send(message, [sendHandle])</code> are obtained using the
<code>message</code> event.

</p>
<p>通过.send()发送的信息可以通过监听&apos;message&apos;事件获取到

</p>
<h3>child.stdin<span><a href="all.html#all_child_stdin" id="all_child_stdin">#</a></span></h3>
<div><ul>
<li><p><span>Stream object</span></p>
</li>
<li><p><span>Stream object</span></p>
</li>
</div></ul>
<p>A <code>Writable Stream</code> that represents the child process&apos;s <code>stdin</code>.
Closing this stream via <code>end()</code> often causes the child process to terminate.

</p>
<p>子进程的&apos;stdin&apos;是一个‘可写流’，通过end()方法关闭该可写流可以终止子进程，

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<p>假如子进程的stdio流与父线程共享，这个child.stdin不会被设置

</p>
<h3>child.stdout<span><a href="all.html#all_child_stdout" id="all_child_stdout">#</a></span></h3>
<div><ul>
<li><p><span>Stream object</span></p>
</li>
<li><p><span>Stream object</span></p>
</li>
</div></ul>
<p>A <code>Readable Stream</code> that represents the child process&apos;s <code>stdout</code>.

</p>
<p>子进程的<code>stdout</code>是个可读流.

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<p>假如子进程的stdio流与父线程共享，这个child.stdin不会被设置

</p>
<h3>child.stderr<span><a href="all.html#all_child_stderr" id="all_child_stderr">#</a></span></h3>
<div><ul>
<li><p><span>Stream object</span></p>
</li>
<li><p><span>Stream object</span></p>
</li>
</div></ul>
<p>A <code>Readable Stream</code> that represents the child process&apos;s <code>stderr</code>.

</p>
<p>子进程的stderr是一个可读流

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<p>假如子进程的stdio流与父线程共享，这个child.stdin不会被设置

</p>
<h3>child.pid<span><a href="all.html#all_child_pid" id="all_child_pid">#</a></span></h3>
<div><ul>
<li><p><span>Integer</span></p>
</li>
<li><p><span>Integer</span></p>
</li>
</div></ul>
<p>The PID of the child process.

</p>
<p>子进程的PID

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>console.log(&apos;Spawned child pid: &apos; + grep.pid);
grep.stdin.end();</code></pre>
<h3>child.kill([signal])<span><a href="all.html#all_child_kill_signal" id="all_child_kill_signal">#</a></span></h3>
<div><ul>
<li><p><code>signal</code> <span>String</span></p>
</li>
<li><p><code>signal</code> <span>String</span></p>
</li>
</div></ul>
<p>Send a signal to the child process. If no argument is given, the process will
be sent <code>&apos;SIGTERM&apos;</code>. See <code>signal(7)</code> for a list of available signals.

</p>
<p>发送一个信号给子线程. 假如没有给参数, 将会发送 <code>&apos;SIGTERM&apos;</code>. 参阅 <code>signal(7)</code> 查看所有可用的signals列表

</p>
<pre><code>// send SIGHUP to process
grep.kill(&apos;SIGHUP&apos;);</code></pre>
<p>May emit an <code>&apos;error&apos;</code> event when the signal cannot be delivered. Sending a
signal to a child process that has already exited is not an error but may
have unforeseen consequences: if the PID (the process ID) has been reassigned
to another process, the signal will be delivered to that process instead.
What happens next is anyone&apos;s guess.

</p>
<p>当一个signal不能被传递的时候，会触发一个&apos;error&apos;事件， 发送一个信号到已终止的子线程不会发生错误，但是可能引起不可预见的后果， 假如该子进程的ID已经重新分配给了其他进程，signal将会被发送到其他进程上面，大家可以猜想到这发生什么后果。

</p>
<p>Note that while the function is called <code>kill</code>, the signal delivered to the
child process may not actually kill it.  <code>kill</code> really just sends a signal
to a process.

</p>
<p>注意，当函数调用‘kill’, 传递给子进程的信号不会去终结子进程， ‘kill’实际上只是发送一个信号到进程而已。

</p>
<p>See <code>kill(2)</code>

</p>
<p>See <code>kill(2)</code>

</p>
<h3>child.send(message, [sendHandle])<span><a href="all.html#all_child_send_message_sendhandle" id="all_child_send_message_sendhandle">#</a></span></h3>
<div><ul>
<li><code>message</code> <span>Object</span></li>
<li><p><code>sendHandle</code> <span>Handle object</span></p>
</li>
<li><p><code>message</code> <span>Object</span></p>
</li>
<li><code>sendHandle</code> <span>Handle object</span></li>
</div></ul>
<p>When using <code>child_process.fork()</code> you can write to the child using
<code>child.send(message, [sendHandle])</code> and messages are received by
a <code>&apos;message&apos;</code> event on the child.

</p>
<p>当使用 <code>child_process.fork()</code> 你可以使用 
<code>child.send(message, [sendHandle])</code>向子进程写数据 and 数据将通过子进程上的‘message’事件接受.

</p>
<p>For example:

</p>
<p>例如：

</p>
<pre><code>n.send({ hello: &apos;world&apos; });</code></pre>
<p>And then the child script, <code>&apos;sub.js&apos;</code> might look like this:

</p>
<p>然后是子进程脚本的代码, <code>&apos;sub.js&apos;</code> 代码如下:

</p>
<pre><code>process.send({ foo: &apos;bar&apos; });</code></pre>
<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
will emit objects each time it receives a message on its channel.

</p>
<p>在子进程脚本中&apos;process&apos;对象有‘send()’方法， ‘process’每次通过它的信道接收到信息都会触发事件，信息以对象形式返回。

</p>
<p>There is a special case when sending a <code>{cmd: &apos;NODE_foo&apos;}</code> message. All messages
containing a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in
the <code>message</code> event, since they are internal messages used by node core.
Messages containing the prefix are emitted in the <code>internalMessage</code> event, you
should by all means avoid using this feature, it is subject to change without notice.

</p>
<p>不过发送<code>{cmd: &apos;NODE_foo&apos;}</code> 信息是个比较特殊的情况. 所有在‘cmd’属性中包含 a <code>NODE_</code>前缀的信息将不会触发‘message’事件, 因为他们是由node 核心使用的内部信息.
相反这种信息会触发 <code>internalMessage</code> 事件, 你应该通过各种方法避免使用这种特性, 他改变的时候不会接收到通知.

</p>
<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a TCP server or
socket object to another process. The child will receive the object as its
second argument to the <code>message</code> event.

</p>
<p><code>child.send()</code>的<code>sendHandle</code> 选项是用来发送一个TCP服务或者socket对象到另一个线程的，子进程将会接收这个参数作为‘message’事件的第二个参数。

</p>
<p>Emits an <code>&apos;error&apos;</code> event if the message cannot be sent, for example because
the child process has already exited.

</p>
<p>假如信息不能被发送，将会触发一个‘error’事件， 比如说因为子线程已经退出了。

</p>
<h4>例子: 发送一个server对象<span><a href="all.html#all_server" id="all_server">#</a></span></h4>
<p>Here is an example of sending a server:

</p>
<p>这里是一个发送一个server对象的例子:

</p>
<pre><code>// 创建一个handle对象，发送一个句柄.
var server = require(&apos;net&apos;).createServer();
server.on(&apos;connection&apos;, function (socket) {
  socket.end(&apos;handled by parent&apos;);
});
server.listen(1337, function() {
  child.send(&apos;server&apos;, server);
});</code></pre>
<p>And the child would the receive the server object as:

</p>
<p>同时子进程将会以如下方式接收到这个server对象:

</p>
<pre><code>process.on(&apos;message&apos;, function(m, server) {
  if (m === &apos;server&apos;) {
    server.on(&apos;connection&apos;, function (socket) {
      socket.end(&apos;handled by child&apos;);
    });
  }
});</code></pre>
<p>Note that the server is now shared between the parent and child, this means
that some connections will be handled by the parent and some by the child.

</p>
<p>注意，server对象现在有父进程和子进程共享，这意味着某些连接将会被父进程和子进程处理。

</p>
<p>For <code>dgram</code> servers the workflow is exactly the same.  Here you listen on
a <code>message</code> event instead of <code>connection</code> and use <code>server.bind</code> instead of
<code>server.listen</code>.  (Currently only supported on UNIX platforms.)

</p>
<p>对‘dgram’服务器，工作流程是一样的, 你监听的是‘message’事件，而不是 ‘connection’事件， 使用‘server.bind’ ,而不是‘server.listen’.(当前仅在UNIX平台支持)

</p>
<h4>示例: 发送socket对象<span><a href="all.html#all_socket" id="all_socket">#</a></span></h4>
<p>Here is an example of sending a socket. It will spawn two children and handle
connections with the remote address <code>74.125.127.100</code> as VIP by sending the
socket to a &quot;special&quot; child process. Other sockets will go to a &quot;normal&quot; process.

</p>
<p>这是个发送socket的例子. 他将创建两个子线程 ，同时处理连接，这是通过使用远程地址 <code>74.125.127.100</code> 作为 VIP 发送socket到一个‘特殊’的子线程. 其他的socket将会发送到‘正常’的线程里.

</p>
<pre><code>  // if this is a VIP
  if (socket.remoteAddress === &apos;74.125.127.100&apos;) {
    special.send(&apos;socket&apos;, socket);
    return;
  }
  // just the usual dudes
  normal.send(&apos;socket&apos;, socket);
});
server.listen(1337);</code></pre>
<p>The <code>child.js</code> could look like this:

</p>
<p> <code>child.js</code> 文件代码如下:

</p>
<pre><code>process.on(&apos;message&apos;, function(m, socket) {
  if (m === &apos;socket&apos;) {
    socket.end(&apos;You were handled as a &apos; + process.argv[2] + &apos; person&apos;);
  }
});</code></pre>
<p>Note that once a single socket has been sent to a child the parent can no
longer keep track of when the socket is destroyed. To indicate this condition
the <code>.connections</code> property becomes <code>null</code>.
It is also recommended not to use <code>.maxConnections</code> in this condition.

</p>
<p>注意，一旦单个的socket被发送到子进程，当这个socket被删除之后，父进程将不再对它保存跟踪，这表明了这个条件下‘.connetions’属性将变成&apos;null&apos;， 在这个条件下同时也不推荐时间‘.maxConnections’

</p>
<h3>child.disconnect()<span><a href="all.html#all_child_disconnect" id="all_child_disconnect">#</a></span></h3>
<p>To close the IPC connection between parent and child use the
<code>child.disconnect()</code> method. This allows the child to exit gracefully since
there is no IPC channel keeping it alive. When calling this method the
<code>disconnect</code> event will be emitted in both parent and child, and the
<code>connected</code> flag will be set to <code>false</code>. Please note that you can also call
<code>process.disconnect()</code> in the child process.

</p>
<p>使用<code>child.disconnect()</code> 方法关闭父进程与子进程的IPC连接. 他让子进程非常优雅的退出，因为已经没有活跃的IPC信道. 当调用这个方法，‘disconnect’事件将会同时在父进程和子进程内被触发，‘connected’的标签将会被设置成‘flase’， 请注意，你也可以在子进程中调用‘process.disconnect()’


</p>
<h2>child_process.spawn(command, [args], [options])<span><a href="all.html#all_child_process_spawn_command_args_options" id="all_child_process_spawn_command_args_options">#</a></span></h2>
<div><ul>
<li><code>command</code> <span>String</span> The command to run</li>
<li><code>args</code> <span>Array</span> List of string arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>stdio</code> <span>Array|String</span> Child&apos;s stdio configuration. (See below)</li>
<li><code>customFds</code> <span>Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See below)</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>detached</code> <span>Boolean</span> The child will be a process group leader.  (See below)</li>
<li><code>uid</code> <span>Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span>Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li>return: <span>ChildProcess object</span></li>
</div></ul>
<ul>
<li><code>command</code> {String}要运行的命令</li>
<li><code>args</code> {Array} 字符串参数列表</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} 子进程的当前的工作目录</li>
<li><code>stdio</code> {Array|String} 子进程 stdio 配置. (参阅下文)</li>
<li><code>customFds</code> {Array} <strong>Deprecated</strong> 作为子进程 stdio 使用的 文件标示符.  (参阅下文)</li>
<li><code>env</code> {Object} 环境变量的键值对</li>
<li><code>detached</code> {Boolean} 子进程将会变成一个进程组的领导者.  (参阅下文)</li>
<li><code>uid</code> {Number} 设置用户进程的ID. (See setuid(2).)</li>
<li><code>gid</code> {Number} 设置进程组的ID. (See setgid(2).)</li>
</ul>
</li>
<li>返回: {ChildProcess object}</li>
</ul>
<p>Launches a new process with the given <code>command</code>, with  command line arguments in <code>args</code>.
If omitted, <code>args</code> defaults to an empty Array.

</p>
<p>用给定的命令发布一个子进程，带有‘args’命令行参数，如果省略的话，‘args’默认为一个空数组

</p>
<p>The third argument is used to specify additional options, which defaults to:

</p>
<p>第三个参数被用来指定额外的设置，默认是:

</p>
<pre><code>{ cwd: undefined,
  env: process.env
}</code></pre>
<p><code>cwd</code> allows you to specify the working directory from which the process is spawned.
Use <code>env</code> to specify environment variables that will be visible to the new process.

</p>
<p><code>cwd</code>允许你从被创建的子进程中指定一个工作目录.
使用 <code>env</code> 去指定在新进程中可用的环境变量.

</p>
<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:

</p>
<p>一个运行 <code>ls -lh /usr</code>的例子, 获取<code>stdout</code>, <code>stderr</code>, 和退出代码:

</p>
<pre><code>ls.on(&apos;close&apos;, function (code) {
  console.log(&apos;child process exited with code &apos; + code);
});</code></pre>
<p>Example: A very elaborate way to run &apos;ps ax | grep ssh&apos;

</p>
<p>例子: 一个非常精巧的方法执行 &apos;ps ax | grep ssh&apos;

</p>
<pre><code>grep.on(&apos;close&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;grep process exited with code &apos; + code);
  }
});</code></pre>
<p>Example of checking for failed exec:

</p>
<p>检查执行错误的例子:

</p>
<pre><code>child.stderr.setEncoding(&apos;utf8&apos;);
child.stderr.on(&apos;data&apos;, function (data) {
  if (/^execvp\(\)/.test(data)) {
    console.log(&apos;Failed to start child process.&apos;);
  }
});</code></pre>
<p>Note that if spawn receives an empty options object, it will result in
spawning the process with an empty environment rather than using
<code>process.env</code>. This due to backwards compatibility issues with a deprecated
API.

</p>
<p>注意，当在spawn过程中接收一个空对象,这会导致创建的进程使用空的环境变量而不是使用‘process.env’.这是由于与一个废弃API向后兼容的问题.

</p>
<p>The &apos;stdio&apos; option to <code>child_process.spawn()</code> is an array where each
index corresponds to a fd in the child.  The value is one of the following:

</p>
<p><code>child_process.spawn()</code> 中的 <code>stdio</code> 选项是一个数组，每个索引对应子进程中的一个文件标识符。可以是下列值之一：

</p>
<ol>
<li><code>&apos;pipe&apos;</code> - Create a pipe between the child process and the parent process.
The parent end of the pipe is exposed to the parent as a property on the
<code>child_process</code> object as <code>ChildProcess.stdio[fd]</code>. Pipes created for
fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout
and ChildProcess.stderr, respectively.</li>
<li><code>&apos;ipc&apos;</code> - Create an IPC channel for passing messages/file descriptors
between parent and child. A ChildProcess may have at most <em>one</em> IPC stdio
file descriptor. Setting this option enables the ChildProcess.send() method.
If the child writes JSON messages to this file descriptor, then this will
trigger ChildProcess.on(&apos;message&apos;).  If the child is a Node.js program, then
the presence of an IPC channel will enable process.send() and
process.on(&apos;message&apos;).</li>
<li><code>&apos;ignore&apos;</code> - Do not set this file descriptor in the child. Note that Node
will always open fd 0 - 2 for the processes it spawns. When any of these is
ignored node will open <code>/dev/null</code> and attach it to the child&apos;s fd.</li>
<li><code>Stream</code> object - Share a readable or writable stream that refers to a tty,
file, socket, or a pipe with the child process. The stream&apos;s underlying
file descriptor is duplicated in the child process to the fd that 
corresponds to the index in the <code>stdio</code> array.</li>
<li>Positive integer - The integer value is interpreted as a file descriptor 
that is is currently open in the parent process. It is shared with the child
process, similar to how <code>Stream</code> objects can be shared.</li>
<li><code>null</code>, <code>undefined</code> - Use default value. For stdio fds 0, 1 and 2 (in other
words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the
default is <code>&apos;ignore&apos;</code>.</li>
</ol>
<ol>
<li><p><code>&apos;pipe&apos;</code> -在子进程与父进程之间创建一个管道，管道的父进程端以 <code>child_process</code> 的属性的形式暴露给父进程，如 <code>ChildProcess.stdio[fd]</code>。
为 文件标识（fds） 0 - 2 建立的管道也可以通过 ChildProcess.stdin，ChildProcess.stdout 及 ChildProcess.stderr 分别访问。</p>
</li>
<li><p><code>&apos;ipc&apos;</code> - 创建一个IPC通道以在父进程与子进程之间传递 消息/文件标识符。一个子进程只能有最多<em>一个</em> IPC stdio 文件标识。
设置该选项激活 ChildProcess.send() 方法。如果子进程向此文件标识符写JSON消息，则会触发 ChildProcess.on(&quot;message&quot;)。
如果子进程是一个nodejs程序，那么IPC通道的存在会激活process.send()和process.on(&apos;message&apos;)</p>
</li>
<li><p><code>&apos;ignore&apos;</code> - 不在子进程中设置该文件标识。注意，Node 总是会为其spawn的进程打开 文件标识（fd） 0 - 2。 
当其中任意一项被 ignored，node 会打开 <code>/dev/null</code> 并将其附给子进程的文件标识（fd）。</p>
</li>
<li><p><code>Stream</code> 对象 - 与子进程共享一个与tty，文件，socket，或者管道(pipe)相关的可读或可写流。
 该流底层（underlying）的文件标识在子进程中被复制给stdio数组索引对应的文件标识（fd）</p>
</li>
<li><p>正数 - 该整形值被解释为父进程中打开的文件标识符。他与子进程共享，和<code>Stream</code>被共享的方式相似。</p>
</li>
<li><p><code>null</code>, <code>undefined</code> - 使用默认值。 对于stdio fds 0,1,2（或者说stdin,stdout和stderr），pipe管道被建立。对于fd 3及往后，默认为<code>ignore</code></p>
</li>
</ol>
<p>As a shorthand, the <code>stdio</code> argument may also be one of the following
strings, rather than an array:

</p>
<p>作为快捷方式，<code>stdio</code> 参数除了数组也可以是下列字符串之一：

</p>
<ul>
<li><code>ignore</code> - <code>[&apos;ignore&apos;, &apos;ignore&apos;, &apos;ignore&apos;]</code></li>
<li><code>pipe</code> - <code>[&apos;pipe&apos;, &apos;pipe&apos;, &apos;pipe&apos;]</code></li>
<li><p><code>inherit</code> - <code>[process.stdin, process.stdout, process.stderr]</code> or <code>[0,1,2]</code></p>
</li>
<li><p><code>ignore</code> - <code>[&apos;ignore&apos;, &apos;ignore&apos;, &apos;ignore&apos;]</code></p>
</li>
<li><code>pipe</code> - <code>[&apos;pipe&apos;, &apos;pipe&apos;, &apos;pipe&apos;]</code></li>
<li><code>inherit</code> - <code>[process.stdin, process.stdout, process.stderr]</code> 或 <code>[0,1,2]</code></li>
</ul>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 开启一个额外的 fd=4 来与提供 startd 风格接口的程序进行交互。
spawn(&apos;prg&apos;, [], { stdio: [&apos;pipe&apos;, null, null, null, &apos;pipe&apos;] });</code></pre>
<p>If the <code>detached</code> option is set, the child process will be made the leader of a
new process group.  This makes it possible for the child to continue running 
after the parent exits.

</p>
<p>如果 <code>detached</code> 选项被设置，则子进程会被作为新进程组的 leader。这使得子进程可以在父进程退出后继续运行。

</p>
<p>By default, the parent will wait for the detached child to exit.  To prevent
the parent from waiting for a given <code>child</code>, use the <code>child.unref()</code> method,
and the parent&apos;s event loop will not include the child in its reference count.

</p>
<p>缺省情况下，父进程会等待脱离了的子进程退出。要阻止父进程等待一个给出的子进程 <code>child</code>，使用 <code>child.unref()</code> 方法，则父进程的事件循环引用计数中将不会包含这个子进程。

</p>
<p>Example of detaching a long-running process and redirecting its output to a
file:

</p>
<p>脱离一个长时间运行的进程并将它的输出重定向到一个文件的例子：

</p>
<pre><code> child.unref();</code></pre>
<p>When using the <code>detached</code> option to start a long-running process, the process
will not stay running in the background unless it is provided with a <code>stdio</code>
configuration that is not connected to the parent.  If the parent&apos;s <code>stdio</code> is
inherited, the child will remain attached to the controlling terminal.

</p>
<p>当使用 <code>detached</code> 选项来启动一个长时间运行的进程，该进程不会在后台保持运行，除非向它提供了一个不连接到父进程的 <code>stdio</code> 配置。如果继承了父进程的 <code>stdio</code>，则子进程会继续附着在控制终端。

</p>
<p>There is a deprecated option called <code>customFds</code> which allows one to specify
specific file descriptors for the stdio of the child process. This API was
not portable to all platforms and therefore removed.
With <code>customFds</code> it was possible to hook up the new process&apos; <code>[stdin, stdout,
stderr]</code> to existing streams; <code>-1</code> meant that a new stream should be created.
Use at your own risk.

</p>
<p>有一个已废弃的选项 <code>customFds</code> 允许指定特定文件描述符作为子进程的 stdio。该 API 无法移植到所有平台，因此被移除。使用 <code>customFds</code> 可以将新进程的 <code>[stdin, stdout, stderr]</code> 钩到已有流上；<code>-1</code> 表示创建新流。自己承担使用风险。

</p>
<p>See also: <code>child_process.exec()</code> and <code>child_process.fork()</code>

</p>
<p>参阅：<code>child_process.exec()</code> 和 <code>child_process.fork()</code>

</p>
<h2>child_process.exec(command, [options], callback)<span><a href="all.html#all_child_process_exec_command_options_callback" id="all_child_process_exec_command_options_callback">#</a></span></h2>
<div><ul>
<li><code>command</code> <span>String</span> The command to run, with space-separated arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span>String</span> (Default: &apos;utf8&apos;)</li>
<li><code>shell</code> <span>String</span> Shell to execute the command with
(Default: &apos;/bin/sh&apos; on UNIX, &apos;cmd.exe&apos; on Windows,  The shell should
 understand the <code>-c</code> switch on UNIX or <code>/s /c</code> on Windows. On Windows,
 command line parsing should be compatible with <code>cmd.exe</code>.)</li>
<li><code>timeout</code> <span>Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span>Number</span> (Default: 200*1024)</li>
<li><code>killSignal</code> <span>String</span> (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> called with the output when process terminates<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li><p>Return: ChildProcess object</p>
</li>
<li><p><code>command</code> <span>String</span> 将要执行的命令，用空格分隔参数</p>
</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> 子进程的当前工作目录</li>
<li><code>env</code> <span>Object</span> 环境变量键值对</li>
<li><code>encoding</code> <span>String</span> 编码（缺省为 &apos;utf8&apos;）</li>
<li><code>shell</code> <span>String</span> 运行命令的 shell（UNIX 上缺省为 &apos;/bin/sh&apos;，Windows 上缺省为 &apos;cmd.exe&apos;。该 shell 在 UNIX 上应当接受 <code>-c</code> 开关，在 Windows 上应当接受 <code>/s /c</code> 开关。在 Windows 中，命令行解析应当兼容 <code>cmd.exe</code>。）</li>
<li><code>timeout</code> <span>Number</span> 超时（缺省为 0）</li>
<li><code>maxBuffer</code> <span>Number</span> 最大缓冲（缺省为 200*1024）</li>
<li><code>killSignal</code> <span>String</span> 结束信号（缺省为 &apos;SIGTERM&apos;）</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> 进程结束时回调并带上输出<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li>返回：ChildProcess 对象</li>
</div></ul>
<p>Runs a command in a shell and buffers the output.

</p>
<p>在 shell 中执行一个命令并缓冲输出。

</p>
<pre><code>child = exec(&apos;cat *.js bad_file | wc -l&apos;,
  function (error, stdout, stderr) {
    console.log(&apos;stdout: &apos; + stdout);
    console.log(&apos;stderr: &apos; + stderr);
    if (error !== null) {
      console.log(&apos;exec error: &apos; + error);
    }
});</code></pre>
<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>
will be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>err.code</code>
will be the exit code of the child process, and <code>err.signal</code> will be set to the
signal that terminated the process.

</p>
<p>回调参数为 <code>(error, stdout, stderr)</code>。当成功时，<code>error</code> 会是 <code>null</code>。当遇到错误时，<code>error</code> 会是一个 <code>Error</code> 实例，并且 <code>err.code</code> 会是子进程的退出代码，同时 <code>err.signal</code> 会被设置为结束进程的信号名。

</p>
<p>There is a second optional argument to specify several options. The
default options are

</p>
<p>第二个可选的参数用于指定一些选项，缺省选项为：

</p>
<pre><code>{ encoding: &apos;utf8&apos;,
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: &apos;SIGTERM&apos;,
  cwd: null,
  env: null }</code></pre>
<p>If <code>timeout</code> is greater than 0, then it will kill the child process
if it runs longer than <code>timeout</code> milliseconds. The child process is killed with
<code>killSignal</code> (default: <code>&apos;SIGTERM&apos;</code>). <code>maxBuffer</code> specifies the largest
amount of data allowed on stdout or stderr - if this value is exceeded then
the child process is killed.

</p>
<p>如果 <code>timeout</code> 大于 0，则当进程运行超过 <code>timeout</code> 毫秒后会被终止。子进程使用 <code>killSignal</code> 信号结束（缺省为 <code>&apos;SIGTERM&apos;</code>）。<code>maxBuffer</code> 指定了 stdout 或 stderr 所允许的最大数据量，如果超出这个值则子进程会被终止。

</p>
<h2>child_process.execFile(file, args, options, callback)<span><a href="all.html#all_child_process_execfile_file_args_options_callback" id="all_child_process_execfile_file_args_options_callback">#</a></span></h2>
<div><ul>
<li><code>file</code> <span>String</span> The filename of the program to run</li>
<li><code>args</code> <span>Array</span> List of string arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span>String</span> (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span>Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span>Number</span> (Default: 200*1024)</li>
<li><code>killSignal</code> <span>String</span> (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> called with the output when process terminates<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li><p>Return: ChildProcess object</p>
</li>
<li><p><code>file</code> <span>String</span> 要运行的程序的文件名</p>
</li>
<li><code>args</code> <span>Array</span> 字符串参数列表</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> 子进程的当前工作目录</li>
<li><code>env</code> <span>Object</span> 环境变量键值对</li>
<li><code>encoding</code> <span>String</span> 编码（缺省为 &apos;utf8&apos;）</li>
<li><code>timeout</code> <span>Number</span> 超时（缺省为 0）</li>
<li><code>maxBuffer</code> <span>Number</span> 最大缓冲（缺省为 200*1024）</li>
<li><code>killSignal</code> <span>String</span> 结束信号（缺省为 &apos;SIGTERM&apos;）</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> 进程结束时回调并带上输出<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li>返回：ChildProcess 对象</li>
</div></ul>
<p>This is similar to <code>child_process.exec()</code> except it does not execute a
subshell but rather the specified file directly. This makes it slightly
leaner than <code>child_process.exec</code>. It has the same options.

</p>
<p>该方法类似于 <code>child_process.exec()</code>，但是它不会执行一个子 shell，而是直接执行所指定的文件。因此它稍微比 <code>child_process.exec</code> 精简，参数与之一致。

</p>
<h2>child_process.fork(modulePath, [args], [options])<span><a href="all.html#all_child_process_fork_modulepath_args_options" id="all_child_process_fork_modulepath_args_options">#</a></span></h2>
<div><ul>
<li><code>modulePath</code> <span>String</span> The module to run in the child</li>
<li><code>args</code> <span>Array</span> List of string arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span>String</span> (Default: &apos;utf8&apos;)</li>
<li><code>execPath</code> <span>String</span> Executable used to create the child process</li>
</ul>
</li>
<li><p>Return: ChildProcess object</p>
</li>
<li><p><code>modulePath</code> <span>String</span> 子进程中运行的模块</p>
</li>
<li><code>args</code> <span>Array</span> 字符串参数列表</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> 子进程的当前工作目录</li>
<li><code>env</code> <span>Object</span> 环境变量键值对</li>
<li><code>encoding</code> <span>String</span> 编码（缺省为 &apos;utf8&apos;）</li>
<li><code>execPath</code> <span>String</span> 创建子进程的可执行文件</li>
</ul>
</li>
<li>返回：ChildProcess 对象</li>
</div></ul>
<p>This is a special case of the <code>spawn()</code> functionality for spawning Node
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. See
<code>child.send(message, [sendHandle])</code> for details.

</p>
<p>该方法是 <code>spawn()</code> 的特殊情景，用于派生 Node 进程。除了普通 ChildProcess 实例所具有的所有方法，所返回的对象还具有内建的通讯通道。详见 <code>child.send(message, [sendHandle])</code>。

</p>
<p>By default the spawned Node process will have the stdout, stderr associated
with the parent&apos;s. To change this behavior set the <code>silent</code> property in the
<code>options</code> object to <code>true</code>.

</p>
<p>缺省情况下所派生的 Node 进程的 stdout、stderr 会关联到父进程。要更改该行为，可将 <code>options</code> 对象中的 <code>silent</code> 属性设置为 <code>true</code>。

</p>
<p>The child process does not automatically exit once it&apos;s done, you need to call
<code>process.exit()</code> explicitly. This limitation may be lifted in the future.

</p>
<p>子进程运行完成时并不会自动退出，您需要明确地调用 <code>process.exit()</code>。该限制可能会在未来版本里接触。

</p>
<p>These child Nodes are still whole new instances of V8. Assume at least 30ms
startup and 10mb memory for each new Node. That is, you cannot create many
thousands of them.

</p>
<p>这些子 Node 是全新的 V8 实例，假设每个新的 Node 需要至少 30 毫秒的启动时间和 10MB 内存，就是说您不能创建成百上千个这样的实例。

</p>
<p>The <code>execPath</code> property in the <code>options</code> object allows for a process to be
created for the child rather than the current <code>node</code> executable. This should be
done with care and by default will talk over the fd represented an
environmental variable <code>NODE_CHANNEL_FD</code> on the child process. The input and
output on this fd is expected to be line delimited JSON objects.

</p>
<p><code>options</code> 对象中的 <code>execPath</code> 属性可以用非当前 <code>node</code> 可执行文件来创建子进程。这需要小心使用，并且缺省情况下会使用子进程上的 <code>NODE_CHANNEL_FD</code> 环境变量所指定的文件描述符来通讯。该文件描述符的输入和输出假定为以行分割的 JSON 对象。

</p>
<h1>断言 (assert)<span><a href="all.html#all_assert" id="all_assert">#</a></span></h1>
<pre><code>稳定度: 5 - 已锁定</code></pre>
<p>This module is used for writing unit tests for your applications, you can
access it with <code>require(&apos;assert&apos;)</code>.

</p>
<p>此模块主要用于对您的程序进行单元测试，要使用它，请 <code>require(&apos;assert&apos;)</code>。

</p>
<h2>assert.fail(actual, expected, message, operator)<span><a href="all.html#all_assert_fail_actual_expected_message_operator" id="all_assert_fail_actual_expected_message_operator">#</a></span></h2>
<p>Throws an exception that displays the values for <code>actual</code> and <code>expected</code> separated by the provided operator.

</p>
<p>抛出异常：显示为被 <code>operator</code> （分隔符）所分隔的 <code>actual</code> （实际值）和 <code>expected</code> （期望值）。

</p>
<h2>assert(value, message), assert.ok(value, [message])<span><a href="all.html#all_assert_value_message_assert_ok_value_message" id="all_assert_value_message_assert_ok_value_message">#</a></span></h2>
<p>Tests if value is truthy, it is equivalent to <code>assert.equal(true, !!value, message);</code>

</p>
<p>测试结果是否为真（true），相当于 <code>assert.equal(true, !!value, message);</code>

</p>
<h2>assert.equal(actual, expected, [message])<span><a href="all.html#all_assert_equal_actual_expected_message" id="all_assert_equal_actual_expected_message">#</a></span></h2>
<p>Tests shallow, coercive equality with the equal comparison operator ( <code>==</code> ).

</p>
<p>浅测试, 强制相等就像使用相等操作符( <code>==</code> ).

</p>
<h2>assert.notEqual(actual, expected, [message])<span><a href="all.html#all_assert_notequal_actual_expected_message" id="all_assert_notequal_actual_expected_message">#</a></span></h2>
<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).

</p>
<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).

</p>
<h2>assert.deepEqual(actual, expected, [message])<span><a href="all.html#all_assert_deepequal_actual_expected_message" id="all_assert_deepequal_actual_expected_message">#</a></span></h2>
<p>Tests for deep equality.

</p>
<p>用于深度匹配测试。

</p>
<h2>assert.notDeepEqual(actual, expected, [message])<span><a href="all.html#all_assert_notdeepequal_actual_expected_message" id="all_assert_notdeepequal_actual_expected_message">#</a></span></h2>
<p>Tests for any deep inequality.

</p>
<p>用于深度非匹配测试。

</p>
<h2>assert.strictEqual(actual, expected, [message])<span><a href="all.html#all_assert_strictequal_actual_expected_message" id="all_assert_strictequal_actual_expected_message">#</a></span></h2>
<p>Tests strict equality, as determined by the strict equality operator ( <code>===</code> )

</p>
<p>用于严格相等匹配测试，由（<code>===</code>）的结果决定

</p>
<h2>assert.notStrictEqual(actual, expected, [message])<span><a href="all.html#all_assert_notstrictequal_actual_expected_message" id="all_assert_notstrictequal_actual_expected_message">#</a></span></h2>
<p>Tests strict non-equality, as determined by the strict not equal operator ( <code>!==</code> )

</p>
<p>严格不相等测试, 强制不相等就像使用严格不相等操作符( <code>!==</code> ).

</p>
<h2>assert.throws(block, [error], [message])<span><a href="all.html#all_assert_throws_block_error_message" id="all_assert_throws_block_error_message">#</a></span></h2>
<p>Expects <code>block</code> to throw an error. <code>error</code> can be constructor, regexp or 
validation function.

</p>
<p>输出一个错误的 <code>block</code>。 <code>error</code> 可以是构造函数，正则或者验证函数

</p>
<p>Validate instanceof using constructor:

</p>
<p>使用验证实例的构造函数

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;错误值&quot;);
  },
  Error
);</code></pre>
<p>Validate error message using RegExp:

</p>
<p>用正则表达式验证错误消息。

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;错误值&quot;);
  },
  /value/
);</code></pre>
<p>Custom error validation:

</p>
<p>自定义错误校验：

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  &quot;unexpected error&quot;
);</code></pre>
<h2>assert.doesNotThrow(block, [message])<span><a href="all.html#all_assert_doesnotthrow_block_message" id="all_assert_doesnotthrow_block_message">#</a></span></h2>
<p>Expects <code>block</code> not to throw an error, see assert.throws for details.

</p>
<p>预期 <code>block</code> 不会抛出错误，详见 assert.throws。

</p>
<h2>assert.ifError(value)<span><a href="all.html#all_assert_iferror_value" id="all_assert_iferror_value">#</a></span></h2>
<p>Tests if value is not a false value, throws if it is a true value. Useful when
testing the first argument, <code>error</code> in callbacks.


</p>
<p>测试值是否不为 false，当为 true 时抛出。常用于回调中第一个 error 参数的检查。
</p>
<h1>TTY<span><a href="all.html#all_tty" id="all_tty">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p>The <code>tty</code> module houses the <code>tty.ReadStream</code> and <code>tty.WriteStream</code> classes. In
most cases, you will not need to use this module directly.

</p>
<p><code>tty</code> 模块提供了 <code>tty.ReadStream</code> 和 <code>tty.WriteStream</code> 类。在大部分情况下，您都不会需要直接使用此模块。

</p>
<p>When node detects that it is being run inside a TTY context, then <code>process.stdin</code>
will be a <code>tty.ReadStream</code> instance and <code>process.stdout</code> will be
a <code>tty.WriteStream</code> instance. The preferred way to check if node is being run in
a TTY context is to check <code>process.stdout.isTTY</code>:

</p>
<p>当 node 检测到它正运行于 TTY 上下文中时，<code>process.stdin</code> 将会是一个 <code>tty.ReadStream</code> 实例，且 <code>process.stdout</code> 也将会是一个 <code>tty.WriteStream</code> 实例。检查 node 是否运行于 TTY 上下文的首选方式是检查 <code>process.stdout.isTTY</code>：

</p>
<pre><code>$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;
true
$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat
false</code></pre>
<h2>tty.isatty(fd)<span><a href="all.html#all_tty_isatty_fd" id="all_tty_isatty_fd">#</a></span></h2>
<p>Returns <code>true</code> or <code>false</code> depending on if the <code>fd</code> is associated with a
terminal.

</p>
<p>若 <code>fd</code> 关联于中端则返回 <code>true</code>，反之返回 <code>false</code>。

</p>
<h2>tty.setRawMode(mode)<span><a href="all.html#all_tty_setrawmode_mode" id="all_tty_setrawmode_mode">#</a></span></h2>
<p>Deprecated. Use <code>tty.ReadStream#setRawMode()</code>
(i.e. <code>process.stdin.setRawMode()</code>) instead.

</p>
<p>已废弃，请使用 <code>tty.ReadStream#setRawMode()</code>（如 <code>process.stdin.setRawMode()</code>）。

</p>
<h2>类: ReadStream<span><a href="all.html#all_readstream" id="all_readstream">#</a></span></h2>
<p>A <code>net.Socket</code> subclass that represents the readable portion of a tty. In normal
circumstances, <code>process.stdin</code> will be the only <code>tty.ReadStream</code> instance in any
node program (only when <code>isatty(0)</code> is true).

</p>
<p>一个 <code>net.Socket</code> 子类，代表 TTY 的可读部分。通常情况下在所有 node 程序中 <code>process.stdin</code> 会是仅有的 <code>tty.ReadStream</code> 实例（进当 <code>isatty(0)</code> 为 true 时）。

</p>
<h3>rs.isRaw<span><a href="all.html#all_rs_israw" id="all_rs_israw">#</a></span></h3>
<p>A <code>Boolean</code> that is initialized to <code>false</code>. It represents the current &quot;raw&quot; state
of the <code>tty.ReadStream</code> instance.

</p>
<p>一个 <code>Boolean</code>，初始为 <code>false</code>，代表 <code>tty.ReadStream</code> 实例的当前 &quot;raw&quot; 状态。

</p>
<h3>rs.setRawMode(mode)<span><a href="all.html#all_rs_setrawmode_mode" id="all_rs_setrawmode_mode">#</a></span></h3>
<p><code>mode</code> should be <code>true</code> or <code>false</code>. This sets the properties of the
<code>tty.ReadStream</code> to act either as a raw device or default. <code>isRaw</code> will be set
to the resulting mode.

</p>
<p><code>mode</code> 可以是 <code>true</code> 或 <code>false</code>。它设定 <code>tty.ReadStream</code> 的属性表现为原始设备或缺省。<code>isRaw</code> 会被设置为结果模式。

</p>
<h2>类: WriteStream<span><a href="all.html#all_writestream" id="all_writestream">#</a></span></h2>
<p>A <code>net.Socket</code> subclass that represents the writable portion of a tty. In normal
circumstances, <code>process.stdout</code> will be the only <code>tty.WriteStream</code> instance
ever created (and only when <code>isatty(1)</code> is true).

</p>
<p>一个 <code>net.Socket</code> 子类，代表 TTY 的可写部分。通常情况下 <code>process.stdout</code> 会是仅有的 <code>tty.WriteStream</code> 实例（进当 <code>isatty(1)</code> 为 true 时）。

</p>
<h3>ws.columns<span><a href="all.html#all_ws_columns" id="all_ws_columns">#</a></span></h3>
<p>A <code>Number</code> that gives the number of columns the TTY currently has. This property
gets updated on &quot;resize&quot; events.

</p>
<p>一个 `Number，表示 TTY 当前的列数。该属性会在 &quot;resize&quot; 事件中被更新。

</p>
<h3>ws.rows<span><a href="all.html#all_ws_rows" id="all_ws_rows">#</a></span></h3>
<p>A <code>Number</code> that gives the number of rows the TTY currently has. This property
gets updated on &quot;resize&quot; events.

</p>
<p>一个 `Number，表示 TTY 当前的行数。该属性会在 &quot;resize&quot; 事件中被更新。

</p>
<h3>事件: &apos;resize&apos;<span><a href="all.html#all_resize" id="all_resize">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted by <code>refreshSize()</code> when either of the <code>columns</code> or <code>rows</code> properties
has changed.

</p>
<p>由 <code>refreshSize()</code> 在 <code>columns</code> 或 <code>rows</code> 属性被改变时触发。

</p>
<pre><code>process.stdout.on(&apos;resize&apos;, function() {
  console.log(&apos;screen size has changed!&apos;);
  console.log(process.stdout.columns + &apos;x&apos; + process.stdout.rows);
});


process.stdout.on(&apos;resize&apos;, function() {
  console.log(&apos;屏幕大小已改变！&apos;);
  console.log(process.stdout.columns + &apos;x&apos; + process.stdout.rows);
});</code></pre>
<h1>Zlib<span><a href="all.html#all_zlib" id="all_zlib">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>You can access this module with:

</p>
<p>你可以这样引入此模块：

</p>
<pre><code>var zlib = require(&apos;zlib&apos;);</code></pre>
<p>This provides bindings to Gzip/Gunzip, Deflate/Inflate, and
DeflateRaw/InflateRaw classes.  Each class takes the same options, and
is a readable/writable Stream.

</p>
<p>这个模块提供了对Gzip/Gunzip, Deflate/Inflate和DeflateRaw/InflateRaw类的绑定。每一个类都可以接收相同的选项，并且本身也是一个可读写的Stream类。

</p>
<h2>例子<span><a href="all.html#all_31" id="all_31">#</a></span></h2>
<p>Compressing or decompressing a file can be done by piping an
fs.ReadStream into a zlib stream, then into an fs.WriteStream.

</p>
<p>压缩或解压缩一个文件可以通过导流一个 fs.ReadStream 到一个 zlib 流，然后到一个 fs.WriteStream 来完成。

</p>
<pre><code>inp.pipe(gzip).pipe(out);</code></pre>
<p>Compressing or decompressing data in one step can be done by using
the convenience methods.

</p>
<p>一步压缩或解压缩数据可以通过快捷方法来完成。

</p>
<pre><code>var buffer = new Buffer(&apos;eJzT0yMAAGTvBe8=&apos;, &apos;base64&apos;);
zlib.unzip(buffer, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString());
  }
});</code></pre>
<p>To use this module in an HTTP client or server, use the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a>
on requests, and the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a>
header on responses.

</p>
<p>要在 HTTP 客户端或服务器中使用此模块，请在请求和响应中使用 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a> 和 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a> 头。

</p>
<p><strong>Note: these examples are drastically simplified to show
the basic concept.</strong>  Zlib encoding can be expensive, and the results
ought to be cached.  See <a href="all.html#zlib_memory_usage_tuning">Memory Usage Tuning</a>
below for more information on the speed/memory/compression
tradeoffs involved in zlib usage.

</p>
<p><strong>注意：这些例子只是极其简单地展示了基础的概念</strong> 
Zlib 编码消耗非常大,结果需要缓存.看下面的<a href="all.html#zlib_memory_usage_tuning">内存调优</a>
中更多的关于Zlib用法中 速度/内存/压缩 的权衡取舍。

</p>
<pre><code>  // 注意: 这不是一个不合格的 accept-encoding 解析器
  // 详见 http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
  if (acceptEncoding.match(/\bdeflate\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;deflate&apos; });
    raw.pipe(zlib.createDeflate()).pipe(response);
  } else if (acceptEncoding.match(/\bgzip\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;gzip&apos; });
    raw.pipe(zlib.createGzip()).pipe(response);
  } else {
    response.writeHead(200, {});
    raw.pipe(response);
  }
}).listen(1337);</code></pre>
<h2>zlib.createGzip([options])<span><a href="all.html#all_zlib_creategzip_options" id="all_zlib_creategzip_options">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_gzip">Gzip</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_gzip">Gzip</a> 对象。

</p>
<h2>zlib.createGunzip([options])<span><a href="all.html#all_zlib_creategunzip_options" id="all_zlib_creategunzip_options">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_gunzip">Gunzip</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_gunzip">Gunzip</a> 对象。

</p>
<h2>zlib.createDeflate([options])<span><a href="all.html#all_zlib_createdeflate_options" id="all_zlib_createdeflate_options">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_deflate">Deflate</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_deflate">Deflate</a> 对象。

</p>
<h2>zlib.createInflate([options])<span><a href="all.html#all_zlib_createinflate_options" id="all_zlib_createinflate_options">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_inflate">Inflate</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_inflate">Inflate</a> 对象。

</p>
<h2>zlib.createDeflateRaw([options])<span><a href="all.html#all_zlib_createdeflateraw_options" id="all_zlib_createdeflateraw_options">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_deflateraw">DeflateRaw</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_deflateraw">DeflateRaw</a> 对象。

</p>
<h2>zlib.createInflateRaw([options])<span><a href="all.html#all_zlib_createinflateraw_options" id="all_zlib_createinflateraw_options">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_inflateraw">InflateRaw</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_inflateraw">InflateRaw</a> 对象。

</p>
<h2>zlib.createUnzip([options])<span><a href="all.html#all_zlib_createunzip_options" id="all_zlib_createunzip_options">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_unzip">Unzip</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_unzip">Unzip</a> 对象。

</p>
<h2>类: zlib.Zlib<span><a href="all.html#all_zlib_zlib" id="all_zlib_zlib">#</a></span></h2>
<p>Not exported by the <code>zlib</code> module. It is documented here because it is the base
class of the compressor/decompressor classes.

</p>
<p>这个类未被 <code>zlib</code> 模块导出，编入此文档是因为它是其它压缩器/解压缩器的基类。

</p>
<h3>zlib.flush([kind], callback)<span><a href="all.html#all_zlib_flush_kind_callback" id="all_zlib_flush_kind_callback">#</a></span></h3>
<p><code>kind</code> defaults to <code>zlib.Z_FULL_FLUSH</code>.

</p>
<p><code>kind</code> 缺省为 <code>zlib.Z_FULL_FLUSH</code>。

</p>
<p>Flush pending data. Don&apos;t call this frivolously, premature flushes negatively
impact the effectiveness of the compression algorithm.

</p>
<p>写入缓冲数据。请勿轻易调用此方法，过早的写入会对压缩算法的作用产生影响。

</p>
<h3>zlib.params(level, strategy, callback)<span><a href="all.html#all_zlib_params_level_strategy_callback" id="all_zlib_params_level_strategy_callback">#</a></span></h3>
<p>Dynamically update the compression level and compression strategy.
Only applicable to deflate algorithm.

</p>
<p>动态更新压缩级别和压缩策略。仅对 deflate 算法有效。

</p>
<h3>zlib.reset()<span><a href="all.html#all_zlib_reset" id="all_zlib_reset">#</a></span></h3>
<p>Reset the compressor/decompressor to factory defaults. Only applicable to
the inflate and deflate algorithms.

</p>
<p>将压缩器/解压缩器重置为缺省值。仅对 inflate 和 deflate 算法有效。

</p>
<h2>类: zlib.Gzip<span><a href="all.html#all_zlib_gzip" id="all_zlib_gzip">#</a></span></h2>
<p>Compress data using gzip.

</p>
<p>使用 gzip 压缩数据。

</p>
<h2>类: zlib.Gunzip<span><a href="all.html#all_zlib_gunzip" id="all_zlib_gunzip">#</a></span></h2>
<p>Decompress a gzip stream.

</p>
<p>解压缩一个 gzip 流。

</p>
<h2>类: zlib.Deflate<span><a href="all.html#all_zlib_deflate" id="all_zlib_deflate">#</a></span></h2>
<p>Compress data using deflate.

</p>
<p>使用 deflate 压缩数据。

</p>
<h2>类: zlib.Inflate<span><a href="all.html#all_zlib_inflate" id="all_zlib_inflate">#</a></span></h2>
<p>Decompress a deflate stream.

</p>
<p>解压缩一个 deflate 流。

</p>
<h2>类: zlib.DeflateRaw<span><a href="all.html#all_zlib_deflateraw" id="all_zlib_deflateraw">#</a></span></h2>
<p>Compress data using deflate, and do not append a zlib header.

</p>
<p>使用 deflate 压缩数据，并且不附带 zlib 头。

</p>
<h2>类: zlib.InflateRaw<span><a href="all.html#all_zlib_inflateraw" id="all_zlib_inflateraw">#</a></span></h2>
<p>Decompress a raw deflate stream.

</p>
<p>解压缩一个原始 deflate 流。

</p>
<h2>类: zlib.Unzip<span><a href="all.html#all_zlib_unzip" id="all_zlib_unzip">#</a></span></h2>
<p>Decompress either a Gzip- or Deflate-compressed stream by auto-detecting
the header.

</p>
<p>自动识别头部来解压缩一个以 gzip 或 deflate 压缩的流。

</p>
<h2>快捷方法<span><a href="all.html#all_32" id="all_32">#</a></span></h2>
<!--type=misc-->

<p>All of these take a string or buffer as the first argument, an optional second
argument to supply options to the zlib classes and will call the supplied
callback with <code>callback(error, result)</code>.

</p>
<p>所有这些方法的第一个参数都可以是字符串或 Buffer；可选地可以将传给 zlib 类的选项作为第二个参数传入；回调格式为 <code>callback(error, result)</code>。

</p>
<h2>zlib.deflate(buf, [options], callback)<span><a href="all.html#all_zlib_deflate_buf_options_callback" id="all_zlib_deflate_buf_options_callback">#</a></span></h2>
<p>Compress a string with Deflate.

</p>
<p>使用 Deflate 压缩一个字符串。

</p>
<h2>zlib.deflateRaw(buf, [options], callback)<span><a href="all.html#all_zlib_deflateraw_buf_options_callback" id="all_zlib_deflateraw_buf_options_callback">#</a></span></h2>
<p>Compress a string with DeflateRaw.

</p>
<p>使用 DeflateRaw 压缩一个字符串。

</p>
<h2>zlib.Gzip(buf, [options], callback)<span><a href="all.html#all_zlib_gzip_buf_options_callback" id="all_zlib_gzip_buf_options_callback">#</a></span></h2>
<p>Compress a string with Gzip.

</p>
<p>使用 Gzip 压缩一个字符串。

</p>
<h2>zlib.gunzip(buf, [options], callback)<span><a href="all.html#all_zlib_gunzip_buf_options_callback" id="all_zlib_gunzip_buf_options_callback">#</a></span></h2>
<p>Decompress a raw Buffer with Gunzip.

</p>
<p>使用 Gunzip 解压缩一个原始的 Buffer。

</p>
<h2>zlib.inflate(buf, [options], callback)<span><a href="all.html#all_zlib_inflate_buf_options_callback" id="all_zlib_inflate_buf_options_callback">#</a></span></h2>
<p>Decompress a raw Buffer with Inflate.

</p>
<p>使用 Inflate 解压缩一个原始的 Buffer。

</p>
<h2>zlib.inflateRaw(buf, [options], callback)<span><a href="all.html#all_zlib_inflateraw_buf_options_callback" id="all_zlib_inflateraw_buf_options_callback">#</a></span></h2>
<p>Decompress a raw Buffer with InflateRaw.

</p>
<p>使用 InflateRaw 解压缩一个原始的 Buffer。

</p>
<h2>zlib.unzip(buf, [options], callback)<span><a href="all.html#all_zlib_unzip_buf_options_callback" id="all_zlib_unzip_buf_options_callback">#</a></span></h2>
<p>Decompress a raw Buffer with Unzip.

</p>
<p>使用 Unzip 解压缩一个原始的 Buffer。

</p>
<h2>选项<span><a href="all.html#all_33" id="all_33">#</a></span></h2>
<!--type=misc-->

<p>Each class takes an options object.  All options are optional.

</p>
<p>各个类都有一个选项对象。所有选项都是可选的。

</p>
<p>Note that some options are only relevant when compressing, and are
ignored by the decompression classes.

</p>
<p>请注意有些选项仅对压缩有效，并会被解压缩类所忽略。

</p>
<ul>
<li>flush (default: <code>zlib.Z_NO_FLUSH</code>)</li>
<li>chunkSize (default: 16*1024)</li>
<li>windowBits</li>
<li>level (compression only)</li>
<li>memLevel (compression only)</li>
<li>strategy (compression only)</li>
<li><p>dictionary (deflate/inflate only, empty dictionary by default)</p>
</li>
<li><p>flush（缺省：<code>zlib.Z_NO_FLUSH</code>）</p>
</li>
<li>chunkSize（缺省：16*1024）</li>
<li>windowBits</li>
<li>level（仅用于压缩）</li>
<li>memLevel（仅用于压缩）</li>
<li>strategy（仅用于压缩）</li>
<li>dictionary（仅用于 deflate/inflate，缺省为空目录）</li>
</ul>
<p>See the description of <code>deflateInit2</code> and <code>inflateInit2</code> at
</p>
<p><a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> for more information on these.

</p>
<p>详情请参阅 <a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> 的 <code>deflateInit2</code> 和 <code>inflateInit2</code>。

</p>
<h2>内存使用调优<span><a href="all.html#all_34" id="all_34">#</a></span></h2>
<!--type=misc-->

<p>From <code>zlib/zconf.h</code>, modified to node&apos;s usage:

</p>
<p>来自 <code>zlib/zconf.h</code>，修改为 node 的用法：

</p>
<p>The memory requirements for deflate are (in bytes):

</p>
<p>deflate 的内存需求（按字节）：

</p>
<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>
<p>that is: 128K for windowBits=15  +  128K for memLevel = 8
(default values) plus a few kilobytes for small objects.

</p>
<p>表示：windowBits = 15 的 128K + memLevel = 8 的 128K（缺省值）加上其它对象的若干 KB。

</p>
<p>For example, if you want to reduce
the default memory requirements from 256K to 128K, set the options to:

</p>
<p>举个例子，如果您需要将缺省内存需求从 256K 减少到 128K，设置选项：

</p>
<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>
<p>Of course this will generally degrade compression (there&apos;s no free lunch).

</p>
<p>当然这通常会降低压缩等级（天底下没有免费午餐）。

</p>
<p>The memory requirements for inflate are (in bytes)

</p>
<p>inflate 的内存需求（按字节）：

</p>
<pre><code>1 &lt;&lt; windowBits</code></pre>
<p>that is, 32K for windowBits=15 (default value) plus a few kilobytes
for small objects.

</p>
<p>表示 windowBits = 15（缺省值）的 32K 加上其它对象的若干 KB。

</p>
<p>This is in addition to a single internal output slab buffer of size
<code>chunkSize</code>, which defaults to 16K.

</p>
<p>这是除了内部输出缓冲外 <code>chunkSize</code> 的大小，缺省为 16K。

</p>
<p>The speed of zlib compression is affected most dramatically by the
<code>level</code> setting.  A higher level will result in better compression, but
will take longer to complete.  A lower level will result in less
compression, but will be much faster.

</p>
<p>zlib 压缩的速度主要受压缩级别 <code>level</code> 的影响。更高的压缩级别会有更好的压缩率，但也要花费更长时间。更低的压缩级别会有较低压缩率，但速度更快。

</p>
<p>In general, greater memory usage options will mean that node has to make
fewer calls to zlib, since it&apos;ll be able to process more data in a
single <code>write</code> operation.  So, this is another factor that affects the
speed, at the cost of memory usage.

</p>
<p>通常，使用更多内存的选项意味着 node 能减少对 zlib 的调用，因为单次 <code>write</code>操作能处理更多数据。因此，这是另一个影响速度和内存占用的因素。

</p>
<h2>常量<span><a href="all.html#all_35" id="all_35">#</a></span></h2>
<!--type=misc-->

<p>All of the constants defined in zlib.h are also defined on
<code>require(&apos;zlib&apos;)</code>.
In the normal course of operations, you will not need to ever set any of
these.  They are documented here so that their presence is not
surprising.  This section is taken almost directly from the <a href="http://zlib.net/manual.html#Constants">zlib
documentation</a>.  See
</p>
<p><a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a> for more details.

</p>
<p>所有在 zlib.h 中定义的常量同样也定义在 <code>require(&apos;zlib&apos;)</code> 中。
在通常情况下您几乎不会用到它们，编入文档只是为了让您不会对它们的存在感到惊讶。该章节几乎完全来自 <a href="http://zlib.net/manual.html#Constants">zlib 的文档</a>。详见 <a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a>。

</p>
<p>Allowed flush values.

</p>
<p>允许的 flush 取值。

</p>
<ul>
<li><code>zlib.Z_NO_FLUSH</code></li>
<li><code>zlib.Z_PARTIAL_FLUSH</code></li>
<li><code>zlib.Z_SYNC_FLUSH</code></li>
<li><code>zlib.Z_FULL_FLUSH</code></li>
<li><code>zlib.Z_FINISH</code></li>
<li><code>zlib.Z_BLOCK</code></li>
<li><p><code>zlib.Z_TREES</code></p>
</li>
<li><p><code>zlib.Z_NO_FLUSH</code></p>
</li>
<li><code>zlib.Z_PARTIAL_FLUSH</code></li>
<li><code>zlib.Z_SYNC_FLUSH</code></li>
<li><code>zlib.Z_FULL_FLUSH</code></li>
<li><code>zlib.Z_FINISH</code></li>
<li><code>zlib.Z_BLOCK</code></li>
<li><code>zlib.Z_TREES</code></li>
</ul>
<p>Return codes for the compression/decompression functions. Negative
values are errors, positive values are used for special but normal
events.

</p>
<p>压缩/解压缩函数的返回值。负数代表错误，正数代表特殊但正常的事件。

</p>
<ul>
<li><code>zlib.Z_OK</code></li>
<li><code>zlib.Z_STREAM_END</code></li>
<li><code>zlib.Z_NEED_DICT</code></li>
<li><code>zlib.Z_ERRNO</code></li>
<li><code>zlib.Z_STREAM_ERROR</code></li>
<li><code>zlib.Z_DATA_ERROR</code></li>
<li><code>zlib.Z_MEM_ERROR</code></li>
<li><code>zlib.Z_BUF_ERROR</code></li>
<li><p><code>zlib.Z_VERSION_ERROR</code></p>
</li>
<li><p><code>zlib.Z_OK</code></p>
</li>
<li><code>zlib.Z_STREAM_END</code></li>
<li><code>zlib.Z_NEED_DICT</code></li>
<li><code>zlib.Z_ERRNO</code></li>
<li><code>zlib.Z_STREAM_ERROR</code></li>
<li><code>zlib.Z_DATA_ERROR</code></li>
<li><code>zlib.Z_MEM_ERROR</code></li>
<li><code>zlib.Z_BUF_ERROR</code></li>
<li><code>zlib.Z_VERSION_ERROR</code></li>
</ul>
<p>Compression levels.

</p>
<p>压缩级别。

</p>
<ul>
<li><code>zlib.Z_NO_COMPRESSION</code></li>
<li><code>zlib.Z_BEST_SPEED</code></li>
<li><code>zlib.Z_BEST_COMPRESSION</code></li>
<li><p><code>zlib.Z_DEFAULT_COMPRESSION</code></p>
</li>
<li><p><code>zlib.Z_NO_COMPRESSION</code></p>
</li>
<li><code>zlib.Z_BEST_SPEED</code></li>
<li><code>zlib.Z_BEST_COMPRESSION</code></li>
<li><code>zlib.Z_DEFAULT_COMPRESSION</code></li>
</ul>
<p>Compression strategy.

</p>
<p>压缩策略。

</p>
<ul>
<li><code>zlib.Z_FILTERED</code></li>
<li><code>zlib.Z_HUFFMAN_ONLY</code></li>
<li><code>zlib.Z_RLE</code></li>
<li><code>zlib.Z_FIXED</code></li>
<li><p><code>zlib.Z_DEFAULT_STRATEGY</code></p>
</li>
<li><p><code>zlib.Z_FILTERED</code></p>
</li>
<li><code>zlib.Z_HUFFMAN_ONLY</code></li>
<li><code>zlib.Z_RLE</code></li>
<li><code>zlib.Z_FIXED</code></li>
<li><code>zlib.Z_DEFAULT_STRATEGY</code></li>
</ul>
<p>Possible values of the data_type field.

</p>
<p>data_type 字段的可能值。

</p>
<ul>
<li><code>zlib.Z_BINARY</code></li>
<li><code>zlib.Z_TEXT</code></li>
<li><code>zlib.Z_ASCII</code></li>
<li><p><code>zlib.Z_UNKNOWN</code></p>
</li>
<li><p><code>zlib.Z_BINARY</code></p>
</li>
<li><code>zlib.Z_TEXT</code></li>
<li><code>zlib.Z_ASCII</code></li>
<li><code>zlib.Z_UNKNOWN</code></li>
</ul>
<p>The deflate compression method (the only one supported in this version).

</p>
<p>deflate 压缩方法（该版本仅支持一种）。

</p>
<ul>
<li><p><code>zlib.Z_DEFLATED</code></p>
</li>
<li><p><code>zlib.Z_DEFLATED</code></p>
</li>
</ul>
<p>For initializing zalloc, zfree, opaque.

</p>
<p>初始化 zalloc/zfree/opaque。

</p>
<ul>
<li><code>zlib.Z_NULL</code></li>
</ul>
<ul>
<li><code>zlib.Z_NULL</code></li>
</ul>
<h1>操作系统<span><a href="all.html#all_36" id="all_36">#</a></span></h1>
<pre><code>稳定度: 4 - 冻结</code></pre>
<p>Provides a few basic operating-system related utility functions.

</p>
<p>提供一些基本的操作系统相关函数。

</p>
<p>Use <code>require(&apos;os&apos;)</code> to access this module.

</p>
<p>使用 <code>require(&apos;os&apos;)</code> 来调用这个模块。

</p>
<h2>os.tmpdir()<span><a href="all.html#all_os_tmpdir" id="all_os_tmpdir">#</a></span></h2>
<p>Returns the operating system&apos;s default directory for temp files.

</p>
<p>返回操作系统默认的临时文件目录

</p>
<h2>os.endianness()<span><a href="all.html#all_os_endianness" id="all_os_endianness">#</a></span></h2>
<p>Returns the endianness of the CPU. Possible values are <code>&quot;BE&quot;</code> or <code>&quot;LE&quot;</code>.

</p>
<p>返回 CPU 的字节序，可能的是 <code>&quot;BE&quot;</code> 或 <code>&quot;LE&quot;</code>。

</p>
<h2>os.hostname()<span><a href="all.html#all_os_hostname" id="all_os_hostname">#</a></span></h2>
<p>Returns the hostname of the operating system.

</p>
<p>返回操作系统的主机名。

</p>
<h2>os.type()<span><a href="all.html#all_os_type" id="all_os_type">#</a></span></h2>
<p>Returns the operating system name.

</p>
<p>返回操作系统名称。

</p>
<h2>os.platform()<span><a href="all.html#all_os_platform" id="all_os_platform">#</a></span></h2>
<p>Returns the operating system platform.

</p>
<p>返回操作系统平台

</p>
<h2>os.arch()<span><a href="all.html#all_os_arch" id="all_os_arch">#</a></span></h2>
<p>Returns the operating system CPU architecture. Possible values are <code>&quot;x64&quot;</code>,
<code>&quot;arm&quot;</code> and <code>&quot;ia32&quot;</code>.

</p>
<p>返回操作系统 CPU 架构，可能的值有 <code>&quot;x64&quot;</code>、<code>&quot;arm&quot;</code> 和 <code>&quot;ia32&quot;</code>。

</p>
<h2>os.release()<span><a href="all.html#all_os_release" id="all_os_release">#</a></span></h2>
<p>Returns the operating system release.

</p>
<p>返回操作系统的发行版本。

</p>
<h2>os.uptime()<span><a href="all.html#all_os_uptime" id="all_os_uptime">#</a></span></h2>
<p>Returns the system uptime in seconds.

</p>
<p>返回操作系统运行的时间，以秒为单位。

</p>
<h2>os.loadavg()<span><a href="all.html#all_os_loadavg" id="all_os_loadavg">#</a></span></h2>
<p>Returns an array containing the 1, 5, and 15 minute load averages.

</p>
<p>返回一个包含 1、5、15 分钟平均负载的数组。

</p>
<h2>os.totalmem()<span><a href="all.html#all_os_totalmem" id="all_os_totalmem">#</a></span></h2>
<p>Returns the total amount of system memory in bytes.

</p>
<p>返回系统内存总量，单位为字节。

</p>
<h2>os.freemem()<span><a href="all.html#all_os_freemem" id="all_os_freemem">#</a></span></h2>
<p>Returns the amount of free system memory in bytes.

</p>
<p>返回操作系统空闲内存量，单位是字节。

</p>
<h2>os.cpus()<span><a href="all.html#all_os_cpus" id="all_os_cpus">#</a></span></h2>
<p>Returns an array of objects containing information about each CPU/core
installed: model, speed (in MHz), and times (an object containing the number of
milliseconds the CPU/core spent in: user, nice, sys, idle, and irq).

</p>
<p>返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。

</p>
<p>Example inspection of os.cpus:

</p>
<p>os.cpus 的示例：

</p>
<pre><code>[ { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>
<h2>os.networkInterfaces()<span><a href="all.html#all_os_networkinterfaces" id="all_os_networkinterfaces">#</a></span></h2>
<p>Get a list of network interfaces:

</p>
<p>获取网络接口的一个列表信息：

</p>
<pre><code>{ lo:
   [ { address: &apos;127.0.0.1&apos;,
       netmask: &apos;255.0.0.0&apos;,
       family: &apos;IPv4&apos;,
       mac: &apos;00:00:00:00:00:00&apos;,
       internal: true },
     { address: &apos;::1&apos;,
       netmask: &apos;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&apos;,
       family: &apos;IPv6&apos;,
       mac: &apos;00:00:00:00:00:00&apos;,
       internal: true } ],
  eth0:
   [ { address: &apos;192.168.1.108&apos;,
       netmask: &apos;255.255.255.0&apos;,
       family: &apos;IPv4&apos;,
       mac: &apos;01:02:03:0a:0b:0c&apos;,
       internal: false },
     { address: &apos;fe80::a00:27ff:fe4e:66a1&apos;,
       netmask: &apos;ffff:ffff:ffff:ffff::&apos;,
       family: &apos;IPv6&apos;,
       mac: &apos;01:02:03:0a:0b:0c&apos;,
       internal: false } ] }</code></pre>
<h2>os.EOL<span><a href="all.html#all_os_eol" id="all_os_eol">#</a></span></h2>
<p>A constant defining the appropriate End-of-line marker for the operating system.


</p>
<p>一个定义了操作系统的一行结束的标识的常量。
</p>
<h1>调试器<span><a href="all.html#all_37" id="all_37">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!-- type=misc -->

<p>V8 comes with an extensive debugger which is accessible out-of-process via a
simple <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP protocol</a>.
Node has a built-in client for this debugger. To use this, start Node with the
<code>debug</code> argument; a prompt will appear:

</p>
<p>V8 提供了一个强大的调试器，可以通过 <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP 协议</a>从外部访问。Node 内建了这个调试器的客户端。要使用调试器，以 <code>debug</code> 参数启动 Node，出现提示符：

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt;</code></pre>
<p>Node&apos;s debugger client doesn&apos;t support the full range of commands, but
simple step and inspection is possible. By putting the statement <code>debugger;</code>
into the source code of your script, you will enable a breakpoint.

</p>
<p>Node 的调试器客户端并未完整支持所有命令，但简单的步进和检查是可行的。通过脚本的源代码中放置 <code>debugger;</code> 语句，您便可启用一个断点。

</p>
<p>For example, suppose <code>myscript.js</code> looked like this:

</p>
<p>比如，假设有一个类似这样的 <code>myscript.js</code>：

</p>
<pre><code>// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log(&quot;world&quot;);
}, 1000);
console.log(&quot;hello&quot;);</code></pre>
<p>Then once the debugger is run, it will break on line 4.

</p>
<p>那么，当调试器运行时，它会在第 4 行中断：

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt; cont
&lt; hello
break in /home/indutny/Code/git/indutny/myscript.js:3
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
debug&gt; next
break in /home/indutny/Code/git/indutny/myscript.js:4
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
debug&gt; repl
Press Ctrl + C to leave debug repl
&gt; x
5
&gt; 2+2
4
debug&gt; next
&lt; world
break in /home/indutny/Code/git/indutny/myscript.js:5
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
  7
debug&gt; quit
%</code></pre>
<p>The <code>repl</code> command allows you to evaluate code remotely. The <code>next</code> command
steps over to the next line. There are a few other commands available and more
to come. Type <code>help</code> to see others.

</p>
<p><code>repl</code> 命令允许您远程执行代码；<code>next</code> 命令步进到下一行。此外还有一些其它命令，输入 <code>help</code> 查看。

</p>
<h2>监视器<span><a href="all.html#all_38" id="all_38">#</a></span></h2>
<p>You can watch expression and variable values while debugging your code.
On every breakpoint each expression from the watchers list will be evaluated
in the current context and displayed just before the breakpoint&apos;s source code
listing.

</p>
<p>调试代码时您可以监视表达式或变量值。在每个断点中监视器列表中的各个表达式会被以当前上下文执行，并在断点的源代码前显示。

</p>
<p>To start watching an expression, type <code>watch(&quot;my_expression&quot;)</code>. <code>watchers</code>
prints the active watchers. To remove a watcher, type
<code>unwatch(&quot;my_expression&quot;)</code>.

</p>
<p>输入 <code>watch(&quot;my_expression&quot;)</code> 开始监视一个表达式；<code>watchers</code> 显示活动监视器；<code>unwatch(&quot;my_expression&quot;)</code> 移除一个监视器。

</p>
<h2>命令参考<span><a href="all.html#all_39" id="all_39">#</a></span></h2>
<h3>步进<span><a href="all.html#all_40" id="all_40">#</a></span></h3>
<ul>
<li><code>cont</code>, <code>c</code> - Continue execution</li>
<li><code>next</code>, <code>n</code> - Step next</li>
<li><code>step</code>, <code>s</code> - Step in</li>
<li><code>out</code>, <code>o</code> - Step out</li>
<li><p><code>pause</code> - Pause running code (like pause button in Developer Tools)</p>
</li>
<li><p><code>cont</code>, <code>c</code> - 继续执行</p>
</li>
<li><code>next</code>, <code>n</code> - Step next</li>
<li><code>step</code>, <code>s</code> - Step in</li>
<li><code>out</code>, <code>o</code> - Step out</li>
<li><code>pause</code> - 暂停执行代码（类似开发者工具中的暂停按钮）</li>
</ul>
<h3>断点<span><a href="all.html#all_41" id="all_41">#</a></span></h3>
<div><ul>
<li><code>setBreakpoint()</code>, <code>sb()</code> - Set breakpoint on current line</li>
<li><code>setBreakpoint(line)</code>, <code>sb(line)</code> - Set breakpoint on specific line</li>
<li><code>setBreakpoint(&apos;fn()&apos;)</code>, <code>sb(...)</code> - Set breakpoint on a first statement in
functions body</li>
<li><code>setBreakpoint(&apos;script.js&apos;, 1)</code>, <code>sb(...)</code> - Set breakpoint on first line of
script.js</li>
<li><p><code>clearBreakpoint</code>, <code>cb(...)</code> - Clear breakpoint</p>
</li>
<li><p><code>setBreakpoint()</code>, <code>sb()</code> - 在当前行设置断点</p>
</li>
<li><code>setBreakpoint(line)</code>, <code>sb(line)</code> - 在指定行设置断点</li>
<li><code>setBreakpoint(&apos;fn()&apos;)</code>, <code>sb(...)</code> - 在函数体的第一条语句设置断点</li>
<li><code>setBreakpoint(&apos;script.js&apos;, 1)</code>, <code>sb(...)</code> - 在 script.js 的第一行设置断点</li>
<li><code>clearBreakpoint</code>, <code>cb(...)</code> - 清除断点</li>
</div></ul>
<p>It is also possible to set a breakpoint in a file (module) that
isn&apos;t loaded yet:

</p>
<p>在一个尚未被加载的文件（模块）中设置断点也是可行的：

</p>
<pre><code>% ./node debug test/fixtures/break-in-module/main.js
&lt; debugger listening on port 5858
connecting to port 5858... ok
break in test/fixtures/break-in-module/main.js:1
  1 var mod = require(&apos;./mod.js&apos;);
  2 mod.hello();
  3 mod.hello();
debug&gt; setBreakpoint(&apos;mod.js&apos;, 23)
Warning: script &apos;mod.js&apos; was not loaded yet.
  1 var mod = require(&apos;./mod.js&apos;);
  2 mod.hello();
  3 mod.hello();
debug&gt; c
break in test/fixtures/break-in-module/mod.js:23
 21
 22 exports.hello = function() {
 23   return &apos;hello from module&apos;;
 24 };
 25
debug&gt;</code></pre>
<h3>信息<span><a href="all.html#all_42" id="all_42">#</a></span></h3>
<div><ul>
<li><code>backtrace</code>, <code>bt</code> - Print backtrace of current execution frame</li>
<li><code>list(5)</code> - List scripts source code with 5 line context (5 lines before and
after)</li>
<li><code>watch(expr)</code> - Add expression to watch list</li>
<li><code>unwatch(expr)</code> - Remove expression from watch list</li>
<li><code>watchers</code> - List all watchers and their values (automatically listed on each
breakpoint)</li>
<li><p><code>repl</code> - Open debugger&apos;s repl for evaluation in debugging script&apos;s context</p>
</li>
<li><p><code>backtrace</code>, <code>bt</code> - 显示当前执行框架的回溯</p>
</li>
<li><code>list(5)</code> - 显示脚本源代码的 5 行上下文（之前 5 行和之后 5 行）</li>
<li><code>watch(expr)</code> - 向监视列表添加表达式</li>
<li><code>unwatch(expr)</code> - 从监视列表移除表达式</li>
<li><code>watchers</code> - 列出所有监视器和它们的值（每个断点会自动列出）</li>
<li><code>repl</code> - 在所调试的脚本的上下文中打开调试器的 repl 执行代码</li>
</div></ul>
<h3>执行控制<span><a href="all.html#all_43" id="all_43">#</a></span></h3>
<div><ul>
<li><code>run</code> - Run script (automatically runs on debugger&apos;s start)</li>
<li><code>restart</code> - Restart script</li>
<li><p><code>kill</code> - Kill script</p>
</li>
<li><p><code>run</code> - 运行脚本（调试器开始时自动运行）</p>
</li>
<li><code>restart</code> - 重新运行脚本</li>
<li><code>kill</code> - 终止脚本</li>
</div></ul>
<h3>杂项<span><a href="all.html#all_44" id="all_44">#</a></span></h3>
<div><ul>
<li><code>scripts</code> - List all loaded scripts</li>
<li><p><code>version</code> - Display v8&apos;s version</p>
</li>
<li><p><code>scripts</code> - 列出所有已加载的脚本</p>
</li>
<li><code>version</code> - 显示 V8 的版本</li>
</div></ul>
<h2>高级使用<span><a href="all.html#all_45" id="all_45">#</a></span></h2>
<p>The V8 debugger can be enabled and accessed either by starting Node with
the <code>--debug</code> command-line flag or by signaling an existing Node process
with <code>SIGUSR1</code>.

</p>
<p>V8 调试器可以从两种方式启用和访问：以 <code>--debug</code> 命令行标志启动 Node；或者向已存在的 Node 进程发送 <code>SIGUSR1</code> 信号。

</p>
<p>Once a process has been set in debug mode with this it can be connected to
with the node debugger. Either connect to the <code>pid</code> or the URI to the debugger.
The syntax is:

</p>
<p>一旦一个进程进入了调试模式，它便可被 Node 调试器连接。调试器可以通过 <code>pid</code> 或 URI 来连接，语法是：

</p>
<ul>
<li><code>node debug -p &lt;pid&gt;</code> - Connects to the process via the <code>pid</code></li>
<li><code>node debug &lt;URI&gt;</code> - Connects to the process via the URI such as localhost:5858</li>
</ul>
<ul>
<li><code>node debug -p &lt;pid&gt;</code> - 通过 <code>pid</code> 连接进程</li>
<li><code>node debug &lt;URI&gt;</code> - 通过类似 localhost:5858 的 URI 连接进程</li>
</ul>
<h1>集群<span><a href="all.html#all_46" id="all_46">#</a></span></h1>
<pre><code>稳定度: 1 - 实验性</code></pre>
<p>A single instance of Node runs in a single thread. To take advantage of
multi-core systems the user will sometimes want to launch a cluster of Node
processes to handle the load.

</p>
<p>单个 Node 实例运行在单个线程中。要发挥多核系统的能力，用户有时候需要启动一个 Node 进程集群来处理负载。

</p>
<p>The cluster module allows you to easily create a network of processes that
all share server ports.

</p>
<p>集群模块允许你方便地创建一个共享服务器端口的进程网络。

</p>
<pre><code>  cluster.on(&apos;exit&apos;, function(worker, code, signal) {
    console.log(&apos;工作进程 &apos; + worker.process.pid + &apos; 被终止&apos;);
  });
} else {
  // 工作进程可以共享任意 TCP 连接
  // 本例中为 HTTP 服务器
  http.createServer(function(req, res) {
    res.writeHead(200);
    res.end(&quot;你好，操蛋的世界\n&quot;);
  }).listen(8000);
}</code></pre>
<p>Running node will now share port 8000 between the workers:

</p>
<p>现在，运行 node 将会在所有工作进程间共享 8000 端口：

</p>
<pre><code>% NODE_DEBUG=cluster node server.js
23521,Master Worker 23524 online
23521,Master Worker 23526 online
23521,Master Worker 23523 online
23521,Master Worker 23528 online</code></pre>
<p>This feature was introduced recently, and may change in future versions.
Please try it out and provide feedback.

</p>
<p>这是一个近期推出的功能，在未来版本中可能会有所改变。请尝试并提供反馈。

</p>
<p>Also note that, on Windows, it is not yet possible to set up a named pipe
server in a worker.

</p>
<p>还要注意的是，在 Windows 中尚不能在工作进程中建立一个被命名的管道服务器。

</p>
<h2>它是如何工作的<span><a href="all.html#all_47" id="all_47">#</a></span></h2>
<!--type=misc-->

<p>The worker processes are spawned using the <code>child_process.fork</code> method,
so that they can communicate with the parent via IPC and pass server
handles back and forth.

</p>
<p>工作进程是通过使用 <code>child_process.fork</code> 方法派生的，因此它们可以通过 IPC（进程间通讯）与父进程通讯并互相传递服务器句柄。

</p>
<p>The cluster module supports two methods of distributing incoming
connections.

</p>
<p>集群模块支持两种分配传入连接的方式。

</p>
<p>The first one (and the default one on all platforms except Windows),
is the round-robin approach, where the master process listens on a
port, accepts new connections and distributes them across the workers
in a round-robin fashion, with some built-in smarts to avoid
overloading a worker process.

</p>
<p>第一种（同时也是除 Windows 外所有平台的缺省方式）为循环式：主进程监听一个端口，接受新连接，并以轮流的方式分配给工作进程，并以一些内建机制来避免单个工作进程的超载。

</p>
<p>The second approach is where the master process creates the listen
socket and sends it to interested workers. The workers then accept
incoming connections directly.

</p>
<p>第二种方式是，主进程建立监听嵌套字，并将它发送给感兴趣的工作进程，由工作进程直接接受传入连接。

</p>
<p>The second approach should, in theory, give the best performance.
In practice however, distribution tends to be very unbalanced due
to operating system scheduler vagaries. Loads have been observed
where over 70% of all connections ended up in just two processes,
out of a total of eight.

</p>
<p>第二种方式理论上有最好的性能。然而在实践中，由于操作系统的调度变幻莫测，分配往往十分不平衡。负载曾被观测到超过 70% 的连接结束于总共八个进程中的两个。

</p>
<p>Because <code>server.listen()</code> hands off most of the work to the master
process, there are three cases where the behavior between a normal
node.js process and a cluster worker differs:

</p>
<p>因为 <code>server.listen()</code> 将大部分工作交给了主进程，所以一个普通的node.js进程和一个集群工作进程会在三种情况下有所区别：

</p>
<ol>
<li><code>server.listen({fd: 7})</code> Because the message is passed to the master,
file descriptor 7 <strong>in the parent</strong> will be listened on, and the
handle passed to the worker, rather than listening to the worker&apos;s
idea of what the number 7 file descriptor references.</li>
<li><code>server.listen(handle)</code> Listening on handles explicitly will cause
the worker to use the supplied handle, rather than talk to the master
process.  If the worker already has the handle, then it&apos;s presumed
that you know what you are doing.</li>
<li><code>server.listen(0)</code> Normally, this will cause servers to listen on a
random port.  However, in a cluster, each worker will receive the
same &quot;random&quot; port each time they do <code>listen(0)</code>.  In essence, the
port is random the first time, but predictable thereafter.  If you
want to listen on a unique port, generate a port number based on the
cluster worker ID.</li>
</ol>
<ol>
<li><code>server.listen({fd: 7})</code> 由于消息被传递到主进程，<strong>父进程中的</strong>文件描述符 7 会被监听，并且句柄会被传递给工作进程，而不是监听工作进程中文件描述符 7 所引用的东西。</li>
<li><code>server.listen(handle)</code> 明确地监听一个句柄会使得工作进程使用所给句柄，而不是与主进程通讯。如果工作进程已经拥有了该句柄，则假定您知道您在做什么。</li>
<li><code>server.listen(0)</code> 通常，这会让服务器监听一个随机端口。然而，在集群中，各个工作进程每次 <code>listen(0)</code> 都会得到一样的“随机”端口。实际上，端口在第一次时是随机的，但在那之后却是可预知的。如果您想要监听一个唯一的端口，则请根据集群工作进程 ID 来生成端口号。</li>
</ol>
<p>There is no routing logic in Node.js, or in your program, and no shared
state between the workers.  Therefore, it is important to design your
program such that it does not rely too heavily on in-memory data objects
for things like sessions and login.

</p>
<p>由于在 Node.js 或您的程序中并没有路由逻辑，工作进程之间也没有共享的状态，因此在您的程序中，诸如会话和登录等功能应当被设计成不能太过依赖于内存中的数据对象。

</p>
<p>Because workers are all separate processes, they can be killed or
re-spawned depending on your program&apos;s needs, without affecting other
workers.  As long as there are some workers still alive, the server will
continue to accept connections.  Node does not automatically manage the
number of workers for you, however.  It is your responsibility to manage
the worker pool for your application&apos;s needs.

</p>
<p>由于工作进程都是独立的进程，因此它们会根据您的程序的需要被终止或重新派生，并且不会影响到其它工作进程。只要还有工作进程存在，服务器就会继续接受连接。但是，Node 不会自动为您管理工作进程的数量，根据您的程序所需管理工作进程池是您的责任。

</p>
<h2>cluster.schedulingPolicy<span><a href="all.html#all_cluster_schedulingpolicy" id="all_cluster_schedulingpolicy">#</a></span></h2>
<p>The scheduling policy, either <code>cluster.SCHED_RR</code> for round-robin or
<code>cluster.SCHED_NONE</code> to leave it to the operating system. This is a
global setting and effectively frozen once you spawn the first worker
or call <code>cluster.setupMaster()</code>, whatever comes first.

</p>
<p>调度策略 <code>cluster.SCHED_RR</code> 表示轮流制，<code>cluster.SCHED_NONE</code> 表示由操作系统处理。这是一个全局设定，并且一旦您派生了第一个工作进程或调用了 <code>cluster.setupMaster()</code> 后便不可更改。

</p>
<p><code>SCHED_RR</code> is the default on all operating systems except Windows.
Windows will change to <code>SCHED_RR</code> once libuv is able to effectively
distribute IOCP handles without incurring a large performance hit.

</p>
<p><code>SCHED_RR</code> 是除 Windows 外所有操作系统上的缺省方式。只要 libuv 能够有效地分配 IOCP 句柄并且不产生巨大的性能损失，Windows 也将会更改为 <code>SCHED_RR</code> 方式。

</p>
<p><code>cluster.schedulingPolicy</code> can also be set through the
<code>NODE_CLUSTER_SCHED_POLICY</code> environment variable. Valid
values are <code>&quot;rr&quot;</code> and <code>&quot;none&quot;</code>.

</p>
<p><code>cluster.schedulingPolicy</code> 也可以通过环境变量 <code>NODE_CLUSTER_SCHED_POLICY</code> 设定。有效值为 <code>&quot;rr&quot;</code> 和 <code>&quot;none&quot;</code>。

</p>
<h2>cluster.settings<span><a href="all.html#all_cluster_settings" id="all_cluster_settings">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> file path to worker file.  (Default=<code>__filename</code>)</li>
<li><code>args</code> <span>Array</span> string arguments passed to worker.
(Default=<code>process.argv.slice(2)</code>)</li>
<li><code>silent</code> <span>Boolean</span> whether or not to send output to parent&apos;s stdio.
(Default=<code>false</code>)</li>
</ul>
</li>
<li><p><span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> 工作进程文件的路径。（缺省为 <code>__filename</code>）</li>
<li><code>args</code> <span>Array</span> 传递给工作进程的字符串参数。（缺省为 <code>process.argv.slice(2)</code>）</li>
<li><code>silent</code> <span>Boolean</span> 是否将输出发送到父进程的 stdio。（缺省为 <code>false</code>）</li>
</ul>
</li>
</div></ul>
<p>All settings set by the <code>.setupMaster</code> is stored in this settings object.
This object is not supposed to be changed or set manually, by you.

</p>
<p>所有由 <code>.setupMaster</code> 设定的设置都会储存在此设置对象中。这个对象不应由您手动更改或设定。

</p>
<h2>集群的主进程(判断当前进程是否是主进程)<span><a href="all.html#all_48" id="all_48">#</a></span></h2>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>True if the process is a master. This is determined
by the <code>process.env.NODE_UNIQUE_ID</code>. If <code>process.env.NODE_UNIQUE_ID</code> is
undefined, then <code>isMaster</code> is <code>true</code>.

</p>
<p>如果进程为主进程则为 <code>true</code>。这是由 <code>process.env.NODE_UNIQUE_ID</code> 判断的，如果 <code>process.env.NODE_UNIQUE_ID</code> 为 undefined，则 <code>isMaster</code> 为 <code>true</code>。

</p>
<h2>集群的主线程(判断当前线程是否是主线程)<span><a href="all.html#all_49" id="all_49">#</a></span></h2>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>This boolean flag is true if the process is a worker forked from a master.
If the <code>process.env.NODE_UNIQUE_ID</code> is set to a value, then
<code>isWorker</code> is <code>true</code>.

</p>
<p>如果当前进程是分支自主进程的工作进程，则该布尔标识的值为 <code>true</code>。如果 <code>process.env.NODE_UNIQUE_ID</code> 被设定为一个值，则 <code>isWorker</code> 为 <code>true</code>。

</p>
<h2>事件: &apos;fork&apos;<span><a href="all.html#all_fork" id="all_fork">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>When a new worker is forked the cluster module will emit a &apos;fork&apos; event.
This can be used to log worker activity, and create you own timeout.

</p>
<p>当一个新的工作进程被分支出来，cluster 模块会产生一个 &apos;fork&apos; 事件。这可被用于记录工作进程活动，以及创建您自己的超时判断。

</p>
<pre><code>cluster.on(&apos;fork&apos;, function(worker) {
  timeouts[worker.id] = setTimeout(errorMsg, 2000);
});
cluster.on(&apos;listening&apos;, function(worker, address) {
  clearTimeout(timeouts[worker.id]);
});
cluster.on(&apos;exit&apos;, function(worker, code, signal) {
  clearTimeout(timeouts[worker.id]);
  errorMsg();
});</code></pre>
<h2>事件: &apos;online&apos;<span><a href="all.html#all_online" id="all_online">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>After forking a new worker, the worker should respond with a online message.
When the master receives a online message it will emit such event.
The difference between &apos;fork&apos; and &apos;online&apos; is that fork is emitted when the
master tries to fork a worker, and &apos;online&apos; is emitted when the worker is
being executed.

</p>
<p>分支出一个新的工作进程后，工作进程会响应一个在线消息。当主进程收到一个在线消息后，它会触发该事件。&apos;fork&apos; 和 &apos;online&apos; 的区别在于前者发生于主进程尝试分支出工作进程时，而后者发生于工作进程被执行时。

</p>
<pre><code>cluster.on(&apos;online&apos;, function(worker) {
  console.log(&quot;嘿嘿，工作进程完成分支并发出回应了&quot;);
});</code></pre>
<h2>事件: &apos;listening&apos;<span><a href="all.html#all_listening_2" id="all_listening_2">#</a></span></h2>
<div><ul>
<li><code>worker</code> <span>Worker object</span></li>
<li><p><code>address</code> <span>Object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><code>address</code> <span>Object</span></li>
</div></ul>
<p>When calling <code>listen()</code> from a worker, a &apos;listening&apos; event is automatically assigned
to the server instance. When the server is listening a message is send to the master
where the &apos;listening&apos; event is emitted.

</p>
<p>当工作进程调用 <code>listen()</code> 时，一个 <code>listening</code> 事件会被自动分配到服务器实例中。当服务器处于监听时，一个消息会被发送到那个&apos;listening&apos;事件被分发的主进程。

</p>
<p>The event handler is executed with two arguments, the <code>worker</code> contains the worker
object and the <code>address</code> object contains the following connection properties:
<code>address</code>, <code>port</code> and <code>addressType</code>. This is very useful if the worker is listening
on more than one address.

</p>
<p>事件处理器被执行时会带上两个参数。其中 <code>worker</code> 包含了工作进程对象，<code>address</code> 对象包含了下列连接属性：地址 <code>address</code>、端口号 <code>port</code> 和地址类型 <code>addressType</code>。如果工作进程监听多个地址，那么这些信息将十分有用。

</p>
<pre><code>cluster.on(&apos;listening&apos;, function(worker, address) {
  console.log(&quot;一个工作进程刚刚连接到 &quot; + address.address + &quot;:&quot; + address.port);
});</code></pre>
<h2>事件: &apos;disconnect&apos;<span><a href="all.html#all_disconnect_1" id="all_disconnect_1">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>When a workers IPC channel has disconnected this event is emitted.
This will happen when the worker dies, usually after calling
<code>.kill()</code>.

</p>
<p>当一个工作进程的 IPC 通道断开时此事件会发生。这发生于工作进程结束时，通常是调用 <code>.kill()</code> 之后。

</p>
<p>When calling <code>.disconnect()</code>, there may be a delay between the
<code>disconnect</code> and <code>exit</code> events.  This event can be used to detect if
the process is stuck in a cleanup or if there are long-living
connections.

</p>
<p>当调用 <code>.disconnect()</code> 后，<code>disconnect</code> 和 <code>exit</code> 事件之间可能存在延迟。该事件可被用于检测进程是否被卡在清理过程或存在长连接。

</p>
<pre><code>cluster.on(&apos;disconnect&apos;, function(worker) {
  console.log(&apos;工作进程 #&apos; + worker.id + &apos; 断开了连接&apos;);
});</code></pre>
<h2>事件: &apos;exit&apos;<span><a href="all.html#all_exit_3" id="all_exit_3">#</a></span></h2>
<div><ul>
<li><code>worker</code> <span>Worker object</span></li>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the name of the signal (eg. <code>&apos;SIGHUP&apos;</code>) that caused
the process to be killed.</p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><code>code</code> <span>Number</span> 如果是正常退出则为退出代码。</li>
<li><code>signal</code> <span>String</span> 使得进程被终止的信号的名称（比如 <code>&apos;SIGHUP&apos;</code>）。</li>
</div></ul>
<p>When any of the workers die the cluster module will emit the &apos;exit&apos; event.
This can be used to restart the worker by calling <code>fork()</code> again.

</p>
<p>当任意工作进程被结束时，集群模块会分发<code>exit</code> 事件。通过再次调用<code>fork()</code>函数，可以使用这个事件来重启工作进程。

</p>
<pre><code>cluster.on(&apos;exit&apos;, function(worker, code, signal) {
  var exitCode = worker.process.exitCode;
  console.log(&apos;工作进程 &apos; + worker.process.pid + &apos; 被结束（&apos;+exitCode+&apos;）。正在重启...&apos;);
  cluster.fork();
});</code></pre>
<h2>事件: &apos;setup&apos;<span><a href="all.html#all_setup" id="all_setup">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>When the <code>.setupMaster()</code> function has been executed this event emits.
If <code>.setupMaster()</code> was not executed before <code>fork()</code> this function will
call <code>.setupMaster()</code> with no arguments.

</p>
<p>当 <code>.setupMaster()</code> 函数被执行时触发此事件。如果 <code>.setupMaster()</code> 在 <code>fork()</code> 之前没被执行，那么它会不带参数调用 <code>.setupMaster()</code>。

</p>
<h2>cluster.setupMaster([settings])<span><a href="all.html#all_cluster_setupmaster_settings" id="all_cluster_setupmaster_settings">#</a></span></h2>
<div><ul>
<li><p><code>settings</code> <span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> file path to worker file.  (Default=<code>__filename</code>)</li>
<li><code>args</code> <span>Array</span> string arguments passed to worker.
(Default=<code>process.argv.slice(2)</code>)</li>
<li><code>silent</code> <span>Boolean</span> whether or not to send output to parent&apos;s stdio.
(Default=<code>false</code>)</li>
</ul>
</li>
<li><p><code>settings</code> <span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> 工作进程文件的路径。（缺省为 <code>__filename</code>）</li>
<li><code>args</code> <span>Array</span> 传给工作进程的字符串参数。（缺省为 <code>process.argv.slice(2)</code>）</li>
<li><code>silent</code> <span>Boolean</span> 是否将输出发送到父进程的 stdio。（缺省为 <code>false</code>）</li>
</ul>
</li>
</div></ul>
<p><code>setupMaster</code> is used to change the default &apos;fork&apos; behavior. The new settings
are effective immediately and permanently, they cannot be changed later on.

</p>
<p><code>setupMaster</code> 被用于更改缺省的 <code>fork</code> 行为。新的设置会立即永久生效，并且在之后不能被更改。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var cluster = require(&quot;cluster&quot;);
cluster.setupMaster({
  exec : &quot;worker.js&quot;,
  args : [&quot;--use&quot;, &quot;https&quot;],
  silent : true
});
cluster.fork();</code></pre>
<h2>cluster.fork([env])<span><a href="all.html#all_cluster_fork_env" id="all_cluster_fork_env">#</a></span></h2>
<div><ul>
<li><code>env</code> <span>Object</span> Key/value pairs to add to child process environment.</li>
<li><p>return <span>Worker object</span></p>
</li>
<li><p><code>env</code> <span>Object</span> 添加到子进程环境变量中的键值对。</p>
</li>
<li>返回 <span>Worker object</span></li>
</div></ul>
<p>Spawn a new worker process. This can only be called from the master process.

</p>
<p>派生一个新的工作进程。这个函数只能在主进程中被调用。

</p>
<h2>cluster.disconnect([callback])<span><a href="all.html#all_cluster_disconnect_callback" id="all_cluster_disconnect_callback">#</a></span></h2>
<div><ul>
<li><p><code>callback</code> <span>Function</span> called when all workers are disconnected and handlers are closed</p>
</li>
<li><p><code>callback</code> <span>Function</span> 当所有工作进程都断开连接并且句柄被关闭时被调用</p>
</li>
</div></ul>
<p>When calling this method, all workers will commit a graceful suicide. When they are
disconnected all internal handlers will be closed, allowing the master process to
die graceful if no other event is waiting.

</p>
<p>调用此方法时，所有的工作进程都会优雅地将自己结束掉。当它们都断开连接时，所有的内部处理器都会被关闭，使得主进程可以可以在没有其它事件等待时优雅地结束。

</p>
<p>The method takes an optional callback argument which will be called when finished.

</p>
<p>该方法带有一个可选的回调参数，会在完成时被调用。

</p>
<h2>cluster.worker<span><a href="all.html#all_cluster_worker" id="all_cluster_worker">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>A reference to the current worker object. Not available in the master process.

</p>
<p>对当前工作进程对象的引用。在主进程中不可用。

</p>
<pre><code>if (cluster.isMaster) {
  console.log(&apos;我是主进程&apos;);
  cluster.fork();
  cluster.fork();
} else if (cluster.isWorker) {
  console.log(&apos;我是工作进程 #&apos; + cluster.worker.id);
}</code></pre>
<h2>cluster.workers<span><a href="all.html#all_cluster_workers" id="all_cluster_workers">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>A hash that stores the active worker objects, keyed by <code>id</code> field. Makes it
easy to loop through all the workers. It is only available in the master
process.

</p>
<p>一个储存活动工作进程对象的哈希表，以 <code>id</code> 字段作为主键。它能被用作遍历所有工作进程，仅在主进程中可用。

</p>
<pre><code>// 遍历所有工作进程
function eachWorker(callback) {
  for (var id in cluster.workers) {
    callback(cluster.workers[id]);
  }
}
eachWorker(function(worker) {
  worker.send(&apos;向一线工作者们致以亲切问候！&apos;);
});</code></pre>
<p>Should you wish to reference a worker over a communication channel, using
the worker&apos;s unique id is the easiest way to find the worker.

</p>
<p>如果您希望通过通讯通道引用一个工作进程，那么使用工作进程的唯一标识是找到那个工作进程的最简单的办法。

</p>
<pre><code>socket.on(&apos;data&apos;, function(id) {
  var worker = cluster.workers[id];
});</code></pre>
<h2>类: Worker<span><a href="all.html#all_worker" id="all_worker">#</a></span></h2>
<p>A Worker object contains all public information and method about a worker.
In the master it can be obtained using <code>cluster.workers</code>. In a worker
it can be obtained using <code>cluster.worker</code>.

</p>
<p>一个 Worker 对象包含了工作进程的所有公开信息和方法。可通过主进程中的 <code>cluster.workers</code> 或工作进程中的 <code>cluster.worker</code> 取得。

</p>
<h3>worker.id<span><a href="all.html#all_worker_id" id="all_worker_id">#</a></span></h3>
<div><ul>
<li><p><span>String</span></p>
</li>
<li><p><span>String</span></p>
</li>
</div></ul>
<p>Each new worker is given its own unique id, this id is stored in the
<code>id</code>.

</p>
<p>每个新的工作进程都被赋予一个唯一的标识，这个标识被储存在 <code>id</code> 中。

</p>
<p>While a worker is alive, this is the key that indexes it in
cluster.workers

</p>
<p>当一个工作进程可用时，这就是它被索引在 cluster.workers 中的主键。

</p>
<h3>worker.process<span><a href="all.html#all_worker_process" id="all_worker_process">#</a></span></h3>
<div><ul>
<li><p><span>ChildProcess object</span></p>
</li>
<li><p><span>ChildProcess object</span></p>
</li>
</div></ul>
<p>All workers are created using <code>child_process.fork()</code>, the returned object
from this function is stored in process.

</p>
<p>所有工作进程都是使用 <code>child_process.fork()</code> 创建的，该函数返回的对象被储存在 process 中。

</p>
<p>See: <a href="child_process.html">Child Process module</a>

</p>
<p>参考：<a href="child_process.html">Child Process 模块</a>

</p>
<h3>worker.suicide<span><a href="all.html#all_worker_suicide" id="all_worker_suicide">#</a></span></h3>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>This property is a boolean. It is set when a worker dies after calling
<code>.kill()</code> or immediately after calling the <code>.disconnect()</code> method.
Until then it is <code>undefined</code>.

</p>
<p>该属性是一个布尔值。它会在工作进程调用 <code>.kill()</code> 后终止时或调用 <code>.disconnect()</code> 方法时被设置。在此之前它的值是 <code>undefined</code>。

</p>
<h3>worker.send(message, [sendHandle])<span><a href="all.html#all_worker_send_message_sendhandle" id="all_worker_send_message_sendhandle">#</a></span></h3>
<div><ul>
<li><code>message</code> <span>Object</span></li>
<li><p><code>sendHandle</code> <span>Handle object</span></p>
</li>
<li><p><code>message</code> <span>Object</span></p>
</li>
<li><code>sendHandle</code> <span>Handle object</span></li>
</div></ul>
<p>This function is equal to the send methods provided by
<code>child_process.fork()</code>.  In the master you should use this function to
send a message to a specific worker.  However in a worker you can also use
<code>process.send(message)</code>, since this is the same function.

</p>
<p>该函数等同于 <code>child_process.fork()</code> 提供的 send 方法。在主进程中您可以用该函数向特定工作进程发送消息。当然，在工作进程中您也能使用 <code>process.send(message)</code>，因为它们是同一个函数。

</p>
<p>This example will echo back all messages from the master:

</p>
<p>这个例子会回应来自主进程的所有消息：

</p>
<pre><code>} else if (cluster.isWorker) {
  process.on(&apos;message&apos;, function(msg) {
    process.send(msg);
  });
}</code></pre>
<h3>worker.kill([signal=&apos;SIGTERM&apos;])<span><a href="all.html#all_worker_kill_signal_sigterm" id="all_worker_kill_signal_sigterm">#</a></span></h3>
<div><ul>
<li><p><code>signal</code> <span>String</span> Name of the kill signal to send to the worker
process.</p>
</li>
<li><p><code>signal</code> <span>String</span> 发送给工作进程的终止信号的名称</p>
</li>
</div></ul>
<p>This function will kill the worker, and inform the master to not spawn a
new worker.  The boolean <code>suicide</code> lets you distinguish between voluntary
and accidental exit.

</p>
<p>该函数会终止工作进程，并告知主进程不要派生一个新工作进程。布尔值 <code>suicide</code> 让您区分自行退出和意外退出。

</p>
<pre><code>// 终止工作进程
worker.kill();</code></pre>
<p>This method is aliased as <code>worker.destroy()</code> for backwards
compatibility.

</p>
<p>该方法的别名是 <code>worker.destroy()</code>，以保持向后兼容。

</p>
<h3>worker.disconnect()<span><a href="all.html#all_worker_disconnect" id="all_worker_disconnect">#</a></span></h3>
<p>When calling this function the worker will no longer accept new connections, but
they will be handled by any other listening worker. Existing connection will be
allowed to exit as usual. When no more connections exist, the IPC channel to the worker
will close allowing it to die graceful. When the IPC channel is closed the <code>disconnect</code>
event will emit, this is then followed by the <code>exit</code> event, there is emitted when
the worker finally die.

</p>
<p>调用该函数后工作进程将不再接受新连接，但新连接仍会被其它正在监听的工作进程处理。已存在的连接允许正常退出。当没有连接存在，连接到工作进程的 IPC 通道会被关闭，以便工作进程安全地结束。当 IPC 通道关闭时 <code>disconnect</code> 事件会被触发，然后则是工作进程最终结束时触发的 <code>exit</code> 事件。

</p>
<p>Because there might be long living connections, it is useful to implement a timeout.
This example ask the worker to disconnect and after 2 seconds it will destroy the
server. An alternative would be to execute <code>worker.kill()</code> after 2 seconds, but
that would normally not allow the worker to do any cleanup if needed.

</p>
<p>由于可能存在长连接，通常会实现一个超时机制。这个例子会告知工作进程断开连接，并且在 2 秒后销毁服务器。另一个备选方案是 2 秒后执行 <code>worker.kill()</code>，但那样通常会使得工作进程没有机会进行必要的清理。

</p>
<pre><code>  process.on(&apos;message&apos;, function(msg) {
    if (msg === &apos;force kill&apos;) {
      server.close();
    }
  });
}</code></pre>
<h3>事件: &apos;message&apos;<span><a href="all.html#all_message_2" id="all_message_2">#</a></span></h3>
<div><ul>
<li><p><code>message</code> <span>Object</span></p>
</li>
<li><p><code>message</code> <span>Object</span></p>
</li>
</div></ul>
<p>This event is the same as the one provided by <code>child_process.fork()</code>.
In the master you should use this event, however in a worker you can also use
<code>process.on(&apos;message&apos;)</code>

</p>
<p>该事件和 <code>child_process.fork()</code> 所提供的一样。在主进程中您应当使用该事件，而在工作进程中您也可以使用 <code>process.on(&apos;message&apos;)</code>。

</p>
<p>As an example, here is a cluster that keeps count of the number of requests
in the master process using the message system:

</p>
<p>举个例子，这里有一个集群，使用消息系统在主进程中统计请求的数量：

</p>
<pre><code>    // 将请求通知主进程
    process.send({ cmd: &apos;notifyRequest&apos; });
  }).listen(8000);
}</code></pre>
<h3>事件: &apos;online&apos;<span><a href="all.html#all_online_1" id="all_online_1">#</a></span></h3>
<p>Same as the <code>cluster.on(&apos;online&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<p>和 <code>cluster.on(&apos;online&apos;)</code> 事件一样，但仅当特定工作进程的状态改变时发生。

</p>
<pre><code>cluster.fork().on(&apos;online&apos;, function() {
  // 工作进程在线
});</code></pre>
<h3>事件: &apos;listening&apos;<span><a href="all.html#all_listening_3" id="all_listening_3">#</a></span></h3>
<div><ul>
<li><p><code>address</code> <span>Object</span></p>
</li>
<li><p><code>address</code> <span>Object</span></p>
</li>
</div></ul>
<p>Same as the <code>cluster.on(&apos;listening&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<p>和 <code>cluster.on(&apos;listening&apos;)</code> 事件一样，但仅当特定工作进程的状态改变时发生。

</p>
<pre><code>cluster.fork().on(&apos;listening&apos;, function(address) {
  // 工作进程正在监听
});</code></pre>
<h3>事件: &apos;disconnect&apos;<span><a href="all.html#all_disconnect_2" id="all_disconnect_2">#</a></span></h3>
<p>Same as the <code>cluster.on(&apos;disconnect&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<p>和 <code>cluster.on(&apos;disconnect&apos;)</code> 事件一样，但仅当特定工作进程的状态改变时发生。

</p>
<pre><code>cluster.fork().on(&apos;disconnect&apos;, function() {
  // 工作进程断开了连接
});</code></pre>
<h3>事件: &apos;exit&apos;<span><a href="all.html#all_exit_4" id="all_exit_4">#</a></span></h3>
<div><ul>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the name of the signal (eg. <code>&apos;SIGHUP&apos;</code>) that caused
the process to be killed.</p>
</li>
<li><p><code>code</code> <span>Number</span> 如果是正常退出则为退出代码。</p>
</li>
<li><code>signal</code> <span>String</span> 使得进程被终止的信号的名称（比如 <code>&apos;SIGHUP&apos;</code>）。</li>
</div></ul>
<p>Emitted by the individual worker instance, when the underlying child process
is terminated.  See <a href="child_process.html#child_process_event_exit">child_process event: &apos;exit&apos;</a>.

</p>
<p>由单个工作进程实例在底层子进程被结束时触发。详见<a href="child_process.html#child_process_event_exit">子进程事件: &apos;exit&apos;</a>。

</p>
<pre><code>var worker = cluster.fork();
worker.on(&apos;exit&apos;, function(code, signal) {
  if( signal ) {
    console.log(&quot;worker was killed by signal: &quot;+signal);
  } else if( code !== 0 ) {
    console.log(&quot;worker exited with error code: &quot;+code);
  } else {
    console.log(&quot;worker success!&quot;);
  }
});


var worker = cluster.fork();
worker.on(&apos;exit&apos;, function(code, signal) {
  if( signal ) {
    console.log(&quot;工人被信号 &quot; + signal + &quot; 杀掉了&quot;);
  } else if( code !== 0 ) {
    console.log(&quot;工作进程退出，错误码：&quot; + code);
  } else {
    console.log(&quot;劳动者的胜利！&quot;);
  }
});</code></pre>
<h1>Smalloc<span><a href="all.html#all_smalloc" id="all_smalloc">#</a></span></h1>
<pre><code>稳定度: 1 - 实验性</code></pre>
<h2>smalloc.alloc(length[, receiver][, type])<span><a href="all.html#all_smalloc_alloc_length_receiver_type" id="all_smalloc_alloc_length_receiver_type">#</a></span></h2>
<div><ul>
<li><code>length</code> <span>Number</span> <code>&lt;= smalloc.kMaxLength</code></li>
<li><code>receiver</code> <span>Object</span>, Optional, Default: <code>new Object</code></li>
<li><p><code>type</code> <span>Enum</span>, Optional, Default: <code>Uint8</code></p>
</li>
<li><p><code>length</code> <span>Number</span> <code>&lt;= smalloc.kMaxLength</code></p>
</li>
<li><code>receiver</code> <span>Object</span> 可选，缺省为 <code>new Object</code></li>
<li><code>type</code> <span>Enum</span> 可选，缺省为 <code>Uint8</code></li>
</div></ul>
<p>Returns <code>receiver</code> with allocated external array data. If no <code>receiver</code> is
passed then a new Object will be created and returned.

</p>
<p>返回 <code>receiver</code> 及所分配的外部数组数据。如果未传入 <code>receiver</code> 则会创建并返回一个新的 Object。

</p>
<p>Buffers are backed by a simple allocator that only handles the assignation of
external raw memory. Smalloc exposes that functionality.

</p>
<p>Buffer 后端为一个只处理外部原始内存的分配的简易分配器所支撑。Smalloc 暴露了该功能。

</p>
<p>This can be used to create your own Buffer-like classes. No other properties are
set, so the user will need to keep track of other necessary information (e.g.
<code>length</code> of the allocation).

</p>
<p>这可用于创建你自己的类似 Buffer 的类。由于不会设置其它属性，因此使用者需要自行跟踪其它所需信息（比如所分配的长度 <code>length</code>）。

</p>
<pre><code>SimpleData.prototype = { /* ... */ };</code></pre>
<p>It only checks if the <code>receiver</code> is an Object, and also not an Array. Because of
this it is possible to allocate external array data to more than a plain Object.

</p>
<p>它只检查 <code>receiver</code> 是否为一个非 Array 的 Object。因此，可以分配外部数组数据的不止纯 Object。

</p>
<pre><code>// { [Function allocMe] &apos;0&apos;: 0, &apos;1&apos;: 0, &apos;2&apos;: 0 }</code></pre>
<p>v8 does not support allocating external array data to an Array, and if passed
will throw.

</p>
<p>V8 不支持向一个 Array 分配外部数组数据，如果这么做将会抛出异常。

</p>
<p>It&apos;s possible is to specify the type of external array data you would like. All
possible options are listed in <code>smalloc.Types</code>. Example usage:

</p>
<p>您可以指定您想要的外部数组数据的类型。所有可取的值都已在 <code>smalloc.Types</code> 中列出。使用示例：

</p>
<pre><code>// { &apos;0&apos;: 0, &apos;1&apos;: 0.1, &apos;2&apos;: 0.2 }</code></pre>
<h2>smalloc.copyOnto(source, sourceStart, dest, destStart, copyLength);<span><a href="all.html#all_smalloc_copyonto_source_sourcestart_dest_deststart_copylength" id="all_smalloc_copyonto_source_sourcestart_dest_deststart_copylength">#</a></span></h2>
<div><ul>
<li><code>source</code> Object with external array allocation</li>
<li><code>sourceStart</code> Position to begin copying from</li>
<li><code>dest</code> Object with external array allocation</li>
<li><code>destStart</code> Position to begin copying onto</li>
<li><p><code>copyLength</code> Length of copy</p>
</li>
<li><p><code>source</code> 分配了外部数组的来源对象</p>
</li>
<li><code>sourceStart</code> 从这个位置开始拷贝</li>
<li><code>dest</code> 分配了外部数组的目标对象</li>
<li><code>destStart</code> 拷贝到这个位置</li>
<li><code>copyLength</code> 拷贝的长度</li>
</div></ul>
<p>Copy memory from one external array allocation to another. No arguments are
optional, and any violation will throw.

</p>
<p>从一个外部数组向另一个拷贝内存。所有参数都是必填，否则将会抛出异常。

</p>
<pre><code>// { &apos;0&apos;: 4, &apos;1&apos;: 6, &apos;2&apos;: 2, &apos;3&apos;: 3 }</code></pre>
<p><code>copyOnto</code> automatically detects the length of the allocation internally, so no
need to set any additional properties for this to work.

</p>
<p><code>copyOnto</code> 会在内部自动检测分配的长度，因此无需对此给出额外的参数。

</p>
<h2>smalloc.dispose(obj)<span><a href="all.html#all_smalloc_dispose_obj" id="all_smalloc_dispose_obj">#</a></span></h2>
<div><ul>
<li><p><code>obj</code> Object</p>
</li>
<li><p><code>obj</code> 对象</p>
</li>
</div></ul>
<p>Free memory that has been allocated to an object via <code>smalloc.alloc</code>.

</p>
<p>释放已使用 <code>smalloc.alloc</code> 分配到一个对象的内存。

</p>
<pre><code>// {}</code></pre>
<p>This is useful to reduce strain on the garbage collector, but developers must be
careful. Cryptic errors may arise in applications that are difficult to trace.

</p>
<p>这对于减轻垃圾回收器的负担有所帮助，但开发者务必小心。难以跟踪的应用程序可能会发生奇怪的错误。

</p>
<pre><code>// 将导致：
// Error: source has no external array data</code></pre>
<p><code>dispose()</code> does not support Buffers, and will throw if passed.

</p>
<p><code>dispose()</code> 不支持 Buffer，传入将会抛出异常。

</p>
<h2>smalloc.kMaxLength<span><a href="all.html#all_smalloc_kmaxlength" id="all_smalloc_kmaxlength">#</a></span></h2>
<p>Size of maximum allocation. This is also applicable to Buffer creation.

</p>
<p>最大的分配大小。该值同时也适用于 Buffer 的创建。

</p>
<h2>smalloc.Types<span><a href="all.html#all_smalloc_types" id="all_smalloc_types">#</a></span></h2>
<p>Enum of possible external array types. Contains:

</p>
<p>外部数组类型的可取值，包含：

</p>
<ul>
<li><code>Int8</code></li>
<li><code>Uint8</code></li>
<li><code>Int16</code></li>
<li><code>Uint16</code></li>
<li><code>Int32</code></li>
<li><code>Uint32</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Uint8Clamped</code></li>
</ul>
<ul>
<li><code>Int8</code></li>
<li><code>Uint8</code></li>
<li><code>Int16</code></li>
<li><code>Uint16</code></li>
<li><code>Int32</code></li>
<li><code>Uint32</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Uint8Clamped</code></li>
</ul>
<h1>关于本文档<span><a href="all.html#all_50" id="all_50">#</a></span></h1>
<!-- type=misc -->

<p>The goal of this documentation is to comprehensively explain the Node.js
API, both from a reference as well as a conceptual point of view.  Each
section describes a built-in module or high-level concept.

</p>
<p>本文档的目标是从参考和概念的角度全面解释 Node.js 的 API，每章节描述一个内置模块或高级概念。

</p>
<p>Where appropriate, property types, method arguments, and the arguments
provided to event handlers are detailed in a list underneath the topic
heading.

</p>
<p>在某些情况下，属性类型、方法参数以及事件处理过程（handler）参数 会被列在主标题下的列表中。

</p>
<p>Every <code>.html</code> document has a corresponding <code>.json</code> document presenting
the same information in a structured manner.  This feature is
experimental, and added for the benefit of IDEs and other utilities that
wish to do programmatic things with the documentation.

</p>
<p>每一个 <code>.html</code> 文件都对应一份内容相同的结构化 <code>.json</code> 文档。这个特性现在还是实验性质的，希望能够为一些需要对文档进行操作的IDE或者其他工具提供帮助。

</p>
<p>Every <code>.html</code> and <code>.json</code> file is generated based on the corresponding
<code>.markdown</code> file in the <code>doc/api/</code> folder in node&apos;s source tree.  The
documentation is generated using the <code>tools/doc/generate.js</code> program.
The HTML template is located at <code>doc/template.html</code>.

</p>
<p>每个 <code>.html</code> 和 <code>.json</code> 文件都是基于源码的 <code>doc/api/</code> 目录下的 <code>.markdown</code> 文件生成的。本文档使用 <code>tools/doc/generate.js</code> 这个程序来生产的。 HTML 模板文件为 <code>doc/template.html</code>。

</p>
<h2>稳定度<span><a href="all.html#all_51" id="all_51">#</a></span></h2>
<!--type=misc-->

<p>Throughout the documentation, you will see indications of a section&apos;s
stability.  The Node.js API is still somewhat changing, and as it
matures, certain parts are more reliable than others.  Some are so
proven, and so relied upon, that they are unlikely to ever change at
all.  Others are brand new and experimental, or known to be hazardous
and in the process of being redesigned.

</p>
<p>在文档中，您可以了解每一个小节的稳定性。Node.js的API会有一些小的改变，当它成熟的时候，会有些部分相比另外一些来说更加可靠。有一部分接受过严格验证，被大量依赖的API几乎是不会改变的。也有一些是新增的、实验性的或者因被证实具有危险性而在重新设计中。

</p>
<p>The stability indices are as follows:

</p>
<p>稳定度定义如下

</p>
<pre><code>稳定度: 5 - 已锁定
除非发现严重缺陷，该代码不会被更改。请不要对此区域提出更改，更改提议将被拒绝。</code></pre>
<h2>JSON 输出<span><a href="all.html#all_json_1" id="all_json_1">#</a></span></h2>
<pre><code>稳定度: 1 - 实验性</code></pre>
<p>Every HTML file in the markdown has a corresponding JSON file with the
same data.

</p>
<p>每个通过 markdown 生成的 HTML 文件都对应于一个具有相同数据的 JSON 文件。

</p>
<p>This feature is new as of node v0.6.12.  It is experimental.


</p>
<p>该特性引入于 node v0.6.12。当前是测试性功能。

</p>
<h1>概述<span><a href="all.html#all_52" id="all_52">#</a></span></h1>
<!--type=misc-->

<p>An example of a <a href="http.html">web server</a> written with Node which responds with &apos;Hello
World&apos;:

</p>
<p>一个输出 “Hello World” 的简单 <a href="http.html">Web 服务器</a>例子：

</p>
<pre><code>console.log(&apos;服务器已运行，请打开 http://127.0.0.1:8124/&apos;);</code></pre>
<p>To run the server, put the code into a file called <code>example.js</code> and execute
it with the node program

</p>
<p>要运行这个服务器，先将程序保存为文件 “example.js”，并使用 node 命令来执行：

</p>
<pre><code>&gt; node example.js
服务器已运行，请打开 http://127.0.0.1:8124/</code></pre>
<p>All of the examples in the documentation can be run similarly.


</p>
<p>所有的文档中的例子均使用相同的方式运行。
</p>
<h1>全局对象<span><a href="all.html#all_53" id="all_53">#</a></span></h1>
<!-- type=misc -->

<p>These objects are available in all modules. Some of these objects aren&apos;t
actually in the global scope but in the module scope - this will be noted.

</p>
<p>这些对象在所有模块中都是可用的。有些对象实际上并非在全局作用域内而是在模块作用域内——这种情况在以下文档中会特别指出。

</p>
<h2>global<span><a href="all.html#all_global_1" id="all_global_1">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Object} The global namespace object.</p>
</li>
<li><p>{Object} 全局命名空间对象。</p>
</li>
</ul>
<p>In browsers, the top-level scope is the global scope. That means that in
browsers if you&apos;re in the global scope <code>var something</code> will define a global
variable. In Node this is different. The top-level scope is not the global
scope; <code>var something</code> inside a Node module will be local to that module.

</p>
<p>在浏览器中，顶级作用域就是全局作用域。这就是说，在浏览器中，如果当前是在全局作用域内，<code>var something</code>将会声明一个全局变量。在Node中则不同。顶级作用域并非全局作用域，在Node模块里的<code>var something</code>只属于那个模块。

</p>
<h2>process<span><a href="all.html#all_process_2" id="all_process_2">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>The process object. See the <a href="process.html#process_process">process object</a> section.

</p>
<p>进程对象。见 <a href="process.html#process_process">进程对象</a>章节。

</p>
<h2>console<span><a href="all.html#all_console_1" id="all_console_1">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>Used to print to stdout and stderr. See the <a href="console.html">console</a> section.

</p>
<p>用于打印标准输出和标准错误。见<a href="console.html">控制台</a>章节。

</p>
<h2>类: Buffer<span><a href="all.html#all_buffer_3" id="all_buffer_3">#</a></span></h2>
<!-- type=global -->

<ul>
<li><p>{Function}</p>
</li>
<li><p>{Function}</p>
</li>
</ul>
<p>Used to handle binary data. See the <a href="buffer.html">buffer section</a>

</p>
<p>用于处理二进制数据。见<a href="buffer.html#buffer_buffer">Buffer</a>章节。

</p>
<h2>require()<span><a href="all.html#all_require_1" id="all_require_1">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{Function}</p>
</li>
<li><p>{Function}</p>
</li>
</ul>
<p>To require modules. See the <a href="modules.html#modules_modules">Modules</a> section.  <code>require</code> isn&apos;t actually a
global but rather local to each module.

</p>
<p>引入模块。见<a href="modules.html#modules_modules">Modules</a>章节。<code>require</code>实际上并非全局的而是各个模块本地的。

</p>
<h3>require.resolve()<span><a href="all.html#all_require_resolve_1" id="all_require_resolve_1">#</a></span></h3>
<p>Use the internal <code>require()</code> machinery to look up the location of a module,
but rather than loading the module, just return the resolved filename.

</p>
<p>使用内部的<code>require()</code>机制查找模块的位置，但不加载模块，只返回解析过的模块文件路径。

</p>
<h3>require.cache<span><a href="all.html#all_require_cache_1" id="all_require_cache_1">#</a></span></h3>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>Modules are cached in this object when they are required. By deleting a key
value from this object, the next <code>require</code> will reload the module.

</p>
<p>模块在引入时会缓存到该对象。通过删除该对象的键值，下次调用<code>require</code>时会重新加载相应模块。

</p>
<h3>require.extensions<span><a href="all.html#all_require_extensions_1" id="all_require_extensions_1">#</a></span></h3>
<pre><code>稳定度：0 - 已废弃</code></pre>
<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>Instruct <code>require</code> on how to handle certain file extensions.

</p>
<p>指导<code>require</code>方法如何处理特定的文件扩展名。

</p>
<p>Process files with the extension <code>.sjs</code> as <code>.js</code>:

</p>
<p>将<code>.sjs</code>文件作为<code>.js</code>文件处理：

</p>
<pre><code>require.extensions[&apos;.sjs&apos;] = require.extensions[&apos;.js&apos;];</code></pre>
<p><strong>Deprecated</strong>  In the past, this list has been used to load
non-JavaScript modules into Node by compiling them on-demand.
However, in practice, there are much better ways to do this, such as
loading modules via some other Node program, or compiling them to
JavaScript ahead of time.

</p>
<p><strong>已废弃</strong> 之前，该列表用于按需编译非JavaScript模块并加载进Node。然而，实践中有更好的方式实现该功能，如通过其他Node程序加载模块，或提前将他们编译成JavaScript代码。

</p>
<p>Since the Module system is locked, this feature will probably never go
away.  However, it may have subtle bugs and complexities that are best
left untouched.

</p>
<p>由于模块系统的API已锁定，该功能可能永远不会去掉。改动它可能会产生细微的错误和复杂性，所以最好保持不变。

</p>
<h2>__filename<span><a href="all.html#all_filename_1" id="all_filename_1">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{String}</p>
</li>
<li><p>{String}</p>
</li>
</ul>
<p>The filename of the code being executed.  This is the resolved absolute path
of this code file.  For a main program this is not necessarily the same
filename used in the command line.  The value inside a module is the path
to that module file.

</p>
<p>当前所执行代码文件的文件路径。这是该代码文件经过解析后的绝对路径。对于主程序来说，这和命令行中使用的文件路径未必是相同的。在模块中此变量值是该模块文件的路径。

</p>
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>

</p>
<p>例子：在<code>/Users/mjr</code>下运行<code>node example.js</code>

</p>
<pre><code>console.log(__filename);
// /Users/mjr/example.js</code></pre>
<p><code>__filename</code> isn&apos;t actually a global but rather local to each module.

</p>
<p><code>__filename</code>实际上并非全局的而是各个模块本地的。

</p>
<h2>__dirname<span><a href="all.html#all_dirname_1" id="all_dirname_1">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{String}</p>
</li>
<li><p>{String}</p>
</li>
</ul>
<p>The name of the directory that the currently executing script resides in.

</p>
<p>当前执行脚本所在目录的目录名。

</p>
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>

</p>
<p>例子：在<code>/Users/mjr</code>下运行<code>node example.js</code>

</p>
<pre><code>console.log(__dirname);
// /Users/mjr</code></pre>
<p><code>__dirname</code> isn&apos;t actually a global but rather local to each module.

</p>
<p><code>__dirname</code>实际上并非全局的而是各个模块本地的。

</p>
<h2>module<span><a href="all.html#all_module_1" id="all_module_1">#</a></span></h2>
<!-- type=var -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>A reference to the current module. In particular
<code>module.exports</code> is the same as the <code>exports</code> object.
<code>module</code> isn&apos;t actually a global but rather local to each module.

</p>
<p>当前模块的引用。特别地，<code>module.exports</code>和<code>exports</code>指向同一个对象。<code>module</code>实际上并非全局的而是各个模块本地的。

</p>
<p>See the <a href="modules.html">module system documentation</a> for more information.

</p>
<p>详情可见<a href="modules.html">模块系统文档</a>。

</p>
<h2>exports<span><a href="all.html#all_exports_1" id="all_exports_1">#</a></span></h2>
<!-- type=var -->

<p>A reference to the <code>module.exports</code> object which is shared between all
instances of the current module and made accessible through <code>require()</code>.
See <a href="modules.html">module system documentation</a> for details on when to use <code>exports</code> and
when to use <code>module.exports</code>.
<code>exports</code> isn&apos;t actually a global but rather local to each module.

</p>
<p><code>module.exports</code>对象的引用，该对象被当前模块的所有实例所共享，通过<code>require()</code>可访问该对象。
何时使用<code>exports</code>以及何时使用<code>module.exports</code>的详情可参见<a href="modules.html">模块系统文档</a>。
<code>exports</code>实际上并非全局的而是各个模块本地的。

</p>
<p>See the <a href="modules.html">module system documentation</a> for more information.

</p>
<p>详情可见<a href="modules.html">模块系统文档</a>。

</p>
<p>See the <a href="modules.html">module section</a> for more information.

</p>
<p>关于模块系统的更多信息可参见<a href="modules.html">模块</a> 。

</p>
<h2>setTimeout(cb, ms)<span><a href="all.html#all_settimeout_cb_ms_1" id="all_settimeout_cb_ms_1">#</a></span></h2>
<p>Run callback <code>cb</code> after <em>at least</em> <code>ms</code> milliseconds. The actual delay depends
on external factors like OS timer granularity and system load.

</p>
<p>在<em>至少</em><code>ms</code>毫秒后调用回调<code>cb</code>。实际延迟取决于外部因素，如操作系统定时器粒度及系统负载。

</p>
<p>The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&apos;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.

</p>
<p>超时值必须在1-2147483647的范围内（包含1和2147483647）。如果该值超出范围，则该值被当作1毫秒处理。一般来说，一个定时器不能超过24.8天。

</p>
<p>Returns an opaque value that represents the timer.

</p>
<p>返回一个代表该定时器的句柄值。

</p>
<h2>clearTimeout(t)<span><a href="all.html#all_cleartimeout_t_1" id="all_cleartimeout_t_1">#</a></span></h2>
<p>Stop a timer that was previously created with <code>setTimeout()</code>. The callback will
not execute.

</p>
<p>停止一个之前通过<code>setTimeout()</code>创建的定时器。回调不会再被执行。

</p>
<h2>setInterval(cb, ms)<span><a href="all.html#all_setinterval_cb_ms_1" id="all_setinterval_cb_ms_1">#</a></span></h2>
<p>Run callback <code>cb</code> repeatedly every <code>ms</code> milliseconds. Note that the actual
interval may vary, depending on external factors like OS timer granularity and
system load. It&apos;s never less than <code>ms</code> but it may be longer.

</p>
<p>每隔<code>ms</code>毫秒重复调用回调<code>cb</code>。注意，取决于外部因素，如操作系统定时器粒度及系统负载，实际间隔可能会改变。它不会少于<code>ms</code>但可能比<code>ms</code>长。

</p>
<p>The interval must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&apos;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.

</p>
<p>间隔值必须在1-2147483647的范围内（包含1和2147483647）。如果该值超出范围，则该值被当作1毫秒处理。一般来说，一个定时器不能超过24.8天。

</p>
<p>Returns an opaque value that represents the timer.

</p>
<p>返回一个代表该定时器的句柄值。

</p>
<h2>clearInterval(t)<span><a href="all.html#all_clearinterval_t_1" id="all_clearinterval_t_1">#</a></span></h2>
<p>Stop a timer that was previously created with <code>setInterval()</code>. The callback
will not execute.

</p>
<p>停止一个之前通过<code>setInterval()</code>创建的定时器。回调不会再被执行。

</p>
<!--type=global-->

<p>The timer functions are global variables. See the <a href="timers.html">timers</a> section.

</p>
<p>定制器函数是全局变量。见<a href="timers.html">定时器</a>章节。

</p>
<h1>控制台<span><a href="all.html#all_54" id="all_54">#</a></span></h1>
<pre><code>稳定度: 4 - 冻结</code></pre>
<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<!--type=global-->

<p>For printing to stdout and stderr.  Similar to the console object functions
provided by most web browsers, here the output is sent to stdout or stderr.

</p>
<p>用于向 stdout 和 stderr 打印字符。类似于大部分 Web 浏览器提供的 console 对象函数，在这里则是输出到 stdout 或 stderr。

</p>
<p>The console functions are synchronous when the destination is a terminal or
a file (to avoid lost messages in case of premature exit) and asynchronous
when it&apos;s a pipe (to avoid blocking for long periods of time).

</p>
<p>当输出目标是一个终端或者文件时,console函数是同步的(为了防止过早退出时丢失信息).当输出目标是一个管道时它们是异步的(防止阻塞过长时间).

</p>
<p>That is, in the following example, stdout is non-blocking while stderr
is blocking:

</p>
<p>也就是说，在下面的例子中，stdout 是非阻塞的，而 stderr 则是阻塞的。

</p>
<pre><code>$ node script.js 2&gt; error.log | tee info.log</code></pre>
<p>In daily use, the blocking/non-blocking dichotomy is not something you
should worry about unless you log huge amounts of data.

</p>
<p>在日常使用中，您不需要太担心阻塞/非阻塞的差别，除非您需要记录大量数据。

</p>
<h2>console.log([data], [...])<span><a href="all.html#all_console_log_data_1" id="all_console_log_data_1">#</a></span></h2>
<p>Prints to stdout with newline. This function can take multiple arguments in a
<code>printf()</code>-like way. Example:

</p>
<p>向 stdout 打印并新起一行。这个函数可以像 <code>printf()</code> 那样接受多个参数，例如：

</p>
<pre><code>console.log(&apos;count: %d&apos;, count);</code></pre>
<p>If formatting elements are not found in the first string then <code>util.inspect</code>
is used on each argument.  See <a href="util.html#util_util_format_format">util.format()</a> for more information.

</p>
<p>如果在第一个字符串中没有找到格式化元素，那么 <code>util.inspect</code> 将被应用到各个参数。详见 <a href="util.html#util_util_format_format">util.format()</a>。

</p>
<h2>console.info([data], [...])<span><a href="all.html#all_console_info_data_1" id="all_console_info_data_1">#</a></span></h2>
<p>Same as <code>console.log</code>.

</p>
<p>同 <code>console.log</code>。

</p>
<h2>console.error([data], [...])<span><a href="all.html#all_console_error_data_1" id="all_console_error_data_1">#</a></span></h2>
<p>Same as <code>console.log</code> but prints to stderr.

</p>
<p>同 <code>console.log</code>，但输出到 stderr。

</p>
<h2>console.warn([data], [...])<span><a href="all.html#all_console_warn_data_1" id="all_console_warn_data_1">#</a></span></h2>
<p>Same as <code>console.error</code>.

</p>
<p>同 <code>console.error</code>。

</p>
<h2>console.dir(obj)<span><a href="all.html#all_console_dir_obj_1" id="all_console_dir_obj_1">#</a></span></h2>
<p>Uses <code>util.inspect</code> on <code>obj</code> and prints resulting string to stdout. This function
bypasses any custom <code>inspect()</code> function on <code>obj</code>.

</p>
<p>对 <code>obj</code> 使用 <code>util.inspect</code> 并将结果字符串输出到 stdout。这个函数会忽略 <code>obj</code> 上的任何自定义 <code>inspect()</code>。

</p>
<h2>console.time(label)<span><a href="all.html#all_console_time_label_1" id="all_console_time_label_1">#</a></span></h2>
<p>Mark a time.

</p>
<p>标记一个时间点。

</p>
<h2>console.timeEnd(label)<span><a href="all.html#all_console_timeend_label_1" id="all_console_timeend_label_1">#</a></span></h2>
<p>Finish timer, record output. Example:

</p>
<p>结束计时器，记录输出。例如：

</p>
<pre><code>console.time(&apos;100-elements&apos;);
for (var i = 0; i &lt; 100; i++) {
  ;
}
console.timeEnd(&apos;100-elements&apos;);</code></pre>
<h2>console.trace(label)<span><a href="all.html#all_console_trace_label_1" id="all_console_trace_label_1">#</a></span></h2>
<p>Print a stack trace to stderr of the current position.

</p>
<p>打印当前位置的栈跟踪到 stderr。

</p>
<h2>console.assert(expression, [message])<span><a href="all.html#all_console_assert_expression_message_1" id="all_console_assert_expression_message_1">#</a></span></h2>
<p>Same as <a href="assert.html#assert_assert_value_message_assert_ok_value_message">assert.ok()</a> where if the <code>expression</code> evaluates as <code>false</code> throw an
AssertionError with <code>message</code>.

</p>
<p>与 <a href="assert.html#assert_assert_value_message_assert_ok_value_message">assert.ok()</a> 相同，如果 <code>expression</code> 执行结果为 <code>false</code> 则抛出一个带上 <code>message</code> 的 AssertionError。

</p>
<h1>定时器<span><a href="all.html#all_55" id="all_55">#</a></span></h1>
<pre><code>稳定度: 5 - 已锁定</code></pre>
<p>All of the timer functions are globals.  You do not need to <code>require()</code>
this module in order to use them.

</p>
<p>所有的定时器函数都是全局变量. 你使用这些函数时不需要 <code>require()</code>模块.

</p>
<h2>setTimeout(callback, delay, [arg], [...])<span><a href="all.html#all_settimeout_callback_delay_arg_1" id="all_settimeout_callback_delay_arg_1">#</a></span></h2>
<p>To schedule execution of a one-time <code>callback</code> after <code>delay</code> milliseconds. Returns a
<code>timeoutId</code> for possible use with <code>clearTimeout()</code>. Optionally you can
also pass arguments to the callback.

</p>
<p>调度 <code>delay</code> 毫秒后的一次 <code>callback</code> 执行。返回一个可能被 <code>clearTimeout()</code> 用到的 <code>timeoutId</code>。可选地，您还能给回调传入参数。

</p>
<p>It is important to note that your callback will probably not be called in exactly
<code>delay</code> milliseconds - Node.js makes no guarantees about the exact timing of when
the callback will fire, nor of the ordering things will fire in. The callback will
be called as close as possible to the time specified.

</p>
<p>请务必注意，您的回调有可能不会在准确的 <code>delay</code> 毫秒后被调用。Node.js 不保证回调被触发的精确时间和顺序。回调会在尽可能接近所指定时间上被调用。

</p>
<h2>clearTimeout(timeoutId)<span><a href="all.html#all_cleartimeout_timeoutid_1" id="all_cleartimeout_timeoutid_1">#</a></span></h2>
<p>Prevents a timeout from triggering.

</p>
<p>阻止一个 timeout 被触发。

</p>
<h2>setInterval(callback, delay, [arg], [...])<span><a href="all.html#all_setinterval_callback_delay_arg_1" id="all_setinterval_callback_delay_arg_1">#</a></span></h2>
<p>To schedule the repeated execution of <code>callback</code> every <code>delay</code> milliseconds.
Returns a <code>intervalId</code> for possible use with <code>clearInterval()</code>. Optionally
you can also pass arguments to the callback.

</p>
<p>调度每隔 <code>delay</code> 毫秒执行一次的 <code>callback</code>。返回一个可能被 <code>clearInterval()</code> 用到的 <code>intervalId</code>。可选地，您还能给回调传入参数。

</p>
<h2>clearInterval(intervalId)<span><a href="all.html#all_clearinterval_intervalid_1" id="all_clearinterval_intervalid_1">#</a></span></h2>
<p>Stops a interval from triggering.

</p>
<p>停止一个 interval 的触发。

</p>
<h2>unref()<span><a href="all.html#all_unref_1" id="all_unref_1">#</a></span></h2>
<p>The opaque value returned by <code>setTimeout</code> and <code>setInterval</code> also has the method
<code>timer.unref()</code> which will allow you to create a timer that is active but if
it is the only item left in the event loop won&apos;t keep the program running.
If the timer is already <code>unref</code>d calling <code>unref</code> again will have no effect.

</p>
<p><code>setTimeout</code> 和 <code>setInterval</code> 所返回的值同时具有 <code>timer.unref()</code> 方法，允许您创建一个活动的、但当它是事件循环中仅剩的项目时不会保持程序运行的定时器。如果定时器已被 <code>unref</code>，再次调用 <code>unref</code> 不会产生其它影响。

</p>
<p>In the case of <code>setTimeout</code> when you <code>unref</code> you create a separate timer that
will wakeup the event loop, creating too many of these may adversely effect
event loop performance -- use wisely.

</p>
<p>在 <code>setTimeout</code> 的情景中当您 <code>unref</code> 您会创建另一个定时器，并唤醒事件循环。创建太多这种定时器可能会影响事件循环的性能，慎用。

</p>
<h2>ref()<span><a href="all.html#all_ref_1" id="all_ref_1">#</a></span></h2>
<p>If you had previously <code>unref()</code>d a timer you can call <code>ref()</code> to explicitly
request the timer hold the program open. If the timer is already <code>ref</code>d calling
<code>ref</code> again will have no effect.

</p>
<p>如果您之前 <code>unref()</code> 了一个定时器，您可以调用 <code>ref()</code> 来明确要求定时器让程序保持运行。如果定时器已被 <code>ref</code> 那么再次调用 <code>ref</code> 不会产生其它影响。

</p>
<h2>setImmediate(callback, [arg], [...])<span><a href="all.html#all_setimmediate_callback_arg_1" id="all_setimmediate_callback_arg_1">#</a></span></h2>
<p>To schedule the &quot;immediate&quot; execution of <code>callback</code> after I/O events
callbacks and before <code>setTimeout</code> and <code>setInterval</code> . Returns an
<code>immediateId</code> for possible use with <code>clearImmediate()</code>. Optionally you
can also pass arguments to the callback.

</p>
<p>调度在所有 I/O 事件回调之后、<code>setTimeout</code> 和 <code>setInterval</code> 之前“立即”执行 <code>callback</code>。返回一个可能被 <code>clearImmediate()</code> 用到的 <code>immediateId</code>。可选地，您还能给回调传入参数。

</p>
<p>Callbacks for immediates are queued in the order in which they were created.
The entire callback queue is processed every event loop iteration. If you queue
an immediate from a inside an executing callback that immediate won&apos;t fire
until the next event loop iteration.

</p>
<p>immediate 的回调以它们创建的顺序被加入队列。整个回调队列会在每个事件循环迭代中被处理。如果您在一个正被执行的回调中添加 immediate，那么这个 immediate 在下一个事件循环迭代之前都不会被触发。

</p>
<h2>clearImmediate(immediateId)<span><a href="all.html#all_clearimmediate_immediateid_1" id="all_clearimmediate_immediateid_1">#</a></span></h2>
<p>Stops an immediate from triggering.


</p>
<p>停止一个 immediate 的触发。
</p>
<h1>Modules<span><a href="all.html#all_modules_1" id="all_modules_1">#</a></span></h1>
<pre><code>稳定度: 5 - 已锁定</code></pre>
<!--name=module-->

<p>Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, <code>foo.js</code> loads the module
<code>circle.js</code> in the same directory.

</p>
<p>Node有一个简易的模块加载系统。在node中，文件和模块是一一对应的。下面示例是<code>foo.js</code>加载同一目录下的<code>circle.js</code>。

</p>
<p>The contents of <code>foo.js</code>:

</p>
<p> <code>foo.js</code>的内容：

</p>
<pre><code>var circle = require(&apos;./circle.js&apos;);
console.log( &apos;The area of a circle of radius 4 is &apos;
           + circle.area(4));</code></pre>
<p>The contents of <code>circle.js</code>:

</p>
<p><code>circle.js</code>的内容:

</p>
<pre><code>var PI = Math.PI;
exports.area = function (r) {
    return PI * r * r;
};
exports.circumference = function (r) {
    return 2 * PI * r;
};</code></pre>
<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and
<code>circumference()</code>.  To export an object, add to the special <code>exports</code>
object.

</p>
<p><code>circle.js</code>模块输出了<code>area()</code>和<code>circumference()</code>两个函数。要输出某个对象，把它加到<code>exports</code>这个特殊对象下即可。

</p>
<p>Note that <code>exports</code> is a reference to <code>module.exports</code> making it suitable
for augmentation only. If you are exporting a single item such as a
constructor you will want to use <code>module.exports</code> directly instead.

</p>
<p>注意，<code>exports</code>是<code>module.exports</code>的一个引用，只是为了用起来方便。当你想输出的是例如构造函数这样的单个项目，那么需要使用<code>module.exports</code>。

</p>
<pre><code>// 正确输出构造函数
module.exports = MyConstructor;</code></pre>
<p>Variables
local to the module will be private. In this example the variable <code>PI</code> is
private to <code>circle.js</code>.

</p>
<p>模块内的本地变量是私有的。在这里例子中，<code>PI</code>这个变量就是<code>circle.js</code>私有的。

</p>
<p>The module system is implemented in the <code>require(&quot;module&quot;)</code> module.

</p>
<p>模块系统的实现在<code>require(&quot;module&quot;)</code>中。

</p>
<h2>循环<span><a href="all.html#all_56" id="all_56">#</a></span></h2>
<!--type=misc-->

<p>When there are circular <code>require()</code> calls, a module might not be
done being executed when it is returned.

</p>
<p>当存在循环的<code>require()</code>调用时，一个模块可能在返回时并不会被执行。

</p>
<p>Consider this situation:

</p>
<p>考虑这样一种情形:

</p>
<p><code>a.js</code>:

</p>
<p><code>a.js</code>:

</p>
<pre><code>console.log(&apos;a starting&apos;);
exports.done = false;
var b = require(&apos;./b.js&apos;);
console.log(&apos;in a, b.done = %j&apos;, b.done);
exports.done = true;
console.log(&apos;a done&apos;);</code></pre>
<p><code>b.js</code>:

</p>
<p><code>b.js</code>:

</p>
<pre><code>console.log(&apos;b starting&apos;);
exports.done = false;
var a = require(&apos;./a.js&apos;);
console.log(&apos;in b, a.done = %j&apos;, a.done);
exports.done = true;
console.log(&apos;b done&apos;);</code></pre>
<p><code>main.js</code>:

</p>
<p><code>main.js</code>:

</p>
<pre><code>console.log(&apos;main starting&apos;);
var a = require(&apos;./a.js&apos;);
var b = require(&apos;./b.js&apos;);
console.log(&apos;in main, a.done=%j, b.done=%j&apos;, a.done, b.done);</code></pre>
<p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>.  At that
point, <code>b.js</code> tries to load <code>a.js</code>.  In order to prevent an infinite
loop an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the
<code>b.js</code> module.  <code>b.js</code> then finishes loading, and its <code>exports</code> object is
provided to the <code>a.js</code> module.

</p>
<p>首先<code>main.js</code>加载<code>a.js</code>,接着<code>a.js</code>又去加载<code>b.js</code>。这时，<code>b.js</code>会尝试去加载<code>a.js</code>。为了防止无限的循环，<code>a.js</code>会返回一个<strong>unfinished copy</strong>给<code>b.js</code>。然后<code>b.js</code>就会停止加载，并将其<code>exports</code>对象返回给<code>a.js</code>模块。

</p>
<p>By the time <code>main.js</code> has loaded both modules, they&apos;re both finished.
The output of this program would thus be:

</p>
<p>这样<code>main.js</code>就把这两个模块都加载完成了。这段程序的输出如下：

</p>
<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true</code></pre>
<p>If you have cyclic module dependencies in your program, make sure to
plan accordingly.

</p>
<p>如果你的程序中有循环的模块依赖，请确保工作正常。

</p>
<h2>核心模块<span><a href="all.html#all_57" id="all_57">#</a></span></h2>
<!--type=misc-->

<p>Node has several modules compiled into the binary.  These modules are
described in greater detail elsewhere in this documentation.

</p>
<p>Node中有一些模块是编译成二进制的。这些模块在本文档的其他地方有更详细的描述。

</p>
<p>The core modules are defined in node&apos;s source in the <code>lib/</code> folder.

</p>
<p>核心模块定义在node源代码的<code>lib/</code>目录下。

</p>
<p>Core modules are always preferentially loaded if their identifier is
passed to <code>require()</code>.  For instance, <code>require(&apos;http&apos;)</code> will always
return the built in HTTP module, even if there is a file by that name.

</p>
<p><code>require()</code>总是会优先加载核心模块。例如，<code>require(&apos;http&apos;)</code>总是返回编译好的HTTP模块，而不管是否有这个名字的文件。

</p>
<h2>文件模块<span><a href="all.html#all_58" id="all_58">#</a></span></h2>
<!--type=misc-->

<p>If the exact filename is not found, then node will attempt to load the
required filename with the added extension of <code>.js</code>, <code>.json</code>, and then <code>.node</code>.

</p>
<p>如果按文件名没有查找到，那么node会添加 <code>.js</code>和 <code>.json</code>后缀名，再尝试加载，如果还是没有找到，最后会加上<code>.node</code>的后缀名再次尝试加载。

</p>
<p><code>.js</code> files are interpreted as JavaScript text files, and <code>.json</code> files are
parsed as JSON text files. <code>.node</code> files are interpreted as compiled addon
modules loaded with <code>dlopen</code>.

</p>
<p><code>.js</code> 会被解析为Javascript纯文本文件，<code>.json</code> 会被解析为JSON格式的纯文本文件. <code>.node</code> 则会被解析为编译后的插件模块，由<code>dlopen</code>进行加载。

</p>
<p>A module prefixed with <code>&apos;/&apos;</code> is an absolute path to the file.  For
example, <code>require(&apos;/home/marco/foo.js&apos;)</code> will load the file at
<code>/home/marco/foo.js</code>.

</p>
<p>模块以<code>&apos;/&apos;</code>为前缀，则表示绝对路径。例如，<code>require(&apos;/home/marco/foo.js&apos;)</code> ，加载的是<code>/home/marco/foo.js</code>这个文件。

</p>
<p>A module prefixed with <code>&apos;./&apos;</code> is relative to the file calling <code>require()</code>.
That is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for
<code>require(&apos;./circle&apos;)</code> to find it.

</p>
<p>模块以<code>&apos;./&apos;</code>为前缀，则路径是相对于调用<code>require()</code>的文件。
也就是说，<code>circle.js</code>必须和<code>foo.js</code>在同一目录下，<code>require(&apos;./circle&apos;)</code>才能找到。

</p>
<p>Without a leading &apos;/&apos; or &apos;./&apos; to indicate a file, the module is either a
&quot;core module&quot; or is loaded from a <code>node_modules</code> folder.

</p>
<p>当没有以&apos;/&apos;或者&apos;./&apos;来指向一个文件时，这个模块要么是&quot;核心模块&quot;，要么就是从<code>node_modules</code>文件夹加载的。

</p>
<p>If the given path does not exist, <code>require()</code> will throw an Error with its
<code>code</code> property set to <code>&apos;MODULE_NOT_FOUND&apos;</code>.

</p>
<p>如果指定的路径不存在，<code>require()</code>会抛出一个<code>code</code>属性为<code>&apos;MODULE_NOT_FOUND&apos;</code>的错误。

</p>
<h2>从<code>node_modules</code>文件夹中加载<span><a href="all.html#all_node_modules_1" id="all_node_modules_1">#</a></span></h2>
<!--type=misc-->

<p>If the module identifier passed to <code>require()</code> is not a native module,
and does not begin with <code>&apos;/&apos;</code>, <code>&apos;../&apos;</code>, or <code>&apos;./&apos;</code>, then node starts at the
parent directory of the current module, and adds <code>/node_modules</code>, and
attempts to load the module from that location.

</p>
<p>如果<code>require()</code>中的模块名不是一个本地模块，也没有以<code>&apos;/&apos;</code>, <code>&apos;../&apos;</code>, 或是 <code>&apos;./&apos;</code>开头，那么node会从当前模块的父目录开始，尝试在它的<code>/node_modules</code>文件夹里加载相应模块。

</p>
<p>If it is not found there, then it moves to the parent directory, and so
on, until the root of the tree is reached.

</p>
<p>如果没有找到，那么就再向上移动到父目录，直到到达顶层目录位置。

</p>
<p>For example, if the file at <code>&apos;/home/ry/projects/foo.js&apos;</code> called
<code>require(&apos;bar.js&apos;)</code>, then node would look in the following locations, in
this order:

</p>
<p>例如，如果位于<code>&apos;/home/ry/projects/foo.js&apos;</code>的文件调用了<code>require(&apos;bar.js&apos;)</code>，那么node查找的位置依次为：

</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><p><code>/node_modules/bar.js</code></p>
</li>
<li><p><code>/home/ry/projects/node_modules/bar.js</code></p>
</li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>This allows programs to localize their dependencies, so that they do not
clash.

</p>
<p>这就要求程序员应尽量把依赖放在就近的位置，以防崩溃。

</p>
<h2>Folders as Modules<span><a href="all.html#all_folders_as_modules_1" id="all_folders_as_modules_1">#</a></span></h2>
<!--type=misc-->

<p>It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library.
There are three ways in which a folder may be passed to <code>require()</code> as
an argument.

</p>
<p>可以把程序和库放到一个单独的文件夹里，并提供单一入口来指向它。有三种方法，使一个文件夹可以作为<code>require()</code>的参数来加载。

</p>
<p>The first is to create a <code>package.json</code> file in the root of the folder,
which specifies a <code>main</code> module.  An example package.json file might
look like this:

</p>
<p>首先是在文件夹的根目录创建一个叫做<code>package.json</code>的文件，它需要指定一个<code>main</code>模块。下面是一个package.json文件的示例。

</p>
<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }</code></pre>
<p>If this was in a folder at <code>./some-library</code>, then
<code>require(&apos;./some-library&apos;)</code> would attempt to load
<code>./some-library/lib/some-library.js</code>.

</p>
<p>示例中这个文件，如果是放在<code>./some-library</code>目录下面，那么<code>require(&apos;./some-library&apos;)</code>就将会去加载<code>./some-library/lib/some-library.js</code>。

</p>
<p>This is the extent of Node&apos;s awareness of package.json files.

</p>
<p>This is the extent of Node&apos;s awareness of package.json files.

</p>
<p>If there is no package.json file present in the directory, then node
will attempt to load an <code>index.js</code> or <code>index.node</code> file out of that
directory.  For example, if there was no package.json file in the above
example, then <code>require(&apos;./some-library&apos;)</code> would attempt to load:

</p>
<p>如果目录里没有package.json这个文件，那么node就会尝试去加载这个路径下的<code>index.js</code>或者<code>index.node</code>。例如，若上面例子中，没有package.json，那么<code>require(&apos;./some-library&apos;)</code>就将尝试加载下面的文件：

</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><p><code>./some-library/index.node</code></p>
</li>
<li><p><code>./some-library/index.js</code></p>
</li>
<li><code>./some-library/index.node</code></li>
</ul>
<h2>Caching<span><a href="all.html#all_caching_1" id="all_caching_1">#</a></span></h2>
<!--type=misc-->

<p>Modules are cached after the first time they are loaded.  This means
(among other things) that every call to <code>require(&apos;foo&apos;)</code> will get
exactly the same object returned, if it would resolve to the same file.

</p>
<p>模块在第一次加载后会被缓存。这意味着（类似其他缓存）每次调用<code>require(&apos;foo&apos;)</code>的时候都会返回同一个对象，当然，必须是每次都解析到同一个文件。

</p>
<p>Multiple calls to <code>require(&apos;foo&apos;)</code> may not cause the module code to be
executed multiple times.  This is an important feature.  With it,
&quot;partially done&quot; objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.

</p>
<p>Multiple calls to <code>require(&apos;foo&apos;)</code> may not cause the module code to be
executed multiple times.  This is an important feature.  With it,
&quot;partially done&quot; objects can be returned, thus allowing transitive
dependencies to be loaded even when they would cause cycles.

</p>
<p>If you want to have a module execute code multiple times, then export a
function, and call that function.

</p>
<p>如果你希望一个模块多次执行，那么就输出一个函数，然后调用这个函数。

</p>
<h3>Module Caching Caveats<span><a href="all.html#all_module_caching_caveats_1" id="all_module_caching_caveats_1">#</a></span></h3>
<!--type=misc-->

<p>Modules are cached based on their resolved filename.  Since modules may
resolve to a different filename based on the location of the calling
module (loading from <code>node_modules</code> folders), it is not a <em>guarantee</em>
that <code>require(&apos;foo&apos;)</code> will always return the exact same object, if it
would resolve to different files.

</p>
<p>模块的缓存是依赖于解析后的文件名。由于随着调用的位置不同，可能解析到不同的文件（比如需从<code>node_modules</code>文件夹加载的情况），所以，如果解析到其他文件时，就不能<em>保证</em><code>require(&apos;foo&apos;)</code>总是会返回确切的同一对象。

</p>
<h2>The <code>module</code> Object<span><a href="all.html#all_the_module_object_1" id="all_the_module_object_1">#</a></span></h2>
<!-- type=var -->
<!-- name=module -->

<!-- type=var -->
<!-- name=module -->

<ul>
<li><p>{Object}</p>
</li>
<li><p>{Object}</p>
</li>
</ul>
<p>In each module, the <code>module</code> free variable is a reference to the object
representing the current module.  In particular
<code>module.exports</code> is accessible via the <code>exports</code> module-global.
<code>module</code> isn&apos;t actually a global but rather local to each module.

</p>
<p>在每一个模块中，变量 <code>module</code> 是一个代表当前模块的对象的引用。
特别地，<code>module.exports</code> 可以通过全局模块对象 <code>exports</code> 获取到。
<code>module</code> 不是事实上的全局对象，而更像是每个模块内部的。

</p>
<h3>module.exports<span><a href="all.html#all_module_exports_1" id="all_module_exports_1">#</a></span></h3>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>The <code>module.exports</code> object is created by the Module system. Sometimes this is not
acceptable, many want their module to be an instance of some class. To do this
assign the desired export object to <code>module.exports</code>. For example suppose we
were making a module called <code>a.js</code>

</p>
<p><code>module.exports</code> 对象是通过模块系统产生的。有时候这是难以接受的，许多人想让他们的模块是某个类的实例。
因此，将要导出的对象赋值给 <code>module.exports</code> 。例如，假设我们有一个模块称之为 <code>a.js</code>

</p>
<pre><code>// Do some work, and after some time emit
// the &apos;ready&apos; event from the module itself.
setTimeout(function() {
  module.exports.emit(&apos;ready&apos;);
}, 1000);</code></pre>
<p>Then in another file we could do

</p>
<p>那么，在另一个文件中我们可以这样写

</p>
<pre><code>var a = require(&apos;./a&apos;);
a.on(&apos;ready&apos;, function() {
  console.log(&apos;module a is ready&apos;);
});</code></pre>
<p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be
done in any callbacks.  This does not work:

</p>
<p>Note that assignment to <code>module.exports</code> must be done immediately. It cannot be
done in any callbacks.  This does not work:

</p>
<p>x.js:

</p>
<p>x.js:

</p>
<pre><code>setTimeout(function() {
  module.exports = { a: &quot;hello&quot; };
}, 0);</code></pre>
<p>y.js:

</p>
<p>y.js:

</p>
<pre><code>var x = require(&apos;./x&apos;);
console.log(x.a);</code></pre>
<h3>module.require(id)<span><a href="all.html#all_module_require_id_1" id="all_module_require_id_1">#</a></span></h3>
<div><ul>
<li><code>id</code> <span>String</span></li>
<li><p>Return: <span>Object</span> <code>module.exports</code> from the resolved module</p>
</li>
<li><p><code>id</code> <span>String</span></p>
</li>
<li>Return: <span>Object</span> 已解析模块的 <code>module.exports</code></li>
</div></ul>
<p>The <code>module.require</code> method provides a way to load a module as if
<code>require()</code> was called from the original module.

</p>
<p><code>module.require</code> 方法提供了一种像 <code>require()</code> 一样从最初的模块加载一个模块的方法。

</p>
<p>Note that in order to do this, you must get a reference to the <code>module</code>
object.  Since <code>require()</code> returns the <code>module.exports</code>, and the <code>module</code> is
typically <em>only</em> available within a specific module&apos;s code, it must be
explicitly exported in order to be used.

</p>
<p>注意，为了这样做，你必须取得一个对 <code>module</code> 对象的引用。
<code>require()</code> 返回 <code>module.exports</code>，并且 <code>module</code> 是一个典型的只能在特定模块作用域内有效的变量，如果要使用它，就必须明确的导出。

</p>
<h3>module.id<span><a href="all.html#all_module_id_1" id="all_module_id_1">#</a></span></h3>
<div><ul>
<li><p><span>String</span></p>
</li>
<li><p><span>String</span></p>
</li>
</div></ul>
<p>The identifier for the module.  Typically this is the fully resolved
filename.

</p>
<p>用于区别模块的标识符。通常是完全解析后的文件名。

</p>
<h3>module.filename<span><a href="all.html#all_module_filename_1" id="all_module_filename_1">#</a></span></h3>
<div><ul>
<li><p><span>String</span></p>
</li>
<li><p><span>String</span></p>
</li>
</div></ul>
<p>The fully resolved filename to the module.

</p>
<p>模块完全解析后的文件名。

</p>
<h3>module.loaded<span><a href="all.html#all_module_loaded_1" id="all_module_loaded_1">#</a></span></h3>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>Whether or not the module is done loading, or is in the process of
loading.

</p>
<p>不论该模块是否加载完毕，或者正在加载的过程中。

</p>
<h3>module.parent<span><a href="all.html#all_module_parent_1" id="all_module_parent_1">#</a></span></h3>
<div><ul>
<li><p><span>Module Object</span></p>
</li>
<li><p><span>Module Object</span></p>
</li>
</div></ul>
<p>The module that required this one.

</p>
<p>引入这个模块的模块。

</p>
<h3>module.children<span><a href="all.html#all_module_children_1" id="all_module_children_1">#</a></span></h3>
<div><ul>
<li><p><span>Array</span></p>
</li>
<li><p><span>Array</span></p>
</li>
</div></ul>
<p>The module objects required by this one.

</p>
<p>这个模块引入的所有模块对象。

</p>
<h2>总体来说...<span><a href="all.html#all_59" id="all_59">#</a></span></h2>
<!-- type=misc -->

<p>To get the exact filename that will be loaded when <code>require()</code> is called, use
the <code>require.resolve()</code> function.

</p>
<p>为了获取调用 <code>require</code> 加载的确切的文件名，使用 <code>require.resolve()</code> 函数。

</p>
<p>Putting together all of the above, here is the high-level algorithm
in pseudocode of what require.resolve does:

</p>
<p>综上所述，下面用伪代码的高级算法形式表达了 require.resolve 是如何工作的：

</p>
<pre><code>NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of &quot;node_modules&quot; in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS</code></pre>
<h2>从全局文件夹加载<span><a href="all.html#all_60" id="all_60">#</a></span></h2>
<!-- type=misc -->

<p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list
of absolute paths, then node will search those paths for modules if they
are not found elsewhere.  (Note: On Windows, <code>NODE_PATH</code> is delimited by
semicolons instead of colons.)

</p>
<p>如果 <code>NODE_PATH</code> 环境变量设置为一个以冒号分割的绝对路径的列表，
找不到模块时 node 将会从这些路径中搜索模块。
（注意：在 windows 操作系统上，<code>NODE_PATH</code> 是以分号间隔的）

</p>
<p>Additionally, node will search in the following locations:

</p>
<p>此外，node 将会搜索以下地址：

</p>
<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li><p>3: <code>$PREFIX/lib/node</code></p>
</li>
<li><p>1: <code>$HOME/.node_modules</code></p>
</li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>
<p>Where <code>$HOME</code> is the user&apos;s home directory, and <code>$PREFIX</code> is node&apos;s
configured <code>node_prefix</code>.

</p>
<p><code>$HOME</code> 是用户的主目录，<code>$PREFIX</code> 是 node 里配置的 <code>node_prefix</code> 。

</p>
<p>These are mostly for historic reasons.  You are highly encouraged to
place your dependencies locally in <code>node_modules</code> folders.  They will be
loaded faster, and more reliably.

</p>
<p>这些大多是由于历史原因。强烈建议读者将所依赖的模块放到 <code>node_modules</code> 文件夹里。
这样加载的更快也更可靠。

</p>
<h2>访问主模块<span><a href="all.html#all_61" id="all_61">#</a></span></h2>
<!-- type=misc -->

<p>When a file is run directly from Node, <code>require.main</code> is set to its
<code>module</code>. That means that you can determine whether a file has been run
directly by testing

</p>
<p>当 Node 直接运行一个文件时，<code>require.main</code> 就被设置为它的 <code>module</code> 。
也就是说你可以判断一个文件是否是直接被运行的

</p>
<pre><code>require.main === module</code></pre>
<p>For a file <code>foo.js</code>, this will be <code>true</code> if run via <code>node foo.js</code>, but
<code>false</code> if run by <code>require(&apos;./foo&apos;)</code>.

</p>
<p>对于一个 <code>foo.js</code> 文件，如果通过 <code>node foo.js</code> 运行是 <code>true</code> ，但是通过 <code>require(&apos;./foo&apos;)</code> 运行却是 <code>false</code> 。

</p>
<p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to
<code>__filename</code>), the entry point of the current application can be obtained
by checking <code>require.main.filename</code>.

</p>
<p>因为 <code>module </code> 提供了一个 <code>filename </code> 属性（通常等于 <code>__filename</code>），
所以当前程序的入口点可以通过 <code>require.main.filename</code> 来获取。

</p>
<h2>附录： 包管理技巧<span><a href="all.html#all_62" id="all_62">#</a></span></h2>
<!-- type=misc -->

<p>The semantics of Node&apos;s <code>require()</code> function were designed to be general
enough to support a number of sane directory structures. Package manager
programs such as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to
build native packages from Node modules without modification.

</p>
<p>Node 的 <code>require()</code> 函数的语义被设计的足够通用化，以支持各种常规目录结构。
包管理程序如 dpkg，rpm 和 npm 将不用修改就能够从 Node 模块构建本地包。

</p>
<p>Below we give a suggested directory structure that could work:

</p>
<p>接下来我们将给你一个可行的目录结构建议：

</p>
<p>Let&apos;s say that we wanted to have the folder at
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a
specific version of a package.

</p>
<p>假设我们希望将一个包的指定版本放在 <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> 目录中。

</p>
<p>Packages can depend on one another. In order to install package <code>foo</code>, you
may have to install a specific version of package <code>bar</code>.  The <code>bar</code> package
may itself have dependencies, and in some cases, these dependencies may even
collide or form cycles.

</p>
<p>包可以依赖于其他包。为了安装包 foo，可能需要安装包 bar 的一个指定版本。
包 bar 也可能有依赖关系，在某些情况下依赖关系可能发生冲突或者形成循环。

</p>
<p>Since Node looks up the <code>realpath</code> of any modules it loads (that is,
resolves symlinks), and then looks for their dependencies in the
<code>node_modules</code> folders as described above, this situation is very simple to
resolve with the following architecture:

</p>
<p>因为 Node 会查找它所加载的模块的真实路径（也就是说会解析符号链接），
然后按照上文描述的方式在 node_modules 目录中寻找依赖关系，这种情形跟以下体系结构非常相像：

</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code>
depends on.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><p><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages
that <code>bar</code> depends on.</p>
</li>
<li><p>/usr/lib/node/foo/1.2.3/ - foo 包 1.2.3 版本的内容</p>
</li>
<li>/usr/lib/node/bar/4.3.2/ - foo 包所依赖的 bar 包的内容</li>
<li>/usr/lib/node/foo/1.2.3/node_modules/bar - 指向 /usr/lib/node/bar/4.3.2/ 的符号链接</li>
<li>/usr/lib/node/bar/4.3.2/node_modules/* - 指向 bar 包所依赖的包的符号链接</li>
</ul>
<p>Thus, even if a cycle is encountered, or if there are dependency
conflicts, every module will be able to get a version of its dependency
that it can use.

</p>
<p>因此即便存在循环依赖或依赖冲突，每个模块还是可以获得他所依赖的包的一个可用版本。

</p>
<p>When the code in the <code>foo</code> package does <code>require(&apos;bar&apos;)</code>, it will get the
version that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>.
Then, when the code in the <code>bar</code> package calls <code>require(&apos;quux&apos;)</code>, it&apos;ll get
the version that is symlinked into
<code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.

</p>
<p>当 foo 包中的代码调用 require(&apos;bar&apos;)，将获得符号链接 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> 指向的版本。
然后，当 bar 包中的代码调用 <code>require(&apos;queue&apos;)</code>，将会获得符号链接 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code> 指向的版本。

</p>
<p>Furthermore, to make the module lookup process even more optimal, rather
than putting packages directly in <code>/usr/lib/node</code>, we could put them in
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then node will not bother
looking for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.

</p>
<p>此外，为了进一步优化模块搜索过程，不要将包直接放在 <code>/usr/lib/node</code> 目录中，而是将它们放在 <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code> 目录中。
这样在依赖的包找不到的情况下，就不会一直寻找 <code>/usr/node_modules</code> 目录或 <code>/node_modules</code> 目录了。

</p>
<p>In order to make modules available to the node REPL, it might be useful to
also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment
variable.  Since the module lookups using <code>node_modules</code> folders are all
relative, and based on the real path of the files making the calls to
<code>require()</code>, the packages themselves can be anywhere.


</p>
<p>为了使模块在 node 的 REPL 中可用，你可能需要将 <code>/usr/lib/node_modules</code> 目录加入到 <code>$NODE_PATH</code> 环境变量中。
由于在 node_modules 目录中搜索模块使用的是相对路径，基于调用 <code>require()</code> 的文件所在真实路径，因此包本身可以放在任何位置。
</p>
<h1>Addons插件<span><a href="all.html#all_addons_1" id="all_addons_1">#</a></span></h1>
<p>Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:

</p>
<p>Addons插件就是动态连接库。它类似胶水，将c、c++和Node粘贴起来。它的API（目前来说）相当复杂，涉及到了几个类库的知识。

</p>
<ul>
<li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:
creating objects, calling functions, etc.  Documented mostly in the
<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node source
tree), which is also available
<a href="http://izs.me/v8-docs/main.html">online</a>.</p>
</li>
<li><p>V8 JavaScript引擎,一个 C++ 类库. 用于和JavaScript进行交互的接口。
创建对象, 调用函数等. 文档大部分在这里：
<code>v8.h</code> 头文件 (<code>deps/v8/include/v8.h</code>在Node源代码目录里), 也有可用的线上文档
<a href="http://izs.me/v8-docs/main.html">线上</a>.
（译者：想要学习c++的addons插件编写，必须先了解v8的接口）</p>
</li>
<li><p><a href="https://github.com/joyent/libuv">libuv</a>, C event loop library.
Anytime one needs to wait for a file descriptor to become readable,
wait for a timer, or wait for a signal to be received one will need
to interface with libuv. That is, if you perform any I/O, libuv will
need to be used.</p>
</li>
<li><p><a href="https://github.com/joyent/libuv">libuv</a>, C语言编写的事件循环类库。任何时候需要等待一个文件描述符变为可读状态，等待一个定时器，或者等待一个接受信号都需要使用libuv类库的接口。也就是说，如果你执行任何I/O操作，libuv类库将会被用到。</p>
</li>
<li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code>
class which you will likely want to derive from.</p>
</li>
<li><p>内部 Node 类库.最重要的接口就是 <code>node::ObjectWrap</code> 类，这个类你应该是最可能想要派生的。</p>
</li>
<li><p>Others. Look in <code>deps/</code> for what else is available.</p>
</li>
<li><p>其他.请参阅 <code>deps/</code> 获得更多可用类库。</p>
</li>
</ul>
<p>Node statically compiles all its dependencies into the executable.
When compiling your module, you don&apos;t need to worry about linking to
any of these libraries.

</p>
<p>Node 静态编译了所有依赖到它的可执行文件中去了。当编译你的模块时，你不必担心无法连接上述那些类库。
（译者：换而言之，你在编译自己的addons插件时，只管在头部 #include &lt;uv.h&gt;，不必在binding.gyp中声明）

</p>
<p>All of the following examples are available for
<a href="https://github.com/rvagg/node-addon-examples">download</a> and may be
used as a starting-point for your own Addon.

</p>
<p>下面所有的例子都可以下载到：
<a href="https://github.com/rvagg/node-addon-examples">下载</a> 
这或许能成为你学习和创作自己addon插件的起点。

</p>
<h2>Hello world（世界你好）<span><a href="all.html#all_hello_world_1" id="all_hello_world_1">#</a></span></h2>
<p>To get started let&apos;s make a small Addon which is the C++ equivalent of
the following JavaScript code:

</p>
<p>作为开始，让我们用编写一个小的addon插件，这个addon插件的c++代码相当于下面的JavaScript代码。

</p>
<pre><code>module.exports.hello = function() { return &apos;world&apos;; };</code></pre>
<p>First we create a file <code>hello.cc</code>:

</p>
<p>首先我们创建一个 <code>hello.cc</code>文件:

</p>
<pre><code>NODE_MODULE(hello, init)//译者：将addon插件名hello和上述init函数关联输出</code></pre>
<p>Note that all Node addons must export an initialization function:

</p>
<p>注意所有Node的addons插件都必须输出一个初始化函数：

</p>
<pre><code>void Initialize (Handle&lt;Object&gt; exports);
NODE_MODULE(module_name, Initialize)</code></pre>
<p>There is no semi-colon after <code>NODE_MODULE</code> as it&apos;s not a function (see
<code>node.h</code>).

</p>
<p>在<code>NODE_MODULE</code>之后没有分号，因为它不是一个函数（请参阅<code>node.h</code>）

</p>
<p>The <code>module_name</code> needs to match the filename of the final binary (minus the
.node suffix).

</p>
<p>这个<code>module_name</code>（模块名）需要和最后编译生成的2进制文件名（减去.node后缀名）相同。

</p>
<p>The source code needs to be built into <code>hello.node</code>, the binary Addon. To
do this we create a file called <code>binding.gyp</code> which describes the configuration
to build your module in a JSON-like format. This file gets compiled by
<a href="https://github.com/TooTallNate/node-gyp">node-gyp</a>.

</p>
<p>源代码需要生成在<code>hello.node</code>，这个2进制addon插件中。
需要做到这些，我们要创建一个名为<code>binding.gyp</code>的文件，它描述了创建这个模块的配置，并且它的格式是类似JSON的。
文件将被命令：<a href="https://github.com/TooTallNate/node-gyp">node-gyp</a> 编译。

</p>
<pre><code>{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;hello&quot;, //译者：addon插件名，注意这里的名字必需和上面NODE_MODULE中的一致
      &quot;sources&quot;: [ &quot;hello.cc&quot; ]  //译者：这是需要编译的源文件
    }
  ]
}</code></pre>
<p>The next step is to generate the appropriate project build files for the
current platform. Use <code>node-gyp configure</code> for that.

</p>
<p>下一步是根据当前的操作系统平台，利用<code>node-gyp configure</code>命令，生成合适的项目文件。

</p>
<p>Now you will have either a <code>Makefile</code> (on Unix platforms) or a <code>vcxproj</code> file
(on Windows) in the <code>build/</code> directory. Next invoke the <code>node-gyp build</code>
command.

</p>
<p>现在你会有一个<code>Makefile</code> (在Unix平台) 或者一个 <code>vcxproj</code> file
(在Windows上)，它们都在<code>build/</code> 文件夹中. 
然后执行命令 <code>node-gyp build</code>进行编译。
（译者：当然你可以执行 <code>node-gyp rebuild</code>一步搞定）

</p>
<p>Now you have your compiled <code>.node</code> bindings file! The compiled bindings end up
in <code>build/Release/</code>.

</p>
<p>现在你已经有了编译好的 <code>.node</code> 文件了，这个编译好的绑定文件会在目录 <code>build/Release/</code>下

</p>
<p>You can now use the binary addon in a Node project <code>hello.js</code> by pointing
<code>require</code> to the recently built <code>hello.node</code> module:

</p>
<p>现在你可以使用这个2进制addon插件在Node项目<code>hello.js</code> 中了，通过指明<code>require</code>这个刚刚创建的<code>hello.node</code>模块使用它。

</p>
<pre><code>console.log(addon.hello()); // &apos;world&apos;</code></pre>
<p>Please see patterns below for further information or
</p>
<p><a href="https://github.com/arturadib/node-qt">https://github.com/arturadib/node-qt</a> for an example in production.

</p>
<p>请阅读下面的内容获得更多详情或者访问<a href="https://github.com/arturadib/node-qt">https://github.com/arturadib/node-qt</a>获取一个生产环境的例子。

</p>
<h2>Addon patterns（插件方式）<span><a href="all.html#all_addon_patterns_1" id="all_addon_patterns_1">#</a></span></h2>
<p>Below are some addon patterns to help you get started. Consult the online
<a href="http://izs.me/v8-docs/main.html">v8 reference</a> for help with the various v8
calls, and v8&apos;s <a href="http://code.google.com/apis/v8/embed.html">Embedder&apos;s Guide</a>
for an explanation of several concepts used such as handles, scopes,
function templates, etc.

</p>
<p>下面是一些帮助你开始编写addon插件的方式。参考这个在线的<a href="http://izs.me/v8-docs/main.html">v8 手册</a>用来帮助你调用各种v8接口， 然后是v8的 <a href="http://code.google.com/apis/v8/embed.html">嵌入式开发向导</a> ，解释几个概念，如 handles, scopes,function templates等。


</p>
<p>In order to use these examples you need to compile them using <code>node-gyp</code>.
Create the following <code>binding.gyp</code> file:

</p>
<p>为了能跑起来这些例子，你必须用 <code>node-gyp</code> 来编译他们。
创建一个<code>binding.gyp</code> 文件：

</p>
<pre><code>{
  &quot;targets&quot;: [
    {
      &quot;target_name&quot;: &quot;addon&quot;,
      &quot;sources&quot;: [ &quot;addon.cc&quot; ]
    }
  ]
}</code></pre>
<p>In cases where there is more than one <code>.cc</code> file, simply add the file name to
the <code>sources</code> array, e.g.:

</p>
<p>事实上可以有多个  <code>.cc</code> 文件, 就简单的在 <code>sources</code>  数组里加上即可，例子：

</p>
<pre><code>&quot;sources&quot;: [&quot;addon.cc&quot;, &quot;myexample.cc&quot;]</code></pre>
<p>Now that you have your <code>binding.gyp</code> ready, you can configure and build the
addon:

</p>
<p>现在你有了你的<code>binding.gyp</code>文件了，你可要开始执行configure 和 build 命令构建你的addon插件了

</p>
<pre><code>$ node-gyp configure build</code></pre>
<h3>Function arguments（函数参数）<span><a href="all.html#all_function_arguments_1" id="all_function_arguments_1">#</a></span></h3>
<p>The following pattern illustrates how to read arguments from JavaScript
function calls and return a result. This is the main and only needed source
<code>addon.cc</code>:

</p>
<p>下面的部分说明了如何从JavaScript的函数调用获得参数然后返回一个值。这是主要的内容并且仅需要源代码<code>addon.cc</code>。

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>You can test it with the following JavaScript snippet:

</p>
<p>你可以使用下面的JavaScript代码片段来测试它

</p>
<pre><code>console.log( &apos;This should be eight:&apos;, addon.add(3,5) );</code></pre>
<h3>Callbacks（回调）<span><a href="all.html#all_callbacks_1" id="all_callbacks_1">#</a></span></h3>
<p>You can pass JavaScript functions to a C++ function and execute them from
there. Here&apos;s <code>addon.cc</code>:

</p>
<p>你可以传递JavaScript functions 到一个C++ function 并且执行他们，这里是 <code>addon.cc</code>文件:

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>Note that this example uses a two-argument form of <code>Init()</code> that receives
the full <code>module</code> object as the second argument. This allows the addon
to completely overwrite <code>exports</code> with a single function instead of
adding the function as a property of <code>exports</code>.

</p>
<p>注意这个例子对<code>Init()</code>使用了两个参数，将完整的 <code>module</code> 对象作为第二个参数传入。这允许addon插件完全的重写 <code>exports</code>，这样就可以用一个函数代替多个函数作为<code>exports</code>的属性了。

</p>
<p>To test it run the following JavaScript snippet:

</p>
<p>你可以使用下面的JavaScript代码片段来测试它

</p>
<pre><code>addon(function(msg){
  console.log(msg); // &apos;hello world&apos;
});</code></pre>
<h3>Object factory（对象工厂）<span><a href="all.html#all_object_factory_1" id="all_object_factory_1">#</a></span></h3>
<p>You can create and return new objects from within a C++ function with this
<code>addon.cc</code> pattern, which returns an object with property <code>msg</code> that echoes
the string passed to <code>createObject()</code>:

</p>
<p>在这个<code>addon.cc</code>文件里用一个c++函数，你可以创建并且返回一个新的对象，这个新的对象拥有一个msg的属性，它的值是通过createObject()方法传入的

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>To test it in JavaScript:

</p>
<p>在js中测试如下:

</p>
<pre><code>var obj1 = addon(&apos;hello&apos;);
var obj2 = addon(&apos;world&apos;);
console.log(obj1.msg+&apos; &apos;+obj2.msg); // &apos;hello world&apos;</code></pre>
<h3>Function factory（函数工厂）<span><a href="all.html#all_function_factory_1" id="all_function_factory_1">#</a></span></h3>
<p>This pattern illustrates how to create and return a JavaScript function that
wraps a C++ function:

</p>
<p>这次将展示如何创建并返回一个JavaScript function函数，这个函数其实是通过c++包装的。

</p>
<pre><code>NODE_MODULE(addon, Init)</code></pre>
<p>To test:

</p>
<p>测试它:

</p>
<pre><code>var fn = addon();
console.log(fn()); // &apos;hello world&apos;</code></pre>
<h3>Wrapping C++ objects（包装c++对象）<span><a href="all.html#all_wrapping_c_objects_c_1" id="all_wrapping_c_objects_c_1">#</a></span></h3>
<p>Here we will create a wrapper for a C++ object/class <code>MyObject</code> that can be
instantiated in JavaScript through the <code>new</code> operator. First prepare the main
module <code>addon.cc</code>:

</p>
<p>这里将创建一个被c++包裹的对象或类<code>MyObject</code>，它是可以在JavaScript中通过<code>new</code>操作符实例化的。
首先我们要准备主要的模块文件<code>addon.cc</code>:

</p>
<pre><code>NODE_MODULE(addon, InitAll)</code></pre>
<p>Then in <code>myobject.h</code> make your wrapper inherit from <code>node::ObjectWrap</code>:

</p>
<p>然后在<code>myobject.h</code>文件中创建你的包装类，它继承自 <code>node::ObjectWrap</code>:

</p>
<pre><code>#endif</code></pre>
<p>And in <code>myobject.cc</code> implement the various methods that you want to expose.
Here we expose the method <code>plusOne</code> by adding it to the constructor&apos;s
prototype:

</p>
<p>在文件 <code>myobject.cc</code> 可以实施各种你想要暴露给js的方法。 
这里我们暴露方法名为 <code>plusOne</code>给就是，它表示将构造函数的属性加1.

</p>
<pre><code>  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<p>Test it with:

</p>
<p>测试它:

</p>
<pre><code>var obj = new addon.MyObject(10);
console.log( obj.plusOne() ); // 11
console.log( obj.plusOne() ); // 12
console.log( obj.plusOne() ); // 13</code></pre>
<h3>Factory of wrapped objects（工厂包装对象）<span><a href="all.html#all_factory_of_wrapped_objects_1" id="all_factory_of_wrapped_objects_1">#</a></span></h3>
<p>This is useful when you want to be able to create native objects without
explicitly instantiating them with the <code>new</code> operator in JavaScript, e.g.

</p>
<p>这是非常有用的，当你想创建原生的JavaScript对象时，又不想明确的使用JavaScript的<code>new</code>操作符。

</p>
<pre><code>var obj = addon.createObject();
// 用上面的方式代替下面的:
// var obj = new addon.Object();</code></pre>
<p>Let&apos;s register our <code>createObject</code> method in <code>addon.cc</code>:

</p>
<p>让我们注册在 <code>addon.cc</code> 文件中注册<code>createObject</code>方法:

</p>
<pre><code>NODE_MODULE(addon, InitAll)</code></pre>
<p>In <code>myobject.h</code> we now introduce the static method <code>NewInstance</code> that takes
care of instantiating the object (i.e. it does the job of <code>new</code> in JavaScript):

</p>
<p>在<code>myobject.h</code>文件中，我们现在介绍静态方法NewInstance<code>，它能够实例化对象（举个例子，它的工作就像是 在JavaScript中的</code>new` 操作符。）

</p>
<pre><code>#endif</code></pre>
<p>The implementation is similar to the above in <code>myobject.cc</code>:

</p>
<p>这里的处理方式和上面的 <code>myobject.cc</code>很像:

</p>
<pre><code>  return scope.Close(Number::New(obj-&gt;counter_));
}</code></pre>
<p>Test it with:

</p>
<p>测试它:

</p>
<pre><code>var obj2 = createObject(20);
console.log( obj2.plusOne() ); // 21
console.log( obj2.plusOne() ); // 22
console.log( obj2.plusOne() ); // 23</code></pre>
<h3>Passing wrapped objects around（传递包装的对象）<span><a href="all.html#all_passing_wrapped_objects_around_1" id="all_passing_wrapped_objects_around_1">#</a></span></h3>
<p>In addition to wrapping and returning C++ objects, you can pass them around
by unwrapping them with Node&apos;s <code>node::ObjectWrap::Unwrap</code> helper function.
In the following <code>addon.cc</code> we introduce a function <code>add()</code> that can take on two
<code>MyObject</code> objects:

</p>
<p>除了包装和返回c++对象以外，你可以传递他们并且通过Node的<code>node::ObjectWrap::Unwrap</code>帮助函数解包装他们。
在下面的<code>addon.cc</code> 文件中，我们介绍了一个函数<code>add()</code>，它能够获取2个<code>MyObject</code>对象。

</p>
<pre><code>NODE_MODULE(addon, InitAll)</code></pre>
<p>To make things interesting we introduce a public method in <code>myobject.h</code> so we
can probe private values after unwrapping the object:

</p>
<p>为了使事情变得有趣，我们在 <code>myobject.h</code> 采用一个公共的方法，所以我们能够在unwrapping解包装对象之后使用私有成员的值。

</p>
<pre><code>#endif</code></pre>
<p>The implementation of <code>myobject.cc</code> is similar as before:

</p>
<p><code>myobject.cc</code>文件的处理方式和前面类似

</p>
<pre><code>  return scope.Close(instance);
}</code></pre>
<p>Test it with:

</p>
<p>测试它:

</p>
<pre><code>var obj1 = addon.createObject(10);
var obj2 = addon.createObject(20);
var result = addon.add(obj1, obj2);

console.log(result); // 30


console.log(result); // 30</code></pre>
<h1>process<span><a href="all.html#all_process_3" id="all_process_3">#</a></span></h1>
<!-- type=global -->

<p>The <code>process</code> object is a global object and can be accessed from anywhere.
It is an instance of <a href="events.html#events_class_events_eventemitter">EventEmitter</a>.

</p>
<p><code>process</code>对象是一个全局对象，可以在任何地方访问到它。
它是<a href="events.html#events_class_events_eventemitter">EventEmitter</a>的一个实例。

</p>
<h2>Exit Codes<span><a href="all.html#all_exit_codes_1" id="all_exit_codes_1">#</a></span></h2>
<p>Node will normally exit with a <code>0</code> status code when no more async
operations are pending.  The following status codes are used in other
cases:

</p>
<p>Node 执行程序正常情况下会返回 0，这也意味着，包括所有“异步”在内的操作都已结束。（笔者注：linux terminal 下使用 echo $? 查看，win cmd 下使用 echo %ERRORLEVEL% 查看）除此之外的其他返回状态如下：

</p>
<ul>
<li><code>1</code> <strong>Uncaught Fatal Exception</strong> - There was an uncaught exception,
and it was not handled by a domain or an <code>uncaughtException</code> event
handler.</li>
<li><code>2</code> - Unused (reserved by Bash for builtin misuse)</li>
<li><code>3</code> <strong>Internal JavaScript Parse Error</strong> - The JavaScript source code
internal in Node&apos;s bootstrapping process caused a parse error.  This
is extremely rare, and generally can only happen during development
of Node itself.</li>
<li><code>4</code> <strong>Internal JavaScript Evaluation Failure</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process failed to
return a function value when evaluated.  This is extremely rare, and
generally can only happen during development of Node itself.</li>
<li><code>5</code> <strong>Fatal Error</strong> - There was a fatal unrecoverable error in V8.
Typically a message will be printed to stderr with the prefix <code>FATAL
ERROR</code>.</li>
<li><code>6</code> <strong>Non-function Internal Exception Handler</strong> - There was an
uncaught exception, but the internal fatal exception handler
function was somehow set to a non-function, and could not be called.</li>
<li><code>7</code> <strong>Internal Exception Handler Run-Time Failure</strong> - There was an
uncaught exception, and the internal fatal exception handler
function itself threw an error while attempting to handle it.  This
can happen, for example, if a <code>process.on(&apos;uncaughtException&apos;)</code> or
<code>domain.on(&apos;error&apos;)</code> handler throws an error.</li>
<li><code>8</code> - Unused.  In previous versions of Node, exit code 8 sometimes
indicated an uncaught exception.</li>
<li><code>9</code> - <strong>Invalid Argument</strong> - Either an unknown option was specified,
or an option requiring a value was provided without a value.</li>
<li><code>10</code> <strong>Internal JavaScript Run-Time Failure</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process threw an error
when the bootstrapping function was called.  This is extremely rare,
and generally can only happen during development of Node itself.</li>
<li><code>12</code> <strong>Invalid Debug Argument</strong> - The <code>--debug</code> and/or <code>--debug-brk</code>
options were set, but an invalid port number was chosen.</li>
<li><p><code>&gt;128</code> <strong>Signal Exits</strong> - If Node receives a fatal signal such as
<code>SIGKILL</code> or <code>SIGHUP</code>, then its exit code will be <code>128</code> plus the
value of the signal code.  This is a standard Unix practice, since
exit codes are defined to be 7-bit integers, and signal exits set
the high-order bit, and then contain the value of the signal code.</p>
</li>
<li><p><code>1</code> <strong>未捕获的致命异常(Uncaught Fatal Exception)</strong> - There was an uncaught exception,
and it was not handled by a domain or an <code>uncaughtException</code> event
handler.</p>
</li>
<li><code>2</code> - 未使用(Unused) (reserved by Bash for builtin misuse)</li>
<li><code>3</code> <strong>解析错误(Internal JavaScript Parse Error)</strong> - The JavaScript source code
internal in Node&apos;s bootstrapping process caused a parse error.  This
is extremely rare, and generally can only happen during development
of Node itself.</li>
<li><code>4</code> <strong>评估失败(Internal JavaScript Evaluation Failure)</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process failed to
return a function value when evaluated.  This is extremely rare, and
generally can only happen during development of Node itself.</li>
<li><code>5</code> <strong>致命错误(Fatal Error)</strong> - There was a fatal unrecoverable error in V8.
Typically a message will be printed to stderr with the prefix <code>FATAL
ERROR</code>.</li>
<li><code>6</code> <strong>未正确的异常处理(Non-function Internal Exception Handler)</strong> - There was an
uncaught exception, but the internal fatal exception handler
function was somehow set to a non-function, and could not be called.</li>
<li><code>7</code> <strong>异常处理函数运行时失败(Internal Exception Handler Run-Time Failure)</strong> - There was an
uncaught exception, and the internal fatal exception handler
function itself threw an error while attempting to handle it.  This
can happen, for example, if a <code>process.on(&apos;uncaughtException&apos;)</code> or
<code>domain.on(&apos;error&apos;)</code> handler throws an error.</li>
<li><code>8</code> - 未使用(Unused).  In previous versions of Node, exit code 8 sometimes
indicated an uncaught exception.</li>
<li><code>9</code> - <strong>无效的参数(Invalid Argument)</strong> - Either an unknown option was specified,
or an option requiring a value was provided without a value.</li>
<li><code>10</code> <strong>运行时失败(Internal JavaScript Run-Time Failure)</strong> - The JavaScript
source code internal in Node&apos;s bootstrapping process threw an error
when the bootstrapping function was called.  This is extremely rare,
and generally can only happen during development of Node itself.</li>
<li><code>12</code> <strong>无效的调试参数(Invalid Debug Argument)</strong> - The <code>--debug</code> and/or <code>--debug-brk</code>
options were set, but an invalid port number was chosen.</li>
<li><code>&gt;128</code> <strong>信号退出(Signal Exits)</strong> - If Node receives a fatal signal such as
<code>SIGKILL</code> or <code>SIGHUP</code>, then its exit code will be <code>128</code> plus the
value of the signal code.  This is a standard Unix practice, since
exit codes are defined to be 7-bit integers, and signal exits set
the high-order bit, and then contain the value of the signal code.</li>
</ul>
<h2>事件: &apos;exit&apos;<span><a href="all.html#all_exit_5" id="all_exit_5">#</a></span></h2>
<p>Emitted when the process is about to exit.  This is a good hook to perform
constant time checks of the module&apos;s state (like for unit tests).  The main
event loop will no longer be run after the &apos;exit&apos; callback finishes, so
timers may not be scheduled.

</p>
<p>当进程将要退出时触发。这是一个在固定时间检查模块状态（如单元测试）的好时机。需要注意的是 &apos;exit&apos; 的回调结束后，主事件循环将不再运行，所以计时器也会失效。

</p>
<p>Example of listening for <code>exit</code>:

</p>
<p>监听 <code>exit</code> 事件的例子：

</p>
<pre><code>process.on(&apos;exit&apos;, function() {
  // 设置一个延迟执行
  setTimeout(function() {
    console.log(&apos;主事件循环已停止，所以不会执行&apos;);
  }, 0);
  console.log(&apos;退出前执行&apos;);
});</code></pre>
<h2>事件: &apos;uncaughtException&apos;（未捕获错误）<span><a href="all.html#all_uncaughtexception_1" id="all_uncaughtexception_1">#</a></span></h2>
<p>Emitted when an exception bubbles all the way back to the event loop. If a
listener is added for this exception, the default action (which is to print
a stack trace and exit) will not occur.

</p>
<p>当一个异常冒泡回归到事件循环中就会触发这个事件，如果建立了一个监听器来监听这个异常，默认的行为（打印堆栈跟踪信息并退出）就不会发生。

</p>
<p>Example of listening for <code>uncaughtException</code>:

</p>
<p>监听 <code>uncaughtException</code> 示例:

</p>
<pre><code>// 故意制造一个异常，而且不catch捕获它.
nonexistentFunc();
console.log(&apos;This will not run.&apos;);</code></pre>
<p>Note that <code>uncaughtException</code> is a very crude mechanism for exception
handling.

</p>
<p>注意，<code>uncaughtException</code>未捕获异常是一个非常粗略的异常处理。

</p>
<p>Don&apos;t use it, use <a href="domain.html">domains</a> instead. If you do use it, restart
your application after every unhandled exception!

</p>
<p>尽量不要使用它，使用 <a href="domain.html">domains</a> 来代替它，如果你已经使用了，请在不处理这个异常之后重启你的应用。

</p>
<p>Do <em>not</em> use it as the node.js equivalent of <code>On Error Resume Next</code>. An
unhandled exception means your application - and by extension node.js itself -
is in an undefined state. Blindly resuming means <em>anything</em> could happen.

</p>
<p>请 <em>不要</em> 象使用node.js的<code>有错误回复执行</code>这样使用.一个未处理异常意味着你的应用和你的扩展Node.js自身是有未知状态的。盲目的恢复意味着<em>任何事情</em>都可能发生。

</p>
<p>Think of resuming as pulling the power cord when you are upgrading your system.
Nine out of ten times nothing happens - but the 10th time, your system is bust.

</p>
<p>你在升级的系统时拉掉了电源线，然后恢复了。可能10次里有9次每一偶问题，但是第10次，你的系统就会崩溃。

</p>
<p>You have been warned.

</p>
<p>你已经被警告。

</p>
<h2>Signal Events<span><a href="all.html#all_signal_events_1" id="all_signal_events_1">#</a></span></h2>
<!--type=event-->
<!--name=SIGINT, SIGUSR1, etc.-->

<!--type=event-->
<!--name=SIGINT, SIGUSR1, etc.-->

<p>Emitted when the processes receives a signal. See sigaction(2) for a list of
standard POSIX signal names such as SIGINT, SIGUSR1, etc.

</p>
<p>当进程接收到信号时触发。信号列表详见 POSIX 标准的 sigaction（2）如 SIGINT、SIGUSR1 等。

</p>
<p>Example of listening for <code>SIGINT</code>:

</p>
<p>监听 <code>SIGINT</code> 信号的示例：

</p>
<pre><code>// 设置 &apos;SIGINT&apos; 信号触发事件
process.on(&apos;SIGINT&apos;, function() {
  console.log(&apos;收到 SIGINT 信号。  退出请使用 Ctrl + D &apos;);
});</code></pre>
<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal
programs.

</p>
<p>在大多数终端下，一个发送 <code>SIGINT</code> 信号的简单方法是按下 <code>ctrl + c</code> 。

</p>
<h2>process.stdout<span><a href="all.html#all_process_stdout_1" id="all_process_stdout_1">#</a></span></h2>
<p>A <code>Writable Stream</code> to <code>stdout</code>.

</p>
<p>一个指向<code>标准输出流(stdout)</code>的 <code>可写的流(Writable Stream)</code>。

</p>
<p>Example: the definition of <code>console.log</code>

</p>
<p>举例: <code>console.log</code> 的实现

</p>
<pre><code>console.log = function(d) {
  process.stdout.write(d + &apos;\n&apos;);
}; </code></pre>
<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.

</p>
<p>process.stderr 和 process.stdout 不像 Node 中其他的流(Streams) 那样，他们通常是阻塞式的写入。当其引用指向 <code>普通文件</code> 或者 <code>TTY文件描述符</code> 时他们就是阻塞的（注：TTY 可以理解为终端的一种，可联想 PuTTY，详见<a href="http://baike.baidu.com/view/749979.htm">百科</a>）。当他们引用指向管道(pipes)时，他们就同其他的流(Streams)一样是非阻塞的。

</p>
<p>To check if Node is being run in a TTY context, read the <code>isTTY</code> property
on <code>process.stderr</code>, <code>process.stdout</code>, or <code>process.stdin</code>:

</p>
<p>要检查 Node 是否正在运行一个 TTY上下文 中（注：linux 中没有运行在 tty 下的进程是 <code>守护进程</code> ），可以用使用 process.stderr、process.stdout 或 process.stdin 的 isTTY 属性：

</p>
<pre><code>$ node -p &quot;Boolean(process.stdout.isTTY)&quot;
true
$ node -p &quot;Boolean(process.stdout.isTTY)&quot; | cat
false </code></pre>
<p>See <a href="tty.html#tty_tty">the tty docs</a> for more information.

</p>
<p>更多信息，请查看 <a href="tty.html#tty_tty">tty 文档</a>。

</p>
<h2>process.stderr<span><a href="all.html#all_process_stderr_1" id="all_process_stderr_1">#</a></span></h2>
<p>A writable stream to stderr.

</p>
<p>一个指向标准错误流(stderr)的 可写的流(Writable Stream)。

</p>
<p><code>process.stderr</code> and <code>process.stdout</code> are unlike other streams in Node in
that writes to them are usually blocking.  They are blocking in the case
that they refer to regular files or TTY file descriptors. In the case they
refer to pipes, they are non-blocking like other streams.

</p>
<p>process.stderr 和 process.stdout 不像 Node 中其他的流(Streams) 那样，他们通常是阻塞式的写入。当其引用指向 <code>普通文件</code> 或者 <code>TTY文件描述符</code> 时他们就是阻塞的（注：TTY 可以理解为终端的一种，可联想 PuTTY，详见<a href="http://baike.baidu.com/view/749979.htm">百科</a>）。当他们引用指向管道(pipes)时，他们就同其他的流(Streams)一样是非阻塞的。

</p>
<h2>process.stdin<span><a href="all.html#all_process_stdin_1" id="all_process_stdin_1">#</a></span></h2>
<p>A <code>Readable Stream</code> for stdin. The stdin stream is paused by default, so one
must call <code>process.stdin.resume()</code> to read from it.

</p>
<p>一个指向 标准输入流(stdin) 的可读流(Readable Stream)。标准输入流默认是暂停 (pause) 的，所以必须要调用 process.stdin.resume() 来恢复 (resume) 接收。

</p>
<p>Example of opening standard input and listening for both events:

</p>
<p>打开标准输入流，并监听两个事件的示例：

</p>
<pre><code>process.stdin.on(&apos;end&apos;, function() {
  process.stdout.write(&apos;end&apos;);
});


// gets 函数的简单实现
function gets(cb){
  process.stdin.resume();
  process.stdin.setEncoding(&apos;utf8&apos;);

  process.stdin.on(&apos;data&apos;, function(chunk) {
     process.stdin.pause();
     cb(chunk);
  });
}

gets(function(reuslt){
  console.log(&quot;[&quot;+reuslt+&quot;]&quot;);
});</code></pre>
<h2>process.argv<span><a href="all.html#all_process_argv_1" id="all_process_argv_1">#</a></span></h2>
<p>An array containing the command line arguments.  The first element will be
&apos;node&apos;, the second element will be the name of the JavaScript file.  The
next elements will be any additional command line arguments.

</p>
<p>一个包含命令行参数的数组。第一个元素会是 &apos;node&apos;， 第二个元素将是 .Js 文件的名称。接下来的元素依次是命令行传入的参数。

</p>
<pre><code>// 打印 process.argv
process.argv.forEach(function(val, index, array) {
  console.log(index + &apos;: &apos; + val);
});</code></pre>
<p>This will generate:

</p>
<p>输出将会是：

</p>
<pre><code>$ node process-2.js one two=three four
0: node
1: /Users/mjr/work/node/process-2.js
2: one
3: two=three
4: four </code></pre>
<h2>process.execPath<span><a href="all.html#all_process_execpath_1" id="all_process_execpath_1">#</a></span></h2>
<p>This is the absolute pathname of the executable that started the process.

</p>
<p>开启当前进程的这个可执行文件的绝对路径。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>/usr/local/bin/node </code></pre>
<h2>process.execArgv<span><a href="all.html#all_process_execargv_1" id="all_process_execargv_1">#</a></span></h2>
<p>This is the set of node-specific command line options from the
executable that started the process.  These options do not show up in
<code>process.argv</code>, and do not include the node executable, the name of
the script, or any options following the script name. These options
are useful in order to spawn child processes with the same execution
environment as the parent.

</p>
<p>与 <code>process.argv</code> 类似，不过是用于保存 node特殊(node-specific) 的命令行选项（参数）。这些特殊的选项不会出现在 <code>process.argv</code> 中，而且 process.execArgv 不会保存 <code>process.argv</code> 中保存的参数（如 0:node 1:文件名 2.3.4.参数 等），
所有文件名之后的参数都会被忽视。这些选项可以用于派生与与父进程相同执行环境的子进程。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>$ node --harmony script.js --version </code></pre>
<p>results in process.execArgv:

</p>
<p>process.execArgv 中的特殊选项:

</p>
<pre><code>[&apos;--harmony&apos;] </code></pre>
<p>and process.argv:

</p>
<p>process.argv 接收到的参数:

</p>
<pre><code>[&apos;/usr/local/bin/node&apos;, &apos;script.js&apos;, &apos;--version&apos;] </code></pre>
<h2>process.abort()<span><a href="all.html#all_process_abort_1" id="all_process_abort_1">#</a></span></h2>
<p>This causes node to emit an abort. This will cause node to exit and
generate a core file.

</p>
<p>这将导致 Node 触发一个abort事件，这会导致Node退出并且创建一个核心文件。

</p>
<h2>process.chdir(directory)<span><a href="all.html#all_process_chdir_directory_1" id="all_process_chdir_directory_1">#</a></span></h2>
<p>Changes the current working directory of the process or throws an exception if that fails.

</p>
<p>改变进程的当前进程的工作目录，若操作失败则抛出异常。 

</p>
<pre><code>console.log(&apos;当前目录：&apos; + process.cwd());
try {
  process.chdir(&apos;/tmp&apos;);
  console.log(&apos;新目录：&apos; + process.cwd());
}
catch (err) {
  console.log(&apos;chdir: &apos; + err);
}</code></pre>
<h2>process.cwd()<span><a href="all.html#all_process_cwd_1" id="all_process_cwd_1">#</a></span></h2>
<p>Returns the current working directory of the process.

</p>
<p>返回进程当前的工作目录。 

</p>
<pre><code>console.log(&apos;当前目录：&apos; + process.cwd());</code></pre>
<h2>process.env<span><a href="all.html#all_process_env_1" id="all_process_env_1">#</a></span></h2>
<p>An object containing the user environment. See environ(7).

</p>
<p>一个包括用户环境的对象。详细参见 environ(7)。

</p>
<h2>process.exit([code])<span><a href="all.html#all_process_exit_code_1" id="all_process_exit_code_1">#</a></span></h2>
<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the
&apos;success&apos; code <code>0</code>.

</p>
<p>终止当前进程并返回给定的 <code>code</code>。如果省略了 <code>code</code>，退出是会默认返回成功的状态码(&apos;success&apos; code) 也就是 <code>0</code>。

</p>
<p>To exit with a &apos;failure&apos; code:

</p>
<p>退出并返回失败的状态 (&apos;failure&apos; code):

</p>
<pre><code>process.exit(1); </code></pre>
<p>The shell that executed node should see the exit code as 1.

</p>
<p>执行上述代码，用来执行 node 的 shell 就能收到值为 1 的 exit code

</p>
<h2>process.exitCode<span><a href="all.html#all_process_exitcode_1" id="all_process_exitcode_1">#</a></span></h2>
<p>A number which will be the process exit code, when the process either
exits gracefully, or is exited via <code>process.exit()</code> without specifying
a code.

</p>
<p>当进程既正常退出，或者通过未指定 code 的 <code>process.exit()</code> 退出时，这个属性中所存储的数字将会成为进程退出的错误码 (exit code)。

</p>
<p>Specifying a code to <code>process.exit(code)</code> will override any previous
setting of <code>process.exitCode</code>.

</p>
<p>如果指名了 <code>process.exit(code)</code> 中退出的错误码 (code)，则会覆盖掉 <code>process.exitCode</code> 的设置。

</p>
<h2>process.getgid()<span><a href="all.html#all_process_getgid_1" id="all_process_getgid_1">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Gets the group identity of the process. (See getgid(2).)
This is the numerical group id, not the group name.

</p>
<p>获取进程的群组标识（详见getgid(2)）。获取到的是群组的数字ID，不是群组名称。

</p>
<pre><code>if (process.getgid) {
  console.log(&apos;当前 gid: &apos; + process.getgid());
}</code></pre>
<h2>process.setgid(id)<span><a href="all.html#all_process_setgid_id_1" id="all_process_setgid_id_1">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Sets the group identity of the process. (See setgid(2).)  This accepts either
a numerical ID or a groupname string. If a groupname is specified, this method
blocks while resolving it to a numerical ID.

</p>
<p>设置进程的群组标识（详见getgid(2)）。参数可以是一个数字ID或者群组名字符串。如果指定了一个群组名，这个方法会阻塞等待将群组名解析为数字ID。 

</p>
<pre><code>if (process.getgid &amp;&amp; process.setgid) {
  console.log(&apos;当前 gid: &apos; + process.getgid());
  try {
    process.setgid(501);
    console.log(&apos;新 gid: &apos; + process.getgid());
  }
  catch (err) {
    console.log(&apos;设置 gid 失败: &apos; + err);
  }
}</code></pre>
<h2>process.getuid()<span><a href="all.html#all_process_getuid_1" id="all_process_getuid_1">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Gets the user identity of the process. (See getuid(2).)
This is the numerical userid, not the username.

</p>
<p>获取执行进程的用户ID（详见getgid(2)）。这是用户的数字ID，不是用户名。

</p>
<pre><code>if (process.getuid) {
  console.log(&apos;当前 uid: &apos; + process.getuid());
}</code></pre>
<h2>process.setuid(id)<span><a href="all.html#all_process_setuid_id_1" id="all_process_setuid_id_1">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Sets the user identity of the process. (See setuid(2).)  This accepts either
a numerical ID or a username string.  If a username is specified, this method
blocks while resolving it to a numerical ID.

</p>
<p>设置执行进程的用户ID（详见getgid(2)）。参数可以使一个数字ID或者用户名字符串。如果指定了一个用户名，那么该方法会阻塞等待将用户名解析为数字ID。

</p>
<pre><code>if (process.getuid &amp;&amp; process.setuid) {
  console.log(&apos;当前 uid: &apos; + process.getuid());
  try {
    process.setuid(501);
    console.log(&apos;新 uid: &apos; + process.getuid());
  }
  catch (err) {
    console.log(&apos;设置 uid 失败: &apos; + err);
  }
}</code></pre>
<h2>process.getgroups()<span><a href="all.html#all_process_getgroups_1" id="all_process_getgroups_1">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Returns an array with the supplementary group IDs. POSIX leaves it unspecified
if the effective group ID is included but node.js ensures it always is.

</p>
<p>返回一个保存补充组ID(supplementary group ID)的数组。POSIX 标准没有指名 如果有效组 ID（effective group ID）被包括在内的情况，而在 node.js 中则确保它始终是。（POSIX leaves it unspecified if the effective group ID is included but node.js ensures it always is.  ）

</p>
<h2>process.setgroups(groups)<span><a href="all.html#all_process_setgroups_groups_1" id="all_process_setgroups_groups_1">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Sets the supplementary group IDs. This is a privileged operation, meaning you
need to be root or have the CAP_SETGID capability.

</p>
<p>设置补充分组的ID标识. 这是一个特殊的操作, 意味着你必须拥有root或者CAP_SETGID权限才可以。（译者：CAP_SETGID表示设定程序允许普通用户使用setgid函数,这与文件的setgid权限位无关）

</p>
<p>The list can contain group IDs, group names or both.

</p>
<p>这个列表可以包括分组的ID表示，或分组名或两者都有。

</p>
<h2>process.initgroups(user, extra_group)<span><a href="all.html#all_process_initgroups_user_extra_group_1" id="all_process_initgroups_user_extra_group_1">#</a></span></h2>
<p>Note: this function is only available on POSIX platforms (i.e. not Windows,
Android)

</p>
<p>注意： 该函数仅适用于遵循 POSIX 标准的系统平台如 Unix、Linux等  而 Windows、
Android 等则不适用。

</p>
<p>Reads /etc/group and initializes the group access list, using all groups of
which the user is a member. This is a privileged operation, meaning you need
to be root or have the CAP_SETGID capability.

</p>
<p>读取 /etc/group 并且初始化group分组访问列表，使用改成员所在的所有分组， 这是一个特殊的操作, 意味着你必须拥有root或者CAP_SETGID权限才可以。

</p>
<p><code>user</code> is a user name or user ID. <code>extra_group</code> is a group name or group ID.

</p>
<p><code>user</code> 是一个用户名或者用户ID. <code>extra_group</code>是分组的组名或者分组ID。

</p>
<p>Some care needs to be taken when dropping privileges. Example:

</p>
<p>有时候，当你在注销权限 (dropping privileges) 的时候需要注意。例如： 

</p>
<pre><code>console.log(process.getgroups());         // [ 0 ]
process.initgroups(&apos;bnoordhuis&apos;, 1000);   // switch user
console.log(process.getgroups());         // [ 27, 30, 46, 1000, 0 ]
process.setgid(1000);                     // drop root gid
console.log(process.getgroups());         // [ 27, 30, 46, 1000 ]</code></pre>
<h2>process.version<span><a href="all.html#all_process_version_1" id="all_process_version_1">#</a></span></h2>
<p>A compiled-in property that exposes <code>NODE_VERSION</code>.

</p>
<p>一个暴露编译时存储版本信息的内置变量 <code>NODE_VERSION</code> 的属性。

</p>
<pre><code>console.log(&apos;版本: &apos; + process.version);</code></pre>
<h2>process.versions<span><a href="all.html#all_process_versions_1" id="all_process_versions_1">#</a></span></h2>
<p>A property exposing version strings of node and its dependencies.

</p>
<p>一个暴露存储 node 以及其依赖包 版本信息的属性。

</p>
<pre><code>console.log(process.versions); </code></pre>
<p>Will print something like:

</p>
<p>输出：

</p>
<pre><code>{ http_parser: &apos;1.0&apos;,
  node: &apos;0.10.4&apos;,
  v8: &apos;3.14.5.8&apos;,
  ares: &apos;1.9.0-DEV&apos;,
  uv: &apos;0.10.3&apos;,
  zlib: &apos;1.2.3&apos;,
  modules: &apos;11&apos;,
  openssl: &apos;1.0.1e&apos; }</code></pre>
<h2>process.config<span><a href="all.html#all_process_config_1" id="all_process_config_1">#</a></span></h2>
<p>An Object containing the JavaScript representation of the configure options
that were used to compile the current node executable. This is the same as
the &quot;config.gypi&quot; file that was produced when running the <code>./configure</code> script.

</p>
<p>一个包含用来编译当前 node.exe 的配置选项的对象。内容与运行 <code>./configure</code> 脚本生成的 &quot;config.gypi&quot; 文件相同。

</p>
<p>An example of the possible output looks like:

</p>
<p>最可能的输出示例如下：

</p>
<pre><code>{ target_defaults:
   { cflags: [],
     default_configuration: &apos;Release&apos;,
     defines: [],
     include_dirs: [],
     libraries: [] },
  variables:
   { host_arch: &apos;x64&apos;,
     node_install_npm: &apos;true&apos;,
     node_prefix: &apos;&apos;,
     node_shared_cares: &apos;false&apos;,
     node_shared_http_parser: &apos;false&apos;,
     node_shared_libuv: &apos;false&apos;,
     node_shared_v8: &apos;false&apos;,
     node_shared_zlib: &apos;false&apos;,
     node_use_dtrace: &apos;false&apos;,
     node_use_openssl: &apos;true&apos;,
     node_shared_openssl: &apos;false&apos;,
     strict_aliasing: &apos;true&apos;,
     target_arch: &apos;x64&apos;,
     v8_use_snapshot: &apos;true&apos; } }</code></pre>
<h2>process.kill(pid, [signal])<span><a href="all.html#all_process_kill_pid_signal_1" id="all_process_kill_pid_signal_1">#</a></span></h2>
<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the
string describing the signal to send.  Signal names are strings like
&apos;SIGINT&apos; or &apos;SIGUSR1&apos;.  If omitted, the signal will be &apos;SIGTERM&apos;.
See kill(2) for more information.

</p>
<p>向进程发送一个信号。 <code>pid</code> 是进程的 id 而 <code>signal</code> 则是描述信号的字符串名称。信号的名称都形似 &apos;SIGINT&apos; 或者 &apos;SIGUSR1&apos;。如果没有指定参数则会默认发送 &apos;SIGTERM&apos; 信号，更多信息请查看 kill(2) 。

</p>
<p>Note that just because the name of this function is <code>process.kill</code>, it is
really just a signal sender, like the <code>kill</code> system call.  The signal sent
may do something other than kill the target process.

</p>
<p>值得注意的是，这个函数的名称虽然是 <code>process.kill</code>， 但就像 <code>kill</code> 系统调用（详见《Unix高级编程》）一样，它仅仅只是一个信号发送器。而信号的发送不仅仅只是用来杀死（kill）目标进程。

</p>
<p>Example of sending a signal to yourself:

</p>
<p>向当前进程发送信号的示例：

</p>
<pre><code>process.kill(process.pid, &apos;SIGHUP&apos;); </code></pre>
<h2>process.pid<span><a href="all.html#all_process_pid_1" id="all_process_pid_1">#</a></span></h2>
<p>The PID of the process.

</p>
<p>当前进程的 PID 

</p>
<pre><code>console.log(&apos;当前进程 id: &apos; + process.pid);</code></pre>
<h2>process.title<span><a href="all.html#all_process_title_1" id="all_process_title_1">#</a></span></h2>
<p>Getter/setter to set what is displayed in &apos;ps&apos;.

</p>
<p>获取/设置 (Getter/setter) &apos;ps&apos; 中显示的进程名。

</p>
<p>When used as a setter, the maximum length is platform-specific and probably
short.

</p>
<p>当设置该属性时，所能设置的字符串最大长度视具体平台而定，如果超过的话会自动截断。

</p>
<p>On Linux and OS X, it&apos;s limited to the size of the binary name plus the
length of the command line arguments because it overwrites the argv memory.

</p>
<p>在 Linux 和 OS X 上，它受限于名称的字节长度加上命令行参数的长度，因为它有覆盖参数内存(argv memory)。

</p>
<p>v0.8 allowed for longer process title strings by also overwriting the environ
memory but that was potentially insecure/confusing in some (rather obscure)
cases.

</p>
<p>v0.8 版本允许更长的进程标题字符串，也支持覆盖环境内存，但是存在潜在的不安全和混乱（很难说清楚）。

</p>
<h2>process.arch<span><a href="all.html#all_process_arch_1" id="all_process_arch_1">#</a></span></h2>
<p>What processor architecture you&apos;re running on: <code>&apos;arm&apos;</code>, <code>&apos;ia32&apos;</code>, or <code>&apos;x64&apos;</code>.

</p>
<p>返回当前 CPU 处理器的架构：&apos;arm&apos;、&apos;ia32&apos; 或者 &apos;x64&apos;.

</p>
<pre><code>console.log(&apos;当前CPU架构是：&apos; + process.arch);</code></pre>
<h2>process.platform<span><a href="all.html#all_process_platform_1" id="all_process_platform_1">#</a></span></h2>
<p>What platform you&apos;re running on:
<code>&apos;darwin&apos;</code>, <code>&apos;freebsd&apos;</code>, <code>&apos;linux&apos;</code>, <code>&apos;sunos&apos;</code> or <code>&apos;win32&apos;</code>

</p>
<p>返回当前程序运行的平台：<code>&apos;darwin&apos;</code>, <code>&apos;freebsd&apos;</code>, <code>&apos;linux&apos;</code>, <code>&apos;sunos&apos;</code> 或者 <code>&apos;win32&apos;</code>

</p>
<pre><code>console.log(&apos;当前系统平台是： &apos; + process.platform);</code></pre>
<h2>process.memoryUsage()<span><a href="all.html#all_process_memoryusage_1" id="all_process_memoryusage_1">#</a></span></h2>
<p>Returns an object describing the memory usage of the Node process
measured in bytes.

</p>
<p>返回一个对象，它描述了Node进程的内存使用情况单位是bytes。 

</p>
<pre><code>console.log(util.inspect(process.memoryUsage())); </code></pre>
<p>This will generate:

</p>
<p>输出将会是：

</p>
<pre><code>{ rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472 } </code></pre>
<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8&apos;s memory usage.

</p>
<p><code>heapTotal</code> 和 <code>heapUsed</code> 是根据 V8引擎的内存使用情况来的

</p>
<h2>process.nextTick(callback)<span><a href="all.html#all_process_nexttick_callback_1" id="all_process_nexttick_callback_1">#</a></span></h2>
<div><ul>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
</div></ul>
<p>Once the current event loop turn runs to completion, call the callback
function.

</p>
<p>在事件循环的下一次循环中调用 callback 回调函数。

</p>
<p>This is <em>not</em> a simple alias to <code>setTimeout(fn, 0)</code>, it&apos;s much more
efficient.  It runs before any additional I/O events (including
timers) fire in subsequent ticks of the event loop.

</p>
<p>这 <em>不是</em> <code>setTimeout(fn, 0)</code> 函数的一个简单别名，因为它的效率高多了。该函数能在任何 I/O 事前之前调用我们的回调函数。但是这个函数在层次超过某个限制的时候，也会出现瑕疵，详细见 <code>process.maxTickDepth</code>。

</p>
<pre><code>console.log(&apos;开始&apos;);
process.nextTick(function() {
  console.log(&apos;nextTick 回调&apos;);
});
console.log(&apos;已设定&apos;);
// 输出:
// 开始
// 已设定
// nextTick 回调</code></pre>
<p>This is important in developing APIs where you want to give the user the
chance to assign event handlers after an object has been constructed,
but before any I/O has occurred.

</p>
<p>如果你想要在【对象创建】之后而【I/O 操作】发生之前执行某些操作，那么这个函数对你而言就十分重要了。

</p>
<pre><code>// thing.startDoingStuff() 现在被调用了, 而不是之前.</code></pre>
<p>It is very important for APIs to be either 100% synchronous or 100%
asynchronous.  Consider this example:

</p>
<p>【注意！！】保证你的函数一定是同步执行或者一定是异步执行，这非常重要！！参考如下的例子：

</p>
<pre><code>  fs.stat(&apos;file&apos;, cb);
} </code></pre>
<p>This API is hazardous.  If you do this:

</p>
<p>这样执行是很危险。如果你还不清楚上述行为的危害请看下面的例子：

</p>
<pre><code>maybeSync(true, function() {
  foo();
});
bar(); </code></pre>
<p>then it&apos;s not clear whether <code>foo()</code> or <code>bar()</code> will be called first.

</p>
<p>那么，使用刚才那个不知道是同步还是异步的操作，在编程的时候你就会发现，你不能确定到底是 foo() 先执行，还是 bar() 先执行。

</p>
<p>This approach is much better:

</p>
<p>用下面的方法就可以更好的解决：

</p>
<pre><code>  fs.stat(&apos;file&apos;, cb);
} </code></pre>
<p>Note: the nextTick queue is completely drained on each pass of the
event loop <strong>before</strong> additional I/O is processed.  As a result,
recursively setting nextTick callbacks will block any I/O from
happening, just like a <code>while(true);</code> loop.

</p>
<p>注意：nextTick 的队列会在完全执行完毕之后才调用 I/O 操作 (the nextTick queue is completely drained on each pass of the event loop <strong>before</strong> additional I/O is processed.) 。因此，递归设置 nextTick 的回调就像一个 <code>while(true) ;</code> 循环一样，将会阻止任何 I/O 操作的发生。

</p>
<h2>process.umask([mask])<span><a href="all.html#all_process_umask_mask_1" id="all_process_umask_mask_1">#</a></span></h2>
<p>Sets or reads the process&apos;s file mode creation mask. Child processes inherit
the mask from the parent process. Returns the old mask if <code>mask</code> argument is
given, otherwise returns the current mask.

</p>
<p>设置或者读取进程的文件模式的创建掩码。子进程从父进程中继承这个掩码。如果设定了参数 mask 那么返回旧的掩码，否则返回当前的掩码。

</p>
<pre><code>oldmask = process.umask(newmask);
console.log(&apos;原掩码: &apos; + oldmask.toString(8) + &apos;\n&apos;
            &apos;新掩码: &apos; + newmask.toString(8));</code></pre>
<h2>process.uptime()<span><a href="all.html#all_process_uptime_1" id="all_process_uptime_1">#</a></span></h2>
<p>Number of seconds Node has been running.

</p>
<p>返回 Node 程序已运行的秒数。

</p>
<h2>process.hrtime()<span><a href="all.html#all_process_hrtime_1" id="all_process_hrtime_1">#</a></span></h2>
<p>Returns the current high-resolution real time in a <code>[seconds, nanoseconds]</code>
tuple Array. It is relative to an arbitrary time in the past. It is not
related to the time of day and therefore not subject to clock drift. The
primary use is for measuring performance between intervals.

</p>
<p>返回当前的高分辨时间，形式为 <code>[秒，纳秒]</code> 的元组数组。它是相对于在过去的任意时间。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。

</p>
<p>You may pass in the result of a previous call to <code>process.hrtime()</code> to get
a diff reading, useful for benchmarks and measuring intervals:

</p>
<p>你可以将前一个 <code>process.hrtime()</code> 的结果传递给当前的 <code>process.hrtime()</code> 函数，结果会返回一个比较值，用于基准和衡量时间间隔。

</p>
<pre><code>  console.log(&apos;基准相差 %d 纳秒&apos;, diff[0] * 1e9 + diff[1]);
  // 基准相差 1000000527 纳秒
}, 1000);</code></pre>
<h1>utils<span><a href="all.html#all_utils_1" id="all_utils_1">#</a></span></h1>
<pre><code>稳定度: 4 - 冻结</code></pre>
<p>These functions are in the module <code>&apos;util&apos;</code>. Use <code>require(&apos;util&apos;)</code> to
access them.

</p>
<p>如果你想使用模块 <code>&apos;util&apos;</code>中已定义的方法. 只需 <code>require(&apos;util&apos;)</code> 即可使用.

</p>
<p>The <code>util</code> module is primarily designed to support the needs of Node&apos;s
internal APIs.  Many of these utilities are useful for your own
programs.  If you find that these functions are lacking for your
purposes, however, you are encouraged to write your own utilities.  We
are not interested in any future additions to the <code>util</code> module that
are unnecessary for Node&apos;s internal functionality.

</p>
<p><code>util</code>模块设计的主要目的是为了满足Node内部API的需求
。这个模块中的很多方法在你编写Node程序的时候都是很有帮助的。如果你觉得提供的这些方法满足不了你的需求，那么我们鼓励你编写自己的实用工具方法。我们
不希望<code>util</code>模块中添加任何对于Node的内部功能非必要的扩展。

</p>
<h2>util.debuglog(section)<span><a href="all.html#all_util_debuglog_section_1" id="all_util_debuglog_section_1">#</a></span></h2>
<div><ul>
<li><code>section</code> <span>String</span> The section of the program to be debugged</li>
<li><p>Returns: <span>Function</span> The logging function</p>
</li>
<li><p><code>section</code> <span>String</span> 被调试的程序节点部分</p>
</li>
<li>返回值: <span>Function</span> 日志处理函数</li>
</div></ul>
<p>This is used to create a function which conditionally writes to stderr
based on the existence of a <code>NODE_DEBUG</code> environment variable.  If the
<code>section</code> name appears in that environment variable, then the returned
function will be similar to <code>console.error()</code>.  If not, then the
returned function is a no-op.

</p>
<p>这个方法是在存在<code>NODE_DEBUG</code>环境变量的基础上，创建一个有条件写到stderr里的函数。如果“节点”的名字出现在这个环境变量里,那么就返回一个功能类似于<code>console.error()</code>的函数.如果不是,那么返回一个空函数.

</p>
<p>For example:

</p>
<p>例如：

</p>
<p>var bar = 123;
debuglog(&apos;hello from foo [%d]&apos;, bar);
</p>
<pre><code>
If this program is run with `NODE_DEBUG=foo` in the environment, then
it will output something like:

如果这个程序以`NODE_DEBUG=foo` 的环境运行，那么它将会输出：

    FOO 3245: hello from foo [123]

where `3245` is the process id.  If it is not run with that
environment variable set, then it will not print anything.

`3245`是进程的ID, 如果程序不以刚才那样设置的环境变量运行，那么将不会输出任何东西。

You may separate multiple `NODE_DEBUG` environment variables with a
comma.  For example, `NODE_DEBUG=fs,net,tls`.

多个`NODE_DEBUG`环境变量,你可以用逗号进行分割。例如，`NODE_DEBUG= fs, net, tls`。

## util.format(format, [...])

Returns a formatted string using the first argument as a `printf`-like format.

根据第一个参数，返回一个格式化字符串，类似`printf`的格式化输出。

The first argument is a string that contains zero or more *placeholders*.
Each placeholder is replaced with the converted value from its corresponding
argument. Supported placeholders are:

第一个参数是一个字符串，包含零个或多个*占位符*。
每一个占位符被替换为与其对应的转换后的值。
支持的占位符有:

* `%s` - String.
* `%d` - Number (both integer and float).
* `%j` - JSON.  Replaced with the string `&apos;[Circular]&apos;` if the argument
         contains circular references.
* `%%` - single percent sign (`&apos;%&apos;`). This does not consume an argument.

* `%s` - 字符串.
* `%d` - 数字 (整型和浮点型).
* `%j` - JSON. 如果这个参数包含循环对象的引用，将会被替换成字符串 `&apos;[Circular]&apos;`。
* `%%` - 单独一个百分号(`&apos;%&apos;`)。不会消耗一个参数。

If the placeholder does not have a corresponding argument, the placeholder is
not replaced.

如果占位符没有相对应的参数，占位符将不会被替换。

    util.format(&apos;%s:%s&apos;, &apos;foo&apos;); // &apos;foo:%s&apos;

If there are more arguments than placeholders, the extra arguments are
converted to strings with `util.inspect()` and these strings are concatenated,
delimited by a space.

如果有多个参数占位符，额外的参数将会调用`util.inspect()`转换为字符串。这些字符串被连接在一起，并且以空格分隔。

    util.format(&apos;%s:%s&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;); // &apos;foo:bar baz&apos;

If the first argument is not a format string then `util.format()` returns
a string that is the concatenation of all its arguments separated by spaces.
Each argument is converted to a string with `util.inspect()`.

如果第一个参数是一个非格式化字符串，那么`util.format()`将会把所有的参数转成字符串，以空格隔开，拼接在一块，并返回该字符串。`util.inspect()`会把每个参数都转成一个字符串。

    util.format(1, 2, 3); // &apos;1 2 3&apos;

## util.log(string)

Output with timestamp on `stdout`.

在控制台进行输出，并带有时间戳。

    示例：require(&apos;util&apos;).log(&apos;Timestamped message.&apos;);

## util.inspect(object, [options])

Return a string representation of `object`, which is useful for debugging.

返回一个对象的字符串表现形式, 在代码调试的时候非常有用.

An optional *options* object may be passed that alters certain aspects of the
formatted string:

可以通过加入一些可选选项，来改变对象的格式化输出形式：

 - `showHidden` - if `true` then the object&apos;s non-enumerable properties will be
   shown too. Defaults to `false`.

 - `showHidden` - 如果设为 `true`，那么该对象的不可枚举的属性将会被显示出来。默认为`false`.

 - `depth` - tells `inspect` how many times to recurse while formatting the
   object. This is useful for inspecting large complicated objects. Defaults to
   `2`. To make it recurse indefinitely pass `null`.

 - `depth` - 告诉 `inspect` 格式化对象的时候递归多少次。这个选项在格式化复杂对象的时候比较有用。 默认为
   `2`。如果想无穷递归下去，则赋值为`null`即可。

 - `colors` - if `true`, then the output will be styled with ANSI color codes.
   Defaults to `false`. Colors are customizable, see below.

 - `colors` - 如果设为`true`，将会以`ANSI`颜色代码风格进行输出.
   默认是`false`。颜色是可定制的，请看下面：

 - `customInspect` - if `false`, then custom `inspect(depth, opts)` functions
   defined on the objects being inspected won&apos;t be called. Defaults to `true`.

 - `customInspect` - 如果设为 `false`，那么定义在被检查对象上的`inspect(depth, opts)` 方法将不会被调用。 默认为`true`。

Example of inspecting all properties of the `util` object:

示例：检查`util`对象上的所有属性

    console.log(util.inspect(util, { showHidden: true, depth: null }));

Values may supply their own custom `inspect(depth, opts)` functions, when
called they receive the current depth in the recursive inspection, as well as
the options object passed to `util.inspect()`.

当被调用的时候，参数值可以提供自己的自定义`inspect(depth, opts)`方法。该方法会接收当前的递归检查深度，以及传入`util.inspect()`的其他参数。

### 自定义 `util.inspect` 颜色

&lt;!-- type=misc --&gt;

Color output (if enabled) of `util.inspect` is customizable globally
via `util.inspect.styles` and `util.inspect.colors` objects.

`util.inspect`彩色输出(如果启用的话) ，可以通过`util.inspect.styles` 和 `util.inspect.colors` 来全局定义。

`util.inspect.styles` is a map assigning each style a color
from `util.inspect.colors`.
Highlighted styles and their default values are:
 * `number` (yellow)
 * `boolean` (yellow)
 * `string` (green)
 * `date` (magenta)
 * `regexp` (red)
 * `null` (bold)
 * `undefined` (grey)
 * `special` - only function at this time (cyan)
 * `name` (intentionally no styling)

`util.inspect.styles`是通过`util.inspect.colors`分配给每个风格颜色的一个映射。
高亮风格和它们的默认值:
 * `number` (黄色)
 * `boolean` (黄色)
 * `string` (绿色)
 * `date` (洋红色)
 * `regexp` (红色)
 * `null` (粗体)
 * `undefined` (灰色)
 * `special` - 在这个时候的唯一方法 (青绿色)
 * `name` (无风格)

Predefined color codes are: `white`, `grey`, `black`, `blue`, `cyan`, 
`green`, `magenta`, `red` and `yellow`.
There are also `bold`, `italic`, `underline` and `inverse` codes.

预定义的颜色代码: `white`, `grey`, `black`, `blue`, `cyan`, 
`green`, `magenta`, `red` 和 `yellow`。
还有 `bold`, `italic`, `underline` 和 `inverse` 代码。

### 自定义对象的`inspect()`方法

&lt;!-- type=misc --&gt;

Objects also may define their own `inspect(depth)` function which `util.inspect()`
will invoke and use the result of when inspecting the object:

对象可以定义自己的 `inspect(depth)`方法；当使用`util.inspect()`检查该对象的时候，将会执行对象自定义的检查方法。

    util.inspect(obj);
      // &quot;{nate}&quot;

You may also return another Object entirely, and the returned String will be
formatted according to the returned Object. This is similar to how
`JSON.stringify()` works:

您也可以返回完全不同的另一个对象，而且返回的字符串将被根据返回的对象格式化。它和`JSON.stringify()`工作原理类似:

    util.inspect(obj);
      // &quot;{ bar: &apos;baz&apos; }&quot;

## util.isArray(object)

Returns `true` if the given &quot;object&quot; is an `Array`. `false` otherwise.

如果给定的对象是`数组`类型，就返回`true`，否则返回`false`

    util.isArray([])
      // true
    util.isArray(new Array)
      // true
    util.isArray({})
      // false

## util.isRegExp(object)

Returns `true` if the given &quot;object&quot; is a `RegExp`. `false` otherwise.

如果给定的对象是`RegExp`类型，就返回`true`，否则返回`false`。

    util.isRegExp(/some regexp/)
      // true
    util.isRegExp(new RegExp(&apos;another regexp&apos;))
      // true
    util.isRegExp({})
      // false

## util.isDate(object)

Returns `true` if the given &quot;object&quot; is a `Date`. `false` otherwise.

如果给定的对象是`Date`类型，就返回`true`，否则返回`false`。

    util.isDate(new Date())
      // true
    util.isDate(Date())
      // false (没有关键字 &apos;new&apos; 返回一个字符串)
    util.isDate({})
      // false

## util.isError(object)

Returns `true` if the given &quot;object&quot; is an `Error`. `false` otherwise.

如果给定的对象是`Error`类型，就返回`true`，否则返回`false`。

    util.isError(new Error())
      // true
    util.isError(new TypeError())
      // true
    util.isError({ name: &apos;Error&apos;, message: &apos;an error occurred&apos; })
      // false

## util.inherits(constructor, superConstructor)

Inherit the prototype methods from one
[constructor](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor)
into another.  The prototype of `constructor` will be set to a new
object created from `superConstructor`.

通过[构造函数](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor)，继承原型对象上的方法。构造函数的`原型`将被设置为一个新的
从`超类`创建的对象。

As an additional convenience, `superConstructor` will be accessible
through the `constructor.super_` property.

你可以很方便的通过 `constructor.super_`来访问到`superConstructor` 

    stream.on(&quot;data&quot;, function(data) {
        console.log(&apos;Received data: &quot;&apos; + data + &apos;&quot;&apos;);
    })
    stream.write(&quot;It works!&quot;); // 输出结果：Received data: &quot;It works!&quot;

## util.debug(string)

    稳定度: 0 - 已过时: 请使用 console.error() 代替

Deprecated predecessor of `console.error`.

`console.error`的已过时的前身

## util.error([...])

    稳定度: 0 - 已过时: 请使用 console.error() 代替

Deprecated predecessor of `console.error`.

`console.error`的已过时的前身

## util.puts([...])

   稳定度: 0 - 已过时: 请使用 console.log() 代替

Deprecated predecessor of `console.log`.

`console.log`的已过时的前身

## util.print([...])

   稳定度: 0 - 已过时: 请使用 console.log() 代替

Deprecated predecessor of `console.log`.

`console.log`的已过时的前身

## util.pump(readableStream, writableStream, [callback])

   稳定度: 0 - 已过时: 请使用readableStream.pipe(writableStream)代替

Deprecated predecessor of `stream.pipe()`.


`stream.pipe()`的已过时的前身

# 事件 (Events)

    稳定度: 4 - 冻结

&lt;!--type=module--&gt;

Many objects in Node emit events: a `net.Server` emits an event each time
a peer connects to it, a `fs.readStream` emits an event when the file is
opened. All objects which emit events are instances of `events.EventEmitter`.
You can access this module by doing: `require(&quot;events&quot;);`

Node里面的许多对象都会分发事件：一个`net.Server`对象会在每次有新连接时分发一个事件， 一个`fs.readStream`对象会在文件被打开的时候发出一个事件。
所有这些产生事件的对象都是 `events.EventEmitter` 的实例。
你可以通过`require(&quot;events&quot;);`来访问该模块

Typically, event names are represented by a camel-cased string, however,
there aren&apos;t any strict restrictions on that, as any string will be accepted.

通常，事件名是驼峰命名 (camel-cased) 的字符串。不过也没有强制的要求，任何字符串都是可以使用的。

Functions can then be attached to objects, to be executed when an event
is emitted. These functions are called _listeners_. Inside a listener
function, `this` refers to the `EventEmitter` that the listener was
attached to.

为了处理发出的事件，我们将函数 (Function) 关联到对象上。
我们把这些函数称为 _监听器 (listeners)_。
在监听函数中 `this` 指向当前监听函数所关联的 `EventEmitter` 对象。

## 类: events.EventEmitter

To access the EventEmitter class, `require(&apos;events&apos;).EventEmitter`.

通过 `require(&apos;events&apos;).EventEmitter` 获取 EventEmitter 类。

When an `EventEmitter` instance experiences an error, the typical action is
to emit an `&apos;error&apos;` event.  Error events are treated as a special case in node.
If there is no listener for it, then the default action is to print a stack
trace and exit the program.

当 `EventEmitter` 实例遇到错误，通常的处理方法是产生一个 `&apos;error&apos;` 事件，node 对错误事件做特殊处理。
如果程序没有监听错误事件，程序会按照默认行为在打印出 栈追踪信息 (stack trace) 后退出。

All EventEmitters emit the event `&apos;newListener&apos;` when new listeners are
added and `&apos;removeListener&apos;` when a listener is removed.

EventEmitter 会在添加 listener 时触发 `&apos;newListener&apos;` 事件，删除 listener 时触发 `&apos;removeListener&apos;` 事件

### emitter.addListener(event, listener)
### emitter.on(event, listener)

### emitter.addListener(event, listener)
### emitter.on(event, listener)

Adds a listener to the end of the listeners array for the specified event.

添加一个 listener 至特定事件的 listener 数组尾部。

    server.on(&apos;connection&apos;, function (stream) {
      console.log(&apos;someone connected!&apos;);
    });

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.once(event, listener)

Adds a **one time** listener for the event. This listener is
invoked only the next time the event is fired, after which
it is removed.

添加一个 **一次性** listener，这个 listener 只会在下一次事件发生时被触发一次，触发完成后就被删除。

    server.once(&apos;connection&apos;, function (stream) {
      console.log(&apos;Ah, we have our first user!&apos;);
    });

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.removeListener(event, listener)

Remove a listener from the listener array for the specified event.
**Caution**: changes array indices in the listener array behind the listener.

从一个事件的 listener 数组中删除一个 listener
**注意**：此操作会改变 listener 数组中当前 listener 后的所有 listener 在的下标

    var callback = function(stream) {
      console.log(&apos;someone connected!&apos;);
    };
    server.on(&apos;connection&apos;, callback);
    // ...
    server.removeListener(&apos;connection&apos;, callback);

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.removeAllListeners([event])

Removes all listeners, or those of the specified event.

删除所有 listener，或者删除某些事件 (event) 的 listener

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### emitter.setMaxListeners(n)

By default EventEmitters will print a warning if more than 10 listeners are
added for a particular event. This is a useful default which helps finding
memory leaks. Obviously not all Emitters should be limited to 10. This function
allows that to be increased. Set to zero for unlimited.

在默认情况下，EventEmitter 会在多于 10 个 listener 监听某个事件的时候出现警告，此限制在寻找内存泄露时非常有用。
显然，也不是所有的 Emitter 事件都要被限制在 10 个 listener 以下，在这种情况下可以使用这个函数来改变这个限制。

Returns emitter, so calls can be chained.

返回 emitter，方便链式调用。

### EventEmitter.defaultMaxListeners

`emitter.setMaxListeners(n)` sets the maximum on a per-instance basis.
This class property lets you set it for *all* `EventEmitter` instances,
current and future, effective immediately. Use with care.

`emitter.setMaxListeners(n)` 设置每个 emitter 实例的最大监听数。
这个类属性为 **所有** `EventEmitter` 实例设置最大监听数（对所有已创建的实例和今后创建的实例都将立即生效）。
使用时请注意。

Note that `emitter.setMaxListeners(n)` still has precedence over
`EventEmitter.defaultMaxListeners`.

请注意，`emitter.setMaxListeners(n)` 优先于 `EventEmitter.defaultMaxListeners`。

### emitter.listeners(event)

Returns an array of listeners for the specified event.

返回指定事件的 listener 数组

    server.on(&apos;connection&apos;, function (stream) {
      console.log(&apos;someone connected!&apos;);
    });
    console.log(util.inspect(server.listeners(&apos;connection&apos;))); // [ [Function] ]

### emitter.emit(event, [arg1], [arg2], [...])

Execute each of the listeners in order with the supplied arguments.

使用提供的参数按顺序执行指定事件的 listener

Returns `true` if event had listeners, `false` otherwise.

若事件有 listener 则返回 `true` 否则返回 `false`。

### 类方法: EventEmitter.listenerCount(emitter, event)

Return the number of listeners for a given event.

返回指定事件的 listener 数量

### 事件: &apos;newListener&apos;

* `event` {String} The event name
* `listener` {Function} The event handler function

* `event` {String} 事件名
* `listener` {Function} 事件处理函数

This event is emitted any time someone adds a new listener.  It is unspecified
if `listener` is in the list returned by `emitter.listeners(event)`.

在添加 listener 时会发生该事件。
此时无法确定 `listener` 是否在 `emitter.listeners(event)` 返回的列表中。

### 事件: &apos;removeListener&apos;

* `event` {String} The event name
* `listener` {Function} The event handler function

* `event` {String} 事件名
* `listener` {Function} 事件处理函数

This event is emitted any time someone removes a listener.  It is unspecified
if `listener` is in the list returned by `emitter.listeners(event)`.


在移除 listener 时会发生该事件。
此时无法确定 `listener` 是否在 `emitter.listeners(event)` 返回的列表中。

# 域

    稳定度: 2 - 不稳定

Domains provide a way to handle multiple different IO operations as a
single group.  If any of the event emitters or callbacks registered to a
domain emit an `error` event, or throw an error, then the domain object
will be notified, rather than losing the context of the error in the
`process.on(&apos;uncaughtException&apos;)` handler, or causing the program to
exit immediately with an error code.

Domains 提供了一种方式，即以一个单一的组的形式来处理多个不同的IO操作。如果任何一个注册到domain的事件触发器或回调触发了一个‘error’事件，或者抛出一个错误，那么domain对象将会被通知到。而不是直接让这个错误的上下文从`process.on（&apos;uncaughtException&apos;）&apos;处理程序中丢失掉，也不会致使程序因为这个错误伴随着错误码立即退出。

## 警告: 不要忽视错误!

&lt;!-- type=misc --&gt;

Domain error handlers are not a substitute for closing down your
process when an error occurs.

Domain error处理程序不是一个在错误发生时，关闭你的进程的替代品

By the very nature of how `throw` works in JavaScript, there is almost
never any way to safely &quot;pick up where you left off&quot;, without leaking
references, or creating some other sort of undefined brittle state.

基于&apos;抛出（throw）&apos;在JavaScript中工作的方式，几乎从来没有任何方式能够在‘不泄露引用，不造成一些其他种类的未定义的脆弱状态’的前提下，安全的“从你离开的地方重新拾起（pick up where you left off）”，

The safest way to respond to a thrown error is to shut down the
process.  Of course, in a normal web server, you might have many
connections open, and it is not reasonable to abruptly shut those down
because an error was triggered by someone else.

响应一个被抛出错误的最安全方式就是关闭进程。当然，在一个正常的Web服务器中，你可能会有很多活跃的连接。由于其他触发的错误你去突然关闭这些连接是不合理。

The better approach is send an error response to the request that
triggered the error, while letting the others finish in their normal
time, and stop listening for new requests in that worker.

更好的方法是发送错误响应给那个触发错误的请求，在保证其他人正常完成工作时，停止监听那个触发错误的人的新请求。

In this way, `domain` usage goes hand-in-hand with the cluster module,
since the master process can fork a new worker when a worker
encounters an error.  For node programs that scale to multiple
machines, the terminating proxy or service registry can take note of
the failure, and react accordingly.

在这种方式中，`域`使用伴随着集群模块，由于主过程可以叉新工人时，一个工人发生了一个错误。节点程序规模的多
机，终止代理或服务注册可以注意一下失败，并做出相应的反应。

For example, this is not a good idea:

举例来说，以下就不是一个好想法：

var d = require(&apos;domain&apos;).create();
d.on(&apos;error&apos;, function(er) {
  // 这个错误不会导致进程崩溃，但是情况会更糟糕！
  // 虽然我们阻止了进程突然重启动，但是我们已经发生了资源泄露
  // 这种事情的发生会让我们发疯。
  // 不如调用 process.on(&apos;uncaughtException&apos;)!
  console.log(&apos;error, but oh well&apos;, er.message);
});
d.run(function() {
  require(&apos;http&apos;).createServer(function(req, res) {
    handleRequest(req, res);
  }).listen(PORT);
});</code></pre>
<p>By using the context of a domain, and the resilience of separating our
program into multiple worker processes, we can react more
appropriately, and handle errors with much greater safety.

</p>
<p>通过对域的上下文的使用，以及将我们的程序分隔成多个工作进程的反射，我们可以做出更加恰当的反应和更加安全的处理。

</p>
<pre><code>// 好一些的做法！

var cluster = require(&apos;cluster&apos;);
var PORT = +process.env.PORT || 1337;

var cluster = require(&apos;cluster&apos;);
var PORT = +process.env.PORT || 1337;

if (cluster.isMaster) {
  // In real life, you&apos;d probably use more than just 2 workers,
  // and perhaps not put the master and worker in the same file.
  //
  // You can also of course get a bit fancier about logging, and
  // implement whatever custom logic you need to prevent DoS
  // attacks and other bad behavior.
  //
  // See the options in the cluster documentation.
  //
  // The important thing is that the master does very little,
  // increasing our resilience to unexpected errors.

if (cluster.isMaster) {
  // 在工作环境中，你可能会使用到不止一个工作分支
  // 而且可能不会把主干和分支放在同一个文件中
  //
  //你当然可以通过日志进行猜测，并且对你需要防止的DoS攻击等不良行为实施自定义的逻辑
  //
  // 看集群文件的选项
  //
  // 最重要的是主干非常小，增加了我们抵抗以外错误的可能性。

  cluster.fork();
  cluster.fork();

  cluster.fork();
  cluster.fork();

  cluster.on(&apos;disconnect&apos;, function(worker) {
    console.error(&apos;disconnect!&apos;);
    cluster.fork();
  });

  cluster.on(&apos;disconnect&apos;, function(worker) {
    console.error(&apos;disconnect!&apos;);
    cluster.fork();
  });

} else {
  // the worker
  //
  // This is where we put our bugs!

} else {
  // 工作进程
  //
  // 这是我们出错的地方

  var domain = require(&apos;domain&apos;);

  var domain = require(&apos;domain&apos;);

  // See the cluster documentation for more details about using
  // worker processes to serve requests.  How it works, caveats, etc.

  //看集群文件对于使用工作进程处理请求的更多细节，它是如何工作的，它的警告等等。

  var server = require(&apos;http&apos;).createServer(function(req, res) {
    var d = domain.create();
    d.on(&apos;error&apos;, function(er) {
      console.error(&apos;error&apos;, er.stack);

  var server = require(&apos;http&apos;).createServer(function(req, res) {
    var d = domain.create();
    d.on(&apos;error&apos;, function(er) {
      console.error(&apos;error&apos;, er.stack);

    // 因为req和res在这个域存在之前就被创建，
    // 所以我们需要显式添加它们。
    // 详见下面关于显式和隐式绑定的解释。
    d.add(req);
    d.add(res);

    // Now run the handler function in the domain.
    d.run(function() {
      handleRequest(req, res);
    });
  });
  server.listen(PORT);
}

    // 现在在域里面运行处理器函数。
    d.run(function() {
      handleRequest(req, res);
    });
  });
  server.listen(PORT);
}

    // 这个部分不是很重要。只是一个简单的路由例子。
    // 你会想把你的超级给力的应用逻辑放在这里。
    function handleRequest(req, res) {
      switch(req.url) {
        case &apos;/error&apos;:
          // 我们干了一些异步的东西，然后。。。
          setTimeout(function() {
            // 呃。。。
            flerb.bark();
          });
          break;
        default:
          res.end(&apos;ok&apos;);
      }
    }</code></pre>
<h2>对Error(错误)对象的内容添加<span><a href="all.html#all_error_7" id="all_error_7">#</a></span></h2>
<!-- type=misc -->

<p>Any time an Error object is routed through a domain, a few extra fields
are added to it.

</p>
<p>每一次一个Error对象被导向经过一个域，它会添加几个新的字段。

</p>
<ul>
<li><code>error.domain</code> The domain that first handled the error.</li>
<li><code>error.domainEmitter</code> The event emitter that emitted an &apos;error&apos; event
with the error object.</li>
<li><code>error.domainBound</code> The callback function which was bound to the
domain, and passed an error as its first argument.</li>
<li><p><code>error.domainThrown</code> A boolean indicating whether the error was
thrown, emitted, or passed to a bound callback function.</p>
</li>
<li><p><code>error.domain</code> 第一个处理这个错误的域。</p>
</li>
<li><code>error.domainEmitter</code> 用这个错误对象触发&apos;error&apos;事件的事件分发器。</li>
<li><code>error.domainBound</code> 回调函数，该回调函数被绑定到域，并且一个错误会作为第一参数传递给这个回调函数。</li>
<li><code>error.domainThrown</code> 一个布尔值表明这个错误是否被抛出，分发或者传递给一个绑定的回调函数。</li>
</ul>
<h2>隐式绑定<span><a href="all.html#all_63" id="all_63">#</a></span></h2>
<!--type=misc-->

<p>If domains are in use, then all <strong>new</strong> EventEmitter objects (including
Stream objects, requests, responses, etc.) will be implicitly bound to
the active domain at the time of their creation.

</p>
<p>如果多个域正在被使用，那么所有的<strong>新</strong>EventEmitter对象（包括Stream对象，请求，应答等等）会被隐式绑定到它们被创建时的有效域。

</p>
<p>Additionally, callbacks passed to lowlevel event loop requests (such as
to fs.open, or other callback-taking methods) will automatically be
bound to the active domain.  If they throw, then the domain will catch
the error.

</p>
<p>而且，被传递到低层事件分发请求的回调函数（例如fs.open，或者其它接受回调函数的函数）会自动绑定到有效域。如果这些回调函数抛出错误，那么这个域会捕捉到这个错误。

</p>
<p>In order to prevent excessive memory usage, Domain objects themselves
are not implicitly added as children of the active domain.  If they
were, then it would be too easy to prevent request and response objects
from being properly garbage collected.

</p>
<p>为了防止内存的过度使用，Domain对象自己不会作为有效域的子对象被隐式添加到有效域。因为如果这样做的话，会很容易影响到请求和应答对象的正常垃圾回收。

</p>
<p>If you <em>want</em> to nest Domain objects as children of a parent Domain,
then you must explicitly add them.

</p>
<p>如果你<em>想</em>在一个父Domain对象里嵌套子Domain对象，那么你需要显式地添加它们。

</p>
<p>Implicit binding routes thrown errors and <code>&apos;error&apos;</code> events to the
Domain&apos;s <code>error</code> event, but does not register the EventEmitter on the
Domain, so <code>domain.dispose()</code> will not shut down the EventEmitter.
Implicit binding only takes care of thrown errors and <code>&apos;error&apos;</code> events.

</p>
<p>隐式绑定将被抛出的错误和<code>&apos;error&apos;</code>事件导向到Domain对象的<code>error</code>事件，但不会注册到Domain对象上的EventEmitter对象，所以<code>domain.dispose()</code>不会令EventEmitter对象停止运作。隐式绑定只关心被抛出的错误和 <code>&apos;error&apos;</code>事件。

</p>
<h2>显式绑定<span><a href="all.html#all_64" id="all_64">#</a></span></h2>
<!--type=misc-->

<p>Sometimes, the domain in use is not the one that ought to be used for a
specific event emitter.  Or, the event emitter could have been created
in the context of one domain, but ought to instead be bound to some
other domain.

</p>
<p>有时，正在使用的域并不是某个事件分发器所应属的域。又或者，事件分发器在一个域内被创建，但是应该被绑定到另一个域。

</p>
<p>For example, there could be one domain in use for an HTTP server, but
perhaps we would like to have a separate domain to use for each request.

</p>
<p>例如，对于一个HTTP服务器，可以有一个正在使用的域，但我们可能希望对每一个请求使用一个不同的域。

</p>
<p>That is possible via explicit binding.

</p>
<p>这可以通过显示绑定来达到。

</p>
<p>For example:

</p>
<p>例如：

</p>
<pre><code>serverDomain.run(function() {
  // 服务器在serverDomain的作用域内被创建
  http.createServer(function(req, res) {
    // req和res同样在serverDomain的作用域内被创建
    // 但是，我们想对于每一个请求使用一个不一样的域。
    // 所以我们首先创建一个域，然后将req和res添加到这个域上。
    var reqd = domain.create();
    reqd.add(req);
    reqd.add(res);
    reqd.on(&apos;error&apos;, function(er) {
      console.error(&apos;Error&apos;, er, req.url);
      try {
        res.writeHead(500);
        res.end(&apos;Error occurred, sorry.&apos;);
      } catch (er) {
        console.error(&apos;Error sending 500&apos;, er, req.url);
      }
    });
  }).listen(1337);    
});
```</code></pre>
<h2>domain.create()<span><a href="all.html#all_domain_create_1" id="all_domain_create_1">#</a></span></h2>
<div><ul>
<li><p>return: <span>Domain</span></p>
</li>
<li><p>return: <span>Domain</span></p>
</li>
</div></ul>
<p>Returns a new Domain object.

</p>
<p>返回一个新的Domain对象。

</p>
<h2>类: Domain<span><a href="all.html#all_domain_1" id="all_domain_1">#</a></span></h2>
<p>The Domain class encapsulates the functionality of routing errors and
uncaught exceptions to the active Domain object.

</p>
<p>Domain类封装了将错误和没有被捕捉的异常导向到有效对象的功能。

</p>
<p>Domain is a child class of <a href="events.html#events_class_events_eventemitter">EventEmitter</a>.  To handle the errors that it
catches, listen to its <code>error</code> event.

</p>
<p>Domain是 <a href="events.html#events_class_events_eventemitter">EventEmitter</a>类的一个子类。监听它的<code>error</code>事件来处理它捕捉到的错误。

</p>
<h3>domain.run(fn)<span><a href="all.html#all_domain_run_fn_1" id="all_domain_run_fn_1">#</a></span></h3>
<div><ul>
<li><p><code>fn</code> <span>Function</span></p>
</li>
<li><p><code>fn</code> <span>Function</span></p>
</li>
</div></ul>
<p>Run the supplied function in the context of the domain, implicitly
binding all event emitters, timers, and lowlevel requests that are
created in that context.

</p>
<p>在域的上下文里运行提供的函数，隐式地绑定所有该上下文里创建的事件分发器，计时器和低层请求。

</p>
<p>This is the most basic way to use a domain.

</p>
<p>这是使用一个域的最基本的方式。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var d = domain.create();
d.on(&apos;error&apos;, function(er) {
  console.error(&apos;Caught error!&apos;, er);
});
d.run(function() {
  process.nextTick(function() {
    setTimeout(function() { // 模拟几个不同的异步的东西
      fs.open(&apos;non-existent file&apos;, &apos;r&apos;, function(er, fd) {
        if (er) throw er;
        // 继续。。。
      });
    }, 100);
  });
});</code></pre>
<p>In this example, the <code>d.on(&apos;error&apos;)</code> handler will be triggered, rather
than crashing the program.

</p>
<p>在这个例子里， <code>d.on(&apos;error&apos;)</code> 处理器会被触发，而不是导致程序崩溃。

</p>
<h3>domain.members<span><a href="all.html#all_domain_members_1" id="all_domain_members_1">#</a></span></h3>
<div><ul>
<li><p><span>Array</span></p>
</li>
<li><p><span>Array</span></p>
</li>
</div></ul>
<p>An array of timers and event emitters that have been explicitly added
to the domain.

</p>
<p>一个数组，里面的元素是被显式添加到域里的计时器和事件分发器。

</p>
<h3>domain.add(emitter)<span><a href="all.html#all_domain_add_emitter_1" id="all_domain_add_emitter_1">#</a></span></h3>
<div><ul>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> emitter or timer to be added to the domain</p>
</li>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> 被添加到域里的时间分发器或计时器</p>
</li>
</div></ul>
<p>Explicitly adds an emitter to the domain.  If any event handlers called by
the emitter throw an error, or if the emitter emits an <code>error</code> event, it
will be routed to the domain&apos;s <code>error</code> event, just like with implicit
binding.

</p>
<p>显式地将一个分发器添加到域。如果这个分发器调用的任意一个事件处理器抛出一个错误，或是这个分发器分发了一个<code>error</code>事，那么它会被导向到这个域的<code>error</code>事件，就像隐式绑定所做的一样。

</p>
<p>This also works with timers that are returned from <code>setInterval</code> and
<code>setTimeout</code>.  If their callback function throws, it will be caught by
the domain &apos;error&apos; handler.

</p>
<p>这对于从<code>setInterval</code>和<code>setTimeout</code>返回的计时器同样适用。如果这些计时器的回调函数抛出错误，它将会被这个域的<code>error</code>处理器捕捉到。

</p>
<p>If the Timer or EventEmitter was already bound to a domain, it is removed
from that one, and bound to this one instead.

</p>
<p>如果这个Timer或EventEmitter对象已经被绑定到另外一个域，那么它将会从那个域被移除，然后绑定到当前的域。

</p>
<h3>domain.remove(emitter)<span><a href="all.html#all_domain_remove_emitter_1" id="all_domain_remove_emitter_1">#</a></span></h3>
<div><ul>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> emitter or timer to be removed from the domain</p>
</li>
<li><p><code>emitter</code> <span>EventEmitter | Timer</span> 要从域里被移除的分发器或计时器</p>
</li>
</div></ul>
<p>The opposite of <code>domain.add(emitter)</code>.  Removes domain handling from the
specified emitter.

</p>
<p>与<code>domain.add(emitter)</code>函数恰恰相反，这个函数将域处理从指明的分发器里移除。

</p>
<h3>domain.bind(callback)<span><a href="all.html#all_domain_bind_callback_1" id="all_domain_bind_callback_1">#</a></span></h3>
<div><ul>
<li><code>callback</code> <span>Function</span> The callback function</li>
<li><p>return: <span>Function</span> The bound function</p>
</li>
<li><p><code>callback</code> <span>Function</span> 回调函数</p>
</li>
<li>return: <span>Function</span> 被绑定的函数</li>
</div></ul>
<p>The returned function will be a wrapper around the supplied callback
function.  When the returned function is called, any errors that are
thrown will be routed to the domain&apos;s <code>error</code> event.

</p>
<p>返回的函数会是一个对于所提供的回调函数的包装函数。当这个被返回的函数被调用时，所有被抛出的错误都会被导向到这个域的<code>error</code>事件。

</p>
<h4>例子<span><a href="all.html#all_65" id="all_65">#</a></span></h4>
<pre><code>d.on(&apos;error&apos;, function(er) {
  // 有个地方发生了一个错误。
  // 如果我们现在抛出这个错误，它会让整个程序崩溃
  // 并给出行号和栈信息。
});</code></pre>
<h3>domain.intercept(callback)<span><a href="all.html#all_domain_intercept_callback_1" id="all_domain_intercept_callback_1">#</a></span></h3>
<div><ul>
<li><code>callback</code> <span>Function</span> The callback function</li>
<li><p>return: <span>Function</span> The intercepted function</p>
</li>
<li><p><code>callback</code> <span>Function</span> 回调函数</p>
</li>
<li>return: <span>Function</span> 被拦截的函数</li>
</div></ul>
<p>This method is almost identical to <code>domain.bind(callback)</code>.  However, in
addition to catching thrown errors, it will also intercept <code>Error</code>
objects sent as the first argument to the function.

</p>
<p>这个函数与<code>domain.bind(callback)</code>几乎一模一样。但是，除了捕捉被抛出的错误外，它还会拦截作为第一参数被传递到这个函数的<code>Error</code>对象。

</p>
<p>In this way, the common <code>if (er) return callback(er);</code> pattern can be replaced
with a single error handler in a single place.

</p>
<p>在这种方式下，常见的&apos;if(er) return callback(er);&apos;的方式可以被一个单独地方的单独的错误处理所取代。

</p>
<h4>例子<span><a href="all.html#all_66" id="all_66">#</a></span></h4>
<pre><code>d.on(&apos;error&apos;, function(er) {
  // 有个地方发生了一个错误。
  // 如果我们现在抛出这个错误，它会让整个程序崩溃
  // 并给出行号和栈信息。
});</code></pre>
<h3>domain.enter()<span><a href="all.html#all_domain_enter_1" id="all_domain_enter_1">#</a></span></h3>
<p>The <code>enter</code> method is plumbing used by the <code>run</code>, <code>bind</code>, and <code>intercept</code>
methods to set the active domain. It sets <code>domain.active</code> and <code>process.domain</code>
to the domain, and implicitly pushes the domain onto the domain stack managed
by the domain module (see <code>domain.exit()</code> for details on the domain stack). The
call to <code>enter</code> delimits the beginning of a chain of asynchronous calls and I/O
operations bound to a domain.

</p>
<p><code>enter</code>函数对于<code>run</code>，<code>bind</code>和<code>intercept</code>来说就像它们的管道系统：它们使用<code>enter</code>函数来设置有效域。<code>enter</code>函数对于域设定了<code>domain.active</code>和 <code>process.domain</code>
，还隐式地将域推入了由域模块管理的域栈（关于域栈的细节详见<code>domain.exit()</code>）。<code>enter</code>函数的调用，分隔了异步调用链以及绑定到一个域的I/O操作的结束或中断。

</p>
<p>Calling <code>enter</code> changes only the active domain, and does not alter the domain
itself. <code>Enter</code> and <code>exit</code> can be called an arbitrary number of times on a
single domain.

</p>
<p>调用<code>enter</code>仅仅改变活动的域，而不改变域本身。
<code>Enter</code> 和 <code>exit</code>在一个单独的域可以被调用任意多次。

</p>
<p>If the domain on which <code>enter</code> is called has been disposed, <code>enter</code> will return
without setting the domain.

</p>
<p>如果域的<code>enter</code>已经设置，<code>enter</code>将不设置域就返回。

</p>
<h3>domain.exit()<span><a href="all.html#all_domain_exit_1" id="all_domain_exit_1">#</a></span></h3>
<p>The <code>exit</code> method exits the current domain, popping it off the domain stack.
Any time execution is going to switch to the context of a different chain of
asynchronous calls, it&apos;s important to ensure that the current domain is exited.
The call to <code>exit</code> delimits either the end of or an interruption to the chain
of asynchronous calls and I/O operations bound to a domain.

</p>
<p><code>exit</code>函数退出当前的域，将当前域从域的栈里移除。每当当程序的执行流程准要切换到一个不同的异步调用链的上下文时，要保证退出当前的域。<code>exit</code>函数的调用，分隔了异步调用链以及绑定到一个域的I/O操作的结束或中断。


</p>
<p>If there are multiple, nested domains bound to the current execution context,
<code>exit</code> will exit any domains nested within this domain.

</p>
<p>如果有多个嵌套的域绑定到当前的执行上下文，
<code>退出</code>将退出在这个域里的所有的嵌套。

</p>
<p>Calling <code>exit</code> changes only the active domain, and does not alter the domain
itself. <code>Enter</code> and <code>exit</code> can be called an arbitrary number of times on a
single domain.

</p>
<p>调用<code>exit</code>只会改变有效域，而不会改变域自身。在一个单一域上，<code>Enter</code>和<code>exit</code>可以被调用任意次。

</p>
<p>If the domain on which <code>exit</code> is called has been disposed, <code>exit</code> will return
without exiting the domain.

</p>
<p>如果在这个域名下<code>exit </code>已经被设置，<code>exit </code>将不退出域返回。

</p>
<h3>domain.dispose()<span><a href="all.html#all_domain_dispose_1" id="all_domain_dispose_1">#</a></span></h3>
<pre><code>稳定度: 0 - 已过时。请通过设置在域上的错误事件处理器，显式地东失败的IO操作中恢复。</code></pre>
<p>Once <code>dispose</code> has been called, the domain will no longer be used by callbacks
bound into the domain via <code>run</code>, <code>bind</code>, or <code>intercept</code>, and a <code>dispose</code> event
is emitted.

</p>
<p>一旦<code>dispose</code>被调用，通过<code>run</code>，<code>bind</code>或<code>intercept</code>绑定到这个域的回调函数将不再使用这个域，并且一个<code>dispose</code>事件会被分发。

</p>
<h1>Buffer<span><a href="all.html#all_buffer_4" id="all_buffer_4">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Pure JavaScript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it&apos;s necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.

</p>
<p>纯javascript对Unicode比较友好，但是无法很好地处理二进制数据。当我们面对TCP流或者文件系统的时候，是需要处理八位字节流的。Node有几种操作，创建和消化八位字节流的策略。

</p>
<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.

</p>
<p>原始数据保存在 <code>Buffer</code> 类的实例中。一个 <code>Buffer</code> 实例类似于一个整数数组，但对应者 V8 堆之外的一个原始内存分配区域。一个 <code>Buffer</code> 的大小不可变。

</p>
<p>The <code>Buffer</code> class is a global, making it very rare that one would need
to ever <code>require(&apos;buffer&apos;)</code>.

</p>
<p><code>Buffer</code> 类是一个全局的类，所以它很罕有地不需要<code>require</code>语句就可以调用。

</p>
<p>Converting between Buffers and JavaScript string objects requires an explicit
encoding method.  Here are the different string encodings.

</p>
<p>在Buffers和JavaScript string转换时，需要明确的一个编码方法。下面是一些不同的string编码。

</p>
<ul>
<li><p><code>&apos;ascii&apos;</code> - for 7 bit ASCII data only.  This encoding method is very fast, and
will strip the high bit if set.</p>
</li>
<li><p><code>&apos;ascii&apos;</code> - 仅适用 7 bit ASCII 格式数据。这个编码方式非常快速，而且会剥离设置过高的bit。</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - 多字节编码 Unicode字符。很多网页或者其他文档的编码格式都是使用 UTF-8的。</p>
</li>
<li><p><code>&apos;utf16le&apos;</code> - 2 or 4 bytes, little endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code>&apos;utf16le&apos;</code> - 2 或者 4 字节, Little Endian (LE)  编码Unicode字符。
代理对 (U+10000 to U+10FFFF) 是支持的.（BE和LE表示大端和小端，Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端；Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端；下同）</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> - Alias of <code>&apos;utf16le&apos;</code>.</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> -  <code>&apos;utf16le&apos;</code>的别名.</p>
</li>
<li><p><code>&apos;base64&apos;</code> - Base64 string encoding.</p>
</li>
<li><p><code>&apos;base64&apos;</code> - Base64 字符串编码。</p>
</li>
<li><p><code>&apos;binary&apos;</code> - A way of encoding raw binary data into strings by using only
the first 8 bits of each character. This encoding method is deprecated and
should be avoided in favor of <code>Buffer</code> objects where possible. This encoding
will be removed in future versions of Node.</p>
</li>
<li><p><code>&apos;binary&apos;</code> - 一个将原始2进制数据编码为字符串的方法，仅使用每个字符的前8bits。 这个编码方式已经被弃用而且应该被避免，尽可能的使用<code>Buffer</code>对象。这个编码方式将会在未来的Node版本中移除。</p>
</li>
<li><p><code>&apos;hex&apos;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
<li><p><code>&apos;hex&apos;</code> - 把每个byte编码成2个十六进制字符</p>
</li>
</ul>
<h2>类: Buffer<span><a href="all.html#all_buffer_5" id="all_buffer_5">#</a></span></h2>
<p>The Buffer class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.

</p>
<p>Buffer 类是一个全局变量类型，用来直接处理2进制数据的。
它能够使用多种方式构建。

</p>
<h3>new Buffer(size)<span><a href="all.html#all_new_buffer_size_1" id="all_new_buffer_size_1">#</a></span></h3>
<div><ul>
<li><p><code>size</code> Number</p>
</li>
<li><p><code>size</code> Number</p>
</li>
</div></ul>
<p>Allocates a new buffer of <code>size</code> octets.

</p>
<p>分配一个新的 buffer 大小是 <code>size</code> 的8位字节.

</p>
<h3>new Buffer(array)<span><a href="all.html#all_new_buffer_array_1" id="all_new_buffer_array_1">#</a></span></h3>
<div><ul>
<li><p><code>array</code> Array</p>
</li>
<li><p><code>array</code> Array</p>
</li>
</div></ul>
<p>Allocates a new buffer using an <code>array</code> of octets.

</p>
<p>分配一个新的 buffer 使用一个8位字节 <code>array</code> 数组.

</p>
<h3>new Buffer(str, [encoding])<span><a href="all.html#all_new_buffer_str_encoding_1" id="all_new_buffer_str_encoding_1">#</a></span></h3>
<div><ul>
<li><code>str</code> String - string to encode.</li>
<li><p><code>encoding</code> String - encoding to use, Optional.</p>
</li>
<li><p><code>str</code> String类型 - 需要存入buffer的string字符串.</p>
</li>
<li><code>encoding</code> String类型 - 使用什么编码方式，参数可选.</li>
</div></ul>
<p>Allocates a new buffer containing the given <code>str</code>.
<code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.

</p>
<p>分配一个新的 buffer ，其中包含着给定的 <code>str</code>字符串.
<code>encoding</code> 编码方式默认是：<code>&apos;utf8&apos;</code>.

</p>
<h3>类方法: Buffer.isEncoding(encoding)<span><a href="all.html#all_buffer_isencoding_encoding_1" id="all_buffer_isencoding_encoding_1">#</a></span></h3>
<div><ul>
<li><p><code>encoding</code> <span>String</span> The encoding string to test</p>
</li>
<li><p><code>encoding</code> <span>String</span> 用来测试给定的编码字符串</p>
</li>
</div></ul>
<p>Returns true if the <code>encoding</code> is a valid encoding argument, or false
otherwise.

</p>
<p>如果给定的编码 <code>encoding</code> 是有效的，返回 true，否则返回 false。

</p>
<h3>类方法: Buffer.isBuffer(obj)<span><a href="all.html#all_buffer_isbuffer_obj_1" id="all_buffer_isbuffer_obj_1">#</a></span></h3>
<div><ul>
<li><code>obj</code> Object</li>
<li><p>Return: Boolean</p>
</li>
<li><p><code>obj</code> Object</p>
</li>
<li>返回: Boolean</li>
</div></ul>
<p>Tests if <code>obj</code> is a <code>Buffer</code>.

</p>
<p>测试这个 <code>obj</code> 是否是一个 <code>Buffer</code>.

</p>
<h3>类方法: Buffer.byteLength(string, [encoding])<span><a href="all.html#all_buffer_bytelength_string_encoding_1" id="all_buffer_bytelength_string_encoding_1">#</a></span></h3>
<div><ul>
<li><code>string</code> String</li>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li><p>Return: Number</p>
</li>
<li><p><code>string</code> String类型</p>
</li>
<li><code>encoding</code> String类型, 可选参数, 默认是: &apos;utf8&apos;</li>
<li>Return: Number类型</li>
</div></ul>
<p>Gives the actual byte length of a string. <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>.
This is not the same as <code>String.prototype.length</code> since that returns the
number of <em>characters</em> in a string.

</p>
<p>将会返回这个字符串真实byte长度。 <code>encoding</code> 编码默认是： <code>&apos;utf8&apos;</code>.
这个和 <code>String.prototype.length</code> 是不一样的，因为那个方法返回这个字符串中有几个字符的数量。
（译者：当用户在写http响应头Cotent-Length的时候，千万记得一定要用 <code>Buffer.byteLength</code> 方法，不要使用 <code>String.prototype.length</code> ）

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>
<h3>类方法: Buffer.concat(list, [totalLength])<span><a href="all.html#all_buffer_concat_list_totallength_1" id="all_buffer_concat_list_totallength_1">#</a></span></h3>
<div><ul>
<li><code>list</code> <span>Array</span> List of Buffer objects to concat</li>
<li><p><code>totalLength</code> <span>Number</span> Total length of the buffers when concatenated</p>
</li>
<li><p><code>list</code> <span>Array</span>数组类型，Buffer数组，用于被连接。</p>
</li>
<li><code>totalLength</code> <span>Number</span>类型 上述Buffer数组的所有Buffer的总大小。（译者：注意这里的totalLength不是数组长度是数组里Buffer实例的大小总和）</li>
</div></ul>
<p>Returns a buffer which is the result of concatenating all the buffers in
the list together.

</p>
<p>返回一个保存着将传入buffer数组中所有buffer对象拼接在一起的buffer对象。（译者：有点拗口，其实就是将数组中所有的buffer实例通过复制拼接在一起）

</p>
<p>If the list has no items, or if the totalLength is 0, then it returns a
zero-length buffer.

</p>
<p>如果传入的数组没有内容，或者 totalLength 参数是0，那将返回一个zero-length的buffer。

</p>
<p>If the list has exactly one item, then the first item of the list is
returned.

</p>
<p>如果数组中只有一项，那么这第一项就会被返回。

</p>
<p>If the list has more than one item, then a new Buffer is created.

</p>
<p>如果数组中的项多于一个，那么一个新的Buffer实例将被创建。

</p>
<p>If totalLength is not provided, it is read from the buffers in the list.
However, this adds an additional loop to the function, so it is faster
to provide the length explicitly.

</p>
<p>如果 totalLength 参数没有提供，虽然会从buffer数组中计算读取，但是会增加一个额外的循环来计算它，所以提供一个明确的 totalLength  参数将会更快。

</p>
<h3>buf.length<span><a href="all.html#all_buf_length_1" id="all_buf_length_1">#</a></span></h3>
<div><ul>
<li><p>Number</p>
</li>
<li><p>Number类型</p>
</li>
</div></ul>
<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.

</p>
<p>这个buffer的bytes大小。注意这未必是这buffer里面内容的大小。<code>length</code> 的依据是buffer对象所分配的内存数值，它不会随着这个buffer对象内容的改变而改变。

</p>
<pre><code>// 1234
// 1234</code></pre>
<h3>buf.write(string, [offset], [length], [encoding])<span><a href="all.html#all_buf_write_string_offset_length_encoding_1" id="all_buf_write_string_offset_length_encoding_1">#</a></span></h3>
<div><ul>
<li><code>string</code> String - data to be written to buffer</li>
<li><code>offset</code> Number, Optional, Default: 0</li>
<li><code>length</code> Number, Optional, Default: <code>buffer.length - offset</code></li>
<li><p><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</p>
</li>
<li><p><code>string</code> String类型 - 将要被写入 buffer 的数据</p>
</li>
<li><code>offset</code> Number类型, 可选参数, 默认: 0</li>
<li><code>length</code> Number类型, 可选参数, 默认: <code>buffer.length - offset</code></li>
<li><code>encoding</code> String类型, 可选参数, 默认: &apos;utf8&apos;</li>
</div></ul>
<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding.
<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&apos;utf8&apos;</code>. <code>length</code> is
the number of bytes to write. Returns number of octets written. If <code>buffer</code> did
not contain enough space to fit the entire string, it will write a partial
amount of the string. <code>length</code> defaults to <code>buffer.length - offset</code>.
The method will not write partial characters.

</p>
<p>根据参数 <code>offset</code> 偏移量和指定的<code>encoding</code>编码方式，将参数 <code>string</code> 数据写入buffer。
<code>offset</code>偏移量 默认是 <code>0</code>, <code>encoding</code>编码方式默认是 <code>&apos;utf8&apos;</code>。 
<code>length</code>长度是将要写入的字符串的bytes大小。
返回number类型，表示多少8位字节流被写入了。如果<code>buffer</code> 没有足够的空间来放入整个string，它将只会写入部分的字符串。
<code>length</code> 默认是 <code>buffer.length - offset</code>。
这个方法不会出现写入部分字符。


</p>
<pre><code>buf = new Buffer(256);
len = buf.write(&apos;\u00bd + \u00bc = \u00be&apos;, 0);
console.log(len + &quot; bytes: &quot; + buf.toString(&apos;utf8&apos;, 0, len));</code></pre>
<h3>buf.toString([encoding], [start], [end])<span><a href="all.html#all_buf_tostring_encoding_start_end_1" id="all_buf_tostring_encoding_start_end_1">#</a></span></h3>
<div><ul>
<li><code>encoding</code> String, Optional, Default: &apos;utf8&apos;</li>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><p><code>end</code> Number, Optional, Default: <code>buffer.length</code></p>
</li>
<li><p><code>encoding</code> String类型, 可选参数, 默认: &apos;utf8&apos;</p>
</li>
<li><code>start</code> Number类型, 可选参数, 默认: 0</li>
<li><code>end</code> Number类型, 可选参数, 默认: <code>buffer.length</code></li>
</div></ul>
<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>
(defaults to <code>&apos;utf8&apos;</code>) beginning at <code>start</code> (defaults to <code>0</code>) and ending at
<code>end</code> (defaults to <code>buffer.length</code>).

</p>
<p>根据 <code>encoding</code>参数（默认是 <code>&apos;utf8&apos;</code>）返回一个解码的 string 类型。还会根据传入的参数 <code>start</code> (默认是<code>0</code>) 和 <code>end</code> (默认是 <code>buffer.length</code>)作为取值范围。

</p>
<p>See <code>buffer.write()</code> example, above.

</p>
<p>查看上面<code>buffer.write()</code> 的例子.

</p>
<h3>buf.toJSON()<span><a href="all.html#all_buf_tojson_1" id="all_buf_tojson_1">#</a></span></h3>
<p>Returns a JSON-representation of the Buffer instance.  <code>JSON.stringify</code>
implicitly calls this function when stringifying a Buffer instance.

</p>
<p>返回一个 JSON表示的Buffer实例。<code>JSON.stringify</code>将会默认调用来字符串序列化这个Buffer实例。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>console.log(copy);
// &lt;Buffer 74 65 73 74&gt;</code></pre>
<h3>buf[index]<span><a href="all.html#all_buf_index_1" id="all_buf_index_1">#</a></span></h3>
<!--type=property-->
<!--name=[index]-->

<!--type=property-->
<!--name=[index]-->

<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.

</p>
<p>获取或者设置在指定<code>index</code>索引位置的8位字节。这个值是指单个字节，所以这个值必须在合法的范围，16进制的<code>0x00</code> 到<code>0xFF</code>，或者<code>0</code> 到<code>255</code>。

</p>
<p>Example: copy an ASCII string into a buffer, one byte at a time:

</p>
<p>例子: 拷贝一个 ASCII 编码的 string 字符串到一个 buffer, 一次一个 byte 进行拷贝:

</p>
<pre><code>// node.js</code></pre>
<h3>buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])<span><a href="all.html#all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend_1" id="all_buf_copy_targetbuffer_targetstart_sourcestart_sourceend_1">#</a></span></h3>
<div><ul>
<li><code>targetBuffer</code> Buffer object - Buffer to copy into</li>
<li><code>targetStart</code> Number, Optional, Default: 0</li>
<li><code>sourceStart</code> Number, Optional, Default: 0</li>
<li><p><code>sourceEnd</code> Number, Optional, Default: <code>buffer.length</code></p>
</li>
<li><p><code>targetBuffer</code> Buffer 类型对象 - 将要进行拷贝的Buffer</p>
</li>
<li><code>targetStart</code> Number类型, 可选参数, 默认: 0</li>
<li><code>sourceStart</code> Number类型, 可选参数, 默认: 0</li>
<li><code>sourceEnd</code> Number类型, 可选参数, 默认: <code>buffer.length</code></li>
</div></ul>
<p>Does copy between buffers. The source and target regions can be overlapped.
<code>targetStart</code> and <code>sourceStart</code> default to <code>0</code>.
<code>sourceEnd</code> defaults to <code>buffer.length</code>.

</p>
<p>进行buffer的拷贝，源和目标可以是重叠的。
<code>targetStart</code> 目标开始偏移 和<code>sourceStart</code>源开始偏移 默认都是 <code>0</code>.
<code>sourceEnd</code> 源结束位置偏移默认是源的长度 <code>buffer.length</code>.

</p>
<p>All values passed that are <code>undefined</code>/<code>NaN</code> or are out of bounds are set equal
to their respective defaults.

</p>
<p>如果传递的值是<code>undefined</code>/<code>NaN</code> 或者是 out of bounds 超越边界的，就将设置为他们的默认值。（译者：这个默认值下面有的例子有说明）

</p>
<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.

</p>
<p>例子: 创建2个Buffer，然后把将<code>buf1</code>的16位到19位 拷贝到 <code>buf2</code>中，并且从<code>buf2</code>的第8位开始拷贝。

</p>
<pre><code>// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
<h3>buf.slice([start], [end])<span><a href="all.html#all_buf_slice_start_end_1" id="all_buf_slice_start_end_1">#</a></span></h3>
<div><ul>
<li><code>start</code> Number, Optional, Default: 0</li>
<li><p><code>end</code> Number, Optional, Default: <code>buffer.length</code></p>
</li>
<li><p><code>start</code> Number类型, 可选参数, 默认: 0</p>
</li>
<li><code>end</code> Number类型, 可选参数, 默认: <code>buffer.length</code></li>
</div></ul>
<p>Returns a new buffer which references the same memory as the old, but offset
and cropped by the <code>start</code> (defaults to <code>0</code>) and <code>end</code> (defaults to
<code>buffer.length</code>) indexes.  Negative indexes start from the end of the buffer.

</p>
<p>返回一个新的buffer，这个buffer将会和老的buffer引用相同的内存地址，只是根据 <code> start</code> (默认是 <code>0</code>) 和<code>end</code> (默认是<code>buffer.length</code>)  偏移和裁剪了索引。
负的索引是从buffer尾部开始计算的。

</p>
<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong>

</p>
<p><strong>修改这个新的buffer实例slice切片，也会改变原来的buffer</strong>

</p>
<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one
byte from the original Buffer.

</p>
<p>例子: 创建一个ASCII 字母的 Buffer，对它slice切片，然后修改源Buffer上的一个byte。

</p>
<pre><code>// abc
// !bc</code></pre>
<h3>buf.readUInt8(offset, [noAssert])<span><a href="all.html#all_buf_readuint8_offset_noassert_1" id="all_buf_readuint8_offset_noassert_1">#</a></span></h3>
<div><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</div></ul>
<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.

</p>
<p>从这个buffer对象里，根据指定的偏移量，读取一个 unsigned 8 bit integer整形。 

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x3
// 0x4
// 0x23
// 0x42</code></pre>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16le_offset_noassert_2" id="all_buf_readuint16le_offset_noassert_2">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16be_offset_noassert_2" id="all_buf_readuint16be_offset_noassert_2">#</a></span></h3>
<h3>buf.readUInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16le_offset_noassert_3" id="all_buf_readuint16le_offset_noassert_3">#</a></span></h3>
<h3>buf.readUInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint16be_offset_noassert_3" id="all_buf_readuint16be_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用特殊的 endian字节序格式读取一个 unsigned 16 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x0304
// 0x0403
// 0x0423
// 0x2304
// 0x2342
// 0x4223</code></pre>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32le_offset_noassert_2" id="all_buf_readuint32le_offset_noassert_2">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32be_offset_noassert_2" id="all_buf_readuint32be_offset_noassert_2">#</a></span></h3>
<h3>buf.readUInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32le_offset_noassert_3" id="all_buf_readuint32le_offset_noassert_3">#</a></span></h3>
<h3>buf.readUInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readuint32be_offset_noassert_3" id="all_buf_readuint32be_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 unsigned 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x03042342
// 0x42230403</code></pre>
<h3>buf.readInt8(offset, [noAssert])<span><a href="all.html#all_buf_readint8_offset_noassert_1" id="all_buf_readint8_offset_noassert_1">#</a></span></h3>
<div><ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</div></ul>
<p>Reads a signed 8 bit integer from the buffer at the specified offset.

</p>
<p>从这个buffer对象里，根据指定的偏移量，读取一个 signed 8 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<p>和 <code>buffer.readUInt8</code>一样的返回，除非buffer中包含了有作为2的补码的有符号值。

</p>
<h3>buf.readInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readint16le_offset_noassert_2" id="all_buf_readint16le_offset_noassert_2">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readint16be_offset_noassert_2" id="all_buf_readint16be_offset_noassert_2">#</a></span></h3>
<h3>buf.readInt16LE(offset, [noAssert])<span><a href="all.html#all_buf_readint16le_offset_noassert_3" id="all_buf_readint16le_offset_noassert_3">#</a></span></h3>
<h3>buf.readInt16BE(offset, [noAssert])<span><a href="all.html#all_buf_readint16be_offset_noassert_3" id="all_buf_readint16be_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a signed 16 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用特殊的 endian字节序格式读取一个 signed 16 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<p>和 buffer.readUInt16一样返回，除非buffer中包含了有作为2的补码的有符号值。

</p>
<h3>buf.readInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readint32le_offset_noassert_2" id="all_buf_readint32le_offset_noassert_2">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readint32be_offset_noassert_2" id="all_buf_readint32be_offset_noassert_2">#</a></span></h3>
<h3>buf.readInt32LE(offset, [noAssert])<span><a href="all.html#all_buf_readint32le_offset_noassert_3" id="all_buf_readint32le_offset_noassert_3">#</a></span></h3>
<h3>buf.readInt32BE(offset, [noAssert])<span><a href="all.html#all_buf_readint32be_offset_noassert_3" id="all_buf_readint32be_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a signed 32 bit integer from the buffer at the specified offset with
specified endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 signed 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&apos;s
complement signed values.

</p>
<p>和 buffer.readUInt32一样返回，除非buffer中包含了有作为2的补码的有符号值。

</p>
<h3>buf.readFloatLE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatle_offset_noassert_2" id="all_buf_readfloatle_offset_noassert_2">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatbe_offset_noassert_2" id="all_buf_readfloatbe_offset_noassert_2">#</a></span></h3>
<h3>buf.readFloatLE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatle_offset_noassert_3" id="all_buf_readfloatle_offset_noassert_3">#</a></span></h3>
<h3>buf.readFloatBE(offset, [noAssert])<span><a href="all.html#all_buf_readfloatbe_offset_noassert_3" id="all_buf_readfloatbe_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a 32 bit float from the buffer at the specified offset with specified
endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 32 bit float。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0x01</code></pre>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublele_offset_noassert_2" id="all_buf_readdoublele_offset_noassert_2">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublebe_offset_noassert_2" id="all_buf_readdoublebe_offset_noassert_2">#</a></span></h3>
<h3>buf.readDoubleLE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublele_offset_noassert_3" id="all_buf_readdoublele_offset_noassert_3">#</a></span></h3>
<h3>buf.readDoubleBE(offset, [noAssert])<span><a href="all.html#all_buf_readdoublebe_offset_noassert_3" id="all_buf_readdoublebe_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>offset</code> Number</li>
<li><code>noAssert</code> Boolean, Optional, Default: false</li>
<li><p>Return: Number</p>
</li>
<li><p><code>offset</code> Number类型</p>
</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
<li>Return: Number类型</li>
</ul>
<p>Reads a 64 bit double from the buffer at the specified offset with specified
endian format.

</p>
<p>从这个buffer对象里，根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 bit double。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>
may be beyond the end of the buffer. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>offset</code>偏移量参数。
这意味着 <code>offset</code>可能会超出buffer的末尾。默认是 <code>false</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 0.3333333333333333</code></pre>
<h3>buf.writeUInt8(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint8_value_offset_noassert_1" id="all_buf_writeuint8_value_offset_noassert_1">#</a></span></h3>
<div><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid unsigned 8 bit integer.

</p>
<p>根据指定的offset偏移量将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的unsigned 8 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer 03 04 23 42&gt;</code></pre>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16le_value_offset_noassert_2" id="all_buf_writeuint16le_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16be_value_offset_noassert_2" id="all_buf_writeuint16be_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeUInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16le_value_offset_noassert_3" id="all_buf_writeuint16le_value_offset_noassert_3">#</a></span></h3>
<h3>buf.writeUInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint16be_value_offset_noassert_3" id="all_buf_writeuint16be_value_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 16 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的unsigned 16 bit integer.

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer de ad be ef&gt;
// &lt;Buffer ad de ef be&gt;</code></pre>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32le_value_offset_noassert_2" id="all_buf_writeuint32le_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32be_value_offset_noassert_2" id="all_buf_writeuint32be_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeUInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32le_value_offset_noassert_3" id="all_buf_writeuint32le_value_offset_noassert_3">#</a></span></h3>
<h3>buf.writeUInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeuint32be_value_offset_noassert_3" id="all_buf_writeuint32be_value_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid unsigned 32 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的unsigned 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer fe ed fa ce&gt;
// &lt;Buffer ce fa ed fe&gt;</code></pre>
<h3>buf.writeInt8(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint8_value_offset_noassert_1" id="all_buf_writeint8_value_offset_noassert_1">#</a></span></h3>
<div><ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</div></ul>
<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a
valid signed 8 bit integer.

</p>
<p>根据指定的offset偏移量将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的 signed 8 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&apos;s complement
signed integer into <code>buffer</code>.

</p>
<p>和 <code>buffer.writeUInt8</code> 一样工作，除非是把有2的补码的 signed integer 有符号整形写入<code>buffer</code>。

</p>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16le_value_offset_noassert_2" id="all_buf_writeint16le_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16be_value_offset_noassert_2" id="all_buf_writeint16be_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeInt16LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16le_value_offset_noassert_3" id="all_buf_writeint16le_value_offset_noassert_3">#</a></span></h3>
<h3>buf.writeInt16BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint16be_value_offset_noassert_3" id="all_buf_writeint16be_value_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 16 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的 signed 16 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<p>和 <code>buffer.writeUInt16*</code> 一样工作，除非是把有2的补码的 signed integer 有符号整形写入<code>buffer</code>。

</p>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32le_value_offset_noassert_2" id="all_buf_writeint32le_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32be_value_offset_noassert_2" id="all_buf_writeint32be_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeInt32LE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32le_value_offset_noassert_3" id="all_buf_writeint32le_value_offset_noassert_3">#</a></span></h3>
<h3>buf.writeInt32BE(value, offset, [noAssert])<span><a href="all.html#all_buf_writeint32be_value_offset_noassert_3" id="all_buf_writeint32be_value_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid signed 32 bit integer.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个合法的 signed 32 bit integer。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&apos;s
complement signed integer into <code>buffer</code>.

</p>
<p>和 <code>buffer.writeUInt32*</code> 一样工作，除非是把有2的补码的 signed integer 有符号整形写入<code>buffer</code>。

</p>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatle_value_offset_noassert_2" id="all_buf_writefloatle_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatbe_value_offset_noassert_2" id="all_buf_writefloatbe_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeFloatLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatle_value_offset_noassert_3" id="all_buf_writefloatle_value_offset_noassert_3">#</a></span></h3>
<h3>buf.writeFloatBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writefloatbe_value_offset_noassert_3" id="all_buf_writefloatbe_value_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, behavior is unspecified if <code>value</code> is not a 32 bit float.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：当<code>value</code> 不是一个 32 bit float 类型的值时，结果将是不确定的。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer 4f 4a fe bb&gt;
// &lt;Buffer bb fe 4a 4f&gt;</code></pre>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublele_value_offset_noassert_2" id="all_buf_writedoublele_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublebe_value_offset_noassert_2" id="all_buf_writedoublebe_value_offset_noassert_2">#</a></span></h3>
<h3>buf.writeDoubleLE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublele_value_offset_noassert_3" id="all_buf_writedoublele_value_offset_noassert_3">#</a></span></h3>
<h3>buf.writeDoubleBE(value, offset, [noAssert])<span><a href="all.html#all_buf_writedoublebe_value_offset_noassert_3" id="all_buf_writedoublebe_value_offset_noassert_3">#</a></span></h3>
<ul>
<li><code>value</code> Number</li>
<li><code>offset</code> Number</li>
<li><p><code>noAssert</code> Boolean, Optional, Default: false</p>
</li>
<li><p><code>value</code> Number类型</p>
</li>
<li><code>offset</code> Number类型</li>
<li><code>noAssert</code> Boolean类型, 可选参数, 默认: false</li>
</ul>
<p>Writes <code>value</code> to the buffer at the specified offset with specified endian
format. Note, <code>value</code> must be a valid 64 bit double.

</p>
<p>根据指定的offset偏移量和指定的 endian字节序格式将<code>value</code>写入buffer。注意：<code>value</code> 必须是一个有效的 64 bit double 类型的值。

</p>
<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means
that <code>value</code> may be too large for the specific function and <code>offset</code> may be
beyond the end of the buffer leading to the values being silently dropped. This
should not be used unless you are certain of correctness. Defaults to <code>false</code>.

</p>
<p>设置参数 <code>noAssert</code>为true表示忽略验证<code>value</code>和<code>offset</code>参数。
这意味着 <code>value</code>可能过大，或者<code>offset</code>可能会超出buffer的末尾造成<code>value</code>被丢弃。
这个参数除了你非常有把握，否则不应该使用它。默认是 <code>false</code>。`.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
<h3>buf.fill(value, [offset], [end])<span><a href="all.html#all_buf_fill_value_offset_end_1" id="all_buf_fill_value_offset_end_1">#</a></span></h3>
<div><ul>
<li><code>value</code></li>
<li><code>offset</code> Number, Optional</li>
<li><p><code>end</code> Number, Optional</p>
</li>
<li><p><code>value</code></p>
</li>
<li><code>offset</code> Number类型, 可选参数</li>
<li><code>end</code> Number类型, 可选参数</li>
</div></ul>
<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)
and <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire
buffer.

</p>
<p>使用指定的value来填充这个buffer。如果 <code>offset</code> (默认是 <code>0</code>) 并且 <code>end</code> (默认是 <code>buffer.length</code>) 没有明确给出，就会填充整个buffer。
（译者：buf.fill调用的是C语言的memset函数非常高效）

</p>
<pre><code>var b = new Buffer(50);
b.fill(&quot;h&quot;);</code></pre>
<h2>buffer.INSPECT_MAX_BYTES<span><a href="all.html#all_buffer_inspect_max_bytes_1" id="all_buffer_inspect_max_bytes_1">#</a></span></h2>
<div><ul>
<li><p>Number, Default: 50</p>
</li>
<li><p>Number类型, 默认: 50</p>
</li>
</div></ul>
<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
be overridden by user modules.

</p>
<p>设置当调用<code>buffer.inspect()</code>方法后，多少bytes将会返回。这个值可以被用户模块重写。
（译者：这个值主要用在当我们打印console.log(buf)时，设置返回多少长度内容）

</p>
<p>Note that this is a property on the buffer module returned by
<code>require(&apos;buffer&apos;)</code>, not on the Buffer global, or a buffer instance.

</p>
<p>注意这个属性是<code>require(&apos;buffer&apos;)</code>模块返回的。这个属性不是在全局变量Buffer中，也不再buffer的实例里。 

</p>
<h2>类: SlowBuffer<span><a href="all.html#all_slowbuffer_1" id="all_slowbuffer_1">#</a></span></h2>
<p>Returns an un-pooled <code>Buffer</code>.

</p>
<p>返回一个不被池管理的 <code>Buffer</code>。

</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated Buffers, by default allocations under 4KB are sliced from a single
larger allocated object. This approach improves both performance and memory
usage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.

</p>
<p>为了避免创建大量独立分配的 Buffer 带来的垃圾回收开销，默认情况下小于 4KB 的空间都是切割自一个较大的独立对象。这种策略既提高了性能也改善了内存使用，因为 V8 不需要跟踪和清理很多 <code>Persistent</code> 对象。

</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time it may be appropriate to create an
un-pooled Buffer instance using SlowBuffer and copy out the relevant bits.

</p>
<p>当开发者需要将池中一小块数据保留不确定的一段时间，较为妥当的办法是用 SlowBuffer 创建一个不被池管理的 Buffer 实例并将相应数据拷贝出来。

</p>
<pre><code>socket.on(&apos;readable&apos;, function() {
  var data = socket.read();
  // 为需要保留的数据分配内存
  var sb = new SlowBuffer(10);
  // 将数据拷贝到新的空间中
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});</code></pre>
<p>Though this should used sparingly and only be a last resort <em>after</em> a developer
has actively observed undue memory retention in their applications.


</p>
<p>请谨慎使用，仅作为开发者频繁观察到他们的应用中过度的内存保留时的<em>最后</em>手段。
</p>
<h1>流<span><a href="all.html#all_67" id="all_67">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p>A stream is an abstract interface implemented by various objects in
Node.  For example a <a href="http.html#http_http_incomingmessage">request to an HTTP
server</a> is a stream, as is
<a href="process.html#process_process_stdout">stdout</a>. Streams are readable, writable, or both. All streams are
instances of <a href="events.html#events_class_events_eventemitter">EventEmitter</a>

</p>
<p>流是一个抽象接口，被 Node 中的很多对象所实现。比如<a href="http.html#http_http_incomingmessage">对一个 HTTP 服务器的请求</a>是一个流，<a href="process.html#process_process_stdout">stdout</a> 也是一个流。流是可读、可写或兼具两者的。所有流都是 <a href="events.html#events_class_events_eventemitter">EventEmitter</a> 的实例。

</p>
<p>You can load the Stream base classes by doing <code>require(&apos;stream&apos;)</code>.
There are base classes provided for <a href="all.html#stream_class_stream_readable">Readable</a> streams, <a href="all.html#stream_class_stream_writable">Writable</a>
streams, <a href="all.html#stream_class_stream_duplex">Duplex</a> streams, and <a href="all.html#stream_class_stream_transform">Transform</a> streams.

</p>
<p>您可以通过 <code>require(&apos;stream&apos;)</code> 加载 Stream 基类，其中包括了 <a href="all.html#stream_class_stream_readable">Readable</a> 流、<a href="all.html#stream_class_stream_writable">Writable</a> 流、<a href="all.html#stream_class_stream_duplex">Duplex</a> 流和 <a href="all.html#stream_class_stream_transform">Transform</a> 流的基类。

</p>
<p>This document is split up into 3 sections.  The first explains the
parts of the API that you need to be aware of to use streams in your
programs.  If you never implement a streaming API yourself, you can
stop there.

</p>
<p>本文档分为三个章节。第一章节解释了您在您的程序中使用流时需要了解的那部分 API，如果您不打算自己实现一个流式 API，您可以只阅读这一章节。

</p>
<p>The second section explains the parts of the API that you need to use
if you implement your own custom streams yourself.  The API is
designed to make this easy for you to do.

</p>
<p>第二章节解释了当您自己实现一个流时需要用到的那部分 API，这些 API 是为了方便您这么做而设计的。

</p>
<p>The third section goes into more depth about how streams work,
including some of the internal mechanisms and functions that you
should probably not modify unless you definitely know what you are
doing.

</p>
<p>第三章节深入讲解了流的工作方式，包括一些内部机制和函数，除非您明确知道您在做什么，否则尽量不要改动它们。

</p>
<h2>面向流消费者的 API<span><a href="all.html#all_api_2" id="all_api_2">#</a></span></h2>
<!--type=misc-->

<p>Streams can be either <a href="all.html#stream_class_stream_readable">Readable</a>, <a href="all.html#stream_class_stream_writable">Writable</a>, or both (<a href="all.html#stream_class_stream_duplex">Duplex</a>).

</p>
<p>流可以是可读（<a href="all.html#stream_class_stream_readable">Readable</a>）或可写（<a href="all.html#stream_class_stream_writable">Writable</a>），或者兼具两者（<a href="all.html#stream_class_stream_duplex">Duplex</a>，双工）的。

</p>
<p>All streams are EventEmitters, but they also have other custom methods
and properties depending on whether they are Readable, Writable, or
Duplex.

</p>
<p>所有流都是 EventEmitter，但它们也具有其它自定义方法和属性，取决于它们是 Readable、Writable 或 Duplex。

</p>
<p>If a stream is both Readable and Writable, then it implements all of
the methods and events below.  So, a <a href="all.html#stream_class_stream_duplex">Duplex</a> or <a href="all.html#stream_class_stream_transform">Transform</a> stream is
fully described by this API, though their implementation may be
somewhat different.

</p>
<p>如果一个流既可读（Readable）也可写（Writable），则它实现了下文所述的所有方法和事件。因此，这些 API 同时也涵盖了 <a href="all.html#stream_class_stream_duplex">Duplex</a> 或 <a href="all.html#stream_class_stream_transform">Transform</a> 流，即便它们的实现可能有点不同。

</p>
<p>It is not necessary to implement Stream interfaces in order to consume
streams in your programs.  If you <strong>are</strong> implementing streaming
interfaces in your own program, please also refer to
<a href="all.html#stream_api_for_stream_implementors">API for Stream Implementors</a> below.

</p>
<p>为了消费流而在您的程序中自己实现 Stream 接口是没有必要的。如果您<strong>确实</strong>正在您自己的程序中实现流式接口，请同时参考下文<a href="all.html#stream_api_for_stream_implementors">面向流实现者的 API</a>。

</p>
<p>Almost all Node programs, no matter how simple, use Streams in some
way.  Here is an example of using Streams in a Node program:

</p>
<p>几乎所有 Node 程序，无论多简单，都在某种途径用到了流。这里有一个使用流的 Node 程序的例子：

</p>
<pre><code>var http = require(&apos;http&apos;);

var server = http.createServer(function (req, res) {
  // req is an http.IncomingMessage, which is a Readable Stream
  // res is an http.ServerResponse, which is a Writable Stream

var server = http.createServer(function (req, res) {
  // req 为 http.IncomingMessage，是一个可读流（Readable Stream）
  // res 为 http.ServerResponse，是一个可写流（Writable Stream）

  var body = &apos;&apos;;
  // we want to get the data as utf8 strings
  // If you don&apos;t set an encoding, then you&apos;ll get Buffer objects
  req.setEncoding(&apos;utf8&apos;);

  var body = &apos;&apos;;
  // 我们打算以 UTF-8 字符串的形式获取数据
  // 如果您不设置编码，您将得到一个 Buffer 对象
  req.setEncoding(&apos;utf8&apos;);

  // Readable streams emit &apos;data&apos; events once a listener is added
  req.on(&apos;data&apos;, function (chunk) {
    body += chunk;
  })

  // 一旦监听器被添加，可读流会触发 &apos;data&apos; 事件
  req.on(&apos;data&apos;, function (chunk) {
    body += chunk;
  })

  // the end event tells you that you have entire body
  req.on(&apos;end&apos;, function () {
    try {
      var data = JSON.parse(body);
    } catch (er) {
      // uh oh!  bad json!
      res.statusCode = 400;
      return res.end(&apos;error: &apos; + er.message);
    }

  // &apos;end&apos; 事件表明您已经得到了完整的 body
  req.on(&apos;end&apos;, function () {
    try {
      var data = JSON.parse(body);
    } catch (er) {
      // uh oh!  bad json!
      res.statusCode = 400;
      return res.end(&apos;错误: &apos; + er.message);
    }

    // write back something interesting to the user:
    res.write(typeof data);
    res.end();
  })
})

    // 向用户回写一些有趣的信息
    res.write(typeof data);
    res.end();
  })
})

server.listen(1337);

server.listen(1337);

// $ curl localhost:1337 -d &apos;{}&apos;
// object
// $ curl localhost:1337 -d &apos;&quot;foo&quot;&apos;
// string
// $ curl localhost:1337 -d &apos;not json&apos;
// 错误: Unexpected token o</code></pre>
<h3>类: stream.Readable<span><a href="all.html#all_stream_readable_2" id="all_stream_readable_2">#</a></span></h3>
<!--type=class-->

<p>The Readable stream interface is the abstraction for a <em>source</em> of
data that you are reading from.  In other words, data comes <em>out</em> of a
Readable stream.

</p>
<p>Readable（可读）流接口是对您正在读取的数据的<em>来源</em>的抽象。换言之，数据<em>出自</em>一个 Readable 流。

</p>
<p>A Readable stream will not start emitting data until you indicate that
you are ready to receive it.

</p>
<p>在您表明您就绪接收之前，Readable 流并不会开始发生数据。

</p>
<p>Readable streams have two &quot;modes&quot;: a <strong>flowing mode</strong> and a <strong>paused
mode</strong>.  When in flowing mode, data is read from the underlying system
and provided to your program as fast as possible.  In paused mode, you
must explicitly call <code>stream.read()</code> to get chunks of data out.
Streams start out in paused mode.

</p>
<p>Readable 流有两种“模式”：<strong>流动模式</strong>和<strong>暂停模式</strong>。当处于流动模式时，数据由底层系统读出，并尽可能快地提供给您的程序；当处于暂停模式时，您必须明确地调用 <code>stream.read()</code> 来取出若干数据块。流默认处于暂停模式。

</p>
<p><strong>Note</strong>: If no data event handlers are attached, and there are no
<a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> destinations, and the stream is switched into flowing
mode, then data will be lost.

</p>
<p><strong>注意</strong>：如果没有绑定 data 事件处理器，并且没有 <a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> 目标，同时流被切换到流动模式，那么数据会流失。

</p>
<p>You can switch to flowing mode by doing any of the following:

</p>
<p>您可以通过下面几种做法切换到流动模式：

</p>
<ul>
<li>Adding a <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a> handler to listen for data.</li>
<li>Calling the <a href="all.html#stream_readable_resume"><code>resume()</code></a> method to explicitly open the flow.</li>
<li><p>Calling the <a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> method to send the data to a <a href="all.html#stream_class_stream_writable">Writable</a>.</p>
</li>
<li><p>添加一个 <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>处理器来监听数据。</p>
</li>
<li>调用 <a href="all.html#stream_readable_resume"><code>resume()</code></a> 方法来明确开启数据流。</li>
<li>调用 <a href="all.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> 方法将数据发送到一个 <a href="all.html#stream_class_stream_writable">Writable</a>。</li>
</ul>
<p>You can switch back to paused mode by doing either of the following:

</p>
<p>您可以通过下面其中一种做法切换回暂停模式：

</p>
<ul>
<li>If there are no pipe destinations, by calling the <a href="all.html#stream_readable_pause"><code>pause()</code></a>
method.</li>
<li><p>If there are pipe destinations, by removing any <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a>
handlers, and removing all pipe destinations by calling the
<a href="all.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> method.</p>
</li>
<li><p>如果没有导流目标，调用 <a href="all.html#stream_readable_pause"><code>pause()</code></a> 方法。</p>
</li>
<li>如果有导流目标，移除所有 [<code>&apos;data&apos;</code> 事件][] 处理器、调用 <a href="all.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> 方法移除所有导流目标。</li>
</ul>
<p>Note that, for backwards compatibility reasons, removing <code>&apos;data&apos;</code>
event handlers will <strong>not</strong> automatically pause the stream.  Also, if
there are piped destinations, then calling <code>pause()</code> will not
guarantee that the stream will <em>remain</em> paused once those
destinations drain and ask for more data.

</p>
<p>请注意，为了向后兼容考虑，移除 <code>&apos;data&apos;</code> 事件监听器并<strong>不会</strong>自动暂停流。同样的，当有导流目标时，调用 <code>pause()</code> 并不能保证流在那些目标排空并请求更多数据时<em>维持</em>暂停状态。

</p>
<p>Examples of readable streams include:

</p>
<p>一些可读流的例子：

</p>
<ul>
<li><a href="http.html#http_http_incomingmessage">http responses, on the client</a></li>
<li><a href="http.html#http_http_incomingmessage">http requests, on the server</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs read streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdout">child process stdout and stderr</a></li>
<li><a href="process.html#process_process_stdin">process.stdin</a></li>
</ul>
<ul>
<li><a href="http.html#http_http_incomingmessage">客户端上的 HTTP 响应</a></li>
<li><a href="http.html#http_http_incomingmessage">服务器上的 HTTP 请求</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs 读取流</a></li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
<li><a href="net.html#net_class_net_socket">TCP 嵌套字</a></li>
<li><a href="child_process.html#child_process_child_stdout">子进程的 stdout 和 stderr</a></li>
<li><a href="process.html#process_process_stdin">process.stdin</a></li>
</ul>
<h4>事件: &apos;readable&apos;<span><a href="all.html#all_readable_1" id="all_readable_1">#</a></span></h4>
<p>When a chunk of data can be read from the stream, it will emit a
<code>&apos;readable&apos;</code> event.

</p>
<p>当一个数据块可以从流中被读出时，它会触发一个 <code>&apos;readable&apos;</code> 事件。

</p>
<p>In some cases, listening for a <code>&apos;readable&apos;</code> event will cause some data
to be read into the internal buffer from the underlying system, if it
hadn&apos;t already.

</p>
<p>在某些情况下，假如未准备好，监听一个 <code>&apos;readable&apos;</code> 事件会使得一些数据从底层系统被读出到内部缓冲区中。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;readable&apos;, function() {
  // 现在有数据可以读了
})</code></pre>
<p>Once the internal buffer is drained, a <code>readable</code> event will fire
again when more data is available.

</p>
<p>当内部缓冲区被排空后，一旦更多数据时，一个 <code>readable</code> 事件会被再次触发。

</p>
<h4>事件: &apos;data&apos;<span><a href="all.html#all_data_2" id="all_data_2">#</a></span></h4>
<div><ul>
<li><p><code>chunk</code> <span>Buffer | String</span> The chunk of data.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 数据块。</p>
</li>
</div></ul>
<p>Attaching a <code>data</code> event listener to a stream that has not been
explicitly paused will switch the stream into flowing mode. Data will
then be passed as soon as it is available.

</p>
<p>绑定一个 <code>data</code> 事件监听器到一个未被明确暂停的流会将流切换到流动模式，数据会被尽可能地传递。

</p>
<p>If you just want to get all the data out of the stream as fast as
possible, this is the best way to do so.

</p>
<p>如果您想从流尽快取出所有数据，这是最理想的方式。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
})</code></pre>
<h4>事件: &apos;end&apos;<span><a href="all.html#all_end_2" id="all_end_2">#</a></span></h4>
<p>This event fires when no more data will be provided.

</p>
<p>该事件会在没有更多数据能够提供时被触发。

</p>
<p>Note that the <code>end</code> event <strong>will not fire</strong> unless the data is
completely consumed.  This can be done by switching into flowing mode,
or by calling <code>read()</code> repeatedly until you get to the end.

</p>
<p>请注意，<code>end</code> 事件在数据被完全消费之前<strong>不会被触发</strong>。这可通过切换到流动模式，或者在到达末端前不断调用 <code>read()</code> 来实现。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
})
readable.on(&apos;end&apos;, function() {
  console.log(&apos;读取完毕。&apos;);
});</code></pre>
<h4>事件: &apos;close&apos;<span><a href="all.html#all_close_9" id="all_close_9">#</a></span></h4>
<p>Emitted when the underlying resource (for example, the backing file
descriptor) has been closed. Not all streams will emit this.

</p>
<p>当底层数据源（比如，源头的文件描述符）被关闭时触发。并不是所有流都会触发这个事件。

</p>
<h4>事件: &apos;error&apos;<span><a href="all.html#all_error_8" id="all_error_8">#</a></span></h4>
<p>Emitted if there was an error receiving data.

</p>
<p>当数据接收时发生错误时触发。

</p>
<h4>readable.read([size])<span><a href="all.html#all_readable_read_size_2" id="all_readable_read_size_2">#</a></span></h4>
<div><ul>
<li><code>size</code> <span>Number</span> Optional argument to specify how much data to read.</li>
<li><p>Return <span>String | Buffer | null</span></p>
</li>
<li><p><code>size</code> <span>Number</span> 可选参数，指定要读取多少数据。</p>
</li>
<li>返回 <span>String | Buffer | null</span></li>
</div></ul>
<p>The <code>read()</code> method pulls some data out of the internal buffer and
returns it.  If there is no data available, then it will return
<code>null</code>.

</p>
<p><code>read()</code> 方法从内部缓冲区中拉取并返回若干数据。当没有更多数据可用时，它会返回 <code>null</code>。

</p>
<p>If you pass in a <code>size</code> argument, then it will return that many
bytes.  If <code>size</code> bytes are not available, then it will return <code>null</code>.

</p>
<p>若您传入了一个 <code>size</code> 参数，那么它会返回相当字节的数据；当 <code>size</code> 字节不可用时，它则返回 <code>null</code>。

</p>
<p>If you do not specify a <code>size</code> argument, then it will return all the
data in the internal buffer.

</p>
<p>若您没有指定 <code>size</code> 参数，那么它会返回内部缓冲区中的所有数据。

</p>
<p>This method should only be called in paused mode.  In flowing mode,
this method is called automatically until the internal buffer is
drained.

</p>
<p>该方法仅应在暂停模式时被调用。在流动模式中，该方法会被自动调用直到内部缓冲区排空。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;readable&apos;, function() {
  var chunk;
  while (null !== (chunk = readable.read())) {
    console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
  }
});</code></pre>
<p>If this method returns a data chunk, then it will also trigger the
emission of a <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a>.

</p>
<p>当该方法返回了一个数据块，它同时也会触发 <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>。

</p>
<h4>readable.setEncoding(encoding)<span><a href="all.html#all_readable_setencoding_encoding_1" id="all_readable_setencoding_encoding_1">#</a></span></h4>
<div><ul>
<li><code>encoding</code> <span>String</span> The encoding to use.</li>
<li><p>Return: <code>this</code></p>
</li>
<li><p><code>encoding</code> <span>String</span> 要使用的编码。</p>
</li>
<li>返回: <code>this</code></li>
</div></ul>
<p>Call this function to cause the stream to return strings of the
specified encoding instead of Buffer objects.  For example, if you do
<code>readable.setEncoding(&apos;utf8&apos;)</code>, then the output data will be
interpreted as UTF-8 data, and returned as strings.  If you do
<code>readable.setEncoding(&apos;hex&apos;)</code>, then the data will be encoded in
hexadecimal string format.

</p>
<p>调用此函数会使得流返回指定编码的字符串而不是 Buffer 对象。比如，当您 <code>readable.setEncoding(&apos;utf8&apos;)</code>，那么输出数据会被作为 UTF-8 数据解析，并以字符串返回。如果您 <code>readable.setEncoding(&apos;hex&apos;)</code>，那么数据会被编码成十六进制字符串格式。

</p>
<p>This properly handles multi-byte characters that would otherwise be
potentially mangled if you simply pulled the Buffers directly and
called <code>buf.toString(encoding)</code> on them.  If you want to read the data
as strings, always use this method.

</p>
<p>该方法能正确处理多字节字符。假如您不这么做，仅仅直接取出 Buffer 并对它们调用 <code>buf.toString(encoding)</code>，很可能会导致字节错位。因此如果您打算以字符串读取数据，请总是使用这个方法。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.setEncoding(&apos;utf8&apos;);
readable.on(&apos;data&apos;, function(chunk) {
  assert.equal(typeof chunk, &apos;string&apos;);
  console.log(&apos;得到了 %d 个字符的字符串数据&apos;, chunk.length);
})</code></pre>
<h4>readable.resume()<span><a href="all.html#all_readable_resume_1" id="all_readable_resume_1">#</a></span></h4>
<div><ul>
<li><p>Return: <code>this</code></p>
</li>
<li><p>返回: <code>this</code></p>
</li>
</div></ul>
<p>This method will cause the readable stream to resume emitting <code>data</code>
events.

</p>
<p>该方法让可读流继续触发 <code>data</code> 事件。

</p>
<p>This method will switch the stream into flowing mode.  If you do <em>not</em>
want to consume the data from a stream, but you <em>do</em> want to get to
its <code>end</code> event, you can call <a href="all.html#stream_readable_resume"><code>readable.resume()</code></a> to open the flow of
data.

</p>
<p>该方法会将流切换到流动模式。如果您<em>不想</em>从流中消费数据，但您<em>想</em>得到它的 <code>end</code> 事件，您可以调用 <a href="all.html#stream_readable_resume"><code>readable.resume()</code></a> 来启动数据流。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.resume();
readable.on(&apos;end&apos;, function(chunk) {
  console.log(&apos;到达末端，但并未读取任何东西&apos;);
})</code></pre>
<h4>readable.pause()<span><a href="all.html#all_readable_pause_1" id="all_readable_pause_1">#</a></span></h4>
<div><ul>
<li><p>Return: <code>this</code></p>
</li>
<li><p>返回: <code>this</code></p>
</li>
</div></ul>
<p>This method will cause a stream in flowing mode to stop emitting
<code>data</code> events, switching out of flowing mode.  Any data that becomes
available will remain in the internal buffer.

</p>
<p>该方法会使一个处于流动模式的流停止触发 <code>data</code> 事件，切换到非流动模式，并让后续可用数据留在内部缓冲区中。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;取得 %d 字节数据&apos;, chunk.length);
  readable.pause();
  console.log(&apos;接下来 1 秒内不会有数据&apos;);
  setTimeout(function() {
    console.log(&apos;现在数据会再次开始流动&apos;);
    readable.resume();
  }, 1000);
})</code></pre>
<h4>readable.pipe(destination, [options])<span><a href="all.html#all_readable_pipe_destination_options_1" id="all_readable_pipe_destination_options_1">#</a></span></h4>
<div><ul>
<li><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> The destination for writing data</li>
<li><p><code>options</code> <span>Object</span> Pipe options</p>
<ul>
<li><code>end</code> <span>Boolean</span> End the writer when the reader ends. Default = <code>true</code></li>
</ul>
</li>
<li><p><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> 写入数据的目标</p>
</li>
<li><code>options</code> <span>Object</span> 导流选项<ul>
<li><code>end</code> <span>Boolean</span> 在读取者结束时结束写入者。缺省为 <code>true</code></li>
</ul>
</li>
</div></ul>
<p>This method pulls all the data out of a readable stream, and writes it
to the supplied destination, automatically managing the flow so that
the destination is not overwhelmed by a fast readable stream.

</p>
<p>该方法从可读流中拉取所有数据，并写入到所提供的目标。该方法能自动控制流量以避免目标被快速读取的可读流所淹没。

</p>
<p>Multiple destinations can be piped to safely.

</p>
<p>可以导流到多个目标。

</p>
<pre><code>var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&apos;file.txt&apos;);
// 所有来自 readable 的数据会被写入到 &apos;file.txt&apos;
readable.pipe(writable);</code></pre>
<p>This function returns the destination stream, so you can set up pipe
chains like so:

</p>
<p>该函数返回目标流，因此您可以建立导流链：

</p>
<pre><code>var r = fs.createReadStream(&apos;file.txt&apos;);
var z = zlib.createGzip();
var w = fs.createWriteStream(&apos;file.txt.gz&apos;);
r.pipe(z).pipe(w);</code></pre>
<p>For example, emulating the Unix <code>cat</code> command:

</p>
<p>例如，模拟 Unix 的 <code>cat</code> 命令：

</p>
<pre><code>process.stdin.pipe(process.stdout);</code></pre>
<p>By default <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> is called on the destination when the source stream
emits <code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end:
false }</code> as <code>options</code> to keep the destination stream open.

</p>
<p>缺省情况下当来源流触发 <code>end</code> 时目标的 <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 会被调用，所以此时 <code>destination</code> 不再可写。传入 <code>{ end: false }</code> 作为 <code>options</code> 可以让目标流保持开启状态。

</p>
<p>This keeps <code>writer</code> open so that &quot;Goodbye&quot; can be written at the
end.

</p>
<p>这将让 <code>writer</code> 保持开启，因此最后可以写入 &quot;Goodbye&quot;。

</p>
<pre><code>reader.pipe(writer, { end: false });
reader.on(&apos;end&apos;, function() {
  writer.end(&apos;Goodbye\n&apos;);
});</code></pre>
<p>Note that <code>process.stderr</code> and <code>process.stdout</code> are never closed until
the process exits, regardless of the specified options.

</p>
<p>请注意 <code>process.stderr</code> 和 <code>process.stdout</code> 在进程结束前都不会被关闭，无论是否指定选项。

</p>
<h4>readable.unpipe([destination])<span><a href="all.html#all_readable_unpipe_destination_1" id="all_readable_unpipe_destination_1">#</a></span></h4>
<div><ul>
<li><p><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> Optional specific stream to unpipe</p>
</li>
<li><p><code>destination</code> <span><a href="all.html#stream_class_stream_writable">Writable</a> Stream</span> 可选，指定解除导流的流</p>
</li>
</div></ul>
<p>This method will remove the hooks set up for a previous <code>pipe()</code> call.

</p>
<p>该方法会移除之前调用 <code>pipe()</code> 所设定的钩子。

</p>
<p>If the destination is not specified, then all pipes are removed.

</p>
<p>如果不指定目标，所有导流都会被移除。

</p>
<p>If the destination is specified, but no pipe is set up for it, then
this is a no-op.

</p>
<p>如果指定了目标，但并没有与之建立导流，则什么事都不会发生。

</p>
<pre><code>var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&apos;file.txt&apos;);
// 来自 readable 的所有数据都会被写入 &apos;file.txt&apos;,
// 但仅发生在第 1 秒
readable.pipe(writable);
setTimeout(function() {
  console.log(&apos;停止写入到 file.txt&apos;);
  readable.unpipe(writable);
  console.log(&apos;自行关闭文件流&apos;);
  writable.end();
}, 1000);</code></pre>
<h4>readable.unshift(chunk)<span><a href="all.html#all_readable_unshift_chunk_1" id="all_readable_unshift_chunk_1">#</a></span></h4>
<div><ul>
<li><p><code>chunk</code> <span>Buffer | String</span> Chunk of data to unshift onto the read queue</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要插回读取队列开头的数据块</p>
</li>
</div></ul>
<p>This is useful in certain cases where a stream is being consumed by a
parser, which needs to &quot;un-consume&quot; some data that it has
optimistically pulled out of the source, so that the stream can be
passed on to some other party.

</p>
<p>该方法在许多场景中都很有用，比如一个流正在被一个解析器消费，解析器可能需要将某些刚拉取出的数据“逆消费”回来源，以便流能将它传递给其它消费者。

</p>
<p>If you find that you must often call <code>stream.unshift(chunk)</code> in your
programs, consider implementing a <a href="all.html#stream_class_stream_transform">Transform</a> stream instead.  (See API
for Stream Implementors, below.)

</p>
<p>如果您发现您需要在您的程序中频繁调用 <code>stream.unshift(chunk)</code>，请考虑实现一个 <a href="all.html#stream_class_stream_transform">Transform</a> 流。（详见下文面向流实现者的 API。）

</p>
<pre><code>// 取出以 \n\n 分割的头部并将多余部分 unshift() 回去
// callback 以 (error, header, stream) 形式调用
var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;
function parseHeader(stream, callback) {
  stream.on(&apos;error&apos;, callback);
  stream.on(&apos;readable&apos;, onReadable);
  var decoder = new StringDecoder(&apos;utf8&apos;);
  var header = &apos;&apos;;
  function onReadable() {
    var chunk;
    while (null !== (chunk = stream.read())) {
      var str = decoder.write(chunk);
      if (str.match(/\n\n/)) {
        // 找到头部边界
        var split = str.split(/\n\n/);
        header += split.shift();
        var remaining = split.join(&apos;\n\n&apos;);
        var buf = new Buffer(remaining, &apos;utf8&apos;);
        if (buf.length)
          stream.unshift(buf);
        stream.removeListener(&apos;error&apos;, callback);
        stream.removeListener(&apos;readable&apos;, onReadable);
        // 现在可以从流中读取消息的主体了
        callback(null, header, stream);
      } else {
        // 仍在读取头部
        header += str;
      }
    }
  }
}</code></pre>
<h4>readable.wrap(stream)<span><a href="all.html#all_readable_wrap_stream_1" id="all_readable_wrap_stream_1">#</a></span></h4>
<div><ul>
<li><p><code>stream</code> <span>Stream</span> An &quot;old style&quot; readable stream</p>
</li>
<li><p><code>stream</code> <span>Stream</span> 一个“旧式”可读流</p>
</li>
</div></ul>
<p>Versions of Node prior to v0.10 had streams that did not implement the
entire Streams API as it is today.  (See &quot;Compatibility&quot; below for
more information.)

</p>
<p>Node v0.10 版本之前的流并未实现现今所有流 API。（更多信息详见下文“兼容性”章节。）

</p>
<p>If you are using an older Node library that emits <code>&apos;data&apos;</code> events and
has a <a href="all.html#stream_readable_pause"><code>pause()</code></a> method that is advisory only, then you can use the
<code>wrap()</code> method to create a <a href="all.html#stream_class_stream_readable">Readable</a> stream that uses the old stream
as its data source.

</p>
<p>如果您正在使用早前版本的 Node 库，它触发 <code>&apos;data&apos;</code> 事件并且有一个仅作查询用途的 <a href="all.html#stream_readable_pause"><code>pause()</code></a> 方法，那么您可以使用 <code>wrap()</code> 方法来创建一个使用旧式流作为数据源的 <a href="all.html#stream_class_stream_readable">Readable</a> 流。

</p>
<p>You will very rarely ever need to call this function, but it exists
as a convenience for interacting with old Node programs and libraries.

</p>
<p>您可能很少需要用到这个函数，但它会作为与旧 Node 程序和库交互的简便方法存在。

</p>
<p>For example:

</p>
<p>例如：

</p>
<pre><code>myReader.on(&apos;readable&apos;, function() {
myReader.read(); // etc.
});</code></pre>
<h3>类: stream.Writable<span><a href="all.html#all_stream_writable_2" id="all_stream_writable_2">#</a></span></h3>
<!--type=class-->

<p>The Writable stream interface is an abstraction for a <em>destination</em>
that you are writing data <em>to</em>.

</p>
<p>Writable（可写）流接口是对您正在写入数据<em>至一个目标</em>的抽象。

</p>
<p>Examples of writable streams include:

</p>
<p>一些可写流的例子：

</p>
<ul>
<li><a href="http.html#http_class_http_clientrequest">http requests, on the client</a></li>
<li><a href="http.html#http_class_http_serverresponse">http responses, on the server</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="process.html#process_process_stdout">process.stdout</a>, <a href="process.html#process_process_stderr">process.stderr</a></li>
</ul>
<ul>
<li><a href="http.html#http_class_http_clientrequest">http requests, on the client</a></li>
<li><a href="http.html#http_class_http_serverresponse">http responses, on the server</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="process.html#process_process_stdout">process.stdout</a>, <a href="process.html#process_process_stderr">process.stderr</a></li>
</ul>
<h4>writable.write(chunk, [encoding], [callback])<span><a href="all.html#all_writable_write_chunk_encoding_callback_2" id="all_writable_write_chunk_encoding_callback_2">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>String | Buffer</span> The data to write</li>
<li><code>encoding</code> <span>String</span> The encoding, if <code>chunk</code> is a String</li>
<li><code>callback</code> <span>Function</span> Callback for when this chunk of data is flushed</li>
<li>Returns: <span>Boolean</span> True if the data was handled completely.</li>
</div></ul>
<ul>
<li><code>chunk</code> {String | Buffer} 要写入的数据</li>
<li><code>encoding</code> {String} 编码，假如 <code>chunk</code> 是一个字符串</li>
<li><code>callback</code> {Function} 数据块写入后的回调</li>
<li>返回: {Boolean} 如果数据已被全部处理则 <code>true</code>。</li>
</ul>
<p>This method writes some data to the underlying system, and calls the
supplied callback once the data has been fully handled.

</p>
<p>该方法向底层系统写入数据，并在数据被处理完毕后调用所给的回调。

</p>
<p>The return value indicates if you should continue writing right now.
If the data had to be buffered internally, then it will return
<code>false</code>.  Otherwise, it will return <code>true</code>.

</p>
<p>返回值表明您是否应该立即继续写入。如果数据需要滞留在内部，则它会返回 <code>false</code>；否则，返回 <code>true</code>。

</p>
<p>This return value is strictly advisory.  You MAY continue to write,
even if it returns <code>false</code>.  However, writes will be buffered in
memory, so it is best not to do this excessively.  Instead, wait for
the <code>drain</code> event before writing more data.

</p>
<p>返回值所表示的状态仅供参考，您【可以】在即便返回 <code>false</code> 的时候继续写入。但是，写入的数据会被滞留在内存中，所以最好不要过分地这么做。最好的做法是等待 <code>drain</code> 事件发生后再继续写入更多数据。

</p>
<h4>事件: &apos;drain&apos;<span><a href="all.html#all_drain_2" id="all_drain_2">#</a></span></h4>
<p>If a <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> call returns false, then the <code>drain</code>
event will indicate when it is appropriate to begin writing more data
to the stream.

</p>
<p>如果一个 <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> 调用返回 <code>false</code>，那么 <code>drain</code> 事件则表明可以继续向流写入更多数据。

</p>
<pre><code>// 向所给可写流写入 1000000 次数据。
// 注意后端压力。
function writeOneMillionTimes(writer, data, encoding, callback) {
  var i = 1000000;
  write();
  function write() {
    var ok = true;
    do {
      i -= 1;
      if (i === 0) {
        // 最后一次！
        writer.write(data, encoding, callback);
      } else {
        // 检查我们应该继续还是等待
        // 不要传递回调，因为我们还没完成。
        ok = writer.write(data, encoding);
      }
    } while (i &gt; 0 &amp;&amp; ok);
    if (i &gt; 0) {
      // 不得不提前停止！
      // 一旦它排空，继续写入数据
      writer.once(&apos;drain&apos;, write);
    }
  }
}</code></pre>
<h4>writable.cork()<span><a href="all.html#all_writable_cork_1" id="all_writable_cork_1">#</a></span></h4>
<p>Forces buffering of all writes.

</p>
<p>强行滞留所有写入。

</p>
<p>Buffered data will be flushed either at <code>.uncork()</code> or at <code>.end()</code> call.

</p>
<p>滞留的数据会在 <code>.uncork()</code> 或 <code>.end()</code> 调用时被写入。

</p>
<h4>writable.uncork()<span><a href="all.html#all_writable_uncork_1" id="all_writable_uncork_1">#</a></span></h4>
<p>Flush all data, buffered since <code>.cork()</code> call.

</p>
<p>写入所有 <code>.cork()</code> 调用之后滞留的数据。

</p>
<h4>writable.end([chunk], [encoding], [callback])<span><a href="all.html#all_writable_end_chunk_encoding_callback_1" id="all_writable_end_chunk_encoding_callback_1">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>String | Buffer</span> Optional data to write</li>
<li><code>encoding</code> <span>String</span> The encoding, if <code>chunk</code> is a String</li>
<li><p><code>callback</code> <span>Function</span> Optional callback for when the stream is finished</p>
</li>
<li><p><code>chunk</code> <span>String | Buffer</span> 可选，要写入的数据</p>
</li>
<li><code>encoding</code> <span>String</span> 编码，假如 chunk 是一个字符串</li>
<li><code>callback</code> <span>Function</span> 可选，流结束后的回调</li>
</div></ul>
<p>Call this method when no more data will be written to the stream.  If
supplied, the callback is attached as a listener on the <code>finish</code> event.

</p>
<p>当没有更多数据会被写入到流时调用此方法。如果给出，回调会被用作 <code>finish</code> 事件的监听器。

</p>
<p>Calling <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> after calling <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> will raise an error.

</p>
<p>在调用 <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 后调用 <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> 会产生错误。

</p>
<pre><code>// 写入 &apos;hello, &apos; 然后以 &apos;world!&apos; 结束
http.createServer(function (req, res) {
  res.write(&apos;hello, &apos;);
  res.end(&apos;world!&apos;);
  // 现在不允许继续写入了
});</code></pre>
<h4>事件: &apos;finish&apos;<span><a href="all.html#all_finish_1" id="all_finish_1">#</a></span></h4>
<p>When the <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> method has been called, and all data has been flushed
to the underlying system, this event is emitted.

</p>
<p>当 <a href="all.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 方法被调用，并且所有数据已被写入到底层系统，此事件会被触发。

</p>
<pre><code>var writer = getWritableStreamSomehow();
for (var i = 0; i &lt; 100; i ++) {
  writer.write(&apos;hello, #&apos; + i + &apos;!\n&apos;);
}
writer.end(&apos;this is the end\n&apos;);
write.on(&apos;finish&apos;, function() {
  console.error(&apos;已完成所有写入。&apos;);
});</code></pre>
<h4>事件: &apos;pipe&apos;<span><a href="all.html#all_pipe_1" id="all_pipe_1">#</a></span></h4>
<div><ul>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> source stream that is piping to this writable</p>
</li>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> 导流到本可写流的来源流</p>
</li>
</div></ul>
<p>This is emitted whenever the <code>pipe()</code> method is called on a readable
stream, adding this writable to its set of destinations.

</p>
<p>该事件发生于可读流的 <code>pipe()</code> 方法被调用并添加本可写流作为它的目标时。

</p>
<pre><code>var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&apos;pipe&apos;, function(src) {
  console.error(&apos;某些东西正被导流到 writer&apos;);
  assert.equal(src, reader);
});
reader.pipe(writer);</code></pre>
<h4>事件: &apos;unpipe&apos;<span><a href="all.html#all_unpipe_1" id="all_unpipe_1">#</a></span></h4>
<div><ul>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> The source stream that <a href="all.html#stream_readable_unpipe_destination">unpiped</a> this writable</p>
</li>
<li><p><code>src</code> <span><a href="all.html#stream_class_stream_readable">Readable</a> Stream</span> <a href="all.html#stream_readable_unpipe_destination">unpiped</a> 本可写流的来源流</p>
</li>
</div></ul>
<p>This is emitted whenever the <a href="all.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> method is called on a
readable stream, removing this writable from its set of destinations.

</p>
<p>该事件发生于可读流的 <code>unpipe()</code> 方法被调用并将本可写流从它的目标移除时。

</p>
<pre><code>var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&apos;unpipe&apos;, function(src) {
  console.error(&apos;某写东西停止导流到 writer 了&apos;);
  assert.equal(src, reader);
});
reader.pipe(writer);
reader.unpipe(writer);</code></pre>
<h3>类: stream.Duplex<span><a href="all.html#all_stream_duplex_2" id="all_stream_duplex_2">#</a></span></h3>
<p>Duplex streams are streams that implement both the <a href="all.html#stream_class_stream_readable">Readable</a> and
<a href="all.html#stream_class_stream_writable">Writable</a> interfaces.  See above for usage.

</p>
<p>双工（Duplex）流同时实现了 <a href="all.html#stream_class_stream_readable">Readable</a> 和 <a href="all.html#stream_class_stream_writable">Writable</a> 的接口。详见下文用例。

</p>
<p>Examples of Duplex streams include:

</p>
<p>一些双工流的例子：

</p>
<ul>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><p><a href="crypto.html">crypto streams</a></p>
</li>
<li><p><a href="net.html#net_class_net_socket">TCP 嵌套字</a></p>
</li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h3>类: stream.Transform<span><a href="all.html#all_stream_transform_2" id="all_stream_transform_2">#</a></span></h3>
<p>Transform streams are <a href="all.html#stream_class_stream_duplex">Duplex</a> streams where the output is in some way
computed from the input.  They implement both the <a href="all.html#stream_class_stream_readable">Readable</a> and
<a href="all.html#stream_class_stream_writable">Writable</a> interfaces.  See above for usage.

</p>
<p>转换（Transform）流是一种输出由输入计算所得的<a href="all.html#stream_class_stream_duplex">双工</a>流。它们同时实现了 <a href="all.html#stream_class_stream_readable">Readable</a> 和 <a href="all.html#stream_class_stream_writable">Writable</a> 的接口。详见下文用例。

</p>
<p>Examples of Transform streams include:

</p>
<p>一些转换流的例子：

</p>
<ul>
<li><a href="zlib.html">zlib streams</a></li>
<li><p><a href="crypto.html">crypto streams</a></p>
</li>
<li><p><a href="zlib.html">zlib 流</a></p>
</li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h2>面向流实现者的 API<span><a href="all.html#all_api_3" id="all_api_3">#</a></span></h2>
<!--type=misc-->

<p>To implement any sort of stream, the pattern is the same:

</p>
<p>无论实现任何形式的流，模式都是一样的：

</p>
<ol>
<li>Extend the appropriate parent class in your own subclass.  (The
<a href="util.html#util_util_inherits_constructor_superconstructor"><code>util.inherits</code></a> method is particularly helpful for this.)</li>
<li>Call the appropriate parent class constructor in your constructor,
to be sure that the internal mechanisms are set up properly.</li>
<li><p>Implement one or more specific methods, as detailed below.</p>
</li>
<li><p>在您的子类中扩充适合的父类。（<a href="util.html#util_util_inherits_constructor_superconstructor"><code>util.inherits</code></a> 方法对此很有帮助。）</p>
</li>
<li>在您的构造函数中调用父类的构造函数，以确保内部的机制被正确初始化。</li>
<li>实现一个或多个特定的方法，参见下面的细节。</li>
</ol>
<p>The class to extend and the method(s) to implement depend on the sort
of stream class you are writing:

</p>
<p>所扩充的类和要实现的方法取决于您要编写的流类的形式：

</p>
<table>
  <thead>
    <tr>
      <th>
        <p>Use-case</p>
      </th>
      <th>
        <p>Class</p>
      </th>
      <th>
        <p>Method(s) to implement</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>Reading only</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_readable_1">Readable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Writing only</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_writable_1">Writable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Reading and writing</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_duplex_1">Duplex</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code>, <code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Operate on written data, then read the result</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_transform_1">Transform</a></p>
    </td>
    <td>
      <p><code>_transform</code>, <code>_flush</code></p>
    </td>
  </tr>
</table>

<table>
  <thead>
    <tr>
      <th>
        <p>使用情景</p>
      </th>
      <th>
        <p>类</p>
      </th>
      <th>
        <p>要实现的方法</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>只读</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_readable_1">Readable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>只写</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_writable_1">Writable</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>读写</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_duplex_1">Duplex</a></p>
    </td>
    <td>
      <p><code><a href="all.html#stream_readable_read_size_1">_read</a></code>, <code><a href="all.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>操作被写入数据，然后读出结果</p>
    </td>
    <td>
      <p><a href="all.html#stream_class_stream_transform_1">Transform</a></p>
    </td>
    <td>
      <p><code>_transform</code>, <code>_flush</code></p>
    </td>
  </tr>
</table>

<p>In your implementation code, it is very important to never call the
methods described in <a href="all.html#stream_api_for_stream_consumers">API for Stream Consumers</a> above.  Otherwise, you
can potentially cause adverse side effects in programs that consume
your streaming interfaces.

</p>
<p>在您的实现代码中，十分重要的一点是绝对不要调用上文<a href="all.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 中所描述的方法，否则可能在消费您的流接口的程序中产生潜在的副作用。

</p>
<h3>类: stream.Readable<span><a href="all.html#all_stream_readable_3" id="all_stream_readable_3">#</a></span></h3>
<!--type=class-->

<p><code>stream.Readable</code> is an abstract class designed to be extended with an
underlying implementation of the <a href="all.html#stream_readable_read_size_1"><code>_read(size)</code></a> method.

</p>
<p><code>stream.Readable</code> 是一个可被扩充的、实现了底层方法 <a href="all.html#stream_readable_read_size_1"><code>_read(size)</code></a> 的抽象类。

</p>
<p>Please see above under <a href="all.html#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
streams in your programs.  What follows is an explanation of how to
implement Readable streams in your programs.

</p>
<p>请阅读前文<a href="all.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 章节了解如何在您的程序中消费流。文将解释如何在您的程序中自己实现 Readable 流。

</p>
<h4>例子: 一个计数流<span><a href="all.html#all_68" id="all_68">#</a></span></h4>
<!--type=example-->

<p>This is a basic example of a Readable stream.  It emits the numerals
from 1 to 1,000,000 in ascending order, and then ends.

</p>
<p>这是一个 Readable 流的基本例子。它将从 1 至 1,000,000 递增地触发数字，然后结束。

</p>
<pre><code>var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);
util.inherits(Counter, Readable);

function Counter(opt) {
  Readable.call(this, opt);
  this._max = 1000000;
  this._index = 1;
}

function Counter(opt) {
  Readable.call(this, opt);
  this._max = 1000000;
  this._index = 1;
}

Counter.prototype._read = function() {
  var i = this._index++;
  if (i &gt; this._max)
    this.push(null);
  else {
    var str = &apos;&apos; + i;
    var buf = new Buffer(str, &apos;ascii&apos;);
    this.push(buf);
  }
};</code></pre>
<h4>例子: SimpleProtocol v1 (Sub-optimal)<span><a href="all.html#all_simpleprotocol_v1_sub_optimal_1" id="all_simpleprotocol_v1_sub_optimal_1">#</a></span></h4>
<p>This is similar to the <code>parseHeader</code> function described above, but
implemented as a custom stream.  Also, note that this implementation
does not convert the incoming data to a string.

</p>
<p>这个有点类似上文提到的 <code>parseHeader</code> 函数，但它被实现成一个自定义流。同样地，请注意这个实现并未将传入数据转换成字符串。

</p>
<p>However, this would be better implemented as a <a href="all.html#stream_class_stream_transform">Transform</a> stream.  See
below for a better implementation.

</p>
<p>实际上，更好的办法是将它实现成一个 <a href="all.html#stream_class_stream_transform">Transform</a> 流。更好的实现详见下文。

</p>
<pre><code>// 简易数据协议的解析器。
// “header”是一个 JSON 对象，后面紧跟 2 个 \n 字符，以及
// 消息主体。
//
// 注意: 使用 Transform 流能更简单地实现这个功能！
// 直接使用 Readable 并不是最佳方式，详见 Transform
// 章节下的备选例子。

var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);

var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);

util.inherits(SimpleProtocol, Readable);

util.inherits(SimpleProtocol, Readable);

function SimpleProtocol(source, options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

function SimpleProtocol(source, options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

  Readable.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;

  Readable.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;

  // source is a readable stream, such as a socket or file
  this._source = source;

  // source 是一个可读流，比如嵌套字或文件
  this._source = source;

  var self = this;
  source.on(&apos;end&apos;, function() {
    self.push(null);
  });

  var self = this;
  source.on(&apos;end&apos;, function() {
    self.push(null);
  });

  // give it a kick whenever the source is readable
  // read(0) will not consume any bytes
  source.on(&apos;readable&apos;, function() {
    self.read(0);
  });

  // 当 source 可读时做点什么
  // read(0) 不会消费任何字节
  source.on(&apos;readable&apos;, function() {
    self.read(0);
  });

  this._rawHeader = [];
  this.header = null;
}

  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._read = function(n) {
  if (!this._inBody) {
    var chunk = this._source.read();

SimpleProtocol.prototype._read = function(n) {
  if (!this._inBody) {
    var chunk = this._source.read();

    if (split === -1) {
      // 继续等待 \n\n
      // 暂存数据块，并再次尝试
      this._rawHeader.push(chunk);
      this.push(&apos;&apos;);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
        return;
      }
      // 现在，我们得到了一些多余的数据，所以需要 unshift
      // 将多余的数据放回读取队列以便我们的消费者能够读取
      var b = chunk.slice(split);
      this.unshift(b);

      // and let them know that we are done parsing the header.
      this.emit(&apos;header&apos;, this.header);
    }
  } else {
    // from there on, just provide the data to our consumer.
    // careful not to push(null), since that would indicate EOF.
    var chunk = this._source.read();
    if (chunk) this.push(chunk);
  }
};

      // 并让它们知道我们完成了头部解析。
      this.emit(&apos;header&apos;, this.header);
    }
  } else {
    // 从现在开始，仅需向我们的消费者提供数据。
    // 注意不要 push(null)，因为它表明 EOF。
    var chunk = this._source.read();
    if (chunk) this.push(chunk);
  }
};

// 用法:
// var parser = new SimpleProtocol(source);
// 现在 parser 是一个会触发 &apos;header&apos; 事件并提供已解析
// 的头部的可读流。</code></pre>
<h4>new stream.Readable([options])<span><a href="all.html#all_new_stream_readable_options_1" id="all_new_stream_readable_options_1">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> The maximum number of bytes to store in
the internal buffer before ceasing to read from the underlying
resource.  Default=16kb, or 16 for <code>objectMode</code> streams</li>
<li><code>encoding</code> <span>String</span> If specified, then buffers will be decoded to
strings using the specified encoding.  Default=null</li>
<li><code>objectMode</code> <span>Boolean</span> Whether this stream should behave
as a stream of objects. Meaning that stream.read(n) returns
a single value instead of a Buffer of size n</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> 停止从底层资源读取前内部缓冲区最多能存放的字节数。缺省为 16kb，对于 objectMode 流则是 16</li>
<li><code>encoding</code> <span>String</span> 若给出，则 Buffer 会被解码成所给编码的字符串。缺省为 <code>null</code></li>
<li><code>objectMode</code> <span>Boolean</span> 该流是否应该表现为对象的流。意思是说 <code>stream.read(n)</code> 返回一个单独的对象，而不是大小为 n 的 Buffer</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Readable class, make sure to call the
Readable constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Readable 类的类中调用 Readable 构造函数以便缓冲设定能被正确初始化。

</p>
<h4>readable._read(size)<span><a href="all.html#all_readable_read_size_3" id="all_readable_read_size_3">#</a></span></h4>
<div><ul>
<li><p><code>size</code> <span>Number</span> Number of bytes to read asynchronously</p>
</li>
<li><p><code>size</code> <span>Number</span> 异步读取的字节数</p>
</li>
</div></ul>
<p>Note: <strong>Implement this function, but do NOT call it directly.</strong>

</p>
<p>注意：<strong>实现这个函数，但【不要】直接调用它。</strong>

</p>
<p>This function should NOT be called directly.  It should be implemented
by child classes, and only called by the internal Readable class
methods.

</p>
<p>这个函数【不应该】被直接调用。它应该被子类所实现，并仅被 Readable 类内部方法所调用。

</p>
<p>All Readable stream implementations must provide a <code>_read</code> method to
fetch data from the underlying resource.

</p>
<p>所有 Readable 流的实现都必须提供一个 <code>_read</code> 方法来从底层资源抓取数据。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<p>When data is available, put it into the read queue by calling
<code>readable.push(chunk)</code>.  If <code>push</code> returns false, then you should stop
reading.  When <code>_read</code> is called again, you should start pushing more
data.

</p>
<p>当数据可用时，调用 <code>readable.push(chunk)</code> 将它加入到读取队列。如果 <code>push</code> 返回 <code>false</code>，那么您应该停止读取。当 <code>_read</code> 被再次调用，您应该继续推出更多数据。

</p>
<p>The <code>size</code> argument is advisory.  Implementations where a &quot;read&quot; is a
single call that returns data can use this to know how much data to
fetch.  Implementations where that is not relevant, such as TCP or
TLS, may ignore this argument, and simply provide data whenever it
becomes available.  There is no need, for example to &quot;wait&quot; until
<code>size</code> bytes are available before calling <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.

</p>
<p>参数 <code>size</code> 仅作查询。“read”调用返回数据的实现可以通过这个参数来知道应当抓取多少数据；其余与之无关的实现，比如 TCP 或 TLS，则可忽略这个参数，并在可用时返回数据。例如，没有必要“等到” <code>size</code> 个字节可用时才调用 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>。

</p>
<h4>readable.push(chunk, [encoding])<span><a href="all.html#all_readable_push_chunk_encoding_1" id="all_readable_push_chunk_encoding_1">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | null | String</span> Chunk of data to push into the read queue</li>
<li><code>encoding</code> <span>String</span> Encoding of String chunks.  Must be a valid
Buffer encoding, such as <code>&apos;utf8&apos;</code> or <code>&apos;ascii&apos;</code></li>
<li><p>return <span>Boolean</span> Whether or not more pushes should be performed</p>
</li>
<li><p><code>chunk</code> <span>Buffer | null | String</span> 推入读取队列的数据块</p>
</li>
<li><code>encoding</code> <span>String</span> 字符串块的编码。必须是有效的 Buffer 编码，比如 <code>utf8</code> 或 <code>ascii</code></li>
<li>返回 <span>Boolean</span> 是否应该继续推入</li>
</div></ul>
<p>Note: <strong>This function should be called by Readable implementors, NOT
by consumers of Readable streams.</strong>

</p>
<p>注意：<strong>这个函数应该被 Readable 实现者调用，【而不是】Readable 流的消费者。</strong>

</p>
<p>The <code>_read()</code> function will not be called again until at least one
<code>push(chunk)</code> call is made.

</p>
<p>函数 <code>_read()</code> 不会被再次调用，直到至少调用了一次 <code>push(chunk)</code>。

</p>
<p>The <code>Readable</code> class works by putting data into a read queue to be
pulled out later by calling the <code>read()</code> method when the <code>&apos;readable&apos;</code>
event fires.

</p>
<p><code>Readable</code> 类的工作方式是，将数据读入一个队列，当 <code>&apos;readable&apos;</code> 事件发生、调用 <code>read()</code> 方法时，数据会被从队列中取出。

</p>
<p>The <code>push()</code> method will explicitly insert some data into the read
queue.  If it is called with <code>null</code> then it will signal the end of the
data (EOF).

</p>
<p><code>push()</code> 方法会明确地向读取队列中插入一些数据。如果调用它时传入了 <code>null</code> 参数，那么它会触发数据结束信号（EOF）。

</p>
<p>This API is designed to be as flexible as possible.  For example,
you may be wrapping a lower-level source which has some sort of
pause/resume mechanism, and a data callback.  In those cases, you
could wrap the low-level source object by doing something like this:

</p>
<p>这个 API 被设计成尽可能地灵活。比如说，您可以包装一个低级别的具备某种暂停/恢复机制和数据回调的数据源。这种情况下，您可以通过这种方式包装低级别来源对象：

</p>
<pre><code>// source 是一个带 readStop() 和 readStart() 方法的类，
// 以及一个当有数据时会被调用的 `ondata` 成员、一个
// 当数据结束时会被调用的 `onend` 成员。

util.inherits(SourceWrapper, Readable);

util.inherits(SourceWrapper, Readable);

function SourceWrapper(options) {
  Readable.call(this, options);

function SourceWrapper(options) {
  Readable.call(this, options);

  this._source = getLowlevelSourceObject();
  var self = this;

  this._source = getLowlevelSourceObject();
  var self = this;

  // Every time there&apos;s data, we push it into the internal buffer.
  this._source.ondata = function(chunk) {
    // if push() returns false, then we need to stop reading from source
    if (!self.push(chunk))
      self._source.readStop();
  };

  // 每当有数据时，我们将它推入到内部缓冲区中
  this._source.ondata = function(chunk) {
    // 如果 push() 返回 false，我们就需要暂停读取 source
    if (!self.push(chunk))
      self._source.readStop();
  };

  // When the source ends, we push the EOF-signalling `null` chunk
  this._source.onend = function() {
    self.push(null);
  };
}

  // 当来源结束时，我们 push 一个 `null` 块以表示 EOF
  this._source.onend = function() {
    self.push(null);
  };
}

// _read 会在流想要拉取更多数据时被调用
// 本例中忽略 size 参数
SourceWrapper.prototype._read = function(size) {
  this._source.readStart();
};</code></pre>
<h3>类: stream.Writable<span><a href="all.html#all_stream_writable_3" id="all_stream_writable_3">#</a></span></h3>
<!--type=class-->

<p><code>stream.Writable</code> is an abstract class designed to be extended with an
underlying implementation of the <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method.

</p>
<p><code>stream.Writable</code> 是一个可被扩充的、实现了底层方法 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 的抽象类。

</p>
<p>Please see above under <a href="all.html#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
writable streams in your programs.  What follows is an explanation of
how to implement Writable streams in your programs.

</p>
<p>请阅读前文<a href="all.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 章节了解如何在您的程序中消费可读流。下文将解释如何在您的程序中自己实现 Writable 流。

</p>
<h4>new stream.Writable([options])<span><a href="all.html#all_new_stream_writable_options_1" id="all_new_stream_writable_options_1">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> Buffer level when <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> starts
returning false. Default=16kb, or 16 for <code>objectMode</code> streams</li>
<li><code>decodeStrings</code> <span>Boolean</span> Whether or not to decode strings into
Buffers before passing them to <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>.  Default=true</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> 开始返回 <code>false</code> 的缓冲级别。缺省为 16kb，对于 <code>objectMode</code> 流则是 16</li>
<li><code>decodeStrings</code> <span>Boolean</span> 是否在传递给 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 前将字符串解码成 Buffer。缺省为 <code>true</code></li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Writable class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Writable 类的类中调用构造函数以便缓冲设定能被正确初始化。

</p>
<h4>writable._write(chunk, encoding, callback)<span><a href="all.html#all_writable_write_chunk_encoding_callback_3" id="all_writable_write_chunk_encoding_callback_3">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | String</span> The chunk to be written.  Will always
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <span>String</span> If the chunk is a string, then this is the
encoding type.  Ignore if chunk is a buffer.  Note that chunk will
<strong>always</strong> be a buffer unless the <code>decodeStrings</code> option is
explicitly set to <code>false</code>.</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要被写入的数据块。总会是一个 Buffer，除非 <code>decodeStrings</code> 选项被设定为 <code>false</code>。</p>
</li>
<li><code>encoding</code> <span>String</span> 如果数据块是字符串，则这里指定它的编码类型。如果数据块是 Buffer 则忽略此设定。请注意数据块<strong>总会是</strong>一个 Buffer，除非 <code>decodeStrings</code> 选项被明确设定为 <code>false</code>。</li>
<li><code>callback</code> <span>Function</span> 当您处理完所给数据块时调用此函数（可选地可附上一个错误参数）。</li>
</div></ul>
<p>All Writable stream implementations must provide a <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>
method to send data to the underlying resource.

</p>
<p>所有 Writable 流的实现必须提供一个 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 方法来将数据发送到底层资源。

</p>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Writable 内部方法所调用。

</p>
<p>Call the callback using the standard <code>callback(error)</code> pattern to
signal that the write completed successfully or with an error.

</p>
<p>使用标准的 <code>callback(error)</code> 形式来调用回调以表明写入成功完成或遇到错误。

</p>
<p>If the <code>decodeStrings</code> flag is set in the constructor options, then
<code>chunk</code> may be a string rather than a Buffer, and <code>encoding</code> will
indicate the sort of string that it is.  This is to support
implementations that have an optimized handling for certain string
data encodings.  If you do not explicitly set the <code>decodeStrings</code>
option to <code>false</code>, then you can safely ignore the <code>encoding</code> argument,
and assume that <code>chunk</code> will always be a Buffer.

</p>
<p>如果构造函数选项中设定了 <code>decodeStrings</code> 标志，则 <code>chunk</code> 可能会是字符串而不是 Buffer，并且 <code>encoding</code> 表明了字符串的格式。这种设计是为了支持对某些字符串数据编码提供优化处理的实现。如果您没有明确地将 <code>decodeStrings</code> 选项设定为 <code>false</code>，那么您可以安全地忽略 <code>encoding</code> 参数，并假定 <code>chunk</code> 总是一个 Buffer。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h3>writable._writev(chunks, callback)<span><a href="all.html#all_writable_writev_chunks_callback_1" id="all_writable_writev_chunks_callback_1">#</a></span></h3>
<div><ul>
<li><code>chunks</code> <span>Array</span> The chunks to be written.  Each chunk has following
format: <code>&lt;span class=&quot;type&quot;&gt; chunk: ..., encoding: ... &lt;/span&gt;</code>.</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunks.</p>
</li>
<li><p><code>chunks</code> <span>Array</span> 要写入的块。每个块都遵循这种格式：<code>{ chunk: ..., encoding: ... }</code>。</p>
</li>
<li><code>callback</code> <span>Function</span> 当您处理完所给数据块时调用此函数（可选地可附上一个错误参数）。</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It may be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Writable 内部方法所调用。

</p>
<p>This function is completely optional to implement. In most cases it is
unnecessary.  If implemented, it will be called with all the chunks
that are buffered in the write queue.

</p>
<p>该函数的实现完全是可选的，在大多数情况下都是不必要的。如果实现，它会被以所有滞留在写入队列中的数据块调用。

</p>
<h3>类: stream.Duplex<span><a href="all.html#all_stream_duplex_3" id="all_stream_duplex_3">#</a></span></h3>
<!--type=class-->

<p>A &quot;duplex&quot; stream is one that is both Readable and Writable, such as a
TCP socket connection.

</p>
<p>“双工”（duplex）流同时兼具可读和可写特性，比如一个 TCP 嵌套字连接。

</p>
<p>Note that <code>stream.Duplex</code> is an abstract class designed to be extended
with an underlying implementation of the <code>_read(size)</code> and
<a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> methods as you would with a
Readable or Writable stream class.

</p>
<p>值得注意的是，<code>stream.Duplex</code> 是一个可以像 Readable 或 Writable 一样被扩充、实现了底层方法 <code>_read(sise)</code> 和 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 的抽象类。

</p>
<p>Since JavaScript doesn&apos;t have multiple prototypal inheritance, this
class prototypally inherits from Readable, and then parasitically from
Writable.  It is thus up to the user to implement both the lowlevel
<code>_read(n)</code> method as well as the lowlevel
<a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method on extension duplex classes.

</p>
<p>由于 JavaScript 并不具备多原型继承能力，这个类实际上继承自 Readable，并寄生自 Writable，从而让用户在双工类的扩充中能同时实现低级别的 <code>_read(n)</code> 方法和 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 方法。

</p>
<h4>new stream.Duplex(options)<span><a href="all.html#all_new_stream_duplex_options_1" id="all_new_stream_duplex_options_1">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors. Also has the following fields:</p>
<ul>
<li><code>allowHalfOpen</code> <span>Boolean</span> Default=true.  If set to <code>false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors. Also has the following fields:</p>
<ul>
<li><code>allowHalfOpen</code> <span>Boolean</span> Default=true.  If set to <code>false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Duplex class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Duplex 类的类中调用构造函数以便缓冲设定能被正确初始化。

</p>
<h3>类: stream.Transform<span><a href="all.html#all_stream_transform_3" id="all_stream_transform_3">#</a></span></h3>
<p>A &quot;transform&quot; stream is a duplex stream where the output is causally
connected in some way to the input, such as a <a href="zlib.html">zlib</a> stream or a
<a href="crypto.html">crypto</a> stream.

</p>
<p>“转换”（transform）流实际上是一个输出与输入存在因果关系的双工流，比如 <a href="zlib.html">zlib</a> 流或 <a href="crypto.html">crypto</a> 流。

</p>
<p>There is no requirement that the output be the same size as the input,
the same number of chunks, or arrive at the same time.  For example, a
Hash stream will only ever have a single chunk of output which is
provided when the input is ended.  A zlib stream will produce output
that is either much smaller or much larger than its input.

</p>
<p>输入和输出并无要求相同大小、相同块数或同时到达。举个例子，一个 Hash 流只会在输入结束时产生一个数据块的输出；一个 zlib 流会产生比输入小得多或大得多的输出。

</p>
<p>Rather than implement the <a href="all.html#stream_readable_read_size_1"><code>_read()</code></a> and <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> methods, Transform
classes must implement the <code>_transform()</code> method, and may optionally
also implement the <code>_flush()</code> method.  (See below.)

</p>
<p>转换类必须实现 <code>_transform()</code> 方法，而不是 <a href="all.html#stream_readable_read_size_1"><code>_read()</code></a> 和 <a href="all.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 方法。可选的，也可以实现 <code>_flush()</code> 方法。（详见下文。）

</p>
<h4>new stream.Transform([options])<span><a href="all.html#all_new_stream_transform_options_1" id="all_new_stream_transform_options_1">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors.</p>
</li>
<li><p><code>options</code> <span>Object</span> 传递给 Writable 和 Readable 构造函数。</p>
</li>
</div></ul>
<p>In classes that extend the Transform class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Transform 类的类中调用了构造函数，以使得缓冲设定能被正确初始化。

</p>
<h4>transform._transform(chunk, encoding, callback)<span><a href="all.html#all_transform_transform_chunk_encoding_callback_1" id="all_transform_transform_chunk_encoding_callback_1">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | String</span> The chunk to be transformed.  Will always
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <span>String</span> If the chunk is a string, then this is the
encoding type.  (Ignore if <code>decodeStrings</code> chunk is a buffer.)</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要被转换的数据块。总是 Buffer，除非 <code>decodeStrings</code> 选项被设定为 <code>false</code>。</p>
</li>
<li><code>encoding</code> <span>String</span> 如果数据块是一个字符串，那么这就是它的编码类型。（数据块是 Buffer 则会忽略此参数。）</li>
<li><code>callback</code> <span>Function</span> 当您处理完所提供的数据块时调用此函数（可选地附上一个错误参数）。</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Transform
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Transform 内部方法所调用。

</p>
<p>All Transform stream implementations must provide a <code>_transform</code>
method to accept input and produce output.

</p>
<p>所有转换流的实现都必须提供一个 <code>_transform</code> 方法来接受输入并产生输出。

</p>
<p><code>_transform</code> should do whatever has to be done in this specific
Transform class, to handle the bytes being written, and pass them off
to the readable portion of the interface.  Do asynchronous I/O,
process things, and so on.

</p>
<p><code>_transform</code> 应当承担特定 Transform 类中所有处理被写入的字节、并将它们丢给接口的可写端的职责，进行异步 I/O，处理其它事情等等。

</p>
<p>Call <code>transform.push(outputChunk)</code> 0 or more times to generate output
from this input chunk, depending on how much data you want to output
as a result of this chunk.

</p>
<p>调用 <code>transform.push(outputChunk)</code> 0 或多次来从输入块生成输出，取决于您想从这个数据块输出多少数据。

</p>
<p>Call the callback function only when the current chunk is completely
consumed.  Note that there may or may not be output as a result of any
particular input chunk.

</p>
<p>仅当当前数据块被完全消费时调用回调函数。注意，任何特定的输入块都有可能或可能不会产生输出。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h4>transform._flush(callback)<span><a href="all.html#all_transform_flush_callback_1" id="all_transform_flush_callback_1">#</a></span></h4>
<div><ul>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done flushing any remaining data.</p>
</li>
<li><p><code>callback</code> <span>Function</span> 当您写入完毕剩下的数据后调用此函数（可选地可附上一个错误对象）。</p>
</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It MAY be implemented
by child classes, and if so, will be called by the internal Transform
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它【可以】被子类所实现，并且如果实现，仅被 Transform 内部方法所调用。

</p>
<p>In some cases, your transform operation may need to emit a bit more
data at the end of the stream.  For example, a <code>Zlib</code> compression
stream will store up some internal state so that it can optimally
compress the output.  At the end, however, it needs to do the best it
can with what is left, so that the data will be complete.

</p>
<p>在一些情景中，您的转换操作可能需要在流的末尾多发生一点点数据。例如，一个 <code>Zlib</code> 压缩流会储存一些内部状态以便更好地压缩输出，但在最后它需要尽可能好地处理剩下的东西以使数据完整。

</p>
<p>In those cases, you can implement a <code>_flush</code> method, which will be
called at the very end, after all the written data is consumed, but
before emitting <code>end</code> to signal the end of the readable side.  Just
like with <code>_transform</code>, call <code>transform.push(chunk)</code> zero or more
times, as appropriate, and call <code>callback</code> when the flush operation is
complete.

</p>
<p>在这种情况中，您可以实现一个 <code>_flush</code> 方法，它会在最后被调用，在所有写入数据被消费、但在触发 <code>end</code> 表示可读端到达末尾之前。和 <code>_transform</code> 一样，只需在写入操作完成时适当地调用 <code>transform.push(chunk)</code> 零或多次。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h4>例子: <code>SimpleProtocol</code> 解析器 v2<span><a href="all.html#all_simpleprotocol_v2_1" id="all_simpleprotocol_v2_1">#</a></span></h4>
<p>The example above of a simple protocol parser can be implemented
simply by using the higher level <a href="all.html#stream_class_stream_transform">Transform</a> stream class, similar to
the <code>parseHeader</code> and <code>SimpleProtocol v1</code> examples above.

</p>
<p>上文的简易协议解析器例子能够很简单地使用高级别 <a href="all.html#stream_class_stream_transform">Transform</a> 流类实现，类似于前文 <code>parseHeader</code> 和 <code>SimpleProtocal v1</code> 示例。

</p>
<p>In this example, rather than providing the input as an argument, it
would be piped into the parser, which is a more idiomatic Node stream
approach.

</p>
<p>在这个示例中，输入会被导流到解析器中，而不是作为参数提供。这种做法更符合 Node 流的惯例。

</p>
<pre><code>var util = require(&apos;util&apos;);
var Transform = require(&apos;stream&apos;).Transform;
util.inherits(SimpleProtocol, Transform);

function SimpleProtocol(options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

function SimpleProtocol(options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

  Transform.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;
  this._rawHeader = [];
  this.header = null;
}

  Transform.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;
  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._transform = function(chunk, encoding, done) {
  if (!this._inBody) {
    // check if the chunk has a \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &apos;\n&apos;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

SimpleProtocol.prototype._transform = function(chunk, encoding, done) {
  if (!this._inBody) {
    // 检查数据块是否有 \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &apos;\n&apos;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

    if (split === -1) {
      // 仍旧等待 \n\n
      // 暂存数据块并重试。
      this._rawHeader.push(chunk);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
        return;
      }
      // 并让它们知道我们完成了头部解析。
      this.emit(&apos;header&apos;, this.header);

      // now, because we got some extra data, emit this first.
      this.push(chunk.slice(split));
    }
  } else {
    // from there on, just provide the data to our consumer as-is.
    this.push(chunk);
  }
  done();
};

      // 现在，由于我们获得了一些额外的数据，先触发这个。
      this.push(chunk.slice(split));
    }
  } else {
    // 之后，仅需向我们的消费者原样提供数据。
    this.push(chunk);
  }
  done();
};

// 用法:
// var parser = new SimpleProtocol();
// source.pipe(parser)
// 现在 parser 是一个会触发 &apos;header&apos; 并带上解析后的
// 头部数据的可读流。</code></pre>
<h3>类: stream.PassThrough<span><a href="all.html#all_stream_passthrough_1" id="all_stream_passthrough_1">#</a></span></h3>
<p>This is a trivial implementation of a <a href="all.html#stream_class_stream_transform">Transform</a> stream that simply
passes the input bytes across to the output.  Its purpose is mainly
for examples and testing, but there are occasionally use cases where
it can come in handy as a building block for novel sorts of streams.

</p>
<p>这是 <a href="all.html#stream_class_stream_transform">Transform</a> 流的一个简单实现，将输入的字节简单地传递给输出。它的主要用途是演示和测试，但偶尔要构建某种特殊流的时候也能派上用场。

</p>
<h2>流：内部细节<span><a href="all.html#all_69" id="all_69">#</a></span></h2>
<!--type=misc-->

<h3>缓冲<span><a href="all.html#all_70" id="all_70">#</a></span></h3>
<!--type=misc-->

<p>Both Writable and Readable streams will buffer data on an internal
object called <code>_writableState.buffer</code> or <code>_readableState.buffer</code>,
respectively.

</p>
<p>无论 Writable 或 Readable 流都会在内部分别叫做 <code>_writableState.buffer</code> 和 <code>_readableState.buffer</code> 的对象中缓冲数据。

</p>
<p>The amount of data that will potentially be buffered depends on the
<code>highWaterMark</code> option which is passed into the constructor.

</p>
<p>被缓冲的数据量取决于传递给构造函数的 <code>highWaterMark</code>（最高水位线）选项。

</p>
<p>Buffering in Readable streams happens when the implementation calls
<a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.  If the consumer of the Stream does not call
<code>stream.read()</code>, then the data will sit in the internal queue until it
is consumed.

</p>
<p>Readable 流的滞留发生于当实现调用 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a> 的时候。如果流的消费者没有调用 <code>stream.read()</code>，那么数据将会一直待在内部队列，直到它被消费。

</p>
<p>Buffering in Writable streams happens when the user calls
<a href="all.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> repeatedly, even when <code>write()</code> returns <code>false</code>.

</p>
<p>Writable 流的滞留发生于当用户重复调用 <a href="all.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> 即便此时 <code>write()</code> 返回 <code>false</code> 时。

</p>
<p>The purpose of streams, especially with the <code>pipe()</code> method, is to
limit the buffering of data to acceptable levels, so that sources and
destinations of varying speed will not overwhelm the available memory.

</p>
<p>流，尤其是 <code>pipe()</code> 方法的初衷，是将数据的滞留量限制到一个可接受的水平，以使得不同速度的来源和目标不会淹没可用内存。

</p>
<h3><code>stream.read(0)</code><span><a href="all.html#all_stream_read_0_1" id="all_stream_read_0_1">#</a></span></h3>
<p>There are some cases where you want to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data.  In that case, you can call <code>stream.read(0)</code>, which will always
return null.

</p>
<p>在某写情景中，您可能需要触发底层可读流机制的刷新，但不真正消费任何数据。在这中情况下，您可以调用 <code>stream.read(0)</code>，它总会返回 <code>null</code>。

</p>
<p>If the internal read buffer is below the <code>highWaterMark</code>, and the
stream is not currently reading, then calling <code>read(0)</code> will trigger
a low-level <code>_read</code> call.

</p>
<p>如果内部读取缓冲低于 <code>highWaterMark</code> 水位线，并且流当前不在读取状态，那么调用 <code>read(0)</code> 会触发一个低级 <code>_read</code> 调用。

</p>
<p>There is almost never a need to do this.  However, you will see some
cases in Node&apos;s internals where this is done, particularly in the
Readable stream class internals.

</p>
<p>虽然几乎没有必要这么做，但您可以在 Node 内部的某些地方看到它确实这么做了，尤其是在 Readable 流类的内部。

</p>
<h3><code>stream.push(&apos;&apos;)</code><span><a href="all.html#all_stream_push_1" id="all_stream_push_1">#</a></span></h3>
<p>Pushing a zero-byte string or Buffer (when not in <a href="all.html#stream_object_mode">Object mode</a>) has an
interesting side effect.  Because it <em>is</em> a call to
<a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push()</code></a>, it will end the <code>reading</code> process.  However, it
does <em>not</em> add any data to the readable buffer, so there&apos;s nothing for
a user to consume.

</p>
<p>推入一个零字节字符串或 Buffer（当不在 <a href="all.html#stream_object_mode">对象模式</a> 时）有一个有趣的副作用。因为<em>它是</em>一个对 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push()</code></a> 的调用，它会结束 <code>reading</code> 进程。然而，它<em>没有</em>添加任何数据到可读缓冲中，所以没有东西可以被用户消费。

</p>
<p>Very rarely, there are cases where you have no data to provide now,
but the consumer of your stream (or, perhaps, another bit of your own
code) will know when to check again, by calling <code>stream.read(0)</code>.  In
those cases, you <em>may</em> call <code>stream.push(&apos;&apos;)</code>.

</p>
<p>在极少数情况下，您当时没有数据提供，但您的流的消费者（或您的代码的其它部分）会通过调用 <code>stream.read(0)</code> 得知何时再次检查。在这中情况下，您<em>可以</em>调用 <code>stream.push(&apos;&apos;)</code>。

</p>
<p>So far, the only use case for this functionality is in the
<a href="tls.html#tls_class_cryptostream">tls.CryptoStream</a> class, which is deprecated in Node v0.12.  If you
find that you have to use <code>stream.push(&apos;&apos;)</code>, please consider another
approach, because it almost certainly indicates that something is
horribly wrong.

</p>
<p>到目前为止，这个功能唯一一个使用情景是在 <a href="tls.html#tls_class_cryptostream">tls.CryptoStream</a> 类中，但它将在 Node v0.12 中被废弃。如果您发现您不得不使用 <code>stream.push(&apos;&apos;)</code>，请考虑另一种方式，因为几乎可以明确表明这是某种可怕的错误。

</p>
<h3>与 Node 早期版本的兼容性<span><a href="all.html#all_node_1" id="all_node_1">#</a></span></h3>
<!--type=misc-->

<p>In versions of Node prior to v0.10, the Readable stream interface was
simpler, but also less powerful and less useful.

</p>
<p>在 v0.10 之前版本的 Node 中，Readable 流的接口较为简单，同时功能和实用性也较弱。

</p>
<ul>
<li>Rather than waiting for you to call the <code>read()</code> method, <code>&apos;data&apos;</code>
events would start emitting immediately.  If you needed to do some
I/O to decide how to handle data, then you had to store the chunks
in some kind of buffer so that they would not be lost.</li>
<li><p>The <a href="all.html#stream_readable_pause"><code>pause()</code></a> method was advisory, rather than guaranteed.  This
meant that you still had to be prepared to receive <code>&apos;data&apos;</code> events
even when the stream was in a paused state.</p>
</li>
<li><p><code>&apos;data&apos;</code> 事件会开始立即开始发生，而不会等待您调用 <code>read()</code> 方法。如果您需要进行某些 I/O 来决定如何处理数据，那么您只能将数据块储存到某种缓冲区中以防它们流失。</p>
</li>
<li><a href="all.html#stream_readable_pause"><code>pause()</code></a> 方法仅起提议作用，而不保证生效。这意味着，即便当流处于暂停状态时，您仍然需要准备接收 <code>&apos;data&apos;</code> 事件。</li>
</ul>
<p>In Node v0.10, the Readable class described below was added.  For
backwards compatibility with older Node programs, Readable streams
switch into &quot;flowing mode&quot; when a <code>&apos;data&apos;</code> event handler is added, or
when the <a href="all.html#stream_readable_resume"><code>resume()</code></a> method is called.  The effect is that, even if
you are not using the new <code>read()</code> method and <code>&apos;readable&apos;</code> event, you
no longer have to worry about losing <code>&apos;data&apos;</code> chunks.

</p>
<p>在 Node v0.10 中，下文所述的 Readable 类被加入进来。为了向后兼容考虑，Readable 流会在添加了 <code>&apos;data&apos;</code> 事件监听器、或 <a href="all.html#stream_readable_resume"><code>resume()</code></a> 方法被调用时切换至“流动模式”。其作用是，即便您不使用新的 <code>read()</code> 方法和 <code>&apos;readable&apos;</code> 事件，您也不必担心丢失 <code>&apos;data&apos;</code> 数据块。

</p>
<p>Most programs will continue to function normally.  However, this
introduces an edge case in the following conditions:

</p>
<p>大多数程序会维持正常功能，然而，这也会在下列条件下引入一种边界情况：

</p>
<ul>
<li>No <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> event</a> handler is added.</li>
<li>The <a href="all.html#stream_readable_resume"><code>resume()</code></a> method is never called.</li>
<li><p>The stream is not piped to any writable destination.</p>
</li>
<li><p>没有添加 <a href="all.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>处理器。</p>
</li>
<li><a href="all.html#stream_readable_resume"><code>resume()</code></a> 方法从未被调用。</li>
<li>流未被导流到任何可写目标。</li>
</ul>
<p>For example, consider the following code:

</p>
<p>举个例子，请留意下面代码：

</p>
<pre><code>// 警告！不能用！
net.createServer(function(socket) {

  // we add an &apos;end&apos; method, but never consume the data
  socket.on(&apos;end&apos;, function() {
    // It will never get here.
    socket.end(&apos;I got your message (but didnt read it)\n&apos;);
  });

  // 我们添加了一个 &apos;end&apos; 事件，但从未消费数据
  socket.on(&apos;end&apos;, function() {
    // 它永远不会到达这里
    socket.end(&apos;我收到了您的来信（但我没看它）\n&apos;);
  });

}).listen(1337);</code></pre>
<p>In versions of node prior to v0.10, the incoming message data would be
simply discarded.  However, in Node v0.10 and beyond, the socket will
remain paused forever.

</p>
<p>在 Node v0.10 之前的版本中，传入消息数据会被简单地丢弃。然而在 Node v0.10 及之后，socket 会一直保持暂停。

</p>
<p>The workaround in this situation is to call the <code>resume()</code> method to
start the flow of data:

</p>
<p>对于这种情形的妥协方式是调用 <code>resume()</code> 方法来开启数据流：

</p>
<pre><code>// 妥协
net.createServer(function(socket) {

  socket.on(&apos;end&apos;, function() {
    socket.end(&apos;I got your message (but didnt read it)\n&apos;);
  });

  socket.on(&apos;end&apos;, function() {
    socket.end(&apos;我收到了您的来信（但我没看它）\n&apos;);
  });

  // start the flow of data, discarding it.
  socket.resume();

  // 开启数据流，并丢弃它们。
  socket.resume();

}).listen(1337);</code></pre>
<p>In addition to new Readable streams switching into flowing mode,
pre-v0.10 style streams can be wrapped in a Readable class using the
<code>wrap()</code> method.

</p>
<p>额外的，对于切换到流动模式的新 Readable 流，v0.10 之前风格的流可以通过 <code>wrap()</code> 方法被包装成 Readable 类。

</p>
<h3>对象模式<span><a href="all.html#all_71" id="all_71">#</a></span></h3>
<!--type=misc-->

<p>Normally, Streams operate on Strings and Buffers exclusively.

</p>
<p>通常情况下，流只操作字符串和 Buffer。

</p>
<p>Streams that are in <strong>object mode</strong> can emit generic JavaScript values
other than Buffers and Strings.

</p>
<p>处于<strong>对象模式</strong>的流除了 Buffer 和字符串外还能读出普通的 JavaScript 值。

</p>
<p>A Readable stream in object mode will always return a single item from
a call to <code>stream.read(size)</code>, regardless of what the size argument
is.

</p>
<p>一个处于对象模式的 Readable 流调用 <code>stream.read(size)</code> 时总会返回单个项目，无论传入什么 size 参数。

</p>
<p>A Writable stream in object mode will always ignore the <code>encoding</code>
argument to <code>stream.write(data, encoding)</code>.

</p>
<p>一个处于对象模式的 Writable 流总是会忽略传给 <code>stream.write(data, encoding)</code> 的 <code>encoding</code> 参数。

</p>
<p>The special value <code>null</code> still retains its special value for object
mode streams.  That is, for object mode readable streams, <code>null</code> as a
return value from <code>stream.read()</code> indicates that there is no more
data, and <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(null)</code></a> will signal the end of stream data
(<code>EOF</code>).

</p>
<p>特殊值 <code>null</code> 在对象模式流中依旧保持它的特殊性。也就说，对于对象模式的可读流，<code>stream.read()</code> 返回 <code>null</code> 意味着没有更多数据，同时 <a href="all.html#stream_readable_push_chunk_encoding"><code>stream.push(null)</code></a> 会告知流数据到达末端（<code>EOF</code>）。

</p>
<p>No streams in Node core are object mode streams.  This pattern is only
used by userland streaming libraries.

</p>
<p>Node 核心不存在对象模式的流，这种设计只被某些用户态流式库所使用。

</p>
<p>You should set <code>objectMode</code> in your stream child class constructor on
the options object.  Setting <code>objectMode</code> mid-stream is not safe.

</p>
<p>您应该在您的流子类构造函数的选项对象中设置 <code>objectMode</code>。在流的过程中设置 <code>objectMode</code> 是不安全的。

</p>
<h3>状态对象<span><a href="all.html#all_72" id="all_72">#</a></span></h3>
<p><a href="all.html#stream_class_stream_readable">Readable</a> streams have a member object called <code>_readableState</code>.
<a href="all.html#stream_class_stream_writable">Writable</a> streams have a member object called <code>_writableState</code>.
<a href="all.html#stream_class_stream_duplex">Duplex</a> streams have both.

</p>
<p><a href="all.html#stream_class_stream_readable">Readable</a> 流有一个成员对象叫作 <code>_readableState</code>。
<a href="all.html#stream_class_stream_writable">Writable</a> 流有一个成员对象叫作 <code>_writableState</code>。
<a href="all.html#stream_class_stream_duplex">Duplex</a> 流二者兼备。

</p>
<p><strong>These objects should generally not be modified in child classes.</strong>
However, if you have a Duplex or Transform stream that should be in
<code>objectMode</code> on the readable side, and not in <code>objectMode</code> on the
writable side, then you may do this in the constructor by setting the
flag explicitly on the appropriate state object.

</p>
<p><strong>这些对象通常不应该被子类所更改。</strong>然而，如果您有一个 Duplex 或 Transform 流，它的可读端应该是 <code>objectMode</code>，但可写端却又不是 <code>objectMode</code>，那么您可以在构造函数里明确地设定合适的状态对象的标记来达到此目的。

</p>
<pre><code>var util = require(&apos;util&apos;);
var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;
var Transform = require(&apos;stream&apos;).Transform;
util.inherits(JSONParseStream, Transform);

// Gets \n-delimited JSON string data, and emits the parsed objects
function JSONParseStream(options) {
  if (!(this instanceof JSONParseStream))
    return new JSONParseStream(options);

// 获取以 \n 分隔的 JSON 字符串数据，并丢出解析后的对象
function JSONParseStream(options) {
  if (!(this instanceof JSONParseStream))
    return new JSONParseStream(options);

  Transform.call(this, options);
  this._writableState.objectMode = false;
  this._readableState.objectMode = true;
  this._buffer = &apos;&apos;;
  this._decoder = new StringDecoder(&apos;utf8&apos;);
}

  Transform.call(this, options);
  this._writableState.objectMode = false;
  this._readableState.objectMode = true;
  this._buffer = &apos;&apos;;
  this._decoder = new StringDecoder(&apos;utf8&apos;);
}

JSONParseStream.prototype._transform = function(chunk, encoding, cb) {
  this._buffer += this._decoder.write(chunk);
  // split on newlines
  var lines = this._buffer.split(/\r?\n/);
  // keep the last partial line buffered
  this._buffer = lines.pop();
  for (var l = 0; l &lt; lines.length; l++) {
    var line = lines[l];
    try {
      var obj = JSON.parse(line);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // push the parsed object out to the readable consumer
    this.push(obj);
  }
  cb();
};

JSONParseStream.prototype._transform = function(chunk, encoding, cb) {
  this._buffer += this._decoder.write(chunk);
  // 以新行分割
  var lines = this._buffer.split(/\r?\n/);
  // 保留最后一行被缓冲
  this._buffer = lines.pop();
  for (var l = 0; l &lt; lines.length; l++) {
    var line = lines[l];
    try {
      var obj = JSON.parse(line);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // 推出解析后的对象到可读消费者
    this.push(obj);
  }
  cb();
};

JSONParseStream.prototype._flush = function(cb) {
  // 仅仅处理剩下的东西
  var rem = this._buffer.trim();
  if (rem) {
    try {
      var obj = JSON.parse(rem);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // 推出解析后的对象到可读消费者
    this.push(obj);
  }
  cb();
};</code></pre>
<p>The state objects contain other useful information for debugging the
state of streams in your programs.  It is safe to look at them, but
beyond setting option flags in the constructor, it is <strong>not</strong> safe to
modify them.

</p>
<p>状态对象包含了其它调试您的程序的流的状态时有用的信息。读取它们是可以的，但越过构造函数的选项来更改它们是<strong>不安全的</strong>。

</p>
<h1>加密（Crypto）<span><a href="all.html#all_crypto_1" id="all_crypto_1">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定；正在讨论未来版本的API变动。会尽量减少重大变动的发生。详见下文。</code></pre>
<p>Use <code>require(&apos;crypto&apos;)</code> to access this module.

</p>
<p>使用 <code>require(&apos;crypto&apos;)</code> 来调用该模块。

</p>
<p>The crypto module offers a way of encapsulating secure credentials to be
used as part of a secure HTTPS net or http connection.

</p>
<p>crypto模块提供在HTTPS或HTTP连接中封装安全凭证的方法.

</p>
<p>It also offers a set of wrappers for OpenSSL&apos;s hash, hmac, cipher,
decipher, sign and verify methods.

</p>
<p>它提供OpenSSL中的一系列哈希方法，包括hmac、cipher、decipher、签名和验证等方法的封装。

</p>
<h2>crypto.getCiphers()<span><a href="all.html#all_crypto_getciphers_1" id="all_crypto_getciphers_1">#</a></span></h2>
<p>Returns an array with the names of the supported ciphers.

</p>
<p>返回一个数组，包含支持的加密算法的名字。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var ciphers = crypto.getCiphers();
console.log(ciphers); // [&apos;AES-128-CBC&apos;, &apos;AES-128-CBC-HMAC-SHA1&apos;, ...]</code></pre>
<h2>crypto.getHashes()<span><a href="all.html#all_crypto_gethashes_1" id="all_crypto_gethashes_1">#</a></span></h2>
<p>Returns an array with the names of the supported hash algorithms.

</p>
<p>返回一个包含所支持的哈希算法的数组。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var hashes = crypto.getHashes();
console.log(hashes); // [&apos;sha&apos;, &apos;sha1&apos;, &apos;sha1WithRSAEncryption&apos;, ...]</code></pre>
<h2>crypto.createCredentials(details)<span><a href="all.html#all_crypto_createcredentials_details_1" id="all_crypto_createcredentials_details_1">#</a></span></h2>
<p>Creates a credentials object, with the optional details being a
dictionary with keys:

</p>
<p>创建一个加密凭证对象，接受一个可选的参数对象：

</p>
<ul>
<li><code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private
key, certificate and CA certificates</li>
<li><code>key</code> : A string holding the PEM encoded private key</li>
<li><code>passphrase</code> : A string of passphrase for the private key or pfx</li>
<li><code>cert</code> : A string holding the PEM encoded certificate</li>
<li><code>ca</code> : Either a string or list of strings of PEM encoded CA
certificates to trust.</li>
<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs
(Certificate Revocation List)</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude.
Consult
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
for details on the format.</p>
</li>
<li><p><code>pfx</code> : 一个字符串或者buffer对象，代表经PFX或者PKCS12编码产生的私钥、证书以及CA证书</p>
</li>
<li><code>key</code> : 一个字符串，代表经PEM编码产生的私钥</li>
<li><code>passphrase</code> : 私钥或者pfx的密码</li>
<li><code>cert</code> : 一个字符串，代表经PEM编码产生的证书</li>
<li><code>ca</code> : 一个字符串或者字符串数组，表示可信任的经PEM编码产生的CA证书列表</li>
<li><code>crl</code> : 一个字符串或者字符串数组，表示经PEM编码产生的CRL（证书吊销列表 Certificate Revocation List）</li>
<li><code>ciphers</code>: 一个字符串，表示需要使用或者排除的加密算法
可以在
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>
查看更多关于加密算法格式的资料。</li>
</ul>
<p>If no &apos;ca&apos; details are given, then node.js will use the default
publicly trusted list of CAs as given in
</p>
<p><a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.

</p>
<p>如果没有指定<code>ca</code>，node.js会使用<a href="http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>提供的公共可信任的CA列表。

</p>
<h2>crypto.createHash(algorithm)<span><a href="all.html#all_crypto_createhash_algorithm_1" id="all_crypto_createhash_algorithm_1">#</a></span></h2>
<p>Creates and returns a hash object, a cryptographic hash with the given
algorithm which can be used to generate hash digests.

</p>
<p>创建并返回一个哈希对象，一个使用所给算法的用于生成摘要的加密哈希。

</p>
<p><code>algorithm</code> is dependent on the available algorithms supported by the
version of OpenSSL on the platform. Examples are <code>&apos;sha1&apos;</code>, <code>&apos;md5&apos;</code>,
<code>&apos;sha256&apos;</code>, <code>&apos;sha512&apos;</code>, etc.  On recent releases, <code>openssl
list-message-digest-algorithms</code> will display the available digest
algorithms.

</p>
<p><code>algorithm</code> 取决与平台上所安装的 OpenSSL 版本所支持的算法。比如 <code>&apos;sha1&apos;</code>、<code>&apos;md5&apos;</code>、<code>&apos;sha256&apos;</code>、<code>&apos;sha512&apos;</code> 等等。在最近的发行版本中，<code>openssl list-message-digest-algorithms</code> 会显示可用的摘要算法。

</p>
<p>Example: this program that takes the sha1 sum of a file

</p>
<p>例子：这段程序会计算出一个文件的 sha1 摘要值。

</p>
<pre><code>s.on(&apos;end&apos;, function() {
  var d = shasum.digest(&apos;hex&apos;);
  console.log(d + &apos;  &apos; + filename);
});</code></pre>
<h2>类: Hash<span><a href="all.html#all_hash_1" id="all_hash_1">#</a></span></h2>
<p>The class for creating hash digests of data.

</p>
<p>创建数据哈希摘要的类。

</p>
<p>It is a <a href="stream.html">stream</a> that is both readable and writable.  The
written data is used to compute the hash.  Once the writable side of
the stream is ended, use the <code>read()</code> method to get the computed hash
digest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.

</p>
<p>它是一个既可读又可写的<a href="stream.html">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。

</p>
<p>Returned by <code>crypto.createHash</code>.

</p>
<p>通过 <code>crypto.createHash</code> 返回。

</p>
<h3>hash.update(data, [input_encoding])<span><a href="all.html#all_hash_update_data_input_encoding_1" id="all_hash_update_data_input_encoding_1">#</a></span></h3>
<p>Updates the hash content with the given <code>data</code>, the encoding of which
is given in <code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or
<code>&apos;binary&apos;</code>.  If no encoding is provided, then a buffer is expected.

</p>
<p>通过提供的数据更新哈希对象，可以通过<code>input_encoding</code>指定编码为<code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>或者
<code>&apos;binary&apos;</code>。如果没有指定编码，将作为二进制数据（buffer）处理。

</p>
<p>This can be called many times with new data as it is streamed.

</p>
<p>因为它是流式数据，所以可以使用不同的数据调用很多次。

</p>
<h3>hash.digest([encoding])<span><a href="all.html#all_hash_digest_encoding_1" id="all_hash_digest_encoding_1">#</a></span></h3>
<p>Calculates the digest of all of the passed data to be hashed.  The
<code>encoding</code> can be <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> or <code>&apos;base64&apos;</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>计算传入的所有数据的摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。

</p>
<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method has been
called.

</p>
<p>注意：<code>hash</code> 对象在 <code>digest()</code> 方法被调用后将不可用。

</p>
<h2>crypto.createHmac(algorithm, key)<span><a href="all.html#all_crypto_createhmac_algorithm_key_1" id="all_crypto_createhmac_algorithm_key_1">#</a></span></h2>
<p>Creates and returns a hmac object, a cryptographic hmac with the given
algorithm and key.

</p>
<p>创建并返回一个hmac对象，也就是通过给定的加密算法和密钥生成的加密图谱（cryptographic）。

</p>
<p>It is a <a href="stream.html">stream</a> that is both readable and writable.  The
written data is used to compute the hmac.  Once the writable side of
the stream is ended, use the <code>read()</code> method to get the computed
digest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.

</p>
<p>它是一个既可读又可写的流（<a href="stream.html">stream</a>）。写入的数据会被用于计算hmac。写入终止后，可以使用<code>read()</code>方法获取计算后的摘要值。之前版本的<code>update</code>和<code>digest</code>方法仍然支持。

</p>
<p><code>algorithm</code> is dependent on the available algorithms supported by
OpenSSL - see createHash above.  <code>key</code> is the hmac key to be used.

</p>
<p><code>algorithm</code>在OpenSSL支持的算法列表中被抛弃了——见上方createHash部分。<code>key</code>是hmac算法用到的密钥。

</p>
<h2>Class: Hmac<span><a href="all.html#all_class_hmac_1" id="all_class_hmac_1">#</a></span></h2>
<p>Class for creating cryptographic hmac content.

</p>
<p>用于创建hmac加密图谱（cryptographic）的类。

</p>
<p>Returned by <code>crypto.createHmac</code>.

</p>
<p>由<code>crypto.createHmac</code>返回。

</p>
<h3>hmac.update(data)<span><a href="all.html#all_hmac_update_data_1" id="all_hmac_update_data_1">#</a></span></h3>
<p>Update the hmac content with the given <code>data</code>.  This can be called
many times with new data as it is streamed.

</p>
<p>通过提供的数据更新hmac对象。因为它是流式数据，所以可以使用新数据调用很多次。

</p>
<h3>hmac.digest([encoding])<span><a href="all.html#all_hmac_digest_encoding_1" id="all_hmac_digest_encoding_1">#</a></span></h3>
<p>Calculates the digest of all of the passed data to the hmac.  The
<code>encoding</code> can be <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> or <code>&apos;base64&apos;</code>.  If no encoding
is provided, then a buffer is returned.

</p>
<p>计算传入的所有数据的hmac摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。

</p>
<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method has been
called.

</p>
<p>注意： <code>hmac</code>对象在调用<code>digest()</code>之后就不再可用了。

</p>
<h2>crypto.createCipher(algorithm, password)<span><a href="all.html#all_crypto_createcipher_algorithm_password_1" id="all_crypto_createcipher_algorithm_password_1">#</a></span></h2>
<p>Creates and returns a cipher object, with the given algorithm and
password.

</p>
<p>用给定的算法和密码，创建并返回一个cipher加密算法的对象。（译者：cipher 就是加密算法的意思， ssl 的 cipher 主要是对称加密算法和不对称加密算法的组合。）

</p>
<p><code>algorithm</code> is dependent on OpenSSL, examples are <code>&apos;aes192&apos;</code>, etc.  On
recent releases, <code>openssl list-cipher-algorithms</code> will display the
available cipher algorithms.  <code>password</code> is used to derive key and IV,
which must be a <code>&apos;binary&apos;</code> encoded string or a <a href="buffer.html">buffer</a>.

</p>
<p><code>algorithm</code>算法是依赖OpenSSL库的, 例如: <code>&apos;aes192&apos;</code>算法等。在最近发布的版本， 执行命令 <code>openssl list-cipher-algorithms</code> 就会显示出所有可用的加密算法，<code>password</code>是用来派生key和IV的，它必须是一个 <code>&apos;binary&apos;</code> 2进制格式的字符串或者是一个<a href="buffer.html">buffer</a>。（译者：key表示密钥，IV表示向量在加密过程和解密过程都要使用）

</p>
<p>It is a <a href="stream.html">stream</a> that is both readable and writable.  The
written data is used to compute the hash.  Once the writable side of
the stream is ended, use the <code>read()</code> method to get the computed hash
digest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.

</p>
<p>它是一个既可读又可写的<a href="stream.html">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。

</p>
<h2>crypto.createCipheriv(algorithm, key, iv)<span><a href="all.html#all_crypto_createcipheriv_algorithm_key_iv_1" id="all_crypto_createcipheriv_algorithm_key_iv_1">#</a></span></h2>
<p>Creates and returns a cipher object, with the given algorithm, key and
iv.

</p>
<p>用给定的算法、密码和向量，创建并返回一个cipher加密算法的对象。

</p>
<p><code>algorithm</code> is the same as the argument to <code>createCipher()</code>.  <code>key</code> is
the raw key used by the algorithm.  <code>iv</code> is an <a href="http://en.wikipedia.org/wiki/Initialization_vector">initialization
vector</a>.

</p>
<p><code>algorithm</code>算法和<code>createCipher()</code> 方法的参数相同.  <code>key</code>密钥是一个被算法使用的原始密钥，<code>iv</code>是一个<a href="http://en.wikipedia.org/wiki/Initialization_vector">初始化向量</a>。

</p>
<p><code>key</code> and <code>iv</code> must be <code>&apos;binary&apos;</code> encoded strings or
<a href="buffer.html">buffers</a>.

</p>
<p><code>key</code>密钥和<code>iv</code>向量必须是<code>&apos;binary&apos;</code>2进制格式的字符串或<a href="buffer.html">buffers</a>.

</p>
<h2>Class: Cipher<span><a href="all.html#all_class_cipher_1" id="all_class_cipher_1">#</a></span></h2>
<p>Class for encrypting data.

</p>
<p>这个类是用来加密数据的。

</p>
<p>Returned by <code>crypto.createCipher</code> and <code>crypto.createCipheriv</code>.

</p>
<p>这个类由 <code>crypto.createCipher</code> 和 <code>crypto.createCipheriv</code> 返回。

</p>
<p>Cipher objects are <a href="stream.html">streams</a> that are both readable and
writable.  The written plain text data is used to produce the
encrypted data on the readable side.  The legacy <code>update</code> and <code>final</code>
methods are also supported.

</p>
<p>Cipher加密对象是 <a href="stream.html">streams</a>，他是具有 readable 可读和 writable 可写的。写入的纯文本数据是用来在可读流一侧加密数据的。
以前版本的<code>update</code> 和<code>final</code>方法也还是支持的。

</p>
<h3>cipher.update(data, [input_encoding], [output_encoding])<span><a href="all.html#all_cipher_update_data_input_encoding_output_encoding_1" id="all_cipher_update_data_input_encoding_output_encoding_1">#</a></span></h3>
<p>Updates the cipher with <code>data</code>, the encoding of which is given in
<code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code>.  If no
encoding is provided, then a buffer is expected.

</p>
<p>用<code>data</code>参数更新cipher加密对象, 它的编码<code>input_encoding</code>必须是下列给定编码的 <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code> 中一种。如果没有编码参数，那么打他参数必须是一个buffer。

</p>
<p>The <code>output_encoding</code> specifies the output format of the enciphered
data, and can be <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>参数 <code>output_encoding</code>输出编码指定了加密数据的输出格式，可以是<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或者<code>&apos;hex&apos;</code>，如果没有提供这个参数，buffer将会返回。

</p>
<p>Returns the enciphered contents, and can be called many times with new
data as it is streamed.

</p>
<p>返回加密内容，并且Returns the enciphered contents, 用新数据作为流的话，它可以被调用多次。

</p>
<h3>cipher.final([output_encoding])<span><a href="all.html#all_cipher_final_output_encoding_1" id="all_cipher_final_output_encoding_1">#</a></span></h3>
<p>Returns any remaining enciphered contents, with <code>output_encoding</code>
being one of: <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is
provided, then a buffer is returned.

</p>
<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>中的任意一个。 如果没有提供编码格式，则返回一个buffer对象。

</p>
<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method has been
called.

</p>
<p>注: 调用<code>final()</code>函数后<code>cipher</code> 对象不能被使用。

</p>
<h3>cipher.setAutoPadding(auto_padding=true)<span><a href="all.html#all_cipher_setautopadding_auto_padding_true_1" id="all_cipher_setautopadding_auto_padding_true_1">#</a></span></h3>
<p>You can disable automatic padding of the input data to block size. If
<code>auto_padding</code> is false, the length of the entire input data must be a
multiple of the cipher&apos;s block size or <code>final</code> will fail.  Useful for
non-standard padding, e.g. using <code>0x0</code> instead of PKCS padding. You
must call this before <code>cipher.final</code>.

</p>
<p>对于将输入数据自动填充到块大小的功能，你可以将其禁用。如果<code>auto_padding</code>是false， 那么整个输入数据的长度必须是加密器的块大小的整倍数，否则<code>final</code>会失败。这对非标准的填充很有用，例如使用<code>0x0</code>而不是PKCS的填充。这个函数必须在<code>cipher.final</code>之前调用。

</p>
<h2>crypto.createDecipher(algorithm, password)<span><a href="all.html#all_crypto_createdecipher_algorithm_password_1" id="all_crypto_createdecipher_algorithm_password_1">#</a></span></h2>
<p>Creates and returns a decipher object, with the given algorithm and
key.  This is the mirror of the <a href="all.html#crypto_crypto_createcipher_algorithm_password">createCipher()</a> above.

</p>
<p>根据给定的算法和密钥，创建并返回一个解密器对象。这是上述<a href="all.html#crypto_crypto_createcipher_algorithm_password">createCipher()</a>的一个镜像。

</p>
<h2>crypto.createDecipheriv(algorithm, key, iv)<span><a href="all.html#all_crypto_createdecipheriv_algorithm_key_iv_1" id="all_crypto_createdecipheriv_algorithm_key_iv_1">#</a></span></h2>
<p>Creates and returns a decipher object, with the given algorithm, key
and iv.  This is the mirror of the <a href="all.html#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a> above.

</p>
<p>Creates and returns a decipher object, with the given algorithm, key
and iv.  This is the mirror of the <a href="all.html#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a> above.
根据给定的算法，密钥和初始化向量，创建并返回一个解密器对象。这是上述<a href="all.html#crypto_crypto_createcipheriv_algorithm_key_iv">createCipheriv()</a>的一个镜像。


</p>
<h2>Class: Decipher<span><a href="all.html#all_class_decipher_1" id="all_class_decipher_1">#</a></span></h2>
<p>Class for decrypting data.

</p>
<p>解密数据的类。

</p>
<p>Returned by <code>crypto.createDecipher</code> and <code>crypto.createDecipheriv</code>.

</p>
<p>由<code>crypto.createDecipher</code>和<code>crypto.createDecipheriv</code>返回。

</p>
<p>Decipher objects are <a href="stream.html">streams</a> that are both readable and
writable.  The written enciphered data is used to produce the
plain-text data on the the readable side.  The legacy <code>update</code> and
<code>final</code> methods are also supported.

</p>
<p>解密器对象是可读写的<a href="stream.html">流</a>对象。用被写入的加密数据生成可读的平文数据。解码器对象也支持The legacy <code>update</code>和
<code>final</code>函数。

</p>
<h3>decipher.update(data, [input_encoding], [output_encoding])<span><a href="all.html#all_decipher_update_data_input_encoding_output_encoding_1" id="all_decipher_update_data_input_encoding_output_encoding_1">#</a></span></h3>
<p>Updates the decipher with <code>data</code>, which is encoded in <code>&apos;binary&apos;</code>,
<code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is provided, then a buffer is
expected.

</p>
<p>用<code>data</code>来更新解密器，其中<code>data</code>以<code>&apos;binary&apos;</code>,
<code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>进行编码。如果没有指明编码方式，则默认<code>data</code>是一个buffer对象。

</p>
<p>The <code>output_decoding</code> specifies in what format to return the
deciphered plaintext: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>.  If no
encoding is provided, then a buffer is returned.

</p>
<p><code>output_decoding</code>指明了用以下哪种编码方式返回解密后的平文：<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>decipher.final([output_encoding])<span><a href="all.html#all_decipher_final_output_encoding_1" id="all_decipher_final_output_encoding_1">#</a></span></h3>
<p>Returns any remaining plaintext which is deciphered, with
<code>output_encoding</code> being one of: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>.  If
no encoding is provided, then a buffer is returned.

</p>
<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>中的任意一个。如果没有指明编码方式，则返回一个buffer对象。

</p>
<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method has been
called.

</p>
<p>注: 调用<code>final()</code>函数后不能使用<code>decipher</code> 对象。

</p>
<h3>decipher.setAutoPadding(auto_padding=true)<span><a href="all.html#all_decipher_setautopadding_auto_padding_true_1" id="all_decipher_setautopadding_auto_padding_true_1">#</a></span></h3>
<p>You can disable auto padding if the data has been encrypted without
standard block padding to prevent <code>decipher.final</code> from checking and
removing it. Can only work if the input data&apos;s length is a multiple of
the ciphers block size. You must call this before streaming data to
<code>decipher.update</code>.

</p>
<p>如果数据以非标准的块填充方式被加密，那么你可以禁用自动填充来防止<code>decipher.final</code>对数据进行检查和移除。这只有在输入数据的长度是加密器块大小的整倍数时才有效。这个函数必须在将数据流传递给<code>decipher.update</code>之前调用。

</p>
<h2>crypto.createSign(algorithm)<span><a href="all.html#all_crypto_createsign_algorithm_1" id="all_crypto_createsign_algorithm_1">#</a></span></h2>
<p>Creates and returns a signing object, with the given algorithm.  On
recent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will
display the available signing algorithms. Examples are <code>&apos;RSA-SHA256&apos;</code>.

</p>
<p>根据给定的算法，创建并返回一个signing对象。在最近的OpenSSL发布版本中，<code>openssl list-public-key-algorithms</code>会列出可用的签名算法，例如<code>&apos;RSA-SHA256&apos;</code>。

</p>
<h2>Class: Sign<span><a href="all.html#all_class_sign_1" id="all_class_sign_1">#</a></span></h2>
<p>Class for generating signatures.

</p>
<p>生成数字签名的类

</p>
<p>Returned by <code>crypto.createSign</code>.

</p>
<p>由<code>crypto.createSign</code>返回。

</p>
<p>Sign objects are writable <a href="stream.html">streams</a>.  The written data is
used to generate the signature.  Once all of the data has been
written, the <code>sign</code> method will return the signature.  The legacy
<code>update</code> method is also supported.

</p>
<p>Sign对象是可写的<a href="stream.html">流</a>对象。被写入的数据用来生成数字签名。当所有的数据都被写入后，<code>sign</code> 函数会返回数字签名。Sign对象也支持The legacy
<code>update</code>函数。

</p>
<h3>sign.update(data)<span><a href="all.html#all_sign_update_data_1" id="all_sign_update_data_1">#</a></span></h3>
<p>Updates the sign object with data.  This can be called many times
with new data as it is streamed.

</p>
<p>用<code>data</code>来更新sign对象。 This can be called many times
with new data as it is streamed.

</p>
<h3>sign.sign(private_key, [output_format])<span><a href="all.html#all_sign_sign_private_key_output_format_1" id="all_sign_sign_private_key_output_format_1">#</a></span></h3>
<p>Calculates the signature on all the updated data passed through the
sign.  <code>private_key</code> is a string containing the PEM encoded private
key for signing.

</p>
<p>根据所有传送给sign的更新数据来计算电子签名。<code>private_key</code>是一个包含了签名私钥的字符串，而该私钥是用PEM编码的。

</p>
<p>Returns the signature in <code>output_format</code> which can be <code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is
returned.

</p>
<p>返回一个数字签名，该签名的格式可以是<code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>. 如果没有指明编码方式，则返回一个buffer对象。

</p>
<p>Note: <code>sign</code> object can not be used after <code>sign()</code> method has been
called.

</p>
<p>注：调用<code>sign()</code>后不能使用<code>sign</code>对象。

</p>
<h2>crypto.createVerify(algorithm)<span><a href="all.html#all_crypto_createverify_algorithm_1" id="all_crypto_createverify_algorithm_1">#</a></span></h2>
<p>Creates and returns a verification object, with the given algorithm.
This is the mirror of the signing object above.

</p>
<p>根据指明的算法，创建并返回一个验证器对象。这是上述签名器对象的镜像。

</p>
<h2>Class: Verify<span><a href="all.html#all_class_verify_1" id="all_class_verify_1">#</a></span></h2>
<p>Class for verifying signatures.

</p>
<p>用来验证数字签名的类。

</p>
<p>Returned by <code>crypto.createVerify</code>.

</p>
<p>由 <code>crypto.createVerify</code>返回。

</p>
<p>Verify objects are writable <a href="stream.html">streams</a>.  The written data
is used to validate against the supplied signature.  Once all of the
data has been written, the <code>verify</code> method will return true if the
supplied signature is valid.  The legacy <code>update</code> method is also
supported.

</p>
<p>验证器对象是可写的<a href="stream.html">流</a>对象.  被写入的数据会被用来验证提供的数字签名。在所有的数据被写入后，如果提供的数字签名有效，<code>verify</code>函数会返回真。验证器对象也支持 The legacy <code>update</code>函数。

</p>
<h3>verifier.update(data)<span><a href="all.html#all_verifier_update_data_1" id="all_verifier_update_data_1">#</a></span></h3>
<p>Updates the verifier object with data.  This can be called many times
with new data as it is streamed.

</p>
<p>用数据更新验证器对象。This can be called many times
with new data as it is streamed.

</p>
<h3>verifier.verify(object, signature, [signature_format])<span><a href="all.html#all_verifier_verify_object_signature_signature_format_1" id="all_verifier_verify_object_signature_signature_format_1">#</a></span></h3>
<p>Verifies the signed data by using the <code>object</code> and <code>signature</code>.
<code>object</code> is  a string containing a PEM encoded object, which can be
one of RSA public key, DSA public key, or X.509 certificate.
<code>signature</code> is the previously calculated signature for the data, in
the <code>signature_format</code> which can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>.
If no encoding is specified, then a buffer is expected.

</p>
<p>用<code>object</code>和<code>signature</code>来验证被签名的数据。
<code>object</code>是一个字符串，这个字符串包含了一个被PEM编码的对象，这个对象可以是RSA公钥，DSA公钥或者X.509 证书。
<code>signature</code>是之前计算出来的数字签名，其中的 <code>signature_format</code>可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>.
如果没有指明编码方式，那么默认是一个buffer对象。

</p>
<p>Returns true or false depending on the validity of the signature for
the data and public key.

</p>
<p>根据数字签名对于数据和公钥的有效性，返回true或false。

</p>
<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method has been
called.

</p>
<p>注: 调用<code>verify()</code>函数后不能使用<code>verifier</code>对象。

</p>
<h2>crypto.createDiffieHellman(prime_length)<span><a href="all.html#all_crypto_creatediffiehellman_prime_length_1" id="all_crypto_creatediffiehellman_prime_length_1">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object and generates a prime of
the given bit length. The generator used is <code>2</code>.

</p>
<p>创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象，并根据给定的位长度生成一个质数。所用的生成器是<code>s</code>。

</p>
<h2>crypto.createDiffieHellman(prime, [encoding])<span><a href="all.html#all_crypto_creatediffiehellman_prime_encoding_1" id="all_crypto_creatediffiehellman_prime_encoding_1">#</a></span></h2>
<p>Creates a Diffie-Hellman key exchange object using the supplied prime.
The generator used is <code>2</code>. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or
<code>&apos;base64&apos;</code>.  If no encoding is specified, then a buffer is expected.

</p>
<p>根据给定的质数创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象。
所用的生成器是<code>2</code>。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或
<code>&apos;base64&apos;</code>。如果没有指明编码方式，则默认是一个buffer对象。

</p>
<h2>Class: DiffieHellman<span><a href="all.html#all_class_diffiehellman_1" id="all_class_diffiehellman_1">#</a></span></h2>
<p>The class for creating Diffie-Hellman key exchanges.

</p>
<p>创建迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)的类。

</p>
<p>Returned by <code>crypto.createDiffieHellman</code>.

</p>
<p>由<code>crypto.createDiffieHellman</code>返回。

</p>
<h3>diffieHellman.generateKeys([encoding])<span><a href="all.html#all_diffiehellman_generatekeys_encoding_1" id="all_diffiehellman_generatekeys_encoding_1">#</a></span></h3>
<p>Generates private and public Diffie-Hellman key values, and returns
the public key in the specified encoding. This key should be
transferred to the other party. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,
or <code>&apos;base64&apos;</code>.  If no encoding is provided, then a buffer is returned.

</p>
<p>生成迪菲－赫尔曼(Diffie-Hellman)算法的公钥和私钥，并根据指明的编码方式返回公钥。这个公钥可以转交给第三方。编码方式可以是 <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>.  如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])<span><a href="all.html#all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding_1" id="all_diffiehellman_computesecret_other_public_key_input_encoding_output_encoding_1">#</a></span></h3>
<p>Computes the shared secret using <code>other_public_key</code> as the other
party&apos;s public key and returns the computed shared secret. Supplied
key is interpreted using specified <code>input_encoding</code>, and secret is
encoded using specified <code>output_encoding</code>. Encodings can be
<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If the input encoding is not
provided, then a buffer is expected.

</p>
<p>以<code>other_public_key</code>作为第三方公钥来计算共享秘密，并返回这个共享秘密。参数中的密钥会以<code>input_encoding</code>编码方式来解读，而共享密钥则会用<code>output_encoding</code>进行编码。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>。如果没有提供输入的编码方式，则默认为一个buffer对象。

</p>
<p>If no output encoding is given, then a buffer is returned.

</p>
<p>如果没有指明输出的编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getPrime([encoding])<span><a href="all.html#all_diffiehellman_getprime_encoding_1" id="all_diffiehellman_getprime_encoding_1">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getGenerator([encoding])<span><a href="all.html#all_diffiehellman_getgenerator_encoding_1" id="all_diffiehellman_getgenerator_encoding_1">#</a></span></h3>
<p>Returns the Diffie-Hellman prime in the specified encoding, which can
be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getPublicKey([encoding])<span><a href="all.html#all_diffiehellman_getpublickey_encoding_1" id="all_diffiehellman_getpublickey_encoding_1">#</a></span></h3>
<p>Returns the Diffie-Hellman public key in the specified encoding, which
can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,
then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)公钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。 如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.getPrivateKey([encoding])<span><a href="all.html#all_diffiehellman_getprivatekey_encoding_1" id="all_diffiehellman_getprivatekey_encoding_1">#</a></span></h3>
<p>Returns the Diffie-Hellman private key in the specified encoding,
which can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is
provided, then a buffer is returned.

</p>
<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)私钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.setPublicKey(public_key, [encoding])<span><a href="all.html#all_diffiehellman_setpublickey_public_key_encoding_1" id="all_diffiehellman_setpublickey_public_key_encoding_1">#</a></span></h3>
<p>Sets the Diffie-Hellman public key. Key encoding can be <code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<p>设置迪菲－赫尔曼(Diffie-Hellman)公钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h3>diffieHellman.setPrivateKey(private_key, [encoding])<span><a href="all.html#all_diffiehellman_setprivatekey_private_key_encoding_1" id="all_diffiehellman_setprivatekey_private_key_encoding_1">#</a></span></h3>
<p>Sets the Diffie-Hellman private key. Key encoding can be <code>&apos;binary&apos;</code>,
<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is
expected.

</p>
<p>设置迪菲－赫尔曼(Diffie-Hellman)私钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。

</p>
<h2>crypto.getDiffieHellman(group_name)<span><a href="all.html#all_crypto_getdiffiehellman_group_name_1" id="all_crypto_getdiffiehellman_group_name_1">#</a></span></h2>
<p>Creates a predefined Diffie-Hellman key exchange object.  The
supported groups are: <code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code> (defined in <a href="http://www.rfc-editor.org/rfc/rfc2412.txt">RFC
2412</a>) and <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>,
<code>&apos;modp18&apos;</code> (defined in <a href="http://www.rfc-editor.org/rfc/rfc3526.txt">RFC 3526</a>).  The returned object mimics the
interface of objects created by <a href="all.html#crypto_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman()</a>
above, but will not allow to change the keys (with
<a href="all.html#crypto_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey()</a> for example).  The advantage of using
this routine is that the parties don&apos;t have to generate nor exchange
group modulus beforehand, saving both processor and communication
time.

</p>
<p>创建一个预定义的迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)对象。支持以下的D-H组：<code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code> (在<a href="http://www.rfc-editor.org/rfc/rfc2412.txt">RFC
2412</a>中定义) 和 <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>,
<code>&apos;modp18&apos;</code> (在 <a href="http://www.rfc-editor.org/rfc/rfc3526.txt">RFC 3526</a>中定义)。返回的对象模仿了上述 <a href="all.html#crypto_crypto_creatediffiehellman_prime_encoding">crypto.createDiffieHellman()</a>方法所创建的对象的接口，但不会晕允许密钥交换
(例如像
<a href="all.html#crypto_diffiehellman_setpublickey_public_key_encoding">diffieHellman.setPublicKey()</a>那样)。执行这套流程的好处是双方不需要事先生成或交换组余数，节省了处理和通信时间。

</p>
<p>Example (obtaining a shared secret):

</p>
<p>例子 (获取一个共享秘密):

</p>
<pre><code>/* alice_secret和 bob_secret应该是一样的 */
console.log(alice_secret == bob_secret);</code></pre>
<h2>crypto.pbkdf2(password, salt, iterations, keylen, callback)<span><a href="all.html#all_crypto_pbkdf2_password_salt_iterations_keylen_callback_1" id="all_crypto_pbkdf2_password_salt_iterations_keylen_callback_1">#</a></span></h2>
<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive
a key of given length from the given password, salt and iterations.
The callback gets two arguments <code>(err, derivedKey)</code>.

</p>
<p>异步PBKDF2提供了一个伪随机函数 HMAC-SHA1，根据给定密码的长度，salt和iterations来得出一个密钥。回调函数得到两个参数 <code>(err, derivedKey)</code>。

</p>
<h2>crypto.pbkdf2Sync(password, salt, iterations, keylen)<span><a href="all.html#all_crypto_pbkdf2sync_password_salt_iterations_keylen_1" id="all_crypto_pbkdf2sync_password_salt_iterations_keylen_1">#</a></span></h2>
<p>Synchronous PBKDF2 function.  Returns derivedKey or throws error.

</p>
<p>同步 PBKDF2 函数。返回derivedKey或抛出一个错误。

</p>
<h2>crypto.randomBytes(size, [callback])<span><a href="all.html#all_crypto_randombytes_size_callback_1" id="all_crypto_randombytes_size_callback_1">#</a></span></h2>
<p>Generates cryptographically strong pseudo-random data. Usage:

</p>
<p>生成密码学强度的伪随机数据。用法：

</p>
<pre><code>// 同步
try {
  var buf = crypto.randomBytes(256);
  console.log(&apos;有 %d 字节的随机数据： %s&apos;, buf.length, buf);
} catch (ex) {
  // handle error
}</code></pre>
<h2>crypto.pseudoRandomBytes(size, [callback])<span><a href="all.html#all_crypto_pseudorandombytes_size_callback_1" id="all_crypto_pseudorandombytes_size_callback_1">#</a></span></h2>
<p>Generates <em>non</em>-cryptographically strong pseudo-random data. The data
returned will be unique if it is sufficiently long, but is not
necessarily unpredictable. For this reason, the output of this
function should never be used where unpredictability is important,
such as in the generation of encryption keys.

</p>
<p>生成<em>非</em>密码学强度的伪随机数据。如果数据足够长的话会返回一个唯一的数据，但这个返回值不一定是不可预料的。基于这个原因，当不可预料性很重要时，这个函数的返回值永远都不应该被使用，例如在生成加密的密钥时。

</p>
<p>Usage is otherwise identical to <code>crypto.randomBytes</code>.

</p>
<p>用法与 <code>crypto.randomBytes</code>一模一样。

</p>
<h2>crypto.DEFAULT_ENCODING<span><a href="all.html#all_crypto_default_encoding_1" id="all_crypto_default_encoding_1">#</a></span></h2>
<p>The default encoding to use for functions that can take either strings
or buffers.  The default value is <code>&apos;buffer&apos;</code>, which makes it default
to using Buffer objects.  This is here to make the crypto module more
easily compatible with legacy programs that expected <code>&apos;binary&apos;</code> to be
the default encoding.

</p>
<p>对于可以接受字符串或buffer对象的函数的默认编码方式。默认值是<code>&apos;buffer&apos;</code>，所以默认使用Buffer对象。这是为了让crypto模块与默认<code>&apos;binary&apos;</code>为编码方式的遗留程序更容易兼容。

</p>
<p>Note that new programs will probably expect buffers, so only use this
as a temporary measure.

</p>
<p>要注意，新的程序会期待buffer对象，所以使用这个时请只作为暂时的手段。

</p>
<h2>Recent API Changes<span><a href="all.html#all_recent_api_changes_1" id="all_recent_api_changes_1">#</a></span></h2>
<p>The Crypto module was added to Node before there was the concept of a
unified Stream API, and before there were Buffer objects for handling
binary data.

</p>
<p>早在统一的流API概念出现，以及引入Buffer对象来处理二进制数据之前，Crypto模块就被添加到Node。

</p>
<p>As such, the streaming classes don&apos;t have the typical methods found on
other Node classes, and many methods accepted and returned
Binary-encoded strings by default rather than Buffers.  This was
changed to use Buffers by default instead.

</p>
<p>因为这样，与流有关的类中并没有其它Node类的典型函数，而且很多函数接受和返回默认的二进制编码的字符串，而不是Buffer对象。在最近的修改中，这些函数都被改成默认使用Buffer对象。

</p>
<p>This is a breaking change for some use cases, but not all.

</p>
<p>这对于某些(但不是全部)使用场景来讲是重大的改变。

</p>
<p>For example, if you currently use the default arguments to the Sign
class, and then pass the results to the Verify class, without ever
inspecting the data, then it will continue to work as before.  Where
you once got a binary string and then presented the binary string to
the Verify object, you&apos;ll now get a Buffer, and present the Buffer to
the Verify object.

</p>
<p>例如，如果你现在使用Sign类的默认参数，然后在没有检查数据的情况下，将结果传递给Verify类，那么程序会照常工作。在以前，你会拿到一个二进制字符串，然后它传递给Verify对象；而现在，你会得到一个Buffer对象，然后把它传递给Verify对象。

</p>
<p>However, if you were doing things with the string data that will not
work properly on Buffers (such as, concatenating them, storing in
databases, etc.), or you are passing binary strings to the crypto
functions without an encoding argument, then you will need to start
providing encoding arguments to specify which encoding you&apos;d like to
use.  To switch to the previous style of using binary strings by
default, set the <code>crypto.DEFAULT_ENCODING</code> field to &apos;binary&apos;.  Note
that new programs will probably expect buffers, so only use this as a
temporary measure.

</p>
<p>但是，如果你以前是使用那些在Buffer对象上不能正常工作的字符串数据，或者以默认编码方式将二进制数据传递给加密函数的话，那你就要开始提供编码方式参数来指明你想使用的编码方式了。如果想准换回旧的风格默认使用二进制字符串，那么你需要把<code>crypto.DEFAULT_ENCODING</code>字段设为&apos;binary&apos;。但请注意，因为新的程序很可能会期望buffer对象，所以仅将此当做临时手段。

</p>
<h1>TLS (SSL)<span><a href="all.html#all_tls_ssl_1" id="all_tls_ssl_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Use <code>require(&apos;tls&apos;)</code> to access this module.

</p>
<p>使用 <code>require(&apos;tls&apos;)</code> 来访问此模块。

</p>
<p>The <code>tls</code> module uses OpenSSL to provide Transport Layer Security and/or
Secure Socket Layer: encrypted stream communication.

</p>
<p><code>tls</code> 模块使用 OpenSSL 来提供传输层安全协议（Transport Layer Security）和/或安全套接层（Secure Socket Layer）：加密过的流通讯。

</p>
<p>TLS/SSL is a public/private key infrastructure. Each client and each
server must have a private key. A private key is created like this

</p>
<p>TLS/SSL 是一种公钥/私钥架构。每个客户端和服务器都必有一个私钥。一个私钥使用类似的方式创建：

</p>
<pre><code>openssl genrsa -out ryans-key.pem 1024</code></pre>
<p>All severs and some clients need to have a certificate. Certificates are public
keys signed by a Certificate Authority or self-signed. The first step to
getting a certificate is to create a &quot;Certificate Signing Request&quot; (CSR)
file. This is done with:

</p>
<p>所有服务器和某些客户端需要具备证书。证书是证书办法机构签发或自签发的公钥。获取证书的第一步是创建一个“证书签发申请”（CSR）文件。使用这条命令完成：

</p>
<pre><code>openssl req -new -key ryans-key.pem -out ryans-csr.pem</code></pre>
<p>To create a self-signed certificate with the CSR, do this:

</p>
<p>像这样使用 CSR 创建一个自签名证书：

</p>
<pre><code>openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</code></pre>
<p>Alternatively you can send the CSR to a Certificate Authority for signing.

</p>
<p>又或者你可以将 CSR 发送给一个数字证书认证机构请求签名。

</p>
<p>(TODO: docs on creating a CA, for now interested users should just look at
<code>test/fixtures/keys/Makefile</code> in the Node source code)

</p>
<p>To create .pfx or .p12, do this:

</p>
<p>像这样创建 .pfx 或 .p12：

</p>
<pre><code>openssl pkcs12 -export -in agent5-cert.pem -inkey agent5-key.pem \
    -certfile ca-cert.pem -out agent5.pfx</code></pre>
<ul>
<li><code>in</code>:  certificate</li>
<li><code>inkey</code>: private key</li>
<li><p><code>certfile</code>: all CA certs concatenated in one file like
<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></p>
</li>
<li><p><code>in</code>:  certificate</p>
</li>
<li><code>inkey</code>: private key</li>
<li><code>certfile</code>: all CA certs concatenated in one file like
<code>cat ca1-cert.pem ca2-cert.pem &gt; ca-cert.pem</code></li>
</ul>
<h2>Client-initiated renegotiation attack mitigation<span><a href="all.html#all_client_initiated_renegotiation_attack_mitigation_1" id="all_client_initiated_renegotiation_attack_mitigation_1">#</a></span></h2>
<!-- type=misc -->

<p>The TLS protocol lets the client renegotiate certain aspects of the TLS session.
Unfortunately, session renegotiation requires a disproportional amount of
server-side resources, which makes it a potential vector for denial-of-service
attacks.

</p>
<p>TLS协议会令客户端可以重新协商TLS会话的某些方面。但是，会话的重新协商是需要相应量的服务器端资源的，所以导致其变成一个阻断服务攻击（denial-of-service）的潜在媒介。

</p>
<p>To mitigate this, renegotiations are limited to three times every 10 minutes. An
error is emitted on the <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a> instance when the threshold is
exceeded. The limits are configurable:

</p>
<p>为了减低这种情况的发生，重新协商被限制在每10分钟三次。如果超过这个数目，那么在<a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>实例上就会分发一个错误。这个限制是可设置的：

</p>
<ul>
<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: renegotiation limit, default is 3.</p>
</li>
<li><p><code>tls.CLIENT_RENEG_LIMIT</code>: 重新协商的次数限制，默认为3。</p>
</li>
<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: renegotiation window in seconds, default is
10 minutes.</p>
</li>
<li><p><code>tls.CLIENT_RENEG_WINDOW</code>: 重新协商窗口的秒数，默认为600（10分钟）。</p>
</li>
</ul>
<p>Don&apos;t change the defaults unless you know what you are doing.

</p>
<p>除非你完全理解整个机制和清楚自己要干什么，否则不要改变这个默认值。

</p>
<p>To test your server, connect to it with <code>openssl s_client -connect address:port</code>
and tap <code>R&lt;CR&gt;</code> (that&apos;s the letter <code>R</code> followed by a carriage return) a few
times.

</p>
<p>要测试你的服务器的话，用命令 <code>openssl s_client -connect 地址:端口</code>连接上服务器，然后敲击<code>R&lt;CR&gt;</code>（字母键<code>R</code>加回车键）几次。

</p>
<h2>NPN 和 SNI<span><a href="all.html#all_npn_sni_1" id="all_npn_sni_1">#</a></span></h2>
<!-- type=misc -->

<p>NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS
handshake extensions allowing you:

</p>
<ul>
<li>NPN - to use one TLS server for multiple protocols (HTTP, SPDY)</li>
<li>SNI - to use one TLS server for multiple hostnames with different SSL
certificates.</li>
</ul>
<h2>tls.getCiphers()<span><a href="all.html#all_tls_getciphers_1" id="all_tls_getciphers_1">#</a></span></h2>
<p>Returns an array with the names of the supported SSL ciphers.

</p>
<p>返回一个数组，其中包含了所支持的SSL加密器的名字。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var ciphers = tls.getCiphers();
console.log(ciphers); // [&apos;AES128-SHA&apos;, &apos;AES256-SHA&apos;, ...]</code></pre>
<h2>tls.createServer(options, [secureConnectionListener])<span><a href="all.html#all_tls_createserver_options_secureconnectionlistener_1" id="all_tls_createserver_options_secureconnectionlistener_1">#</a></span></h2>
<p>Creates a new <a href="all.html#tls_class_tls_server">tls.Server</a>.  The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="all.html#tls_event_secureconnection">secureConnection</a> event.  The
<code>options</code> object has these possibilities:

</p>
<p>新建一个新的 <a href="all.html#tls_class_tls_server">tls.Server</a>.  The <code>connectionListener</code> 参数会自动设置为 <a href="all.html#tls_event_secureconnection">secureConnection</a> 事件的监听器. 这个 <code>options</code> 对象有这些可能性:

</p>
<ul>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and
CA certs of the server in PFX or PKCS12 format. (Mutually exclusive with
the <code>key</code>, <code>cert</code> and <code>ca</code> options.)</p>
</li>
<li><p><code>pfx</code>: 一个String 或<code>Buffer</code>包含了私钥, 证书和CA certs, 一般是 PFX 或者 PKCS12 格式. (Mutually exclusive with
the <code>key</code>, <code>cert</code> and <code>ca</code> options.)</p>
</li>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the server in
PEM format. (Required)</p>
</li>
<li><p><code>key</code>: 一个字符串或 <code>Buffer</code>对象，其中包含了PEF格式的服务器的私钥。 (必需)</p>
</li>
<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code>passphrase</code>: 私钥或pfx密码的字符串。</p>
</li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the server in
PEM format. (Required)</p>
</li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known &quot;root&quot; CAs will be used, like VeriSign.
These are used to authorize connections.</p>
</li>
<li><p><code>crl</code> : Either a string or list of strings of PEM encoded CRLs (Certificate
Revocation List)</p>
</li>
<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude.</p>
<p><strong>NOTE</strong>: Previous revisions of this section suggested <code>AES256-SHA</code> as an
acceptable cipher. Unfortunately, <code>AES256-SHA</code> is a CBC cipher and therefore
susceptible to BEAST attacks. Do <em>not</em> use it.</p>
</li>
<li><p><code>handshakeTimeout</code>: Abort the connection if the SSL/TLS handshake does not
finish in this many milliseconds. The default is 120 seconds.</p>
<p>A <code>&apos;clientError&apos;</code> is emitted on the <code>tls.Server</code> object whenever a handshake
times out.</p>
</li>
<li><p><code>honorCipherOrder</code> : When choosing a cipher, use the server&apos;s preferences
instead of the client preferences.</p>
<p>Although, this option is disabled by default, it is <em>recommended</em> that you
use this option in conjunction with the <code>ciphers</code> option to mitigate
BEAST attacks.</p>
</li>
<li><p><code>requestCert</code>: If <code>true</code> the server will request a certificate from
clients that connect and attempt to verify that certificate. Default:
<code>false</code>.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code> the server will reject any connection
which is not authorized with the list of supplied CAs. This option only
has an effect if <code>requestCert</code> is <code>true</code>. Default: <code>false</code>.</p>
</li>
<li><p><code>NPNProtocols</code>: An array or <code>Buffer</code> of possible NPN protocols. (Protocols
should be ordered by their priority).</p>
</li>
<li><p><code>SNICallback(servername, cb)</code>: A function that will be called if client
supports SNI TLS extension. Two argument will be passed to it: <code>servername</code>,
and <code>cb</code>. <code>SNICallback</code> should invoke <code>cb(null, ctx)</code>, where <code>ctx</code> is a
SecureContext instance.
(You can use <code>crypto.createCredentials(...).context</code> to get proper
SecureContext). If <code>SNICallback</code> wasn&apos;t provided - default callback with
high-level API will be used (see below).</p>
</li>
<li><p><code>sessionTimeout</code>: An integer specifying the seconds after which TLS
session identifiers and TLS session tickets created by the server are
timed out. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html">SSL_CTX_set_timeout</a> for more details.</p>
</li>
<li><p><code>sessionIdContext</code>: A string containing a opaque identifier for session
resumption. If <code>requestCert</code> is <code>true</code>, the default is MD5 hash value
generated from command-line. Otherwise, the default is not provided.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
</ul>
<p>Here is a simple example echo server:

</p>
<p>这是一个简单的应答服务器例子：

</p>
<pre><code>var server = tls.createServer(options, function(socket) {
  console.log(&apos;服务器已连接&apos;,
              socket.authorized ? &apos;已授权&apos; : &apos;未授权&apos;);
  socket.write(&quot;欢迎！\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;server bound&apos;);
});</code></pre>
<p>Or

</p>
<p>或者

</p>
<pre><code>};

var server = tls.createServer(options, function(socket) {
  console.log(&apos;server connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  socket.write(&quot;welcome!\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;server bound&apos;);
});</code></pre>
<p>You can test this server by connecting to it with <code>openssl s_client</code>:

</p>
<pre><code>var server = tls.createServer(options, function(socket) {
  console.log(&apos;服务器已连接&apos;,
              socket.authorized ? &apos;已授权&apos; : &apos;未授权&apos;);
  socket.write(&quot;欢迎！\n&quot;);
  socket.setEncoding(&apos;utf8&apos;);
  socket.pipe(socket);
});
server.listen(8000, function() {
  console.log(&apos;服务器已绑定&apos;);
});</code></pre>
<p>您可以使用 <code>openssl s_client</code> 连接这个服务器来测试：

</p>
<pre><code>openssl s_client -connect 127.0.0.1:8000</code></pre>
<h2>tls.connect(options, [callback])<span><a href="all.html#all_tls_connect_options_callback_2" id="all_tls_connect_options_callback_2">#</a></span></h2>
<h2>tls.connect(port, [host], [options], [callback])<span><a href="all.html#all_tls_connect_port_host_options_callback_2" id="all_tls_connect_port_host_options_callback_2">#</a></span></h2>
<h2>tls.connect(options, [callback])<span><a href="all.html#all_tls_connect_options_callback_3" id="all_tls_connect_options_callback_3">#</a></span></h2>
<h2>tls.connect(port, [host], [options], [callback])<span><a href="all.html#all_tls_connect_port_host_options_callback_3" id="all_tls_connect_port_host_options_callback_3">#</a></span></h2>
<p>Creates a new client connection to the given <code>port</code> and <code>host</code> (old API) or
<code>options.port</code> and <code>options.host</code>. (If <code>host</code> is omitted, it defaults to
<code>localhost</code>.) <code>options</code> should be an object which specifies:

</p>
<ul>
<li><p><code>host</code>: Host the client should connect to</p>
</li>
<li><p><code>port</code>: Port the client should connect to</p>
</li>
<li><p><code>socket</code>: Establish secure connection on a given socket rather than
creating a new socket. If this option is specified, <code>host</code> and <code>port</code>
are ignored.</p>
</li>
<li><p><code>pfx</code>: A string or <code>Buffer</code> containing the private key, certificate and
CA certs of the server in PFX or PKCS12 format.</p>
</li>
<li><p><code>key</code>: A string or <code>Buffer</code> containing the private key of the client in
PEM format.</p>
</li>
<li><p><code>passphrase</code>: A string of passphrase for the private key or pfx.</p>
</li>
<li><p><code>passphrase</code>: 私钥或pfx密码的字符串。</p>
</li>
<li><p><code>cert</code>: A string or <code>Buffer</code> containing the certificate key of the client in
PEM format.</p>
</li>
<li><p><code>ca</code>: An array of strings or <code>Buffer</code>s of trusted certificates. If this is
omitted several well known &quot;root&quot; CAs will be used, like VeriSign.
These are used to authorize connections.</p>
</li>
<li><p><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against
the list of supplied CAs. An <code>&apos;error&apos;</code> event is emitted if verification
fails. Default: <code>true</code>.</p>
</li>
<li><p><code>NPNProtocols</code>: An array of string or <code>Buffer</code> containing supported NPN
protocols. <code>Buffer</code> should have following format: <code>0x05hello0x05world</code>,
where first byte is next protocol name&apos;s length. (Passing array should
usually be much simpler: <code>[&apos;hello&apos;, &apos;world&apos;]</code>.)</p>
</li>
<li><p><code>servername</code>: Servername for SNI (Server Name Indication) TLS extension.</p>
</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
</ul>
<p>The <code>callback</code> parameter will be added as a listener for the
<a href="all.html#tls_event_secureconnect">&apos;secureConnect&apos;</a> event.

</p>
<p><code>callback</code>参数会被作为监听器添加到<a href="all.html#tls_event_secureconnect">&apos;secureConnect&apos;</a>事件。

</p>
<p><code>tls.connect()</code> returns a <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a> object.

</p>
<p><code>tls.connect()</code>返回一个<a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>对象。

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<p>下面是一个上述应答服务器的客户端的例子：

</p>
<pre><code>var socket = tls.connect(8000, options, function() {
  console.log(&apos;client connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&apos;utf8&apos;);
socket.on(&apos;data&apos;, function(data) {
  console.log(data);
});
socket.on(&apos;end&apos;, function() {
  server.close();
});</code></pre>
<p>Or

</p>
<p>或者

</p>
<pre><code>var socket = tls.connect(8000, options, function() {
  console.log(&apos;client connected&apos;,
              socket.authorized ? &apos;authorized&apos; : &apos;unauthorized&apos;);
  process.stdin.pipe(socket);
  process.stdin.resume();
});
socket.setEncoding(&apos;utf8&apos;);
socket.on(&apos;data&apos;, function(data) {
  console.log(data);
});
socket.on(&apos;end&apos;, function() {
  server.close();
});</code></pre>
<h2>类: tls.TLSSocket<span><a href="all.html#all_tls_tlssocket_2" id="all_tls_tlssocket_2">#</a></span></h2>
<p>Wrapper for instance of <a href="net.html#net_class_net_socket">net.Socket</a>, replaces internal socket read/write
routines to perform transparent encryption/decryption of incoming/outgoing data.

</p>
<h2>new tls.TLSSocket(socket, options)<span><a href="all.html#all_new_tls_tlssocket_socket_options_1" id="all_new_tls_tlssocket_socket_options_1">#</a></span></h2>
<p>Construct a new TLSSocket object from existing TCP socket.

</p>
<p><code>socket</code> is an instance of <a href="net.html#net_class_net_socket">net.Socket</a>

</p>
<p><code>socket</code>是一个<a href="net.html#net_class_net_socket">net.Socket</a>示例。

</p>
<p><code>options</code> is an object that might contain following properties:

</p>
<p><code>options</code>是一个可能包含以下属性的对象：

</p>
<ul>
<li><p><code>credentials</code>: An optional credentials object from
 <code>crypto.createCredentials( ... )</code></p>
</li>
<li><p><code>isServer</code>: If true - TLS socket will be instantiated in server-mode</p>
</li>
<li><p><code>server</code>: An optional <a href="net.html#net_class_net_server">net.Server</a> instance</p>
</li>
<li><p><code>server</code>: 一个可选的<a href="net.html#net_class_net_server">net.Server</a>实例</p>
</li>
<li><p><code>requestCert</code>: Optional, see <a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>requestCert</code>: 可选的，见<a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>rejectUnauthorized</code>: Optional, see <a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>rejectUnauthorized</code>: 可选的，见<a href="all.html#tls_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized">tls.createSecurePair</a></p>
</li>
<li><p><code>NPNProtocols</code>: Optional, see <a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>NPNProtocols</code>: 可选的，见<a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>SNICallback</code>: Optional, see <a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
<li><p><code>SNICallback</code>: 可选的，见<a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a></p>
</li>
</ul>
<h2>tls.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])<span><a href="all.html#all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized_1" id="all_tls_createsecurepair_credentials_isserver_requestcert_rejectunauthorized_1">#</a></span></h2>
<pre><code>稳定性: 0 - 已废弃。使用 tls.TLSSocket 替代。</code></pre>
<p>Creates a new secure pair object with two streams, one of which reads/writes
encrypted data, and one reads/writes cleartext data.
Generally the encrypted one is piped to/from an incoming encrypted data stream,
and the cleartext one is used as a replacement for the initial encrypted stream.

</p>
<ul>
<li><p><code>credentials</code>: A credentials object from crypto.createCredentials( ... )</p>
</li>
<li><p><code>isServer</code>: A boolean indicating whether this tls connection should be
opened as a server or a client.</p>
</li>
<li><p><code>requestCert</code>: A boolean indicating whether a server should request a
certificate from a connecting client. Only applies to server connections.</p>
</li>
<li><p><code>rejectUnauthorized</code>: A boolean indicating whether a server should
automatically reject clients with invalid certificates. Only applies to
servers with <code>requestCert</code> enabled.</p>
</li>
</ul>
<p><code>tls.createSecurePair()</code> returns a SecurePair object with <code>cleartext</code> and
<code>encrypted</code> stream properties.

</p>
<p>NOTE: <code>cleartext</code> has the same APIs as <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>

</p>
<h2>类: SecurePair<span><a href="all.html#all_securepair_1" id="all_securepair_1">#</a></span></h2>
<p>Returned by tls.createSecurePair.

</p>
<p>由tls.createSecurePair返回。

</p>
<h3>事件: &apos;secure&apos;<span><a href="all.html#all_secure_1" id="all_secure_1">#</a></span></h3>
<p>The event is emitted from the SecurePair once the pair has successfully
established a secure connection.

</p>
<p>Similarly to the checking for the server &apos;secureConnection&apos; event,
pair.cleartext.authorized should be checked to confirm whether the certificate
used properly authorized.

</p>
<h2>类: tls.Server<span><a href="all.html#all_tls_server_1" id="all_tls_server_1">#</a></span></h2>
<p>This class is a subclass of <code>net.Server</code> and has the same methods on it.
Instead of accepting just raw TCP connections, this accepts encrypted
connections using TLS or SSL.

</p>
<h3>事件: &apos;secureConnection&apos;<span><a href="all.html#all_secureconnection_1" id="all_secureconnection_1">#</a></span></h3>
<p><code>function (tlsSocket) {}</code>

</p>
<p><code>function (tlsSocket) {}</code>

</p>
<p>This event is emitted after a new connection has been successfully
handshaked. The argument is a instance of <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a>. It has all the
common stream methods and events.

</p>
<p><code>socket.authorized</code> is a boolean value which indicates if the
client has verified by one of the supplied certificate authorities for the
server. If <code>socket.authorized</code> is false, then
<code>socket.authorizationError</code> is set to describe how authorization
failed. Implied but worth mentioning: depending on the settings of the TLS
server, you unauthorized connections may be accepted.
<code>socket.npnProtocol</code> is a string containing selected NPN protocol.
<code>socket.servername</code> is a string containing servername requested with
SNI.

</p>
<h3>Event: &apos;clientError&apos;<span><a href="all.html#all_event_clienterror_2" id="all_event_clienterror_2">#</a></span></h3>
<p><code>function (exception, tlsSocket) { }</code>

</p>
<p><code>function (exception, tlsSocket) { }</code>

</p>
<p>When a client connection emits an &apos;error&apos; event before secure connection is
established - it will be forwarded here.

</p>
<p><code>tlsSocket</code> is the <a href="all.html#tls_class_tls_tlssocket">tls.TLSSocket</a> that the error originated from.

</p>
<h3>事件: &apos;newSession&apos;<span><a href="all.html#all_newsession_1" id="all_newsession_1">#</a></span></h3>
<p><code>function (sessionId, sessionData) { }</code>

</p>
<p><code>function (sessionId, sessionData) { }</code>

</p>
<p>Emitted on creation of TLS session. May be used to store sessions in external
storage.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
<h3>事件: &apos;resumeSession&apos;<span><a href="all.html#all_resumesession_1" id="all_resumesession_1">#</a></span></h3>
<p><code>function (sessionId, callback) { }</code>

</p>
<p><code>function (sessionId, callback) { }</code>

</p>
<p>Emitted when client wants to resume previous TLS session. Event listener may
perform lookup in external storage using given <code>sessionId</code>, and invoke
<code>callback(null, sessionData)</code> once finished. If session can&apos;t be resumed
(i.e. doesn&apos;t exist in storage) one may call <code>callback(null, null)</code>. Calling
<code>callback(err)</code> will terminate incoming connection and destroy socket.

</p>
<p>NOTE: adding this event listener will have an effect only on connections
established after addition of event listener.

</p>
<h3>server.listen(port, [host], [callback])<span><a href="all.html#all_server_listen_port_host_callback_1" id="all_server_listen_port_host_callback_1">#</a></span></h3>
<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be called
when the server has been bound.

</p>
<p>See <code>net.Server</code> for more information.

</p>
<p>更多信息见<code>net.Server</code>。

</p>
<h3>server.close()<span><a href="all.html#all_server_close_1" id="all_server_close_1">#</a></span></h3>
<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>&apos;close&apos;</code>
event.

</p>
<h3>server.address()<span><a href="all.html#all_server_address_2" id="all_server_address_2">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
server as reported by the operating system.  See <a href="net.html#net_server_address">net.Server.address()</a> for
more information.

</p>
<h3>server.addContext(hostname, credentials)<span><a href="all.html#all_server_addcontext_hostname_credentials_1" id="all_server_addcontext_hostname_credentials_1">#</a></span></h3>
<p>Add secure context that will be used if client request&apos;s SNI hostname is
matching passed <code>hostname</code> (wildcards can be used). <code>credentials</code> can contain
<code>key</code>, <code>cert</code> and <code>ca</code>.

</p>
<h3>server.maxConnections<span><a href="all.html#all_server_maxconnections_2" id="all_server_maxconnections_2">#</a></span></h3>
<p>Set this property to reject connections when the server&apos;s connection count
gets high.

</p>
<h3>server.connections<span><a href="all.html#all_server_connections_2" id="all_server_connections_2">#</a></span></h3>
<p>The number of concurrent connections on the server.

</p>
<p>服务器的并发连接数.

</p>
<h2>类: CryptoStream<span><a href="all.html#all_cryptostream_1" id="all_cryptostream_1">#</a></span></h2>
<pre><code>稳定性: 0 - 已废弃。使用 tls.TLSSocket 替代。</code></pre>
<p>This is an encrypted stream.

</p>
<p>这是一个被加密的流。

</p>
<h3>cryptoStream.bytesWritten<span><a href="all.html#all_cryptostream_byteswritten_1" id="all_cryptostream_byteswritten_1">#</a></span></h3>
<p>A proxy to the underlying socket&apos;s bytesWritten accessor, this will return
the total bytes written to the socket, <em>including the TLS overhead</em>.

</p>
<h2>类: tls.TLSSocket<span><a href="all.html#all_tls_tlssocket_3" id="all_tls_tlssocket_3">#</a></span></h2>
<p>This is a wrapped version of <a href="net.html#net_class_net_socket">net.Socket</a> that does transparent encryption
of written data and all required TLS negotiation.

</p>
<p>This instance implements a duplex <a href="stream.html#stream_stream">Stream</a> interfaces.  It has all the
common stream methods and events.

</p>
<h3>事件: &apos;secureConnect&apos;<span><a href="all.html#all_secureconnect_1" id="all_secureconnect_1">#</a></span></h3>
<p>This event is emitted after a new connection has been successfully handshaked.
The listener will be called no matter if the server&apos;s certificate was
authorized or not. It is up to the user to test <code>tlsSocket.authorized</code>
to see if the server certificate was signed by one of the specified CAs.
If <code>tlsSocket.authorized === false</code> then the error can be found in
<code>tlsSocket.authorizationError</code>. Also if NPN was used - you can check
<code>tlsSocket.npnProtocol</code> for negotiated protocol.

</p>
<h3>tlsSocket.authorized<span><a href="all.html#all_tlssocket_authorized_1" id="all_tlssocket_authorized_1">#</a></span></h3>
<p>A boolean that is <code>true</code> if the peer certificate was signed by one of the
specified CAs, otherwise <code>false</code>

</p>
<h3>tlsSocket.authorizationError<span><a href="all.html#all_tlssocket_authorizationerror_1" id="all_tlssocket_authorizationerror_1">#</a></span></h3>
<p>The reason why the peer&apos;s certificate has not been verified. This property
becomes available only when <code>tlsSocket.authorized === false</code>.

</p>
<h3>tlsSocket.getPeerCertificate()<span><a href="all.html#all_tlssocket_getpeercertificate_1" id="all_tlssocket_getpeercertificate_1">#</a></span></h3>
<p>Returns an object representing the peer&apos;s certificate. The returned object has
some properties corresponding to the field of the certificate.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>{ subject: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  issuer: 
   { C: &apos;UK&apos;,
     ST: &apos;Acknack Ltd&apos;,
     L: &apos;Rhys Jones&apos;,
     O: &apos;node.js&apos;,
     OU: &apos;Test TLS Certificate&apos;,
     CN: &apos;localhost&apos; },
  valid_from: &apos;Nov 11 09:52:22 2009 GMT&apos;,
  valid_to: &apos;Nov  6 09:52:22 2029 GMT&apos;,
  fingerprint: &apos;2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF&apos; }</code></pre>
<p>If the peer does not provide a certificate, it returns <code>null</code> or an empty
object.

</p>
<h3>tlsSocket.getCipher()<span><a href="all.html#all_tlssocket_getcipher_1" id="all_tlssocket_getcipher_1">#</a></span></h3>
<p>Returns an object representing the cipher name and the SSL/TLS
protocol version of the current connection.

</p>
<p>Example:
{ name: &apos;AES256-SHA&apos;, version: &apos;TLSv1/SSLv3&apos; }

</p>
<p>Example:
{ name: &apos;AES256-SHA&apos;, version: &apos;TLSv1/SSLv3&apos; }

</p>
<p>See SSL_CIPHER_get_name() and SSL_CIPHER_get_version() in
<a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS">http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_CIPHERS</a> for more
information.

</p>
<h3>tlsSocket.renegotiate(options, callback)<span><a href="all.html#all_tlssocket_renegotiate_options_callback_1" id="all_tlssocket_renegotiate_options_callback_1">#</a></span></h3>
<p>Initiate TLS renegotiation process. The <code>options</code> may contain the following
fields: <code>rejectUnauthorized</code>, <code>requestCert</code> (See <a href="all.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer</a>
for details). <code>callback(err)</code> will be executed with <code>null</code> as <code>err</code>,
once the renegotiation is successfully completed.

</p>
<p>NOTE: Can be used to request peer&apos;s certificate after the secure connection
has been established.

</p>
<p>ANOTHER NOTE: When running as the server, socket will be destroyed
with an error after <code>handshakeTimeout</code> timeout.

</p>
<h3>tlsSocket.address()<span><a href="all.html#all_tlssocket_address_1" id="all_tlssocket_address_1">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
underlying socket as reported by the operating system. Returns an
object with three properties, e.g.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<h3>tlsSocket.remoteAddress<span><a href="all.html#all_tlssocket_remoteaddress_1" id="all_tlssocket_remoteaddress_1">#</a></span></h3>
<p>The string representation of the remote IP address. For example,
<code>&apos;74.125.127.100&apos;</code> or <code>&apos;2001:4860:a005::68&apos;</code>.

</p>
<p>远程IP地址的字符串表示。例如，<code>&apos;74.125.127.100&apos;</code>或 <code>&apos;2001:4860:a005::68&apos;</code>。

</p>
<h3>tlsSocket.remotePort<span><a href="all.html#all_tlssocket_remoteport_1" id="all_tlssocket_remoteport_1">#</a></span></h3>
<p>The numeric representation of the remote port. For example, <code>443</code>.

</p>
<p>远程端口的数值表示。例如， <code>443</code>。

</p>
<h3>tlsSocket.localAddress<span><a href="all.html#all_tlssocket_localaddress_1" id="all_tlssocket_localaddress_1">#</a></span></h3>
<p>The string representation of the local IP address.

</p>
<p>本地IP地址的字符串表达。

</p>
<h3>tlsSocket.localPort<span><a href="all.html#all_tlssocket_localport_1" id="all_tlssocket_localport_1">#</a></span></h3>
<p>The numeric representation of the local port.

</p>
<p>本地端口的数值表示。

</p>
<h1>字符串解码器<span><a href="all.html#all_73" id="all_73">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>To use this module, do <code>require(&apos;string_decoder&apos;)</code>. StringDecoder decodes a
buffer to a string. It is a simple interface to <code>buffer.toString()</code> but provides
additional support for utf8.

</p>
<p>通过 <code>require(&apos;string_decoder&apos;)</code> 使用这个模块。这个模块将一个 Buffer 解码成一个字符串。他是 <code>buffer.toString()</code> 的一个简单接口，但提供对 utf8 的支持。

</p>
<pre><code>var euro = new Buffer([0xE2, 0x82, 0xAC]);
console.log(decoder.write(euro));</code></pre>
<h2>类: StringDecoder<span><a href="all.html#all_stringdecoder_1" id="all_stringdecoder_1">#</a></span></h2>
<p>Accepts a single argument, <code>encoding</code> which defaults to <code>utf8</code>.

</p>
<p>接受 <code>encoding</code> 一个参数，默认是 <code>utf8</code>。

</p>
<h3>decoder.write(buffer)<span><a href="all.html#all_decoder_write_buffer_1" id="all_decoder_write_buffer_1">#</a></span></h3>
<p>Returns a decoded string.

</p>
<p>返回解码后的字符串。

</p>
<h3>decoder.end()<span><a href="all.html#all_decoder_end_1" id="all_decoder_end_1">#</a></span></h3>
<p>Returns any trailing bytes that were left in the buffer.


</p>
<p>返回 Buffer 中剩下的末尾字节。
</p>
<h1>File System<span><a href="all.html#all_file_system_1" id="all_file_system_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!--name=fs-->

<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code>require(&apos;fs&apos;)</code>. All the methods have asynchronous and
synchronous forms.

</p>
<p>文件系统模块是一个简单包装的标准 POSIX 文件 I/O 操作方法集。您可以通过调用<code>require(&apos;fs&apos;)</code>来获取该模块。文件系统模块中的所有方法均有异步和同步版本。 

</p>
<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.

</p>
<p>文件系统模块中的异步方法需要一个完成时的回调函数作为最后一个传入形参。
回调函数的构成由您调用的异步方法所决定，通常情况下回调函数的第一个形参为返回的错误信息。
如果异步操作执行正确并返回，该错误形参则为<code>null</code>或者<code>undefined</code>。

</p>
<p>When using the synchronous form any exceptions are immediately thrown.
You can use try/catch to handle exceptions or allow them to bubble up.

</p>
<p>如果您使用的是同步版本的操作方法，则一旦出现错误，会以通常的抛出错误的形式返回错误。
你可以用<code>try</code>和<code>catch</code>等语句来拦截错误并使程序继续进行。

</p>
<p>Here is an example of the asynchronous version:

</p>
<p>这里是一个异步版本的例子：

</p>
<pre><code>fs.unlink(&apos;/tmp/hello&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;successfully deleted /tmp/hello&apos;);
});</code></pre>
<p>Here is the synchronous version:

</p>
<p>这是同步版本的例子:

</p>
<pre><code>fs.unlinkSync(&apos;/tmp/hello&apos;)
console.log(&apos;successfully deleted /tmp/hello&apos;);</code></pre>
<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:

</p>
<p>当使用异步版本时不能保证执行顺序,因此下面这个例子很容易出错:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;renamed complete&apos;);
});
fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
  if (err) throw err;
  console.log(&apos;stats: &apos; + JSON.stringify(stats));
});</code></pre>
<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.
The correct way to do this is to chain the callbacks.

</p>
<p><code>fs.stat</code>有可能在<code>fs.rename</code>前执行.要等到正确的执行顺序应该用下面的方法:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
    if (err) throw err;
    console.log(&apos;stats: &apos; + JSON.stringify(stats));
  });
});</code></pre>
<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.

</p>
<p>在繁重的任务中,<em>强烈推荐</em>使用这些函数的异步版本.同步版本会阻塞进程,直到完成处理,也就是说会暂停所有的连接.

</p>
<p>Relative path to filename can be used, remember however that this path will be
relative to <code>process.cwd()</code>.

</p>
<p>可以使用文件名的相对路径, 但是记住这个路径是相对于<code>process.cwd()</code>的.

</p>
<p>Most fs functions let you omit the callback argument. If you do, a default
callback is used that rethrows errors. To get a trace to the original call
site, set the NODE_DEBUG environment variable:

</p>
<p>大部分的文件系统(fs)函数可以忽略回调函数(callback)这个参数.如果忽略它,将会由一个默认回调函数(callback)来重新抛出(rethrow)错误.要获得原调用点的堆栈跟踪(trace)信息,需要在环境变量里设置NODE_DEBUG.

</p>
<pre><code>$ env NODE_DEBUG=fs node script.js
fs.js:66
        throw err;
              ^
Error: EISDIR, read
    at rethrow (fs.js:61:21)
    at maybeCallback (fs.js:79:42)
    at Object.fs.readFile (fs.js:153:18)
    at bad (/path/to/script.js:2:17)
    at Object.&lt;anonymous&gt; (/path/to/script.js:5:1)
    &lt;etc.&gt;</code></pre>
<h2>fs.rename(oldPath, newPath, callback)<span><a href="all.html#all_fs_rename_oldpath_newpath_callback_1" id="all_fs_rename_oldpath_newpath_callback_1">#</a></span></h2>
<p>Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的rename函数(2).完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.renameSync(oldPath, newPath)<span><a href="all.html#all_fs_renamesync_oldpath_newpath_1" id="all_fs_renamesync_oldpath_newpath_1">#</a></span></h2>
<p>Synchronous rename(2).

</p>
<p>同步版本的rename(2).

</p>
<h2>fs.ftruncate(fd, len, callback)<span><a href="all.html#all_fs_ftruncate_fd_len_callback_1" id="all_fs_ftruncate_fd_len_callback_1">#</a></span></h2>
<p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<p>异步版本的ftruncate(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.ftruncateSync(fd, len)<span><a href="all.html#all_fs_ftruncatesync_fd_len_1" id="all_fs_ftruncatesync_fd_len_1">#</a></span></h2>
<p>Synchronous ftruncate(2).

</p>
<p>同步版本的ftruncate(2).

</p>
<h2>fs.truncate(path, len, callback)<span><a href="all.html#all_fs_truncate_path_len_callback_1" id="all_fs_truncate_path_len_callback_1">#</a></span></h2>
<p>Asynchronous truncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<p>异步版本的truncate(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.truncateSync(path, len)<span><a href="all.html#all_fs_truncatesync_path_len_1" id="all_fs_truncatesync_path_len_1">#</a></span></h2>
<p>Synchronous truncate(2).

</p>
<p>同步版本的truncate(2).

</p>
<p>异步版本的chown.完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<p>Asynchronous chown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的chown(2).完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.chownSync(path, uid, gid)<span><a href="all.html#all_fs_chownsync_path_uid_gid_1" id="all_fs_chownsync_path_uid_gid_1">#</a></span></h2>
<p>Synchronous chown(2).

</p>
<p>同步版本的chown(2).

</p>
<h2>fs.fchown(fd, uid, gid, callback)<span><a href="all.html#all_fs_fchown_fd_uid_gid_callback_1" id="all_fs_fchown_fd_uid_gid_callback_1">#</a></span></h2>
<p>Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的fchown(2)。回调函数的参数除了出现错误时有一个错误对象外，没有其它参数。

</p>
<h2>fs.fchownSync(fd, uid, gid)<span><a href="all.html#all_fs_fchownsync_fd_uid_gid_1" id="all_fs_fchownsync_fd_uid_gid_1">#</a></span></h2>
<p>Synchronous fchown(2).

</p>
<p>同步版本的fchown(2).

</p>
<h2>fs.lchown(path, uid, gid, callback)<span><a href="all.html#all_fs_lchown_path_uid_gid_callback_1" id="all_fs_lchown_path_uid_gid_callback_1">#</a></span></h2>
<p>Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的lchown(2)。完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.lchownSync(path, uid, gid)<span><a href="all.html#all_fs_lchownsync_path_uid_gid_1" id="all_fs_lchownsync_path_uid_gid_1">#</a></span></h2>
<p>Synchronous lchown(2).

</p>
<p>同步版本的lchown(2).

</p>
<h2>fs.chmod(path, mode, callback)<span><a href="all.html#all_fs_chmod_path_mode_callback_1" id="all_fs_chmod_path_mode_callback_1">#</a></span></h2>
<p>Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 chmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.chmodSync(path, mode)<span><a href="all.html#all_fs_chmodsync_path_mode_1" id="all_fs_chmodsync_path_mode_1">#</a></span></h2>
<p>Synchronous chmod(2).

</p>
<p>同步版的 chmod(2).

</p>
<h2>fs.fchmod(fd, mode, callback)<span><a href="all.html#all_fs_fchmod_fd_mode_callback_1" id="all_fs_fchmod_fd_mode_callback_1">#</a></span></h2>
<p>Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<p>异步版的 fchmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.fchmodSync(fd, mode)<span><a href="all.html#all_fs_fchmodsync_fd_mode_1" id="all_fs_fchmodsync_fd_mode_1">#</a></span></h2>
<p>Synchronous fchmod(2).

</p>
<p>同步版的 fchmod(2).

</p>
<h2>fs.lchmod(path, mode, callback)<span><a href="all.html#all_fs_lchmod_path_mode_callback_1" id="all_fs_lchmod_path_mode_callback_1">#</a></span></h2>
<p>Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<p>异步版的 lchmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<p>Only available on Mac OS X.

</p>
<p>仅在 Mac OS X 系统下可用。

</p>
<h2>fs.lchmodSync(path, mode)<span><a href="all.html#all_fs_lchmodsync_path_mode_1" id="all_fs_lchmodsync_path_mode_1">#</a></span></h2>
<p>Synchronous lchmod(2).

</p>
<p>同步版的 lchmod(2).

</p>
<h2>fs.stat(path, callback)<span><a href="all.html#all_fs_stat_path_callback_1" id="all_fs_stat_path_callback_1">#</a></span></h2>
<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <a href="all.html#fs_class_fs_stats">fs.Stats</a> object.  See the <a href="all.html#fs_class_fs_stats">fs.Stats</a>
section below for more information.

</p>
<p>异步版的 stat(2). 回调函数（callback） 接收两个参数： <code>(err, stats)</code> ，其中
<code>stats</code> 是一个 <a href="all.html#fs_class_fs_stats">fs.Stats</a> 对象。 详情请参考 <a href="all.html#fs_class_fs_stats">fs.Stats</a>

</p>
<h2>fs.lstat(path, callback)<span><a href="all.html#all_fs_lstat_path_callback_1" id="all_fs_lstat_path_callback_1">#</a></span></h2>
<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>lstat()</code> is identical to <code>stat()</code>, except that if
<code>path</code> is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.

</p>
<p>异步版的 lstat(2). 回调函数（callback）接收两个参数： <code>(err, stats)</code> 其中
<code>stats</code> 是一个 <code>fs.Stats</code> 对象。 <code>lstat()</code> 与 <code>stat()</code> 相同，区别在于：
若 <code>path</code> 是一个符号链接时（symbolic link）,读取的是该符号链接本身，而不是它所
链接到的文件。

</p>
<h2>fs.fstat(fd, callback)<span><a href="all.html#all_fs_fstat_fd_callback_1" id="all_fs_fstat_fd_callback_1">#</a></span></h2>
<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>fstat()</code> is identical to <code>stat()</code>, except that
the file to be stat-ed is specified by the file descriptor <code>fd</code>.

</p>
<p>异步版的 fstat(2). 回调函数（callback）接收两个参数： <code>(err, stats)</code> 其中
<code>stats</code> 是一个 <code>fs.Stats</code> 对象。 <code>fstat()</code> 与 <code>stat()</code> 相同，区别在于：
要读取的文件（译者注：即第一个参数）是一个文件描述符（file descriptor） <code>fd</code> 。

</p>
<h2>fs.statSync(path)<span><a href="all.html#all_fs_statsync_path_1" id="all_fs_statsync_path_1">#</a></span></h2>
<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 stat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.lstatSync(path)<span><a href="all.html#all_fs_lstatsync_path_1" id="all_fs_lstatsync_path_1">#</a></span></h2>
<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 lstat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.fstatSync(fd)<span><a href="all.html#all_fs_fstatsync_fd_1" id="all_fs_fstatsync_fd_1">#</a></span></h2>
<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 fstat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.link(srcpath, dstpath, callback)<span><a href="all.html#all_fs_link_srcpath_dstpath_callback_1" id="all_fs_link_srcpath_dstpath_callback_1">#</a></span></h2>
<p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.

</p>
<p>异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。

</p>
<h2>fs.linkSync(srcpath, dstpath)<span><a href="all.html#all_fs_linksync_srcpath_dstpath_1" id="all_fs_linksync_srcpath_dstpath_1">#</a></span></h2>
<p>Synchronous link(2).

</p>
<p>同步版的 link(2).

</p>
<h2>fs.symlink(srcpath, dstpath, [type], callback)<span><a href="all.html#all_fs_symlink_srcpath_dstpath_type_callback_1" id="all_fs_symlink_srcpath_dstpath_type_callback_1">#</a></span></h2>
<p>Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.
<code>type</code> argument can be either <code>&apos;dir&apos;</code>, <code>&apos;file&apos;</code>, or <code>&apos;junction&apos;</code> (default is <code>&apos;file&apos;</code>).  It is only 
used on Windows (ignored on other platforms).
Note that Windows junction points require the destination path to be absolute.  When using
<code>&apos;junction&apos;</code>, the <code>destination</code> argument will automatically be normalized to absolute path.

</p>
<p>异步版的 symlink(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。
<code>type</code> 可以是 <code>&apos;dir&apos;</code>, <code>&apos;file&apos;</code>, 或者<code>&apos;junction&apos;</code> (默认是 <code>&apos;file&apos;</code>)，此参数仅用于
Windows 系统（其他系统平台会被忽略）。
注意： Windows 系统要求目标路径（译者注：即 <code>dstpath</code> 参数）必须是一个绝对路径，当使用
<code>&apos;junction&apos;</code> 时，<code>dstpath</code> 参数会自动转换为绝对路径。

</p>
<h2>fs.symlinkSync(srcpath, dstpath, [type])<span><a href="all.html#all_fs_symlinksync_srcpath_dstpath_type_1" id="all_fs_symlinksync_srcpath_dstpath_type_1">#</a></span></h2>
<p>Synchronous symlink(2).

</p>
<p>同步版的 symlink(2).

</p>
<h2>fs.readlink(path, callback)<span><a href="all.html#all_fs_readlink_path_callback_1" id="all_fs_readlink_path_callback_1">#</a></span></h2>
<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,
linkString)</code>.

</p>
<p>异步版的 readlink(2). 回调函数（callback）接收两个参数： <code>(err,
linkString)</code>.

</p>
<h2>fs.readlinkSync(path)<span><a href="all.html#all_fs_readlinksync_path_1" id="all_fs_readlinksync_path_1">#</a></span></h2>
<p>Synchronous readlink(2). Returns the symbolic link&apos;s string value.

</p>
<p>同步版的 readlink(2). 返回符号链接（symbolic link）的字符串值。

</p>
<h2>fs.realpath(path, [cache], callback)<span><a href="all.html#all_fs_realpath_path_cache_callback_1" id="all_fs_realpath_path_cache_callback_1">#</a></span></h2>
<p>Asynchronous realpath(2). The <code>callback</code> gets two arguments <code>(err,
resolvedPath)</code>. May use <code>process.cwd</code> to resolve relative paths. <code>cache</code> is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional <code>fs.stat</code> calls for known real paths.

</p>
<p>异步版的 realpath(2). 回调函数（callback）接收两个参数： <code>(err,
resolvedPath)</code>. May use <code>process.cwd</code> to resolve relative paths. <code>cache</code> is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional <code>fs.stat</code> calls for known real paths.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var cache = {&apos;/etc&apos;:&apos;/private/etc&apos;};
fs.realpath(&apos;/etc/passwd&apos;, cache, function (err, resolvedPath) {
  if (err) throw err;
  console.log(resolvedPath);
});</code></pre>
<h2>fs.realpathSync(path, [cache])<span><a href="all.html#all_fs_realpathsync_path_cache_1" id="all_fs_realpathsync_path_cache_1">#</a></span></h2>
<p>Synchronous realpath(2). Returns the resolved path.

</p>
<p>realpath(2) 的同步版本。返回解析出的路径。

</p>
<h2>fs.unlink(path, callback)<span><a href="all.html#all_fs_unlink_path_callback_1" id="all_fs_unlink_path_callback_1">#</a></span></h2>
<p>Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 unlink(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息.

</p>
<h2>fs.unlinkSync(path)<span><a href="all.html#all_fs_unlinksync_path_1" id="all_fs_unlinksync_path_1">#</a></span></h2>
<p>Synchronous unlink(2).

</p>
<p>同步版的 unlink(2).

</p>
<h2>fs.rmdir(path, callback)<span><a href="all.html#all_fs_rmdir_path_callback_1" id="all_fs_rmdir_path_callback_1">#</a></span></h2>
<p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 rmdir(2). 异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。

</p>
<h2>fs.rmdirSync(path)<span><a href="all.html#all_fs_rmdirsync_path_1" id="all_fs_rmdirsync_path_1">#</a></span></h2>
<p>Synchronous rmdir(2).

</p>
<p>同步版的 rmdir(2).

</p>
<h2>fs.mkdir(path, [mode], callback)<span><a href="all.html#all_fs_mkdir_path_mode_callback_1" id="all_fs_mkdir_path_mode_callback_1">#</a></span></h2>
<p>Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback. <code>mode</code> defaults to <code>0777</code>.

</p>
<p>异步版的 mkdir(2)。 异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。文件 <code>mode</code> 默认为 <code>0777</code>。

</p>
<h2>fs.mkdirSync(path, [mode])<span><a href="all.html#all_fs_mkdirsync_path_mode_1" id="all_fs_mkdirsync_path_mode_1">#</a></span></h2>
<p>Synchronous mkdir(2).

</p>
<p>同步版的 mkdir(2)。

</p>
<h2>fs.readdir(path, callback)<span><a href="all.html#all_fs_readdir_path_callback_1" id="all_fs_readdir_path_callback_1">#</a></span></h2>
<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>&apos;.&apos;</code> and <code>&apos;..&apos;</code>.

</p>
<p>异步版的 readdir(3)。 读取 path 路径所在目录的内容。 回调函数 (callback) 接受两个参数 <code>(err, files)</code> 其中 <code>files</code> 是一个存储目录中所包含的文件名称的数组，数组中不包括 <code>&apos;.&apos;</code> 和 <code>&apos;..&apos;</code>。

</p>
<h2>fs.readdirSync(path)<span><a href="all.html#all_fs_readdirsync_path_1" id="all_fs_readdirsync_path_1">#</a></span></h2>
<p>Synchronous readdir(3). Returns an array of filenames excluding <code>&apos;.&apos;</code> and
<code>&apos;..&apos;</code>.

</p>
<p>同步版的 readdir(3). 返回文件名数组，其中不包括 <code>&apos;.&apos;</code> 和 <code>&apos;..&apos;</code> 目录.

</p>
<h2>fs.close(fd, callback)<span><a href="all.html#all_fs_close_fd_callback_1" id="all_fs_close_fd_callback_1">#</a></span></h2>
<p>Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版 close(2).  完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.closeSync(fd)<span><a href="all.html#all_fs_closesync_fd_1" id="all_fs_closesync_fd_1">#</a></span></h2>
<p>Synchronous close(2).

</p>
<p>同步版的 close(2).

</p>
<h2>fs.open(path, flags, [mode], callback)<span><a href="all.html#all_fs_open_path_flags_mode_callback_1" id="all_fs_open_path_flags_mode_callback_1">#</a></span></h2>
<p>Asynchronous file open. See open(2). <code>flags</code> can be:

</p>
<p>异步版的文件打开. 详见 open(2). <code>flags</code> 可以是:

</p>
<ul>
<li><p><code>&apos;r&apos;</code> - Open file for reading.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code>&apos;r&apos;</code>  - 以【只读】的方式打开文件. 当文件不存在时产生异常.</p>
</li>
<li><p><code>&apos;r+&apos;</code> - Open file for reading and writing.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code>&apos;r+&apos;</code> - 以【读写】的方式打开文件. 当文件不存在时产生异常.</p>
</li>
<li><p><code>&apos;rs&apos;</code> - Open file for reading in synchronous mode. Instructs the operating
system to bypass the local file system cache.</p>
</li>
<li><p><code>&apos;rs&apos;</code> - 同步模式下，以【只读】的方式打开文件. 指令绕过操作系统的本地文件系统缓存.</p>
<p>This is primarily useful for opening files on NFS mounts as it allows you to
skip the potentially stale local cache. It has a very real impact on I/O
performance so don&apos;t use this flag unless you need it.</p>
</li>
</ul>
<p>该功能主要用于打开 NFS 挂载的文件, 因为它可以让你跳过默认使用的过时本地缓存. 但这实际上非常影响 I/O 操作的性能, 因此除非你确实有这样的需求, 否则请不要使用该标志.

</p>
<p>  Note that this doesn&apos;t turn <code>fs.open()</code> into a synchronous blocking call.
  If that&apos;s what you want then you should be using <code>fs.openSync()</code>

</p>
<p> 注意: 这并不意味着 <code>fs.open()</code> 变成了一个同步阻塞的请求. 如果你想要一个同步阻塞的请求你应该使用 <code>fs.openSync()</code>.

</p>
<ul>
<li><p><code>&apos;rs+&apos;</code> - Open file for reading and writing, telling the OS to open it
synchronously. See notes for <code>&apos;rs&apos;</code> about using this with caution.</p>
</li>
<li><p><code>&apos;rs+&apos;</code> - 同步模式下, 以【读写】的方式打开文件. 请谨慎使用该方式, 详细请查看 <code>&apos;rs&apos;</code> 的注释.</p>
</li>
<li><p><code>&apos;w&apos;</code> - Open file for writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code>&apos;w&apos;</code> - 以【只写】的形式打开文件. 文件会被创建 (如果文件不存在) 或者覆盖 (如果存在).</p>
</li>
<li><p><code>&apos;wx&apos;</code> - Like <code>&apos;w&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;wx&apos;</code> - 类似 <code>&apos;w&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;w+&apos;</code> - Open file for reading and writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code>&apos;w+&apos;</code> - 以【读写】的方式打开文件. 文件会被创建 (如果文件不存在) 或者覆盖 (如果存在).</p>
</li>
<li><p><code>&apos;wx+&apos;</code> - Like <code>&apos;w+&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;wx+&apos;</code> - 类似 <code>&apos;w+&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;a&apos;</code> - Open file for appending.
The file is created if it does not exist.</p>
</li>
<li><p><code>&apos;a&apos;</code> - 以【附加】的形式打开文件，即新写入的数据会附加在原来的文件内容之后. 如果文件不存在则会默认创建.</p>
</li>
<li><p><code>&apos;ax&apos;</code> - Like <code>&apos;a&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;ax&apos;</code> - 类似 <code>&apos;a&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;a+&apos;</code> - Open file for reading and appending.
The file is created if it does not exist.</p>
</li>
<li><p><code>&apos;a+&apos;</code> - 以【读取】和【附加】的形式打开文件. 如果文件不存在则会默认创建.</p>
</li>
<li><p><code>&apos;ax+&apos;</code> - Like <code>&apos;a+&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;ax+&apos;</code> - 类似 <code>&apos;a+&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
</ul>
<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the file was
created. It defaults to <code>0666</code>, readable and writeable.

</p>
<p>参数 <code>mode</code> 用于设置文件模式 (permission and sticky bits), 不过前提是这个文件是已存在的. 默认情况下是 <code>0666</code>, 有可读和可写权限.

</p>
<p>The callback gets two arguments <code>(err, fd)</code>.

</p>
<p>该 callback 接收两个参数 <code>(err, fd)</code>.

</p>
<p>The exclusive flag <code>&apos;x&apos;</code> (<code>O_EXCL</code> flag in open(2)) ensures that <code>path</code> is newly
created. On POSIX systems, <code>path</code> is considered to exist even if it is a symlink
to a non-existent file. The exclusive flag may or may not work with network file
systems.

</p>
<p>排除 (exclusive) 标识 <code>&apos;x&apos;</code> （对应 open(2) 的 <code>O_EXCL</code> 标识） 保证 <code>path</code> 是一个新建的文件。
POSIX 操作系统上，即使 <code>path</code> 是一个指向不存在位置的符号链接，也会被认定为文件存在。
排除标识在网络文件系统不能确定是否有效。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.openSync(path, flags, [mode])<span><a href="all.html#all_fs_opensync_path_flags_mode_1" id="all_fs_opensync_path_flags_mode_1">#</a></span></h2>
<p>Synchronous version of <code>fs.open()</code>.

</p>
<p><code>fs.open()</code> 的同步版.

</p>
<h2>fs.utimes(path, atime, mtime, callback)<span><a href="all.html#all_fs_utimes_path_atime_mtime_callback_2" id="all_fs_utimes_path_atime_mtime_callback_2">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a href="all.html#all_fs_utimessync_path_atime_mtime_2" id="all_fs_utimessync_path_atime_mtime_2">#</a></span></h2>
<h2>fs.utimes(path, atime, mtime, callback)<span><a href="all.html#all_fs_utimes_path_atime_mtime_callback_3" id="all_fs_utimes_path_atime_mtime_callback_3">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a href="all.html#all_fs_utimessync_path_atime_mtime_3" id="all_fs_utimessync_path_atime_mtime_3">#</a></span></h2>
<p>Change file timestamps of the file referenced by the supplied path.

</p>
<p>更改 path 所指向的文件的时间戳。

</p>
<h2>fs.futimes(fd, atime, mtime, callback)<span><a href="all.html#all_fs_futimes_fd_atime_mtime_callback_2" id="all_fs_futimes_fd_atime_mtime_callback_2">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a href="all.html#all_fs_futimessync_fd_atime_mtime_2" id="all_fs_futimessync_fd_atime_mtime_2">#</a></span></h2>
<h2>fs.futimes(fd, atime, mtime, callback)<span><a href="all.html#all_fs_futimes_fd_atime_mtime_callback_3" id="all_fs_futimes_fd_atime_mtime_callback_3">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a href="all.html#all_fs_futimessync_fd_atime_mtime_3" id="all_fs_futimessync_fd_atime_mtime_3">#</a></span></h2>
<p>Change the file timestamps of a file referenced by the supplied file
descriptor.

</p>
<p>更改文件描述符 (file discriptor) 所指向的文件的时间戳。

</p>
<h2>fs.fsync(fd, callback)<span><a href="all.html#all_fs_fsync_fd_callback_1" id="all_fs_fsync_fd_callback_1">#</a></span></h2>
<p>Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的 fsync(2)。回调函数仅含有一个异常 (exception) 参数。

</p>
<h2>fs.fsyncSync(fd)<span><a href="all.html#all_fs_fsyncsync_fd_1" id="all_fs_fsyncsync_fd_1">#</a></span></h2>
<p>Synchronous fsync(2).

</p>
<p>fsync(2) 的同步版本。

</p>
<h2>fs.write(fd, buffer, offset, length[, position], callback)<span><a href="all.html#all_fs_write_fd_buffer_offset_length_position_callback_1" id="all_fs_write_fd_buffer_offset_length_position_callback_1">#</a></span></h2>
<p>Write <code>buffer</code> to the file specified by <code>fd</code>.

</p>
<p>通过文件标识<code>fd</code>，向指定的文件中写入<code>buffer</code>。

</p>
<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.

</p>
<p><code>offset</code> 和<code>length</code> 可以确定从哪个位置开始写入buffer。

</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &apos;number&apos;</code>, the data will be written
at the current position. See pwrite(2).

</p>
<p><code>position</code> 是参考当前文档光标的位置，然后从该处写入数据。如果<code>typeof position !== &apos;number&apos;</code>，那么数据会从当前文档位置写入，请看pwrite(2)。

</p>
<p>The callback will be given three arguments <code>(err, written, buffer)</code> where
<code>written</code> specifies how many <em>bytes</em> were written from <code>buffer</code>.

</p>
<p>回调中会给出三个参数 <code>(err, written, buffer)</code>，<code>written</code> 说明从<code>buffer</code>写入的字节数。

</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.

</p>
<p>注意，<code>fs.write</code>多次地在同一个文件中使用而没有等待回调是不安全的。在这种情况下，强烈推荐使用<code>fs.createWriteStream</code>。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.write(fd, data[, position[, encoding]], callback)<span><a href="all.html#all_fs_write_fd_data_position_encoding_callback_1" id="all_fs_write_fd_data_position_encoding_callback_1">#</a></span></h2>
<p>Write <code>data</code> to the file specified by <code>fd</code>.  If <code>data</code> is not a Buffer instance
then the value will be coerced to a string.

</p>
<p>把<code>data</code>写入到文档中通过指定的<code>fd</code>,如果<code>data</code>不是buffer对象的实例则会把值强制转化成一个字符串。

</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &apos;number&apos;</code> the data will be written at
the current position. See pwrite(2).

</p>
<p><code>position</code> 是参考当前文档光标的位置，然后从该处写入数据。如果<code>typeof position !== &apos;number&apos;</code>，那么数据会从当前文档位置写入，请看pwrite(2)。

</p>
<p><code>encoding</code> is the expected string encoding.

</p>
<p><code>encoding</code> 是预期得到一个字符串编码

</p>
<p>The callback will receive the arguments <code>(err, written, string)</code> where <code>written</code>
specifies how many <em>bytes</em> the passed string required to be written. Note that
bytes written is not the same as string characters. See
<a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">Buffer.byteLength</a>.

</p>
<p>回调会得到这些参数 <code>(err, written, string)</code>，<code>written</code>表明传入的<code>string</code>需要写入的字符串长度。注意字节的写入跟字符串写入是不一样的。请看<a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">Buffer.byteLength</a>.

</p>
<p>Unlike when writing <code>buffer</code>, the entire string must be written. No substring
may be specified. This is because the byte offset of the resulting data may not
be the same as the string offset.

</p>
<p>与写入<code>buffer</code>不同，必须写入完整的字符串，截取字符串不是符合规定的。这是因为返回的字节的位移跟字符串的位移是不一样的。

</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.

</p>
<p>注意，<code>fs.write</code>多次地在同一个文件中使用而没有等待回调是不安全的。在这种情况下，强烈推荐使用<code>fs.createWriteStream</code>。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.writeSync(fd, buffer, offset, length[, position])<span><a href="all.html#all_fs_writesync_fd_buffer_offset_length_position_1" id="all_fs_writesync_fd_buffer_offset_length_position_1">#</a></span></h2>
<h2>fs.writeSync(fd, data[, position[, encoding]])<span><a href="all.html#all_fs_writesync_fd_data_position_encoding_1" id="all_fs_writesync_fd_data_position_encoding_1">#</a></span></h2>
<p>Synchronous versions of <code>fs.write()</code>. Returns the number of bytes written.

</p>
<p>同步版本的<code>fs.write()</code>。返回写入的字节数。

</p>
<h2>fs.read(fd, buffer, offset, length, position, callback)<span><a href="all.html#all_fs_read_fd_buffer_offset_length_position_callback_1" id="all_fs_read_fd_buffer_offset_length_position_callback_1">#</a></span></h2>
<p>Read data from the file specified by <code>fd</code>.

</p>
<p>从指定的文档标识符<code>fd</code>读取文件数据。

</p>
<p><code>buffer</code> is the buffer that the data will be written to.

</p>
<p><code>buffer</code> 是缓冲区，数据将会写入这里。

</p>
<p><code>offset</code> is the offset in the buffer to start writing at.

</p>
<p><code>offset</code> 是开始向缓冲区 <code>buffer</code> 写入的偏移量。

</p>
<p><code>length</code> is an integer specifying the number of bytes to read.

</p>
<p><code>length</code> 是一个整形值，指定了读取的字节数。

</p>
<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.

</p>
<p><code>position</code> 是一个整形值，指定了从哪里开始读取文件，如果<code>position</code>为<code>null</code>，将会从文件当前的位置读取数据。

</p>
<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)</code>.

</p>
<p>回调函数给定了三个参数， <code>(err, bytesRead, buffer)</code>， 分别为错误，读取的字节和缓冲区。

</p>
<h2>fs.readSync(fd, buffer, offset, length, position)<span><a href="all.html#all_fs_readsync_fd_buffer_offset_length_position_1" id="all_fs_readsync_fd_buffer_offset_length_position_1">#</a></span></h2>
<p>Synchronous version of <code>fs.read</code>. Returns the number of <code>bytesRead</code>.

</p>
<p> <code>fs.read</code> 函数的同步版本。 返回<code>bytesRead</code>的个数。

</p>
<h2>fs.readFile(filename, [options], callback)<span><a href="all.html#all_fs_readfile_filename_options_callback_1" id="all_fs_readfile_filename_options_callback_1">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>null</code></li>
<li><code>flag</code> <span>String</span> default = <code>&apos;r&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>null</code></li>
<li><code>flag</code> <span>String</span> default = <code>&apos;r&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously reads the entire contents of a file. Example:

</p>
<p>异步读取一个文件的全部内容。举例：

</p>
<pre><code>fs.readFile(&apos;/etc/passwd&apos;, function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.

</p>
<p>回调函数传递了两个参数 <code>(err, data)</code>,  <code>data</code> 就是文件的内容。

</p>
<p>If no encoding is specified, then the raw buffer is returned.

</p>
<p>如果未指定编码方式，原生buffer就会被返回。

</p>
<h2>fs.readFileSync(filename, [options])<span><a href="all.html#all_fs_readfilesync_filename_options_1" id="all_fs_readfilesync_filename_options_1">#</a></span></h2>
<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.

</p>
<p> <code>fs.readFile</code>的同步版本。 返回文件名为 <code>filename</code> 的文件内容。

</p>
<p>If the <code>encoding</code> option is specified then this function returns a
string. Otherwise it returns a buffer.

</p>
<p>如果 <code>encoding</code> 选项被指定， 那么这个函数返回一个字符串。如果未指定，则返回一个原生buffer。

</p>
<h2>fs.writeFile(filename, data, [options], callback)<span><a href="all.html#all_fs_writefile_filename_data_options_callback_1" id="all_fs_writefile_filename_data_options_callback_1">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;w&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;w&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer.

</p>
<p>异步的将数据写入一个文件, 如果文件原先存在，会被替换。
<code>data</code> 可以是一个string，也可以是一个原生buffer。

</p>
<p>The <code>encoding</code> option is ignored if <code>data</code> is a buffer. It defaults
to <code>&apos;utf8&apos;</code>.

</p>
<p><code>encoding</code> 选项会被忽视如果 <code>data</code> 不是string而是原生buffer。<code>encoding</code>缺省为 <code>&apos;utf8&apos;</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;It\&apos;s saved!&apos;); //文件被保存
});</code></pre>
<h2>fs.writeFileSync(filename, data, [options])<span><a href="all.html#all_fs_writefilesync_filename_data_options_1" id="all_fs_writefilesync_filename_data_options_1">#</a></span></h2>
<p>The synchronous version of <code>fs.writeFile</code>.

</p>
<p><code>fs.writeFile</code>的同步版本。

</p>
<h2>fs.appendFile(filename, data, [options], callback)<span><a href="all.html#all_fs_appendfile_filename_data_options_callback_1" id="all_fs_appendfile_filename_data_options_callback_1">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;a&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;a&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously append data to a file, creating the file if it not yet exists.
<code>data</code> can be a string or a buffer.

</p>
<p>异步的将数据添加到一个文件的尾部，如果文件不存在，会创建一个新的文件。
<code>data</code> 可以是一个string，也可以是原生buffer。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>fs.appendFile(&apos;message.txt&apos;, &apos;data to append&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;The &quot;data to append&quot; was appended to file!&apos;); //数据被添加到文件的尾部
});</code></pre>
<h2>fs.appendFileSync(filename, data, [options])<span><a href="all.html#all_fs_appendfilesync_filename_data_options_1" id="all_fs_appendfilesync_filename_data_options_1">#</a></span></h2>
<p>The synchronous version of <code>fs.appendFile</code>.

</p>
<p><code>fs.appendFile</code>的同步版本。

</p>
<h2>fs.watchFile(filename, [options], listener)<span><a href="all.html#all_fs_watchfile_filename_options_listener_1" id="all_fs_watchfile_filename_options_listener_1">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定.   尽可能的话推荐使用 fs.watch 来代替。</code></pre>
<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each
time the file is accessed.

</p>
<p>监视<code>filename</code>指定的文件的改变. 回调函数 <code>listener</code> 会在文件每一次被访问时被调用。

</p>
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing two members a boolean, <code>persistent</code>, and <code>interval</code>. <code>persistent</code>
indicates whether the process should continue to run as long as files are
being watched. <code>interval</code> indicates how often the target should be polled,
in milliseconds. The default is <code>{ persistent: true, interval: 5007 }</code>.

</p>
<p>第二个参数是可选的。 如果提供此参数，<code>options</code> 应该是包含两个成员<code>persistent</code>和<code>interval</code>的对象，其中<code>persistent</code>值为boolean类型。<code>persistent</code>指定进程是否应该在文件被监视（watch）时继续运行，<code>interval</code>指定了目标文件被查询的间隔，以毫秒为单位。缺省值为<code>{ persistent: true, interval: 5007 }</code>。

</p>
<p>The <code>listener</code> gets two arguments the current stat object and the previous
stat object:

</p>
<p><code>listener</code> 有两个参数，第一个为文件现在的状态，第二个为文件的前一个状态。

</p>
<pre><code>fs.watchFile(&apos;message.text&apos;, function (curr, prev) {
  console.log(&apos;the current mtime is: &apos; + curr.mtime);
  console.log(&apos;the previous mtime was: &apos; + prev.mtime);
});</code></pre>
<p>These stat objects are instances of <code>fs.Stat</code>.

</p>
<p><code>listener</code>中的文件状态对象类型为<code>fs.Stat</code>。

</p>
<p>If you want to be notified when the file was modified, not just accessed
you need to compare <code>curr.mtime</code> and <code>prev.mtime</code>.

</p>
<p>如果你只想在文件被修改时被告知，而不是仅仅在被访问时就告知，你应当在<code>listener</code>回调函数中比较下两个状态对象的<code>mtime</code>属性。即<code>curr.mtime</code> 和 <code>prev.mtime</code>.

</p>
<h2>fs.unwatchFile(filename, [listener])<span><a href="all.html#all_fs_unwatchfile_filename_listener_1" id="all_fs_unwatchfile_filename_listener_1">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定.   尽可能的话推荐使用 fs.watch 来代替。</code></pre>
<p>Stop watching for changes on <code>filename</code>. If <code>listener</code> is specified, only that
particular listener is removed. Otherwise, <em>all</em> listeners are removed and you
have effectively stopped watching <code>filename</code>.

</p>
<p>停止监视文件名为 <code>filename</code>的文件. 如果 <code>listener</code> 参数被指定, 会移除在<code>fs.watchFile</code>函数中指定的那一个listener回调函数。 否则, <em>所有的</em> 回调函数都会被移除，你将彻底停止监视<code>filename</code>文件。

</p>
<p>Calling <code>fs.unwatchFile()</code> with a filename that is not being watched is a
no-op, not an error.

</p>
<p>调用 <code>fs.unwatchFile()</code> 时，传递的文件名为未被监视的文件时，不会发生错误，而会发生一个no-op。

</p>
<h2>fs.watch(filename, [options], [listener])<span><a href="all.html#all_fs_watch_filename_options_listener_1" id="all_fs_watch_filename_options_listener_1">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定的</code></pre>
<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a
directory.  The returned object is a <a href="all.html#fs_class_fs_fswatcher">fs.FSWatcher</a>.

</p>
<p>观察指定路径的改变，<code>filename</code> 路径可以是文件或者目录。改函数返回的对象是 <a href="all.html#fs_class_fs_fswatcher">fs.FSWatcher</a>。

</p>
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing a boolean member <code>persistent</code>, which indicates whether the process
should continue to run as long as files are being watched. The default is
<code>{ persistent: true }</code>.

</p>
<p>第二个参数是可选的. 如果 <code>options</code> 选项被提供那么它应当是一个只包含成员<code>persistent</code>得对象，
<code>persistent</code>为boolean类型。<code>persistent</code>指定了进程是否“只要文件被监视就继续执行”缺省值为
<code>{ persistent: true }</code>.

</p>
<p>The listener callback gets two arguments <code>(event, filename)</code>.  <code>event</code> is either
&apos;rename&apos; or &apos;change&apos;, and <code>filename</code> is the name of the file which triggered
the event.

</p>
<p>监听器的回调函数得到两个参数 <code>(event, filename)</code>。其中 <code>event</code> 是 &apos;rename&apos;（重命名）或者 &apos;change&apos;（改变），而 <code>filename</code> 则是触发事件的文件名。

</p>
<h3>注意事项<span><a href="all.html#all_74" id="all_74">#</a></span></h3>
<!--type=misc-->

<p>The <code>fs.watch</code> API is not 100% consistent across platforms, and is
unavailable in some situations.

</p>
<p><code>fs.watch</code> 不是完全跨平台的，且在某些情况下不可用。

</p>
<h4>可用性<span><a href="all.html#all_75" id="all_75">#</a></span></h4>
<!--type=misc-->

<p>This feature depends on the underlying operating system providing a way
to be notified of filesystem changes.

</p>
<p>此功能依赖于操作系统底层提供的方法来监视文件系统的变化。

</p>
<ul>
<li>On Linux systems, this uses <code>inotify</code>.</li>
<li>On BSD systems (including OS X), this uses <code>kqueue</code>.</li>
<li>On SunOS systems (including Solaris and SmartOS), this uses <code>event ports</code>.</li>
<li><p>On Windows systems, this feature depends on <code>ReadDirectoryChangesW</code>.</p>
</li>
<li><p>在 Linux 操作系统上，使用 <code>inotify</code>。</p>
</li>
<li>在 BSD 操作系统上 (包括 OS X)，使用 <code>kqueue</code>。</li>
<li>在 SunOS 操作系统上 (包括 Solaris 和 SmartOS)，使用 <code>event ports</code>。</li>
<li>在 Windows 操作系统上，该特性依赖于 <code>ReadDirectoryChangesW</code>。</li>
</ul>
<p>If the underlying functionality is not available for some reason, then
<code>fs.watch</code> will not be able to function.  For example, watching files or
directories on network file systems (NFS, SMB, etc.) often doesn&apos;t work
reliably or at all.

</p>
<p>如果系统底层函数出于某些原因不可用，那么 <code>fs.watch</code> 也就无法工作。例如，监视网络文件系统(如 NFS, SMB 等)的文件或者目录，就时常不能稳定的工作，有时甚至完全不起作用。

</p>
<p>You can still use <code>fs.watchFile</code>, which uses stat polling, but it is slower and
less reliable.

</p>
<p>你仍然可以调用使用了文件状态调查的 <code>fs.watchFile</code>，但是会比较慢而且比较不可靠。

</p>
<h4>文件名参数<span><a href="all.html#all_76" id="all_76">#</a></span></h4>
<!--type=misc-->

<p>Providing <code>filename</code> argument in the callback is not supported
on every platform (currently it&apos;s only supported on Linux and Windows).  Even
on supported platforms <code>filename</code> is not always guaranteed to be provided.
Therefore, don&apos;t assume that <code>filename</code> argument is always provided in the
callback, and have some fallback logic if it is null.

</p>
<p>在回调函数中提供的 <code>filename</code> 参数不是在每一个操作系统中都被支持（当下仅在Linux和Windows上支持）。
即便是在支持的系统中，<code>filename</code>也不能保证在每一次回调都被提供。因此，不要假设<code>filename</code>参数总会会在
回调函数中提供，在回调函数中添加检测<code>filename</code>是否为null的if判断语句。

</p>
<pre><code>fs.watch(&apos;somedir&apos;, function (event, filename) {
  console.log(&apos;event is: &apos; + event);
  if (filename) {
    console.log(&apos;filename provided: &apos; + filename);
  } else {
    console.log(&apos;filename not provided&apos;);
  }
});</code></pre>
<h2>fs.exists(path, callback)<span><a href="all.html#all_fs_exists_path_callback_1" id="all_fs_exists_path_callback_1">#</a></span></h2>
<p>Test whether or not the given path exists by checking with the file system.
Then call the <code>callback</code> argument with either true or false.  Example:

</p>
<p>检查指定路径的文件或者目录是否存在。接着通过 <code>callback</code> 传入的参数指明存在 (true) 或者不存在 (false)。示例:

</p>
<pre><code>fs.exists(&apos;/etc/passwd&apos;, function (exists) {
  util.debug(exists ? &quot;存在&quot; : &quot;不存在!&quot;);
});</code></pre>
<h2>fs.existsSync(path)<span><a href="all.html#all_fs_existssync_path_1" id="all_fs_existssync_path_1">#</a></span></h2>
<p>Synchronous version of <code>fs.exists</code>.

</p>
<p><code>fs.exists</code> 函数的同步版。

</p>
<h2>Class: fs.Stats<span><a href="all.html#all_class_fs_stats_1" id="all_class_fs_stats_1">#</a></span></h2>
<p>Objects returned from <code>fs.stat()</code>, <code>fs.lstat()</code> and <code>fs.fstat()</code> and their
synchronous counterparts are of this type.

</p>
<p><code>fs.stat()</code>, <code>fs.lstat()</code> 和 <code>fs.fstat()</code> 以及他们对应的同步版本返回的对象。

</p>
<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li>
<li><code>stats.isFIFO()</code></li>
<li><p><code>stats.isSocket()</code></p>
</li>
<li><p><code>stats.isFile()</code></p>
</li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (仅在与 <code>fs.lstat()</code>一起使用时合法)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<p>For a regular file <code>util.inspect(stats)</code> would return a string very
similar to this:

</p>
<p>对于一个普通文件使用 <code>util.inspect(stats)</code> 将会返回一个类似如下输出的字符串：

</p>
<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>
<p>Please note that <code>atime</code>, <code>mtime</code>, <code>birthtime</code>, and <code>ctime</code> are
instances of <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> object and to compare the values of
these objects you should use appropriate methods. For most general
uses <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> will return the number of
milliseconds elapsed since <em>1 January 1970 00:00:00 UTC</em> and this
integer should be sufficient for any comparison, however there
additional methods which can be used for displaying fuzzy information.
More details can be found in the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a>
page.

</p>
<p>请注意 <code>atime</code>, <code>mtime</code>, <code>birthtime</code>, and <code>ctime</code> 是
 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> 对象的实例。而且在比较这些对象的值时你应当使用合适的方法。
大部分情况下，使用 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> 将会返回自 <em>1 January 1970 00:00:00 UTC</em> 以来逝去的毫秒数，
而且这个整形值应该能满足任何比较的使用条件。但是仍然还有一些额外的方法可以用来显示一些模糊的信息。更多细节请查看
 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> 页面。

</p>
<h3>Stat Time Values<span><a href="all.html#all_stat_time_values_1" id="all_stat_time_values_1">#</a></span></h3>
<p>The times in the stat object have the following semantics:

</p>
<p>在状态对象（stat object）中的时间有以下语义：

</p>
<ul>
<li><code>atime</code> &quot;Access Time&quot; - Time when file data last accessed.  Changed
by the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>read(2)</code> system calls.</li>
<li><code>mtime</code> &quot;Modified Time&quot; - Time when file data last modified.
Changed by the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>write(2)</code> system calls.</li>
<li><code>ctime</code> &quot;Change Time&quot; - Time when file status was last changed
(inode data modification).  Changed by the <code>chmod(2)</code>, <code>chown(2)</code>,
<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>,
<code>read(2)</code>, and <code>write(2)</code> system calls.</li>
<li><p><code>birthtime</code> &quot;Birth Time&quot; -  Time of file creation. Set once when the
file is created.  On filesystems where birthtime is not available,
this field may instead hold either the <code>ctime</code> or
<code>1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code>0</code>).  On Darwin and
other FreeBSD variants, also set if the <code>atime</code> is explicitly set to
an earlier value than the current <code>birthtime</code> using the <code>utimes(2)</code>
system call.</p>
</li>
<li><p><code>atime</code> &quot;Access Time&quot; - 文件数据上次被访问的时间.<br>会被 <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>read(2)</code> 等系统调用改变。</p>
</li>
<li><code>mtime</code> &quot;Modified Time&quot; - 文件上次被修改的时间。
会被 <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>write(2)</code> 等系统调用改变。</li>
<li><code>ctime</code> &quot;Change Time&quot; - 文件状态上次改变的时间。
(inode data modification).  会被 <code>chmod(2)</code>, <code>chown(2)</code>,
<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>,
<code>read(2)</code>, and <code>write(2)</code> 等系统调用改变。</li>
<li><code>birthtime</code> &quot;Birth Time&quot; -  文件被创建的时间。 会在文件被创建时生成。
在一些不提供文件<code>birthtime</code>的文件系统中,
这个字段会被 <code>ctime</code> 或
<code>1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code>0</code>)来填充。  在 Darwin 和其他
 FreeBSD 系统变体中, 也将 <code>atime</code> 显式地设置成比它现在的 <code>birthtime</code> 更早的一个时间值，这个过程使用了<code>utimes(2)</code>系统调用。</li>
</ul>
<p>Prior to Node v0.12, the <code>ctime</code> held the <code>birthtime</code> on Windows
systems.  Note that as of v0.12, <code>ctime</code> is not &quot;creation time&quot;, and
on Unix systems, it never was.

</p>
<p>在Node v0.12版本之前, <code>ctime</code> 持有Windows系统的 <code>birthtime</code> 值. 注意在v.0.12版本中, <code>ctime</code> 不再是&quot;creation time&quot;, 而且在Unix系统中，他从来都不是。

</p>
<h2>fs.createReadStream(path, [options])<span><a href="all.html#all_fs_createreadstream_path_options_1" id="all_fs_createreadstream_path_options_1">#</a></span></h2>
<p>Returns a new ReadStream object (See <code>Readable Stream</code>).

</p>
<p>返回一个新的 ReadStream 对象 (详见 <code>Readable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ flags: &apos;r&apos;,
  encoding: null,
  fd: null,
  mode: 0666,
  autoClose: true
}</code></pre>
<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and
start at 0. The <code>encoding</code> can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.

</p>
<p><code>options</code> 可以提供 <code>start</code> 和 <code>end</code> 值用于读取文件内的特定范围而非整个文件。
<code>start</code> 和 <code>end</code> 都是包含在范围内的（inclusive, 可理解为闭区间）并且以 0 开始。
<code>encoding</code> 可选为 <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> 或者 <code>&apos;base64&apos;</code>。

</p>
<p>If <code>autoClose</code> is false, then the file descriptor won&apos;t be closed, even if
there&apos;s an error.  It is your responsibility to close it and make sure
there&apos;s no file descriptor leak.  If <code>autoClose</code> is set to true (default
behavior), on <code>error</code> or <code>end</code> the file descriptor will be closed
automatically.

</p>
<p>如果 <code>autoClose</code> 为 false 则即使在发生错误时也不会关闭文件描述符 (file descriptor)。
此时你需要负责关闭文件，避免文件描述符泄露 (leak)。
如果 <code>autoClose</code> 为 true （缺省值），
当发生 <code>error</code> 或者 <code>end</code> 事件时，文件描述符会被自动释放。

</p>
<p>An example to read the last 10 bytes of a file which is 100 bytes long:

</p>
<p>一个从100字节的文件中读取最后10字节的例子：

</p>
<pre><code>fs.createReadStream(&apos;sample.txt&apos;, {start: 90, end: 99});</code></pre>
<h2>Class: fs.ReadStream<span><a href="all.html#all_class_fs_readstream_1" id="all_class_fs_readstream_1">#</a></span></h2>
<p><code>ReadStream</code> is a <a href="stream.html#stream_class_stream_readable">Readable Stream</a>.

</p>
<p><code>ReadStream</code> 是一个可读的流<a href="stream.html#stream_class_stream_readable">(Readable Stream)</a>.

</p>
<h3>事件: &apos;open&apos;<span><a href="all.html#all_open_2" id="all_open_2">#</a></span></h3>
<div><ul>
<li><p><code>fd</code> <span>Integer</span> file descriptor used by the ReadStream.</p>
</li>
<li><p><code>fd</code> <span>整形</span> ReadStream 所使用的文件描述符。</p>
</li>
</div></ul>
<p>Emitted when the ReadStream&apos;s file is opened.

</p>
<p>当文件的 ReadStream 被创建时触发。

</p>
<h2>fs.createWriteStream(path, [options])<span><a href="all.html#all_fs_createwritestream_path_options_1" id="all_fs_createwritestream_path_options_1">#</a></span></h2>
<p>Returns a new WriteStream object (See <code>Writable Stream</code>).

</p>
<p>返回一个新的 WriteStream 对象 (详见 <code>Writable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ flags: &apos;w&apos;,
  encoding: null,
  mode: 0666 }</code></pre>
<p><code>options</code> may also include a <code>start</code> option to allow writing data at
some position past the beginning of the file.  Modifying a file rather
than replacing it may require a <code>flags</code> mode of <code>r+</code> rather than the
default mode <code>w</code>.

</p>
<p><code>options</code> 也可以包含一个 <code>start</code> 选项用于指定在文件中开始写入数据的位置。
修改而不替换文件需要 <code>flags</code> 的模式指定为 <code>r+</code> 而不是默值的 <code>w</code>.

</p>
<h2>Class: fs.WriteStream<span><a href="all.html#all_class_fs_writestream_1" id="all_class_fs_writestream_1">#</a></span></h2>
<p><code>WriteStream</code> is a <a href="stream.html#stream_class_stream_writable">Writable Stream</a>.

</p>
<p><code>WriteStream</code> 是一个可写的流<a href="stream.html#stream_class_stream_writable">(Writable Stream)</a>.

</p>
<h3>事件: &apos;open&apos;<span><a href="all.html#all_open_3" id="all_open_3">#</a></span></h3>
<div><ul>
<li><p><code>fd</code> <span>Integer</span> file descriptor used by the WriteStream.</p>
</li>
<li><p><code>fd</code> <span>整形</span> WriteStream 所使用的文件描述符。</p>
</li>
</div></ul>
<p>Emitted when the WriteStream&apos;s file is opened.

</p>
<p>当 WriteStream 创建时触发。

</p>
<h3>file.bytesWritten<span><a href="all.html#all_file_byteswritten_1" id="all_file_byteswritten_1">#</a></span></h3>
<p>The number of bytes written so far. Does not include data that is still queued
for writing.

</p>
<p>已写的字节数。不包含仍在队列中准备写入的数据。

</p>
<h2>Class: fs.FSWatcher<span><a href="all.html#all_class_fs_fswatcher_1" id="all_class_fs_fswatcher_1">#</a></span></h2>
<p>Objects returned from <code>fs.watch()</code> are of this type.

</p>
<p><code>fs.watch()</code> 返回的对象类型。

</p>
<h3>watcher.close()<span><a href="all.html#all_watcher_close_1" id="all_watcher_close_1">#</a></span></h3>
<p>Stop watching for changes on the given <code>fs.FSWatcher</code>.

</p>
<p>停止观察 <code>fs.FSWatcher</code> 对象中的更改。

</p>
<h3>事件: &apos;change&apos;<span><a href="all.html#all_change_1" id="all_change_1">#</a></span></h3>
<div><ul>
<li><code>event</code> <span>String</span> The type of fs change</li>
<li><p><code>filename</code> <span>String</span> The filename that changed (if relevant/available)</p>
</li>
<li><p><code>event</code> <span>字符串</span> fs 改变的类型</p>
</li>
<li><code>filename</code> <span>字符串</span> 改变的文件名 (if relevant/available)</li>
</div></ul>
<p>Emitted when something changes in a watched directory or file.
See more details in <a href="all.html#fs_fs_watch_filename_options_listener">fs.watch</a>.

</p>
<p>当正在观察的目录或文件发生变动时触发。更多细节，详见 <a href="all.html#fs_fs_watch_filename_options_listener">fs.watch</a>。

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_9" id="all_error_9">#</a></span></h3>
<div><ul>
<li><p><code>error</code> <span>Error object</span></p>
</li>
<li><p><code>error</code> <span>Error 对象</span></p>
</li>
</div></ul>
<p>Emitted when an error occurs.


</p>
<p>当产生错误时触发
</p>
<h1>路径 (Path)<span><a href="all.html#all_path_1" id="all_path_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>This module contains utilities for handling and transforming file
paths.  Almost all these methods perform only string transformations.
The file system is not consulted to check whether paths are valid.

</p>
<p>本模块包含一套用于处理和转换文件路径的工具集。几乎所有的方法仅对字符串进行转换，
文件系统是不会检查路径是否真实有效的。

</p>
<p>Use <code>require(&apos;path&apos;)</code> to use this module.  The following methods are provided:

</p>
<p>通过 <code>require(&apos;path&apos;)</code> 来加载此模块。以下是本模块所提供的方法：

</p>
<h2>path.normalize(p)<span><a href="all.html#all_path_normalize_p_1" id="all_path_normalize_p_1">#</a></span></h2>
<p>Normalize a string path, taking care of <code>&apos;..&apos;</code> and <code>&apos;.&apos;</code> parts.

</p>
<p>规范化字符串路径，注意 <code>&apos;..&apos;</code> 和 `&apos;.&apos; 部分

</p>
<p>When multiple slashes are found, they&apos;re replaced by a single one;
when the path contains a trailing slash, it is preserved.
On Windows backslashes are used.

</p>
<p>当发现有多个连续的斜杠时，会替换成一个；
当路径末尾包含斜杠时，会保留；
在 Windows 系统会使用反斜杠。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.join([path1], [path2], [...])<span><a href="all.html#all_path_join_path1_path2_1" id="all_path_join_path1_path2_1">#</a></span></h2>
<p>Join all arguments together and normalize the resulting path.

</p>
<p>组合参数中的所有路径，返回规范化后的路径。

</p>
<p>Arguments must be strings.  In v0.8, non-string arguments were
silently ignored.  In v0.10 and up, an exception is thrown.

</p>
<p>参数必须是字符串。在 v0.8 版本非字符串参数会被悄悄忽略。
在 v0.10 及以后版本将会抛出一个异常。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.join(&apos;foo&apos;, {}, &apos;bar&apos;)
// 抛出异常
TypeError: Arguments to path.join must be strings</code></pre>
<h2>path.resolve([from ...], to)<span><a href="all.html#all_path_resolve_from_to_1" id="all_path_resolve_from_to_1">#</a></span></h2>
<p>Resolves <code>to</code> to an absolute path.

</p>
<p>将 <code>to</code> 参数解析为一个绝对路径。

</p>
<p>If <code>to</code> isn&apos;t already absolute <code>from</code> arguments are prepended in right to left
order, until an absolute path is found. If after using all <code>from</code> paths still
no absolute path is found, the current working directory is used as well. The
resulting path is normalized, and trailing slashes are removed unless the path
gets resolved to the root directory. Non-string arguments are ignored.

</p>
<p>如果<code>to</code>不是一个相对于<code>from</code> 参数的绝对路径，<code>to</code>会被添加到<code>from</code>的右边，直到找出一个绝对路径为止。如果使用<code>from</code>路径且仍没有找到绝对路径时，使用当时路径作为目录。返回的结果已经规范化，得到的路径会去掉结尾的斜杠，除非得到的当前路径为root目录。非字符串参数将被忽略。

</p>
<p>Another way to think of it is as a sequence of <code>cd</code> commands in a shell.

</p>
<p>另一种思考方式就是像在shell里面用一系列的‘cd’命令一样.

</p>
<pre><code>path.resolve(&apos;foo/bar&apos;, &apos;/tmp/file/&apos;, &apos;..&apos;, &apos;a/../subfile&apos;)</code></pre>
<p>Is similar to:

</p>
<p>相当于:

</p>
<pre><code>cd foo/bar
cd /tmp/file/
cd ..
cd a/../subfile
pwd</code></pre>
<p>The difference is that the different paths don&apos;t need to exist and may also be
files.

</p>
<p>不同的是，不同的路径不需要存在的，也可能是文件。

</p>
<p>Examples:

</p>
<p>示例:

</p>
<pre><code>path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;)
// 如果当前工作目录为 /home/myself/node，它返回：
&apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos;</code></pre>
<h2>path.isAbsolute(path)<span><a href="all.html#all_path_isabsolute_path_1" id="all_path_isabsolute_path_1">#</a></span></h2>
<p>Determines whether <code>path</code> is an absolute path. An absolute path will always
resolve to the same location, regardless of the working directory.

</p>
<p>判定<code>path</code>是否为绝对路径。一个绝对路径总是指向一个相同的位置，无论当前工作目录是在哪里。

</p>
<p>Posix examples:

</p>
<p>Posix 示例:

</p>
<pre><code>path.isAbsolute(&apos;/foo/bar&apos;) // true
path.isAbsolute(&apos;/baz/..&apos;)  // true
path.isAbsolute(&apos;qux/&apos;)     // false
path.isAbsolute(&apos;.&apos;)        // false</code></pre>
<p>Windows examples:

</p>
<p>Windows 示例:

</p>
<pre><code>path.isAbsolute(&apos;//server&apos;)  // true
path.isAbsolute(&apos;C:/foo/..&apos;) // true
path.isAbsolute(&apos;bar\\baz&apos;)   // false
path.isAbsolute(&apos;.&apos;)         // false</code></pre>
<h2>path.relative(from, to)<span><a href="all.html#all_path_relative_from_to_1" id="all_path_relative_from_to_1">#</a></span></h2>
<p>Solve the relative path from <code>from</code> to <code>to</code>.

</p>
<p>解决从<code>from</code>到<code>to</code>的相对路径。

</p>
<p>At times we have two absolute paths, and we need to derive the relative
path from one to the other.  This is actually the reverse transform of
<code>path.resolve</code>, which means we see that:

</p>
<p>有时我们有2个绝对路径, 我们需要从中找出相对目录的起源目录。这完全是<code>path.resolve</code>的相反实现,我们可以看看是什么意思:

</p>
<pre><code>path.resolve(from, path.relative(from, to)) == path.resolve(to)</code></pre>
<p>Examples:

</p>
<p>示例:

</p>
<pre><code>path.relative(&apos;/data/orandea/test/aaa&apos;, &apos;/data/orandea/impl/bbb&apos;)
// 返回
&apos;../../impl/bbb&apos;</code></pre>
<h2>path.dirname(p)<span><a href="all.html#all_path_dirname_p_1" id="all_path_dirname_p_1">#</a></span></h2>
<p>Return the directory name of a path.  Similar to the Unix <code>dirname</code> command.

</p>
<p>返回路径中文件夹的名称.  类似于Unix的<code>dirname</code> 命令.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.dirname(&apos;/foo/bar/baz/asdf/quux&apos;)
// returns
&apos;/foo/bar/baz/asdf&apos;</code></pre>
<h2>path.basename(p, [ext])<span><a href="all.html#all_path_basename_p_ext_1" id="all_path_basename_p_ext_1">#</a></span></h2>
<p>Return the last portion of a path.  Similar to the Unix <code>basename</code> command.

</p>
<p>返回路径中的最后哦一部分.  类似于Unix 的 <code>basename</code> 命令.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>path.basename(&apos;/foo/bar/baz/asdf/quux.html&apos;, &apos;.html&apos;)
// returns
&apos;quux&apos;</code></pre>
<h2>path.extname(p)<span><a href="all.html#all_path_extname_p_1" id="all_path_extname_p_1">#</a></span></h2>
<p>Return the extension of the path, from the last &apos;.&apos; to end of string
in the last portion of the path.  If there is no &apos;.&apos; in the last portion
of the path or the first character of it is &apos;.&apos;, then it returns
an empty string.  Examples:

</p>
<p>返回路径中文件的扩展名, 在从最后一部分中的最后一个&apos;.&apos;到字符串的末尾。
如果在路径的最后一部分没有&apos;.&apos;，或者第一个字符是&apos;.&apos;，就返回一个
空字符串。 例子：

</p>
<pre><code>path.extname(&apos;index&apos;)
// returns
&apos;&apos;</code></pre>
<h2>path.sep<span><a href="all.html#all_path_sep_1" id="all_path_sep_1">#</a></span></h2>
<p>The platform-specific file separator. <code>&apos;\\&apos;</code> or <code>&apos;/&apos;</code>.

</p>
<p>特定平台的文件分隔工具. <code>&apos;\\&apos;</code> 或者 <code>&apos;/&apos;</code>.

</p>
<p>An example on *nix:

</p>
<p>*nix 上的例子:

</p>
<pre><code>&apos;foo/bar/baz&apos;.split(path.sep)
// returns
[&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]</code></pre>
<p>An example on Windows:

</p>
<p>Windows 上的例子:

</p>
<pre><code>&apos;foo\\bar\\baz&apos;.split(path.sep)
// returns
[&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;]</code></pre>
<h2>path.delimiter<span><a href="all.html#all_path_delimiter_1" id="all_path_delimiter_1">#</a></span></h2>
<p>The platform-specific path delimiter, <code>;</code> or <code>&apos;:&apos;</code>.

</p>
<p>特定平台的路径分隔符, <code>;</code> 或者 <code>&apos;:&apos;</code>.

</p>
<p>An example on *nix:

</p>
<p>*nix 上的例子:

</p>
<pre><code>process.env.PATH.split(path.delimiter)
// returns
[&apos;/usr/bin&apos;, &apos;/bin&apos;, &apos;/usr/sbin&apos;, &apos;/sbin&apos;, &apos;/usr/local/bin&apos;]</code></pre>
<p>An example on Windows:

</p>
<p>Windows 上的例子:

</p>
<pre><code>console.log(process.env.PATH)
// &apos;C:\Windows\system32;C:\Windows;C:\Program Files\nodejs\&apos;

process.env.PATH.split(path.delimiter)
// returns
[&apos;C:\Windows\system32&apos;, &apos;C:\Windows&apos;, &apos;C:\Program Files\nodejs\&apos;]


process.env.PATH.split(path.delimiter)
// returns
[&apos;C:\Windows\system32&apos;, &apos;C:\Windows&apos;, &apos;C:\Program Files\nodejs\&apos;]</code></pre>
<h1>网络<span><a href="all.html#all_77" id="all_77">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>The <code>net</code> module provides you with an asynchronous network wrapper. It contains
methods for creating both servers and clients (called streams). You can include
this module with <code>require(&apos;net&apos;);</code>

</p>
<p><code>net</code> 模块封装了异步网络功能，提供了一些方法来创建服务器和客户端（称之为流）。您可以用 <code>require(&apos;net&apos;)</code> 来引入这个模块。

</p>
<h2>net.createServer([options], [connectionListener])<span><a href="all.html#all_net_createserver_options_connectionlistener_1" id="all_net_createserver_options_connectionlistener_1">#</a></span></h2>
<p>Creates a new TCP server. The <code>connectionListener</code> argument is
automatically set as a listener for the <a href="all.html#net_event_connection">&apos;connection&apos;</a> event.

</p>
<p>创建一个新的 TCP 服务器。参数 <code>connectionListener</code> 会被自动作为 <a href="all.html#net_event_connection">&apos;connection&apos;</a> 事件的监听器。

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ allowHalfOpen: false
}</code></pre>
<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won&apos;t automatically send a FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the <code>end()</code> method explicitly.
See <a href="all.html#net_event_end">&apos;end&apos;</a> event for more information.

</p>
<p>如果允许半开连接 <code>allowHalfOpen</code> 被设置为 <code>true</code>，则当另一端的套接字发送 FIN 报文时套接字并不会自动发送 FIN 报文。套接字会变为不可读，但仍然可写。您应当明确地调用 <code>end()</code> 方法。详见 <a href="all.html#net_event_end">&apos;end&apos;</a> 事件。

</p>
<p>Here is an example of an echo server which listens for connections
on port 8124:

</p>
<p>下面是一个监听 8124 端口连接的应答服务器的例子：

</p>
<pre><code>var net = require(&apos;net&apos;);
var server = net.createServer(function(c) { // &apos;connection&apos; 监听器
  console.log(&apos;服务器已连接&apos;);
  c.on(&apos;end&apos;, function() {
    console.log(&apos;服务器已断开&apos;);
  });
  c.write(&apos;hello\r\n&apos;);
  c.pipe(c);
});
server.listen(8124, function() { // &apos;listening&apos; 监听器
  console.log(&apos;服务器已绑定&apos;);
});</code></pre>
<p>Test this by using <code>telnet</code>:

</p>
<p>使用 <code>telnet</code> 测试：

</p>
<pre><code>telnet localhost 8124</code></pre>
<p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would
just be changed to

</p>
<p>要监听套接字 <code>/tmp/echo.sock</code> 仅需更改倒数第三行代码：

</p>
<pre><code>server.listen(&apos;/tmp/echo.sock&apos;, function() { // &apos;listening&apos; 监听器</code></pre>
<p>Use <code>nc</code> to connect to a UNIX domain socket server:

</p>
<p>使用 <code>nc</code> 连接到一个 UNIX domain 套接字服务器：

</p>
<pre><code>nc -U /tmp/echo.sock</code></pre>
<h2>net.connect(options, [connectionListener])<span><a href="all.html#all_net_connect_options_connectionlistener_2" id="all_net_connect_options_connectionlistener_2">#</a></span></h2>
<h2>net.createConnection(options, [connectionListener])<span><a href="all.html#all_net_createconnection_options_connectionlistener_2" id="all_net_createconnection_options_connectionlistener_2">#</a></span></h2>
<h2>net.connect(options, [connectionListener])<span><a href="all.html#all_net_connect_options_connectionlistener_3" id="all_net_connect_options_connectionlistener_3">#</a></span></h2>
<h2>net.createConnection(options, [connectionListener])<span><a href="all.html#all_net_createconnection_options_connectionlistener_3" id="all_net_createconnection_options_connectionlistener_3">#</a></span></h2>
<p>Constructs a new socket object and opens the socket to the given location.
When the socket is established, the <a href="all.html#net_event_connect">&apos;connect&apos;</a> event will be emitted.

</p>
<p>构建一个新的套接字对象并打开所给位置的套接字。当套接字就绪时会触发 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件。

</p>
<p>For TCP sockets, <code>options</code> argument should be an object which specifies:

</p>
<p>对于 TCP 套接字，选项 <code>options</code> 参数应为一个指定下列参数的对象：

</p>
<ul>
<li><p><code>port</code>: Port the client should connect to (Required).</p>
</li>
<li><p><code>port</code>：客户端连接到的端口（必须）</p>
</li>
<li><p><code>host</code>: Host the client should connect to. Defaults to <code>&apos;localhost&apos;</code>.</p>
</li>
<li><p><code>host</code>：客户端连接到的主机，缺省为 <code>&apos;localhost&apos;</code></p>
</li>
<li><p><code>localAddress</code>: Local interface to bind to for network connections.</p>
</li>
<li><p><code>localAddress</code>：网络连接绑定的本地接口</p>
</li>
<li><p><code>family</code> : Version of IP stack. Defaults to <code>4</code>.</p>
</li>
<li><p><code>family</code>：IP 栈版本，缺省为 <code>4</code></p>
</li>
</ul>
<p>For UNIX domain sockets, <code>options</code> argument should be an object which specifies:

</p>
<p>对于 UNIX domain 套接字，选项 <code>options</code> 参数应当为一个指定下列参数的对象：

</p>
<ul>
<li><p><code>path</code>: Path the client should connect to (Required).</p>
</li>
<li><p><code>path</code>：客户端连接到的路径（必须）</p>
</li>
</ul>
<p>Common options are:

</p>
<p>通用选项：

</p>
<ul>
<li><p><code>allowHalfOpen</code>: if <code>true</code>, the socket won&apos;t automatically send
a FIN packet when the other end of the socket sends a FIN packet.
Defaults to <code>false</code>.  See <a href="all.html#net_event_end">&apos;end&apos;</a> event for more information.</p>
</li>
<li><p><code>allowHalfOpen</code>：允许半开连接，如果被设置为 <code>true</code>，则当另一端的套接字发送 FIN 报文时套接字并不会自动发送 FIN 报文。缺省为 <code>false</code>。详见 <a href="all.html#net_event_end">&apos;end&apos;</a> 事件。</p>
</li>
</ul>
<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p> <code>connectListener</code> 用于 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器

</p>
<p>Here is an example of a client of echo server as described previously:

</p>
<p>下面是一个上述应答服务器的客户端的例子：

</p>
<pre><code>var net = require(&apos;net&apos;);
var client = net.connect({port: 8124},
    function() { //&apos;connect&apos; 监听器
  console.log(&apos;client connected&apos;);
  client.write(&apos;world!\r\n&apos;);
});
client.on(&apos;data&apos;, function(data) {
  console.log(data.toString());
  client.end();
});
client.on(&apos;end&apos;, function() {
  console.log(&apos;客户端断开连接&apos;);
});</code></pre>
<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be
changed to

</p>
<p>要连接到套接字 <code>/tmp/echo.sock</code>，仅需将第二行改为

</p>
<pre><code>var client = net.connect({path: &apos;/tmp/echo.sock&apos;},</code></pre>
<h2>net.connect(port, [host], [connectListener])<span><a href="all.html#all_net_connect_port_host_connectlistener_2" id="all_net_connect_port_host_connectlistener_2">#</a></span></h2>
<h2>net.createConnection(port, [host], [connectListener])<span><a href="all.html#all_net_createconnection_port_host_connectlistener_2" id="all_net_createconnection_port_host_connectlistener_2">#</a></span></h2>
<h2>net.connect(port, [host], [connectListener])<span><a href="all.html#all_net_connect_port_host_connectlistener_3" id="all_net_connect_port_host_connectlistener_3">#</a></span></h2>
<h2>net.createConnection(port, [host], [connectListener])<span><a href="all.html#all_net_createconnection_port_host_connectlistener_3" id="all_net_createconnection_port_host_connectlistener_3">#</a></span></h2>
<p>Creates a TCP connection to <code>port</code> on <code>host</code>. If <code>host</code> is omitted,
<code>&apos;localhost&apos;</code> will be assumed.
The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p>创建一个 <code>host</code> 主机 <code>port</code> 端口的 TCP 连接。如果省略 <code>host</code> 则假定为 <code>&apos;localhost&apos;</code>。<code>connectListener</code> 参数会被用作 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器。

</p>
<h2>net.connect(path, [connectListener])<span><a href="all.html#all_net_connect_path_connectlistener_2" id="all_net_connect_path_connectlistener_2">#</a></span></h2>
<h2>net.createConnection(path, [connectListener])<span><a href="all.html#all_net_createconnection_path_connectlistener_2" id="all_net_createconnection_path_connectlistener_2">#</a></span></h2>
<h2>net.connect(path, [connectListener])<span><a href="all.html#all_net_connect_path_connectlistener_3" id="all_net_connect_path_connectlistener_3">#</a></span></h2>
<h2>net.createConnection(path, [connectListener])<span><a href="all.html#all_net_createconnection_path_connectlistener_3" id="all_net_createconnection_path_connectlistener_3">#</a></span></h2>
<p>Creates unix socket connection to <code>path</code>.
The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p>创建一个到路径 <code>path</code> 的 UNIX 套接字连接。<code>connectListener</code> 参数会被用作 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器。

</p>
<h2>类: net.Server<span><a href="all.html#all_net_server_1" id="all_net_server_1">#</a></span></h2>
<p>This class is used to create a TCP or UNIX server.
A server is a <code>net.Socket</code> that can listen for new incoming connections.

</p>
<p>该类用于创建一个 TCP 或 UNIX 服务器。服务器本质上是一个可监听传入连接的 <code>net.Socket</code>。

</p>
<h3>server.listen(port, [host], [backlog], [callback])<span><a href="all.html#all_server_listen_port_host_backlog_callback_3" id="all_server_listen_port_host_backlog_callback_3">#</a></span></h3>
<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>). A port value of zero will assign a random port.

</p>
<p>在指定端口 <code>port</code> 和主机 <code>host</code> 上开始接受连接。如果省略 <code>host</code> 则服务器会接受来自所有 IPv4 地址（<code>INADDR_ANY</code>）的连接；端口为 0 则会使用分随机分配的端口。

</p>
<p>Backlog is the maximum length of the queue of pending connections.
The actual length will be determined by your OS through sysctl settings such as
<code>tcp_max_syn_backlog</code> and <code>somaxconn</code> on linux. The default value of this
parameter is 511 (not 512).

</p>
<p>积压量 <code>backlog</code> 为连接等待队列的最大长度。实际长度由您的操作系统通过 sysctl 设置决定，比如 Linux 上的 <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。该参数缺省值为 511（不是 512）。

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="net.html#net_event_listening">&apos;listening&apos;</a> event will be emitted.  The last parameter <code>callback</code>
will be added as an listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.

</p>
<p>这是一个异步函数。当服务器已被绑定时会触发 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件。最后一个参数 <code>callback</code> 会被用作 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件的监听器。

</p>
<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. This means that
another server is already running on the requested port. One way of handling this
would be to wait a second and then try again. This can be done with

</p>
<p>有些用户会遇到的情况是遇到 &apos;EADDINUSE&apos; 错误。这表示另一个服务器已经运行在所请求的端口上。一个处理这种情况的方法是等待一段时间再重试

</p>
<pre><code>server.on(&apos;error&apos;, function (e) {
  if (e.code == &apos;EADDRINUSE&apos;) {
    console.log(&apos;地址被占用，重试中...&apos;);
    setTimeout(function () {
      server.close();
      server.listen(PORT, HOST);
    }, 1000);
  }
});</code></pre>
<p>(Note: All sockets in Node set <code>SO_REUSEADDR</code> already)

</p>
<p>（注意：Node 中的所有套接字已设置了 <code>SO_REUSEADDR</code>）

</p>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback_4" id="all_server_listen_path_callback_4">#</a></span></h3>
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.

</p>
<p>启动一个 UNIX 套接字服务器在所给路径 <code>path</code> 上监听连接。

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="net.html#net_event_listening">&apos;listening&apos;</a> event will be emitted.  The last parameter <code>callback</code>
will be added as an listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.

</p>
<p>这是一个异步函数。当服务器已被绑定时会触发 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件。最后一个参数 <code>callback</code> 会被用作 <a href="net.html#net_event_listening">&apos;listening&apos;</a> 事件的监听器。

</p>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback_4" id="all_server_listen_handle_callback_4">#</a></span></h3>
<div><ul>
<li><code>handle</code> <span>Object</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>handle</code>处理器 <span>Object</span></p>
</li>
<li><code>callback</code>回调函数 <span>Function</span></li>
</div></ul>
<p>The <code>handle</code> object can be set to either a server or socket (anything
with an underlying <code>_handle</code> member), or a <code>{fd: &lt;n&gt;}</code> object.

</p>
<p><code>handle</code> 变量可以被设置为server 或者 socket(任一以下划线开头的成员 <code>_handle</code>), 或者一个 <code>{fd: &lt;n&gt;}</code> 对象

</p>
<p>This will cause the server to accept connections on the specified
handle, but it is presumed that the file descriptor or handle has
already been bound to a port or domain socket.

</p>
<p>这将使服务器用指定的句柄接受连接，但它假设文件描述符或者句柄已经被绑定在特定的端口或者域名套接字。

</p>
<p>Listening on a file descriptor is not supported on Windows.

</p>
<p>Windows 不支持监听一个文件描述符。

</p>
<p>This function is asynchronous.  When the server has been bound,
<a href="all.html#event_listening_">&apos;listening&apos;</a> event will be emitted.
the last parameter <code>callback</code> will be added as an listener for the
<a href="all.html#event_listening_">&apos;listening&apos;</a> event.

</p>
<p>这是一个异步函数。当服务器已被绑定时会触发 <a href="all.html#event_listening_">&apos;listening&apos;</a> 事件。最后一个参数 <code>callback</code> 会被用作 <a href="all.html#event_listening_">&apos;listening&apos;</a> 事件的监听器。

</p>
<h3>server.close([callback])<span><a href="all.html#all_server_close_callback_3" id="all_server_close_callback_3">#</a></span></h3>
<p>Stops the server from accepting new connections and keeps existing
connections. This function is asynchronous, the server is finally
closed when all connections are ended and the server emits a <code>&apos;close&apos;</code>
event. Optionally, you can pass a callback to listen for the <code>&apos;close&apos;</code>
event.

</p>
<p>用于停止服务器接受新连接，但保持已存在的连接。这是一个异步函数，
服务器将在所有的连接都结束后关闭，并且服务器发送 <code>&apos;close&apos;</code>事件
你可以有选择的传入回调函数来监听 <code>&apos;close&apos;</code>事件。

</p>
<h3>server.address()<span><a href="all.html#all_server_address_3" id="all_server_address_3">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the server
as reported by the operating system.
Useful to find which port was assigned when giving getting an OS-assigned address.
Returns an object with three properties, e.g.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<p>返回操作系统报告的绑定的地址，协议族和端口。
对查找操作系统分配的地址哪个端口已被分配非常有用， 如.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 获得随机端口
server.listen(function() {
  address = server.address();
  console.log(&quot;opened server on %j&quot;, address);
});</code></pre>
<p>Don&apos;t call <code>server.address()</code> until the <code>&apos;listening&apos;</code> event has been emitted.

</p>
<p>在 <code>&apos;listening&apos;</code> 事件发生前请勿调用 <code>server.address()</code>。

</p>
<h3>server.unref()<span><a href="all.html#all_server_unref_1" id="all_server_unref_1">#</a></span></h3>
<p>Calling <code>unref</code> on a server will allow the program to exit if this is the only
active server in the event system. If the server is already <code>unref</code>d calling
<code>unref</code> again will have no effect.

</p>
<p>如果这是事件系统中唯一一个活动的服务器，调用 <code>unref</code> 将允许程序退出。如果服务器已被 <code>unref</code>，则再次调用 <code>unref</code> 并不会产生影响。

</p>
<h3>server.ref()<span><a href="all.html#all_server_ref_1" id="all_server_ref_1">#</a></span></h3>
<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d server will <em>not</em>
let the program exit if it&apos;s the only server left (the default behavior). If
the server is <code>ref</code>d calling <code>ref</code> again will have no effect.

</p>
<p>与 <code>unref</code> 相反，如果这是仅剩的服务器，在一个之前被 <code>unref</code> 了的服务器上调用 <code>ref</code> 将不会让程序退出（缺省行为）。如果服务器已经被 <code>ref</code>，则再次调用 <code>ref</code> 并不会产生影响。

</p>
<h3>server.maxConnections<span><a href="all.html#all_server_maxconnections_3" id="all_server_maxconnections_3">#</a></span></h3>
<p>Set this property to reject connections when the server&apos;s connection count gets
high.

</p>
<p>设置这个选项能在当服务器连接数超过数量时拒绝连接。

</p>
<p>It is not recommended to use this option once a socket has been sent to a child
with <code>child_process.fork()</code>.

</p>
<p>这个选项不推荐使用在套接字已经用 <code>child_process.fork()</code>发送给子进程。

</p>
<h3>server.connections<span><a href="all.html#all_server_connections_3" id="all_server_connections_3">#</a></span></h3>
<p>This function is <strong>deprecated</strong>; please use [server.getConnections()][] instead.
The number of concurrent connections on the server.

</p>
<p>这个函数已被 <strong>废弃</strong>; 请用 [server.getConnections()][] 代替.
服务器的当前活动连接的数量。

</p>
<p>This becomes <code>null</code> when sending a socket to a child with
<code>child_process.fork()</code>. To poll forks and get current number of active
connections use asynchronous <code>server.getConnections</code> instead.

</p>
<p>当用<code>child_process.fork()</code>发送一个套接字给子进程时，它将是 <code>null</code> 。
要轮询子进程来获取当前活动的连接请用 <code>server.getConnections</code> 代替.

</p>
<p><code>net.Server</code> is an <a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<p><code>net.Server</code> 是一个包含下列事件的 <a href="events.html#events_class_events_eventemitter">EventEmitter</a> :

</p>
<h3>server.getConnections(callback)<span><a href="all.html#all_server_getconnections_callback_1" id="all_server_getconnections_callback_1">#</a></span></h3>
<p>Asynchronously get the number of concurrent connections on the server. Works
when sockets were sent to forks.

</p>
<p>异步获取服务器当前活跃的连接数. 
用于套接字呗发送给子进程。

</p>
<p>Callback should take two arguments <code>err</code> and <code>count</code>.

</p>
<p>回调函数需要两个参数 <code>err</code> 和 <code>count</code>.

</p>
<h3>事件: &apos;listening&apos;<span><a href="all.html#all_listening_4" id="all_listening_4">#</a></span></h3>
<p>Emitted when the server has been bound after calling <code>server.listen</code>.

</p>
<p>在服务器调用 <code>server.listen</code>绑定后触发。

</p>
<h3>事件: &apos;connection&apos;<span><a href="all.html#all_connection_2" id="all_connection_2">#</a></span></h3>
<div><ul>
<li><p><span>Socket object</span> The connection object</p>
</li>
<li><p><span>Socket object</span> 连接对象</p>
</li>
</div></ul>
<p>Emitted when a new connection is made. <code>socket</code> is an instance of
<code>net.Socket</code>.

</p>
<p>在一个新连接被创建时触发。 <code>socket</code> 是一个<code>net.Socket</code>的实例。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_10" id="all_close_10">#</a></span></h3>
<p>Emitted when the server closes. Note that if connections exist, this
event is not emitted until all connections are ended.

</p>
<p>当服务被关闭时触发. 注意：如果当前仍有活动连接，他个事件将等到所有连接都结束后才触发。

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_10" id="all_error_10">#</a></span></h3>
<div><ul>
<li><p><span>Error Object</span></p>
</li>
<li><p><span>Error Object</span></p>
</li>
</div></ul>
<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly
following this event.  See example in discussion of <code>server.listen</code>.

</p>
<p>当一个错误发生时触发。  <code>&apos;close&apos;</code> 事件将直接被下列时间调用。
请查看讨论 <code>server.listen</code>的例子。

</p>
<h2>类: net.Socket<span><a href="all.html#all_net_socket_1" id="all_net_socket_1">#</a></span></h2>
<p>This object is an abstraction of a TCP or UNIX socket.  <code>net.Socket</code>
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Node
and passed to the user through the <code>&apos;connection&apos;</code> event of a server.

</p>
<p>这个对象是一个TCP或UNIX套接字的抽象。  <code>net.Socket</code>
实例实现了一个双工流接口。 他们可以被用户使用在客户端(使用 <code>connect()</code>) 
或者它们可以由 Node创建，并通过 <code>&apos;connection&apos;</code>服务器事件传递给用户。

</p>
<h3>new net.Socket([options])<span><a href="all.html#all_new_net_socket_options_1" id="all_new_net_socket_options_1">#</a></span></h3>
<p>Construct a new socket object.

</p>
<p>构造一个新的套接字对象。

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ fd: null
  type: null
  allowHalfOpen: false
}</code></pre>
<p><code>fd</code> allows you to specify the existing file descriptor of socket. <code>type</code>
specified underlying protocol. It can be <code>&apos;tcp4&apos;</code>, <code>&apos;tcp6&apos;</code>, or <code>&apos;unix&apos;</code>.
About <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>&apos;end&apos;</code> event.

</p>
<p><code>fd</code> 允许你指定一个存在的文件描述符和套接字。
 <code>type</code> 指定一个优先的协议。 他可以是 <code>&apos;tcp4&apos;</code>, <code>&apos;tcp6&apos;</code>, 或 <code>&apos;unix&apos;</code>.
关于 <code>allowHalfOpen</code>, 参见 <code>createServer()</code> 和 <code>&apos;end&apos;</code> 事件。

</p>
<h3>socket.connect(port, [host], [connectListener])<span><a href="all.html#all_socket_connect_port_host_connectlistener_2" id="all_socket_connect_port_host_connectlistener_2">#</a></span></h3>
<h3>socket.connect(path, [connectListener])<span><a href="all.html#all_socket_connect_path_connectlistener_2" id="all_socket_connect_path_connectlistener_2">#</a></span></h3>
<h3>socket.connect(port, [host], [connectListener])<span><a href="all.html#all_socket_connect_port_host_connectlistener_3" id="all_socket_connect_port_host_connectlistener_3">#</a></span></h3>
<h3>socket.connect(path, [connectListener])<span><a href="all.html#all_socket_connect_path_connectlistener_3" id="all_socket_connect_path_connectlistener_3">#</a></span></h3>
<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,
then the socket will be opened as a TCP socket, if <code>host</code> is omitted,
<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be
opened as a unix socket to that path.

</p>
<p>使用传入的套接字打开一个连接 如果 <code>port</code> 和 <code>host</code> 都被传入，
那么套接字将会被已TCP套接字打开，如果 <code>host</code> 被省略,
默认为<code>localhost</code> . 如果 <code>path</code> 被传入,
套接字将会被已指定路径UNIX套接字打开。

</p>
<p>Normally this method is not needed, as <code>net.createConnection</code> opens the
socket. Use this only if you are implementing a custom Socket.

</p>
<p>一般情况下这个函数是不需要使用, 比如用 <code>net.createConnection</code> 打开套接字.
只有在您实现了自定义套接字时候才需要。

</p>
<p>This function is asynchronous. When the <a href="all.html#net_event_connect">&apos;connect&apos;</a> event is emitted the
socket is established. If there is a problem connecting, the <code>&apos;connect&apos;</code> event
will not be emitted, the <code>&apos;error&apos;</code> event will be emitted with the exception.

</p>
<p>这是一个异步函数。 当 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 触发了的套接字是established状态
.或者在连接的时候出现了一个问题, <code>&apos;connect&apos;</code> 事件不会被触发，
而 <code>&apos;error&apos;</code> 事件会触发并发送异常信息。

</p>
<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="all.html#net_event_connect">&apos;connect&apos;</a> event.

</p>
<p> <code>connectListener</code> 用于 <a href="all.html#net_event_connect">&apos;connect&apos;</a> 事件的监听器

</p>
<h3>socket.bufferSize<span><a href="all.html#all_socket_buffersize_1" id="all_socket_buffersize_1">#</a></span></h3>
<p><code>net.Socket</code> has the property that <code>socket.write()</code> always works. This is to
help users get up and running quickly. The computer cannot always keep up
with the amount of data that is written to a socket - the network connection
simply might be too slow. Node will internally queue up the data written to a
socket and send it out over the wire when it is possible. (Internally it is
polling on the socket&apos;s file descriptor for being writable).

</p>
<p>是一个<code>net.Socket</code> 的属性，用于 <code>socket.write()</code> . 
用于帮助用户获取更快的运行速度。 计算机不能一直处于大量数据被写入状态 ——
网络链接可能会变得过慢。 Node 在内部会排队等候数据被写入套接字并确保传输连接上的数据完好。
(内部实现为：轮询套接字的文件描述符等待它为可写).

</p>
<p>The consequence of this internal buffering is that memory may grow. This
property shows the number of characters currently buffered to be written.
(Number of characters is approximately equal to the number of bytes to be
written, but the buffer may contain strings, and the strings are lazily
encoded, so the exact number of bytes is not known.)

</p>
<p>内部缓冲的可能后果是内存使用会增加。这个属性表示了现在处于缓冲区等待被写入的字符数。（字符的数目约等于要被写入的字节数，但是缓冲区可能包含字符串，而字符串是惰性编码的，所以确切的字节数是未知的。）

</p>
<p>Users who experience large or growing <code>bufferSize</code> should attempt to
&quot;throttle&quot; the data flows in their program with <code>pause()</code> and <code>resume()</code>.

</p>
<p>遇到数值很大或者增长很快的<code>bufferSize</code>的时候，用户应该尝试用<code>pause()</code>和<code>resume()</code>来控制数据流。

</p>
<h3>socket.setEncoding([encoding])<span><a href="all.html#all_socket_setencoding_encoding_1" id="all_socket_setencoding_encoding_1">#</a></span></h3>
<p>Set the encoding for the socket as a Readable Stream. See
<a href="stream.html#stream_stream_setencoding_encoding">stream.setEncoding()</a> for more information.

</p>
<p>设置套接字的编码为一个可读流. 
更多信息请查看 <a href="stream.html#stream_stream_setencoding_encoding">stream.setEncoding()</a> 

</p>
<h3>socket.write(data, [encoding], [callback])<span><a href="all.html#all_socket_write_data_encoding_callback_1" id="all_socket_write_data_encoding_callback_1">#</a></span></h3>
<p>Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.

</p>
<p>在套接字上发送数据。第二参数指明了使用字符串时的编码方式-默认为UTF8编码。

</p>
<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<p>如果所有数据被成功刷新到内核缓冲区，则返回<code>true</code>。如果所有或部分数据在用户内存里还处于队列中，则返回<code>false</code>。当缓冲区再次被释放时，<code>&apos;drain&apos;</code>事件会被分发。
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<p>The optional <code>callback</code> parameter will be executed when the data is finally
written out - this may not be immediately.

</p>
<p>当数据最终被完整写入时，可选的<code>callback</code>参数会被执行 - 但不一定是马上执行。

</p>
<h3>socket.end([data], [encoding])<span><a href="all.html#all_socket_end_data_encoding_1" id="all_socket_end_data_encoding_1">#</a></span></h3>
<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the
server will still send some data.

</p>
<p>半关闭套接字 如., 它发送一个 FIN 包 .可能服务器仍在发送数据。

</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<code>socket.write(data, encoding)</code> followed by <code>socket.end()</code>.

</p>
<p>如果 <code>data</code>被传入, 等同于调用
<code>socket.write(data, encoding)</code> 然后调用 <code>socket.end()</code>.

</p>
<h3>socket.destroy()<span><a href="all.html#all_socket_destroy_1" id="all_socket_destroy_1">#</a></span></h3>
<p>Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).

</p>
<p>确保没有I/O活动在这个套接字。
只有在错误发生情况下才需要（处理错误等等）。

</p>
<h3>socket.pause()<span><a href="all.html#all_socket_pause_1" id="all_socket_pause_1">#</a></span></h3>
<p>Pauses the reading of data. That is, <code>&apos;data&apos;</code> events will not be emitted.
Useful to throttle back an upload.

</p>
<p>暂停读取数据。 <code>&apos;data&apos;</code> 事件不会被触发。
对于控制上传非常有用。

</p>
<h3>socket.resume()<span><a href="all.html#all_socket_resume_1" id="all_socket_resume_1">#</a></span></h3>
<p>Resumes reading after a call to <code>pause()</code>.

</p>
<p>在调用 <code>pause()</code>后恢复读操作。

</p>
<h3>socket.setTimeout(timeout, [callback])<span><a href="all.html#all_socket_settimeout_timeout_callback_1" id="all_socket_settimeout_timeout_callback_1">#</a></span></h3>
<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on
the socket. By default <code>net.Socket</code> do not have a timeout.

</p>
<p>如果套接字超过<code>timeout</code>毫秒处于闲置状态，则将套接字设为超时。默认情况下<code>net.Socket</code>不存在超时。

</p>
<p>When an idle timeout is triggered the socket will receive a <code>&apos;timeout&apos;</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the socket.

</p>
<p>当一个闲置超时被触发时，套接字会接收到一个<code>&apos;timeout&apos;</code>事件，但是连接将不会被断开。用户必须手动<code>end()</code>或<code>destroy()</code>这个套接字。

</p>
<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.

</p>
<p>如果<code>timeout</code>为0，那么现有的闲置超时会被禁用。

</p>
<p>The optional <code>callback</code> parameter will be added as a one time listener for the
<code>&apos;timeout&apos;</code> event.

</p>
<p>可选的<code>callback</code>参数将会被添加成为<code>&apos;timeout&apos;</code>事件的一次性监听器。

</p>
<h3>socket.setNoDelay([noDelay])<span><a href="all.html#all_socket_setnodelay_nodelay_1" id="all_socket_setnodelay_nodelay_1">#</a></span></h3>
<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>true</code> for
<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.
<code>noDelay</code> defaults to <code>true</code>.

</p>
<p>禁用纳格（Nagle）算法。默认情况下TCP连接使用纳格算法，这些连接在发送数据之前对数据进行缓冲处理。 将<code>noDelay</code>设成<code>true</code>会在每次<code>socket.write()</code>被调用时立刻发送数据。<code>noDelay</code>默认为<code>true</code>。

</p>
<h3>socket.setKeepAlive([enable], [initialDelay])<span><a href="all.html#all_socket_setkeepalive_enable_initialdelay_1" id="all_socket_setkeepalive_enable_initialdelay_1">#</a></span></h3>
<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
<code>enable</code> defaults to <code>false</code>.

</p>
<p>禁用/启用长连接功能，并在第一个在闲置套接字上的长连接probe被发送之前，可选地设定初始延时。<code>enable</code>默认为<code>false</code>。

</p>
<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting. Defaults to <code>0</code>.

</p>
<p>设定<code>initialDelay</code> (毫秒)，来设定在收到的最后一个数据包和第一个长连接probe之间的延时。将initialDelay设成0会让值保持不变(默认值或之前所设的值)。默认为<code>0</code>。

</p>
<h3>socket.address()<span><a href="all.html#all_socket_address_2" id="all_socket_address_2">#</a></span></h3>
<p>Returns the bound address, the address family name and port of the
socket as reported by the operating system. Returns an object with
three properties, e.g.
<code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<p>返回 socket 绑定的IP地址, 协议类型 (family name) 以及 端口号 (port). 具体是一个包含三个属性的对象, 形如 <code>{ port: 12346, family: &apos;IPv4&apos;, address: &apos;127.0.0.1&apos; }</code>

</p>
<h3>socket.unref()<span><a href="all.html#all_socket_unref_2" id="all_socket_unref_2">#</a></span></h3>
<p>Calling <code>unref</code> on a socket will allow the program to exit if this is the only
active socket in the event system. If the socket is already <code>unref</code>d calling
<code>unref</code> again will have no effect.

</p>
<p>如果这是事件系统中唯一一个活动的套接字，调用 <code>unref</code> 将允许程序退出。如果套接字已被 <code>unref</code>，则再次调用 <code>unref</code> 并不会产生影响。

</p>
<h3>socket.ref()<span><a href="all.html#all_socket_ref_2" id="all_socket_ref_2">#</a></span></h3>
<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d socket will <em>not</em>
let the program exit if it&apos;s the only socket left (the default behavior). If
the socket is <code>ref</code>d calling <code>ref</code> again will have no effect.

</p>
<p>与 <code>unref</code> 相反，如果这是仅剩的套接字，在一个之前被 <code>unref</code> 了的套接字上调用 <code>ref</code> 将<em>不会</em>让程序退出（缺省行为）。如果一个套接字已经被 <code>ref</code>，则再次调用 <code>ref</code> 并不会产生影响。

</p>
<h3>socket.remoteAddress<span><a href="all.html#all_socket_remoteaddress_1" id="all_socket_remoteaddress_1">#</a></span></h3>
<p>The string representation of the remote IP address. For example,
<code>&apos;74.125.127.100&apos;</code> or <code>&apos;2001:4860:a005::68&apos;</code>.

</p>
<p>远程IP地址的字符串表示。例如，<code>&apos;74.125.127.100&apos;</code>或 <code>&apos;2001:4860:a005::68&apos;</code>。

</p>
<h3>socket.remotePort<span><a href="all.html#all_socket_remoteport_1" id="all_socket_remoteport_1">#</a></span></h3>
<p>The numeric representation of the remote port. For example,
<code>80</code> or <code>21</code>.

</p>
<p>远程端口的数值表示。例如，<code>80</code> 或 <code>21</code>。

</p>
<h3>socket.localAddress<span><a href="all.html#all_socket_localaddress_1" id="all_socket_localaddress_1">#</a></span></h3>
<p>The string representation of the local IP address the remote client is
connecting on. For example, if you are listening on <code>&apos;0.0.0.0&apos;</code> and the
client connects on <code>&apos;192.168.1.1&apos;</code>, the value would be <code>&apos;192.168.1.1&apos;</code>.

</p>
<p>远程客户端正在连接的本地IP地址的字符串表示。例如，如果你在监听<code>&apos;0.0.0.0&apos;</code>而客户端连接在<code>&apos;192.168.1.1&apos;</code>，这个值就会是 <code>&apos;192.168.1.1&apos;</code>。

</p>
<h3>socket.localPort<span><a href="all.html#all_socket_localport_1" id="all_socket_localport_1">#</a></span></h3>
<p>The numeric representation of the local port. For example,
<code>80</code> or <code>21</code>.

</p>
<p>本地端口的数值表示。比如<code>80</code> 或 <code>21</code>。

</p>
<h3>socket.bytesRead<span><a href="all.html#all_socket_bytesread_1" id="all_socket_bytesread_1">#</a></span></h3>
<p>The amount of received bytes.

</p>
<p>所接收的字节数。

</p>
<h3>socket.bytesWritten<span><a href="all.html#all_socket_byteswritten_1" id="all_socket_byteswritten_1">#</a></span></h3>
<p>The amount of bytes sent.

</p>
<p>所发送的字节数。

</p>
<p><code>net.Socket</code> instances are <a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<p><code>net.Socket</code>实例是带有以下事件的<a href="events.html#events_class_events_eventemitter">EventEmitter</a>对象：

</p>
<h3>事件: &apos;lookup&apos;<span><a href="all.html#all_lookup_1" id="all_lookup_1">#</a></span></h3>
<p>Emitted after resolving the hostname but before connecting.
Not applicable to UNIX sockets.

</p>
<p>这个事件在解析主机名之后，连接主机之前被分发。对UNIX套接字不适用。

</p>
<ul>
<li><code>err</code> {Error | Null} The error object.  See [dns.lookup()][].</li>
<li><code>address</code> {String} The IP address.</li>
<li><p><code>family</code> {String | Null} The address type.  See [dns.lookup()][].</p>
</li>
<li><p><code>err</code> {Error | Null} 错误对象。见[dns.lookup()][]。</p>
</li>
<li><code>address</code> {String} IP地址。</li>
<li><code>family</code> {String | Null} 得知类型。见[dns.lookup()][]。</li>
</ul>
<h3>事件: &apos;connect&apos;<span><a href="all.html#all_connect_3" id="all_connect_3">#</a></span></h3>
<p>Emitted when a socket connection is successfully established.
See <code>connect()</code>.

</p>
<p>该事件在一个套接字连接成功建立后被分发。见<code>connect()</code>。

</p>
<h3>事件: &apos;data&apos;<span><a href="all.html#all_data_3" id="all_data_3">#</a></span></h3>
<div><ul>
<li><p><span>Buffer object</span></p>
</li>
<li><p><span>Buffer object</span></p>
</li>
</div></ul>
<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or
<code>String</code>.  Encoding of data is set by <code>socket.setEncoding()</code>.
(See the <a href="stream.html#stream_readable_stream">Readable Stream</a> section for more information.)

</p>
<p>当收到数据时被分发。<code>data</code>参数会是一个<code>Buffer</code>或<code>String</code>对象。数据的编码方式由<code>socket.setEncoding()</code>设定。
（详见 [可读流][] 章节）

</p>
<p>Note that the <strong>data will be lost</strong> if there is no listener when a <code>Socket</code>
emits a <code>&apos;data&apos;</code> event.

</p>
<p>请注意，如果一个<code>Socket</code>对象分发一个<code>&apos;data&apos;</code>事件时没有任何监听器存在，则 <strong>数据会丢失</strong>。

</p>
<h3>事件: &apos;end&apos;<span><a href="all.html#all_end_3" id="all_end_3">#</a></span></h3>
<p>Emitted when the other end of the socket sends a FIN packet.

</p>
<p>当套接字的另一端发送FIN包时，该事件被分发。

</p>
<p>By default (<code>allowHalfOpen == false</code>) the socket will destroy its file
descriptor  once it has written out its pending write queue.  However, by
setting <code>allowHalfOpen == true</code> the socket will not automatically <code>end()</code>
its side allowing the user to write arbitrary amounts of data, with the
caveat that the user is required to <code>end()</code> their side now.

</p>
<p>默认情况下 （<code>allowHalfOpen == false</code>），当套接字完成待写入队列中的任务时，它会destroy文件描述符。然而，如果把<code>allowHalfOpen</code>设成<code>true</code>，那么套接字将不会从它这边自动调用<code>end()</code>，使得用户可以随意写入数据，但同时使得用户自己需要调用<code>end()</code>。

</p>
<h3>事件: &apos;timeout&apos;<span><a href="all.html#all_timeout_1" id="all_timeout_1">#</a></span></h3>
<p>Emitted if the socket times out from inactivity. This is only to notify that
the socket has been idle. The user must manually close the connection.

</p>
<p>当套接字因为非活动状态而超时时该事件被分发。这只是用来表明套接字处于空闲状态。用户必须手动关闭这个连接。

</p>
<p>See also: <code>socket.setTimeout()</code>

</p>
<p>参阅：<code>socket.setTimeout()</code>

</p>
<h3>事件: &apos;drain&apos;<span><a href="all.html#all_drain_3" id="all_drain_3">#</a></span></h3>
<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.

</p>
<p>当写入缓冲被清空时产生。可被用于控制上传流量。

</p>
<p>See also: the return values of <code>socket.write()</code>

</p>
<p>参阅：<code>socket.write()</code> 的返回值

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_11" id="all_error_11">#</a></span></h3>
<div><ul>
<li><p><span>Error object</span></p>
</li>
<li><p><span>Error object</span></p>
</li>
</div></ul>
<p>Emitted when an error occurs.  The <code>&apos;close&apos;</code> event will be called directly
following this event.

</p>
<p>当一个错误发生时产生。<code>&apos;close&apos;</code> 事件会紧接着该事件被触发。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_11" id="all_close_11">#</a></span></h3>
<div><ul>
<li><p><code>had_error</code> <span>Boolean</span> true if the socket had a transmission error</p>
</li>
<li><p><code>had_error</code> <span>Boolean</span> 如果套接字发生了传输错误则此字段为true</p>
</li>
</div></ul>
<p>Emitted once the socket is fully closed. The argument <code>had_error</code> is a boolean
which says if the socket was closed due to a transmission error.

</p>
<p>当套接字完全关闭时该事件被分发。参数<code>had_error</code>是一个布尔值，表示了套接字是否因为一个传输错误而被关闭。

</p>
<h2>net.isIP(input)<span><a href="all.html#all_net_isip_input_1" id="all_net_isip_input_1">#</a></span></h2>
<p>Tests if input is an IP address. Returns 0 for invalid strings,
returns 4 for IP version 4 addresses, and returns 6 for IP version 6 addresses.

</p>
<p>测试 input 是否 IP 地址。无效字符串返回 0；IP 版本 4 地址返回 4；IP 版本 6 地址返回 6。

</p>
<h2>net.isIPv4(input)<span><a href="all.html#all_net_isipv4_input_1" id="all_net_isipv4_input_1">#</a></span></h2>
<p>Returns true if input is a version 4 IP address, otherwise returns false.

</p>
<p>如果 input 为版本 4 地址则返回 true，否则返回 false。

</p>
<h2>net.isIPv6(input)<span><a href="all.html#all_net_isipv6_input_1" id="all_net_isipv6_input_1">#</a></span></h2>
<p>Returns true if input is a version 6 IP address, otherwise returns false.

</p>
<p>如果 input 为版本 6 地址则返回 true，否则返回 false。

</p>
<h1>UDP / 数据报套接字<span><a href="all.html#all_udp_1" id="all_udp_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!-- name=dgram -->

<p>Datagram sockets are available through <code>require(&apos;dgram&apos;)</code>.

</p>
<p>数据报套接字通过 <code>require(&apos;dgram&apos;)</code> 提供。

</p>
<p>Important note: the behavior of <code>dgram.Socket#bind()</code> has changed in v0.10
and is always asynchronous now.  If you have code that looks like this:

</p>
<p>重要提醒：<code>dgram.Socket#bind()</code> 的行为在 v0.10 中已改变，并且现在它总是异步的。如果您的代码看起来像这样：

</p>
<pre><code>var s = dgram.createSocket(&apos;udp4&apos;);
s.bind(1234);
s.addMembership(&apos;224.0.0.114&apos;);</code></pre>
<p>You have to change it to this:

</p>
<p>您需要将它改成这样：

</p>
<pre><code>var s = dgram.createSocket(&apos;udp4&apos;);
s.bind(1234, function() {
  s.addMembership(&apos;224.0.0.114&apos;);
});</code></pre>
<h2>dgram.createSocket(type, [callback])<span><a href="all.html#all_dgram_createsocket_type_callback_1" id="all_dgram_createsocket_type_callback_1">#</a></span></h2>
<div><ul>
<li><code>type</code> String. Either &apos;udp4&apos; or &apos;udp6&apos;</li>
<li><code>callback</code> Function. Attached as a listener to <code>message</code> events.
Optional</li>
<li><p>Returns: Socket object</p>
</li>
<li><p><code>type</code> String 可以是 &apos;udp4&apos; 或 &apos;udp6&apos;</p>
</li>
<li><code>callback</code> Function 可选，会被作为 <code>message</code> 事件的监听器。</li>
<li>返回：Socket 对象</li>
</div></ul>
<p>Creates a datagram Socket of the specified types.  Valid types are <code>udp4</code>
and <code>udp6</code>.

</p>
<p>创建一个指定类型的数据报 Socket。有效类型包括 <code>udp4</code> 和 <code>udp6</code>。

</p>
<p>Takes an optional callback which is added as a listener for <code>message</code> events.

</p>
<p>接受一个可选的回调，会被添加为 <code>message</code> 事件的监听器。

</p>
<p>Call <code>socket.bind</code> if you want to receive datagrams. <code>socket.bind()</code> will bind
to the &quot;all interfaces&quot; address on a random port (it does the right thing for
both <code>udp4</code> and <code>udp6</code> sockets). You can then retrieve the address and port
with <code>socket.address().address</code> and <code>socket.address().port</code>.

</p>
<p>如果您想接收数据报则可调用 <code>socket.bind</code>。<code>socket.bind()</code> 会绑定到“所有网络接口”地址的一个随机端口（<code>udp4</code> 和 <code>udp6</code> 皆是如此）。然后您可以通过 <code>socket.address().address</code> 和 <code>socket.address().port</code> 来取得地址和端口。

</p>
<h2>类: dgram.Socket<span><a href="all.html#all_dgram_socket_1" id="all_dgram_socket_1">#</a></span></h2>
<p>The dgram Socket class encapsulates the datagram functionality.  It
should be created via <code>dgram.createSocket(type, [callback])</code>.

</p>
<p>dgram Socket 类封装了数据报功能，可以通过 <code>dgram.createSocket(type, [callback])</code> 创建。

</p>
<h3>事件: &apos;message&apos;<span><a href="all.html#all_message_3" id="all_message_3">#</a></span></h3>
<div><ul>
<li><code>msg</code> Buffer object. The message</li>
<li><p><code>rinfo</code> Object. Remote address information</p>
</li>
<li><p><code>msg</code> Buffer 对象，消息</p>
</li>
<li><code>rinfo</code> Object，远程地址信息</li>
</div></ul>
<p>Emitted when a new datagram is available on a socket.  <code>msg</code> is a <code>Buffer</code> and
<code>rinfo</code> is an object with the sender&apos;s address information:

</p>
<p>当套接字中有新的数据报时发生。<code>msg</code> 是一个 <code>Buffer</code>，<code>rinfo</code> 是一个包含了发送者地址信息的对象：

</p>
<pre><code>socket.on(&apos;message&apos;, function(msg, rinfo) {
  console.log(&apos;收到 %d 字节，来自 %s:%d\n&apos;,
              msg.length, rinfo.address, rinfo.port);
});</code></pre>
<h3>事件: &apos;listening&apos;<span><a href="all.html#all_listening_5" id="all_listening_5">#</a></span></h3>
<p>Emitted when a socket starts listening for datagrams.  This happens as soon as UDP sockets
are created.

</p>
<p>当一个套接字开始监听数据报时产生。它会在 UDP 套接字被创建时发生。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_12" id="all_close_12">#</a></span></h3>
<p>Emitted when a socket is closed with <code>close()</code>.  No new <code>message</code> events will be emitted
on this socket.

</p>
<p>当一个套接字被 <code>close()</code> 关闭时产生。之后这个套接字上不会再有 <code>message</code> 事件发生。

</p>
<h3>事件: &apos;error&apos;<span><a href="all.html#all_error_12" id="all_error_12">#</a></span></h3>
<div><ul>
<li><p><code>exception</code> Error object</p>
</li>
<li><p><code>exception</code> Error 对象</p>
</li>
</div></ul>
<p>Emitted when an error occurs.

</p>
<p>当发生错误时产生。

</p>
<h3>socket.send(buf, offset, length, port, address, [callback])<span><a href="all.html#all_socket_send_buf_offset_length_port_address_callback_1" id="all_socket_send_buf_offset_length_port_address_callback_1">#</a></span></h3>
<div><ul>
<li><code>buf</code> Buffer object.  Message to be sent</li>
<li><code>offset</code> Integer. Offset in the buffer where the message starts.</li>
<li><code>length</code> Integer. Number of bytes in the message.</li>
<li><code>port</code> Integer. destination port</li>
<li><code>address</code> String. destination IP</li>
<li><p><code>callback</code> Function. Callback when message is done being delivered.
Optional.</p>
</li>
<li><p><code>buf</code> Buffer 对象，要发送的消息</p>
</li>
<li><code>offset</code> Integer，Buffer 中消息起始偏移值。</li>
<li><code>length</code> Integer，消息的字节数。</li>
<li><code>port</code> Integer，目标端口</li>
<li><code>address</code> String，目标 IP</li>
<li><code>callback</code> Function，可选，当消息被投递后的回调。</li>
</div></ul>
<p>For UDP sockets, the destination port and IP address must be specified.  A string
may be supplied for the <code>address</code> parameter, and it will be resolved with DNS.  An
optional callback may be specified to detect any DNS errors and when <code>buf</code> may be
re-used.  Note that DNS lookups will delay the time that a send takes place, at
least until the next tick.  The only way to know for sure that a send has taken place
is to use the callback.

</p>
<p>对于 UDP 套接字，必须指定目标端口和 IP 地址。<code>address</code> 参数可以是一个字符串，它会被 DNS 解析。可选地可以指定一个回调以用于发现任何 DNS 错误或当 <code>buf</code> 可被重用。请注意 DNS 查询会将发送的时间推迟到至少下一个事件循环。确认发送完毕的唯一已知方法是使用回调。

</p>
<p>If the socket has not been previously bound with a call to <code>bind</code>, it&apos;s
assigned a random port number and bound to the &quot;all interfaces&quot; address
(0.0.0.0 for <code>udp4</code> sockets, ::0 for <code>udp6</code> sockets).

</p>
<p>如果套接字之前并未被调用 <code>bind</code> 绑定，则它会被分配一个随机端口并绑定到“所有网络接口”地址（<code>udp4</code> 套接字是 0.0.0.0；<code>udp6</code> 套接字是 ::0）。

</p>
<p>Example of sending a UDP packet to a random port on <code>localhost</code>;

</p>
<p>向 <code>localhost</code> 随机端口发送 UDP 报文的例子：

</p>
<pre><code>var dgram = require(&apos;dgram&apos;);
var message = new Buffer(&quot;Some bytes&quot;);
var client = dgram.createSocket(&quot;udp4&quot;);
client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err) {
  client.close();
});</code></pre>
<p><strong>A Note about UDP datagram size</strong>

</p>
<p><strong>关于 UDP 数据报大小的注意事项</strong>

</p>
<p>The maximum size of an <code>IPv4/v6</code> datagram depends on the <code>MTU</code> (<em>Maximum Transmission Unit</em>)
and on the <code>Payload Length</code> field size.

</p>
<p>一个 <code>IPv4/v6</code> 数据报的最大大小取决与 <code>MTU</code>（<em>最大传输单位</em>）和 <code>Payload Length</code> 字段大小。

</p>
<ul>
<li><p>The <code>Payload Length</code> field is <code>16 bits</code> wide, which means that a normal payload
cannot be larger than 64K octets including internet header and data
(65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header);
this is generally true for loopback interfaces, but such long datagrams
are impractical for most hosts and networks.</p>
</li>
<li><p><code>Payload Length</code> 字段宽 <code>16 bits</code>，意味着正常负载包括网络头和数据不能大于 64K（65,507 字节 = 65,535 − 8 字节 UDP 头 − 20 字节 IP 头）；这对环回接口通常是真的，但如此大的数据报对大多数主机和网络来说是不切实际的。</p>
</li>
<li><p>The <code>MTU</code> is the largest size a given link layer technology can support for datagrams.
For any link, <code>IPv4</code> mandates a minimum <code>MTU</code> of <code>68</code> octets, while the recommended <code>MTU</code>
for IPv4 is <code>576</code> (typically recommended as the <code>MTU</code> for dial-up type applications),
whether they arrive whole or in fragments.</p>
</li>
<li><p><code>MTU</code> 是一个给定的数据链路层技术能为数据报提供支持的最大大小。对于任何连接，<code>IPv4</code> 允许最小 <code>68</code> 字节的 <code>MTU</code>，而 IPv4 所推荐的 <code>MTU</code> 为 <code>576</code>（通常作为拨号类应用的推荐 <code>MTU</code>），无论它们是完整接收还是分片。</p>
<p>For <code>IPv6</code>, the minimum <code>MTU</code> is <code>1280</code> octets, however, the mandatory minimum
fragment reassembly buffer size is <code>1500</code> octets.
The value of <code>68</code> octets is very small, since most current link layer technologies have
a minimum <code>MTU</code> of <code>1500</code> (like Ethernet).</p>
<p>对于 <code>IPv6</code>，最小的 <code>MTU</code> 为 <code>1280</code> 字节，但所允许的最小碎片重组缓冲大小为 <code>1500</code> 字节。
<code>68</code> 的值是非常小的，因为现在大多数数据链路层技术有都具有 <code>1500</code> 的最小 <code>MTU</code>（比如以太网）。</p>
</li>
</ul>
<p>Note that it&apos;s impossible to know in advance the MTU of each link through which
a packet might travel, and that generally sending a datagram greater than
the (receiver) <code>MTU</code> won&apos;t work (the packet gets silently dropped, without
informing the source that the data did not reach its intended recipient).

</p>
<p>请注意我们不可能提前得知一个报文可能经过的每一个连接 MTU，因此通常情况下不能发送一个大于（接收者的）<code>MTU</code> 的数据报（报文会被悄悄地丢掉，而不会将数据没有到达它意图的接收者的消息告知来源）。

</p>
<h3>socket.bind(port, [address], [callback])<span><a href="all.html#all_socket_bind_port_address_callback_1" id="all_socket_bind_port_address_callback_1">#</a></span></h3>
<div><ul>
<li><code>port</code> Integer</li>
<li><code>address</code> String, Optional</li>
<li><p><code>callback</code> Function with no parameters, Optional. Callback when
binding is done.</p>
</li>
<li><p><code>port</code> Integer</p>
</li>
<li><code>address</code> String，可选</li>
<li><code>callback</code> 没有参数的 Function，可选，当绑定完成时被调用。</li>
</div></ul>
<p>For UDP sockets, listen for datagrams on a named <code>port</code> and optional
<code>address</code>. If <code>address</code> is not specified, the OS will try to listen on
all addresses.  After binding is done, a &quot;listening&quot; event is emitted
and the <code>callback</code>(if specified) is called. Specifying both a
&quot;listening&quot; event listener and <code>callback</code> is not harmful but not very
useful.

</p>
<p>对于 UDP 套接字，在一个具名端口 <code>port</code> 和可选的地址 <code>address</code> 上监听数据报。如果 <code>address</code> 未指定，则操作系统会尝试监听所有地址。当绑定完成后，一个 &quot;listening&quot; 事件会发生，并且回调 <code>callback</code>（如果指定）会被调用。同时指定 &quot;listening&quot; 事件监听器和 <code>callback</code> 并不会产生副作用，但也没什么用。

</p>
<p>A bound datagram socket keeps the node process running to receive
datagrams.

</p>
<p>一个绑定了的数据报套接字会保持 node 进程运行来接收数据报。

</p>
<p>If binding fails, an &quot;error&quot; event is generated. In rare case (e.g.
binding a closed socket), an <code>Error</code> may be thrown by this method.

</p>
<p>如果绑定失败，则一个 &quot;error&quot; 事件会被产生。在极少情况下（比如绑定一个已关闭的套接字），该方法会抛出一个 <code>Error</code>。

</p>
<p>Example of a UDP server listening on port 41234:

</p>
<p>一个监听端口 41234 的 UDP 服务器的例子：

</p>
<pre><code>server.bind(41234);
// 服务器正在监听 0.0.0.0:41234</code></pre>
<h3>socket.close()<span><a href="all.html#all_socket_close_1" id="all_socket_close_1">#</a></span></h3>
<p>Close the underlying socket and stop listening for data on it.

</p>
<p>关闭底层套接字并停止监听数据。

</p>
<h3>socket.address()<span><a href="all.html#all_socket_address_3" id="all_socket_address_3">#</a></span></h3>
<p>Returns an object containing the address information for a socket.  For UDP sockets,
this object will contain <code>address</code> , <code>family</code> and <code>port</code>.

</p>
<p>返回一个包含了套接字地址信息的对象。对于 UDP 套接字，该对象会包含地址 <code>address</code>、地址族 <code>family</code> 和端口号 <code>port</code>。

</p>
<h3>socket.setBroadcast(flag)<span><a href="all.html#all_socket_setbroadcast_flag_1" id="all_socket_setbroadcast_flag_1">#</a></span></h3>
<div><ul>
<li><p><code>flag</code> Boolean</p>
</li>
<li><p><code>flag</code> Boolean</p>
</li>
</div></ul>
<p>Sets or clears the <code>SO_BROADCAST</code> socket option.  When this option is set, UDP packets
may be sent to a local interface&apos;s broadcast address.

</p>
<p>设置或清除 <code>SO_BROADCAST</code> 套接字选项。当该选项被设置，则 UDP 报文可能被发送到一个本地接口的广播地址。

</p>
<h3>socket.setTTL(ttl)<span><a href="all.html#all_socket_setttl_ttl_1" id="all_socket_setttl_ttl_1">#</a></span></h3>
<div><ul>
<li><p><code>ttl</code> Integer</p>
</li>
<li><p><code>ttl</code> Integer</p>
</li>
</div></ul>
<p>Sets the <code>IP_TTL</code> socket option.  TTL stands for &quot;Time to Live,&quot; but in this context it
specifies the number of IP hops that a packet is allowed to go through.  Each router or
gateway that forwards a packet decrements the TTL.  If the TTL is decremented to 0 by a
router, it will not be forwarded.  Changing TTL values is typically done for network
probes or when multicasting.

</p>
<p>设置 <code>IP_TTL</code> 套接字选项。TTL 表示“Time to Live”（生存时间），但在此上下文中它指的是报文允许通过的 IP 跃点数。各个转发报文的路由器或网关都会递减 TTL。如果 TTL 被一个路由器递减到 0，则它将不会被转发。改变 TTL 值通常被用于网络探测器或多播。

</p>
<p>The argument to <code>setTTL()</code> is a number of hops between 1 and 255.  The default on most
systems is 64.

</p>
<p><code>setTTL()</code> 的参数为介于 1 至 255 的跃点数。在大多数系统上缺省值为 64。

</p>
<h3>socket.setMulticastTTL(ttl)<span><a href="all.html#all_socket_setmulticastttl_ttl_1" id="all_socket_setmulticastttl_ttl_1">#</a></span></h3>
<div><ul>
<li><p><code>ttl</code> Integer</p>
</li>
<li><p><code>ttl</code> Integer</p>
</li>
</div></ul>
<p>Sets the <code>IP_MULTICAST_TTL</code> socket option.  TTL stands for &quot;Time to Live,&quot; but in this
context it specifies the number of IP hops that a packet is allowed to go through,
specifically for multicast traffic.  Each router or gateway that forwards a packet
decrements the TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.

</p>
<p>设置 <code>IP_MULTICAST_TTL</code> 套接字选项。TTL 表示“Time to Live”（生存时间），但在此上下文中它指的是报文允许通过的 IP 跃点数，特别是组播流量。各个转发报文的路由器或网关都会递减 TTL。如果 TTL 被一个路由器递减到 0，则它将不会被转发。

</p>
<p>The argument to <code>setMulticastTTL()</code> is a number of hops between 0 and 255.  The default on most
systems is 1.

</p>
<p><code>setMulticastTTL()</code> 的参数为介于 1 至 255 的跃点数。在大多数系统上缺省值为 1。

</p>
<h3>socket.setMulticastLoopback(flag)<span><a href="all.html#all_socket_setmulticastloopback_flag_1" id="all_socket_setmulticastloopback_flag_1">#</a></span></h3>
<div><ul>
<li><p><code>flag</code> Boolean</p>
</li>
<li><p><code>flag</code> Boolean</p>
</li>
</div></ul>
<p>Sets or clears the <code>IP_MULTICAST_LOOP</code> socket option.  When this option is set, multicast
packets will also be received on the local interface.

</p>
<p>设置或清除 <code>IP_MULTICAST_LOOP</code> 套接字选项。当该选项被设置时，组播报文也会被本地接口收到。

</p>
<h3>socket.addMembership(multicastAddress, [multicastInterface])<span><a href="all.html#all_socket_addmembership_multicastaddress_multicastinterface_1" id="all_socket_addmembership_multicastaddress_multicastinterface_1">#</a></span></h3>
<div><ul>
<li><code>multicastAddress</code> String</li>
<li><p><code>multicastInterface</code> String, Optional</p>
</li>
<li><p><code>multicastAddress</code> String</p>
</li>
<li><code>multicastInterface</code> String，可选</li>
</div></ul>
<p>Tells the kernel to join a multicast group with <code>IP_ADD_MEMBERSHIP</code> socket option.

</p>
<p>以 <code>IP_ADD_MEMBERSHIP</code> 套接字选项告诉内核加入一个组播分组。

</p>
<p>If <code>multicastInterface</code> is not specified, the OS will try to add membership to all valid
interfaces.

</p>
<p>如果未指定 <code>multicastInterface</code>，则操作系统会尝试向所有有效接口添加关系。

</p>
<h3>socket.dropMembership(multicastAddress, [multicastInterface])<span><a href="all.html#all_socket_dropmembership_multicastaddress_multicastinterface_1" id="all_socket_dropmembership_multicastaddress_multicastinterface_1">#</a></span></h3>
<div><ul>
<li><code>multicastAddress</code> String</li>
<li><p><code>multicastInterface</code> String, Optional</p>
</li>
<li><p><code>multicastAddress</code> String</p>
</li>
<li><code>multicastInterface</code> String，可选</li>
</div></ul>
<p>Opposite of <code>addMembership</code> - tells the kernel to leave a multicast group with
<code>IP_DROP_MEMBERSHIP</code> socket option. This is automatically called by the kernel
when the socket is closed or process terminates, so most apps will never need to call
this.

</p>
<p>与 <code>addMembership</code> 相反，以 <code>IP_DROP_MEMBERSHIP</code> 套接字选项告诉内核退出一个组播分组。当套接字被关闭或进程结束时内核会自动调用，因此大多数应用都没必要调用它。

</p>
<p>If <code>multicastInterface</code> is not specified, the OS will try to drop membership to all valid
interfaces.

</p>
<p>如果未指定 <code>multicastInterface</code>，则操作系统会尝试向所有有效接口移除关系。

</p>
<h3>socket.unref()<span><a href="all.html#all_socket_unref_3" id="all_socket_unref_3">#</a></span></h3>
<p>Calling <code>unref</code> on a socket will allow the program to exit if this is the only
active socket in the event system. If the socket is already <code>unref</code>d calling
<code>unref</code> again will have no effect.

</p>
<p>如果这是事件系统中唯一一个活动的套接字，调用 <code>unref</code> 将允许程序退出。如果套接字已被 <code>unref</code>，则再次调用 <code>unref</code> 并不会产生影响。

</p>
<h3>socket.ref()<span><a href="all.html#all_socket_ref_3" id="all_socket_ref_3">#</a></span></h3>
<p>Opposite of <code>unref</code>, calling <code>ref</code> on a previously <code>unref</code>d socket will <em>not</em>
let the program exit if it&apos;s the only socket left (the default behavior). If
the socket is <code>ref</code>d calling <code>ref</code> again will have no effect.


</p>
<p>与 <code>unref</code> 相反，如果这是仅剩的套接字，在一个之前被 <code>unref</code> 了的套接字上调用 <code>ref</code> 将<em>不会</em>让程序退出（缺省行为）。如果一个套接字已经被 <code>ref</code>，则再次调用 <code>ref</code> 并不会产生影响。
</p>
<h1>DNS<span><a href="all.html#all_dns_1" id="all_dns_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Use <code>require(&apos;dns&apos;)</code> to access this module. All methods in the dns module
use C-Ares except for <code>dns.lookup</code> which uses <code>getaddrinfo(3)</code> in a thread
pool. C-Ares is much faster than <code>getaddrinfo</code> but the system resolver is
more constant with how other programs operate. When a user does
<code>net.connect(80, &apos;google.com&apos;)</code> or <code>http.get({ host: &apos;google.com&apos; })</code> the
<code>dns.lookup</code> method is used. Users who need to do a large number of lookups
quickly should use the methods that go through C-Ares.

</p>
<p>使用 <code>require(&apos;dns&apos;)</code> 引入此模块。dns 模块中的所有方法都使用了 C-Ares，除了 <code>dns.lookup</code> 使用了线程池中的 <code>getaddrinfo(3)</code>。C-Ares 比 <code>getaddrinfo</code> 要快得多，但系统解析器相对于其它程序的操作要更固定。当一个用户使用 <code>net.connect(80, &apos;google.com&apos;)</code> 或 <code>http.get({ host: &apos;google.com&apos; })</code> 时会使用 <code>dns.lookup</code> 方法。如果用户需要进行大量的快速查询，则最好使用 C-Ares 提供的方法。

</p>
<p>Here is an example which resolves <code>&apos;www.google.com&apos;</code> then reverse
resolves the IP addresses which are returned.

</p>
<p>下面是一个解析 <code>&apos;www.google.com&apos;</code> 并反向解析所返回 IP 地址的例子。

</p>
<pre><code>      console.log(&apos;反向解析 &apos; + a + &apos;: &apos; + JSON.stringify(domains));
    });
  });
});</code></pre>
<h2>dns.lookup(domain, [family], callback)<span><a href="all.html#all_dns_lookup_domain_family_callback_1" id="all_dns_lookup_domain_family_callback_1">#</a></span></h2>
<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into the first found A (IPv4) or
AAAA (IPv6) record.
The <code>family</code> can be the integer <code>4</code> or <code>6</code>. Defaults to <code>null</code> that indicates
both Ip v4 and v6 address family.

</p>
<p>将一个域名（比如 <code>&apos;google.com&apos;</code>）解析为第一个找到的 A 记录（IPv4）或 AAAA 记录（IPv6）。地址族 <code>family</code> 可以是数字 <code>4</code> 或 <code>6</code>，缺省为 <code>null</code> 表示同时允许 IPv4 和 IPv6 地址族。

</p>
<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument
is a string representation of a IP v4 or v6 address. The <code>family</code> argument
is either the integer 4 or 6 and denotes the family of <code>address</code> (not
necessarily the value initially passed to <code>lookup</code>).

</p>
<p>回调参数为 <code>(err, address, family)</code>。地址 <code>address</code> 参数为一个代表 IPv4 或 IPv6 地址的字符串。地址族 <code>family</code> 参数为数字 4 或 6，地表 <code>address</code> 的地址族（不一定是之前传入 <code>lookup</code> 的值）。

</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is the error code.
Keep in mind that <code>err.code</code> will be set to <code>&apos;ENOENT&apos;</code> not only when
the domain does not exist but also when the lookup fails in other ways
such as no available file descriptors.

</p>
<p>当错误发生时，<code>err</code> 为一个 <code>Error</code> 对象，其中 <code>err.code</code> 为错误代码。请记住 <code>err.code</code> 被设定为 <code>&apos;ENOENT&apos;</code> 的情况不仅是域名不存在，也可能是查询在其它途径出错，比如没有可用文件描述符时。

</p>
<h2>dns.resolve(domain, [rrtype], callback)<span><a href="all.html#all_dns_resolve_domain_rrtype_callback_1" id="all_dns_resolve_domain_rrtype_callback_1">#</a></span></h2>
<p>Resolves a domain (e.g. <code>&apos;google.com&apos;</code>) into an array of the record types
specified by rrtype. Valid rrtypes are <code>&apos;A&apos;</code> (IPV4 addresses, default),
<code>&apos;AAAA&apos;</code> (IPV6 addresses), <code>&apos;MX&apos;</code> (mail exchange records), <code>&apos;TXT&apos;</code> (text
records), <code>&apos;SRV&apos;</code> (SRV records), <code>&apos;PTR&apos;</code> (used for reverse IP lookups),
<code>&apos;NS&apos;</code> (name server records) and <code>&apos;CNAME&apos;</code> (canonical name records).

</p>
<p>将一个域名（比如 <code>&apos;google.com&apos;</code>）解析为一个 <code>rrtype</code> 指定记录类型的数组。有效 <code>rrtypes</code> 取值有 <code>&apos;A&apos;</code>（IPv4 地址，缺省）、<code>&apos;AAAA&apos;</code>（IPv6 地址）、<code>&apos;MX&apos;</code>（邮件交换记录）、<code>&apos;TXT&apos;</code>（文本记录）、<code>&apos;SRV&apos;</code>（SRV 记录）、<code>&apos;PTR&apos;</code>（用于 IP 反向查找）、<code>&apos;NS&apos;</code>（域名服务器记录）和 <code>&apos;CNAME&apos;</code>（别名记录）。

</p>
<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item
in <code>addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.

</p>
<p>回调参数为 <code>(err, addresses)</code>。其中 <code>addresses</code> 中每一项的类型取决于记录类型，详见下文对应的查找方法。

</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is
one of the error codes listed below.

</p>
<p>当出错时，<code>err</code> 参数为一个 <code>Error</code> 对象，其中 <code>err.code</code> 为下文所列出的错误代码之一。

</p>
<h2>dns.resolve4(domain, callback)<span><a href="all.html#all_dns_resolve4_domain_callback_1" id="all_dns_resolve4_domain_callback_1">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).
<code>addresses</code> is an array of IPv4 addresses (e.g.
<code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>).

</p>
<p>于 <code>dns.resolve()</code> 一样，但只用于查询 IPv4（<code>A</code> 记录）。<code>addresses</code> 是一个 IPv4 地址的数组（比如 <code>[&apos;74.125.79.104&apos;, &apos;74.125.79.105&apos;, &apos;74.125.79.106&apos;]</code>）。

</p>
<h2>dns.resolve6(domain, callback)<span><a href="all.html#all_dns_resolve6_domain_callback_1" id="all_dns_resolve6_domain_callback_1">#</a></span></h2>
<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).

</p>
<p>类似于 <code>dns.resolve4()</code>，但用于 IPv6（<code>AAAA</code>）查询。

</p>
<h2>dns.resolveMx(domain, callback)<span><a href="all.html#all_dns_resolvemx_domain_callback_1" id="all_dns_resolvemx_domain_callback_1">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).

</p>
<p>类似于 <code>dns.resolve()</code>，但用于邮件交换查询（<code>MX</code> 记录）。

</p>
<p><code>addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>).

</p>
<p><code>addresses</code> 为一个 MX 记录的数组，每一项包含优先级和交换属性（比如 <code>[{&apos;priority&apos;: 10, &apos;exchange&apos;: &apos;mx.example.com&apos;},...]</code>）。

</p>
<h2>dns.resolveTxt(domain, callback)<span><a href="all.html#all_dns_resolvetxt_domain_callback_1" id="all_dns_resolvetxt_domain_callback_1">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).
<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,
<code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>).

</p>
<p>与 <code>dns.resolve()</code> 相似，但用于文本查询（<code>TXT</code> 记录）。<code>addresses</code> 为 <code>domain</code> 可用文本记录的数组（比如 <code>[&apos;v=spf1 ip4:0.0.0.0 ~all&apos;]</code>）。

</p>
<h2>dns.resolveSrv(domain, callback)<span><a href="all.html#all_dns_resolvesrv_domain_callback_1" id="all_dns_resolvesrv_domain_callback_1">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).
<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties
of SRV records are priority, weight, port, and name (e.g.,
<code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>).

</p>
<p>查询 SRV 记录，与 <code>dns.resolve()</code> 相似。
<code>addresses</code> 是域名 <code>domain</code> 可用的 SRV 记录数组，
每一条记录都包含优先级（priority）、权重（weight）、端口号（port）、服务名称（name）等属性
(比如：  <code>[{&apos;priority&apos;: 10, {&apos;weight&apos;: 5, &apos;port&apos;: 21223, &apos;name&apos;: &apos;service.example.com&apos;}, ...]</code>)。

</p>
<h2>dns.resolveNs(domain, callback)<span><a href="all.html#all_dns_resolvens_domain_callback_1" id="all_dns_resolvens_domain_callback_1">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for name server records (<code>NS</code> records).
<code>addresses</code> is an array of the name server records available for <code>domain</code>
(e.g., <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>).

</p>
<p>查询 NS 记录，与 <code>dns.resolve()</code> 相似。
<code>addresses</code> 是域名 <code>domain</code> 可用的 NS 记录数组，
(比如： <code>[&apos;ns1.example.com&apos;, &apos;ns2.example.com&apos;]</code>).

</p>
<h2>dns.resolveCname(domain, callback)<span><a href="all.html#all_dns_resolvecname_domain_callback_1" id="all_dns_resolvecname_domain_callback_1">#</a></span></h2>
<p>The same as <code>dns.resolve()</code>, but only for canonical name records (<code>CNAME</code>
records). <code>addresses</code> is an array of the canonical name records available for
<code>domain</code> (e.g., <code>[&apos;bar.example.com&apos;]</code>).

</p>
<p>查询 CNAME 记录，与 <code>dns.resolve()</code> 相似。
<code>addresses</code> 是域名 <code>domain</code> 可用的 CNAME 记录数组，
(比如： <code>[&apos;bar.example.com&apos;]</code>).

</p>
<h2>dns.reverse(ip, callback)<span><a href="all.html#all_dns_reverse_ip_callback_1" id="all_dns_reverse_ip_callback_1">#</a></span></h2>
<p>Reverse resolves an ip address to an array of domain names.

</p>
<p>反向解析 IP 地址，返回指向该 IP 地址的域名数组。

</p>
<p>The callback has arguments <code>(err, domains)</code>.

</p>
<p>回调函数接收两个参数： <code>(err, domains)</code>.

</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is
one of the error codes listed below.

</p>
<p>当出错时，<code>err</code> 参数为一个 <code>Error</code> 对象，其中 <code>err.code</code> 为下文所列出的错误代码之一。

</p>
<h2>dns.getServers()<span><a href="all.html#all_dns_getservers_1" id="all_dns_getservers_1">#</a></span></h2>
<p>Returns an array of IP addresses as strings that are currently being used for
resolution

</p>
<p>已字符串返回一个当前用于解析的 IP 地址的数组。

</p>
<h2>dns.setServers(servers)<span><a href="all.html#all_dns_setservers_servers_1" id="all_dns_setservers_servers_1">#</a></span></h2>
<p>Given an array of IP addresses as strings, set them as the servers to use for
resolving

</p>
<p>指定一个 IP 地址字符串数组，将它们作为解析所用的服务器。

</p>
<p>If you specify a port with the address it will be stripped, as the underlying
library doesn&apos;t support that.

</p>
<p>如果您在地址中指定了端口，则端口会被忽略，因为底层库并不支持。

</p>
<p>This will throw if you pass invalid input.

</p>
<p>如果您传入无效参数，则会抛出异常。

</p>
<h2>错误代码<span><a href="all.html#all_78" id="all_78">#</a></span></h2>
<p>Each DNS query can return one of the following error codes:

</p>
<p>每个 DNS 查询都可能返回下列错误代码之一：

</p>
<ul>
<li><code>dns.NODATA</code>: DNS server returned answer with no data.</li>
<li><code>dns.FORMERR</code>: DNS server claims query was misformatted.</li>
<li><code>dns.SERVFAIL</code>: DNS server returned general failure.</li>
<li><code>dns.NOTFOUND</code>: Domain name not found.</li>
<li><code>dns.NOTIMP</code>: DNS server does not implement requested operation.</li>
<li><code>dns.REFUSED</code>: DNS server refused query.</li>
<li><code>dns.BADQUERY</code>: Misformatted DNS query.</li>
<li><code>dns.BADNAME</code>: Misformatted domain name.</li>
<li><code>dns.BADFAMILY</code>: Unsupported address family.</li>
<li><code>dns.BADRESP</code>: Misformatted DNS reply.</li>
<li><code>dns.CONNREFUSED</code>: Could not contact DNS servers.</li>
<li><code>dns.TIMEOUT</code>: Timeout while contacting DNS servers.</li>
<li><code>dns.EOF</code>: End of file.</li>
<li><code>dns.FILE</code>: Error reading file.</li>
<li><code>dns.NOMEM</code>: Out of memory.</li>
<li><code>dns.DESTRUCTION</code>: Channel is being destroyed.</li>
<li><code>dns.BADSTR</code>: Misformatted string.</li>
<li><code>dns.BADFLAGS</code>: Illegal flags specified.</li>
<li><code>dns.NONAME</code>: Given hostname is not numeric.</li>
<li><code>dns.BADHINTS</code>: Illegal hints flags specified.</li>
<li><code>dns.NOTINITIALIZED</code>: c-ares library initialization not yet performed.</li>
<li><code>dns.LOADIPHLPAPI</code>: Error loading iphlpapi.dll.</li>
<li><code>dns.ADDRGETNETWORKPARAMS</code>: Could not find GetNetworkParams function.</li>
<li><p><code>dns.CANCELLED</code>: DNS query cancelled.</p>
</li>
<li><p><code>dns.NODATA</code>: DNS 服务器返回无数据应答。</p>
</li>
<li><code>dns.FORMERR</code>: DNS 声称查询格式错误。</li>
<li><code>dns.SERVFAIL</code>: DNS 服务器返回一般失败。</li>
<li><code>dns.NOTFOUND</code>: 域名未找到。</li>
<li><code>dns.NOTIMP</code>: DNS 服务器未实现所请求操作。</li>
<li><code>dns.REFUSED</code>: DNS 服务器拒绝查询。</li>
<li><code>dns.BADQUERY</code>: DNS 查询格式错误。</li>
<li><code>dns.BADNAME</code>: 域名格式错误。</li>
<li><code>dns.BADFAMILY</code>: 不支持的地址类型。</li>
<li><code>dns.BADRESP</code>: DNS 答复格式错误。</li>
<li><code>dns.CONNREFUSED</code>: 无法联系 DNS 服务器。</li>
<li><code>dns.TIMEOUT</code>: 联系 DNS 服务器超时。</li>
<li><code>dns.EOF</code>: 文件末端。</li>
<li><code>dns.FILE</code>: 读取文件错误。</li>
<li><code>dns.NOMEM</code>: 超出内存。</li>
<li><code>dns.DESTRUCTION</code>: 通道正在被销毁。</li>
<li><code>dns.BADSTR</code>: 字符串格式错误。</li>
<li><code>dns.BADFLAGS</code>: 指定了非法标记。</li>
<li><code>dns.NONAME</code>: 所给主机名非数字。</li>
<li><code>dns.BADHINTS</code>: 指定了非法提示标记。</li>
<li><code>dns.NOTINITIALIZED</code>: c-ares 库初始化尚未进行。</li>
<li><code>dns.LOADIPHLPAPI</code>: 加载 iphlpapi.dll 出错。</li>
<li><code>dns.ADDRGETNETWORKPARAMS</code>: 无法找到 GetNetworkParams 函数。</li>
<li><p><code>dns.CANCELLED</code>: DNS 查询取消。</p>
<h1>HTTP<span><a href="all.html#all_http_1" id="all_http_1">#</a></span></h1>
<p>  稳定度: 3 - 稳定</p>
</li>
</ul>
<p>To use the HTTP server and client one must <code>require(&apos;http&apos;)</code>.

</p>
<p>要使用HTTP服务或客户端功能，需引用此模块<code>require(&apos;http&apos;)</code>.

</p>
<p>The HTTP interfaces in Node are designed to support many features
of the protocol which have been traditionally difficult to use.
In particular, large, possibly chunk-encoded, messages. The interface is
careful to never buffer entire requests or responses--the
user is able to stream data.

</p>
<p>Node中的HTTP接口的设计支持许多这个协议中原本用起来很困难的特性.特别是对于很大的或者块编码的消息.这些接口很谨慎,它从来不会完全缓存整个请求(request)或响应(response),这样用户可以在请求(request)或响应(response)中使用数据流.

</p>
<p>HTTP message headers are represented by an object like this:

</p>
<p>HTTP 的消息头(Headers)通过如下对象来表示:

</p>
<pre><code>{ &apos;content-length&apos;: &apos;123&apos;,
  &apos;content-type&apos;: &apos;text/plain&apos;,
  &apos;connection&apos;: &apos;keep-alive&apos;,
  &apos;host&apos;: &apos;mysite.com&apos;,
  &apos;accept&apos;: &apos;*/*&apos; }</code></pre>
<p>Keys are lowercased. Values are not modified.

</p>
<p>其中键为小写字母，值是不能修改的。

</p>
<p>In order to support the full spectrum of possible HTTP applications, Node&apos;s
HTTP API is very low-level. It deals with stream handling and message
parsing only. It parses a message into headers and body but it does not
parse the actual headers or the body.

</p>
<p>为了能更加全面地支持HTTP应用，Node的HTTP API是很接近底层，它是可以处理数据流还有只转化消息。它把一个消息写到报文头和报文体，但是它并没有解析报文头或报文体。

</p>
<p>Defined headers that allow multiple values are concatenated with a <code>,</code>
character, except for the <code>set-cookie</code> and <code>cookie</code> headers which are
represented as an array of values.  Headers such as <code>content-length</code>
which can only have a single value are parsed accordingly, and only a
single value is represented on the parsed object.

</p>
<p>定义好的消息头允许多个值以<code>,</code>分割, 除了<code>set-cookie</code>和<code>cookie</code>,因为他们表示值的数组. 消息头,比如 <code>content-length</code>只能有单个值, 并且单个值表示解析好的对象.

</p>
<p>The raw headers as they were received are retained in the <code>rawHeaders</code>
property, which is an array of <code>[key, value, key2, value2, ...]</code>.  For
example, the previous message header object might have a <code>rawHeaders</code>
list like the following:

</p>
<p>接收到的原始头信息以数组形式 <code>[key, value, key2, value2, ...]</code> 保存在 <code>rawHeaders</code> 属性中. 例如, 前面提到的消息对象会有 <code>rawHeaders</code> 列表如下:

</p>
<pre><code>[ &apos;ConTent-Length&apos;, &apos;123456&apos;,
  &apos;content-LENGTH&apos;, &apos;123&apos;,
  &apos;content-type&apos;, &apos;text/plain&apos;,
  &apos;CONNECTION&apos;, &apos;keep-alive&apos;,
  &apos;Host&apos;, &apos;mysite.com&apos;,
  &apos;accepT&apos;, &apos;*/*&apos; ]</code></pre>
<h2>http.STATUS_CODES<span><a href="all.html#all_http_status_codes_1" id="all_http_status_codes_1">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>A collection of all the standard HTTP response status codes, and the
short description of each.  For example, <code>http.STATUS_CODES[404] === &apos;Not
Found&apos;</code>.

</p>
<p>所以标准HTTP响应码的集合,以及每个响应码的简短描述.例如:<code>http.STATUS_CODES[404]===&apos;Not Found&apos;</code>.

</p>
<h2>http.createServer([requestListener])<span><a href="all.html#all_http_createserver_requestlistener_1" id="all_http_createserver_requestlistener_1">#</a></span></h2>
<p>Returns a new web server object.

</p>
<p>返回一个新的web服务器对象

</p>
<p>The <code>requestListener</code> is a function which is automatically
added to the <code>&apos;request&apos;</code> event.

</p>
<p>参数 <code>requestListener</code> 是一个函数,它将会自动加入到 <code>&apos;request&apos;</code> 事件的监听队列.

</p>
<h2>http.createClient([port], [host])<span><a href="all.html#all_http_createclient_port_host_1" id="all_http_createclient_port_host_1">#</a></span></h2>
<p>This function is <strong>deprecated</strong>; please use <a href="http.html#http_http_request_options_callback">http.request()</a> instead.
Constructs a new HTTP client. <code>port</code> and <code>host</code> refer to the server to be
connected to.

</p>
<p>该函数已<strong>弃用</strong>,请用<a href="http.html#http_http_request_options_callback">http.request()</a>代替.
创建一个新的HTTP客户端. <code>port</code> 和<code>host</code> 表示所连接的服务器.

</p>
<h2>Class: http.Server<span><a href="all.html#all_class_http_server_1" id="all_class_http_server_1">#</a></span></h2>
<p>This is an <a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<p>这是一个包含下列事件的<a href="events.html#events_class_events_eventemitter">EventEmitter</a>:

</p>
<h3>Event: &apos;request&apos;<span><a href="all.html#all_event_request_1" id="all_event_request_1">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p><code>function (request, response) { }</code>

</p>
<p>Emitted each time there is a request. Note that there may be multiple requests
per connection (in the case of keep-alive connections).
<code>request</code> is an instance of <code>http.IncomingMessage</code> and <code>response</code> is
an instance of <code>http.ServerResponse</code>

</p>
<p>每次收到一个请求时触发.注意每个连接又可能有多个请求(在<code>keep-alive</code>的连接中).<code>request</code>是<code>http.IncomingMessage</code>的一个实例.<code>response</code>是<code>http.ServerResponse</code>的一个实例

</p>
<h3>事件: &apos;connection&apos;<span><a href="all.html#all_connection_3" id="all_connection_3">#</a></span></h3>
<p><code>function (socket) { }</code>

</p>
<p><code>function (socket) { }</code>

</p>
<p>When a new TCP stream is established. <code>socket</code> is an object of type
<code>net.Socket</code>. Usually users will not want to access this event. In
particular, the socket will not emit <code>readable</code> events because of how
the protocol parser attaches to the socket. The <code>socket</code> can also be
accessed at <code>request.connection</code>.

</p>
<p>新的TCP流建立时出发。 <code>socket</code>是一个<code>net.Socket</code>对象。
通常用户无需处理该事件。
特别注意，协议解析器绑定套接字时采用的方式使套接字不会出发<code>readable</code>事件。
还可以通过<code>request.connection</code>访问<code>socket</code>。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_13" id="all_close_13">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Emitted when the server closes.

</p>
<p>当此服务器关闭时触发

</p>
<h3>Event: &apos;checkContinue&apos;<span><a href="all.html#all_event_checkcontinue_1" id="all_event_checkcontinue_1">#</a></span></h3>
<p><code>function (request, response) { }</code>

</p>
<p><code>function (request, response) { }</code>

</p>
<p>Emitted each time a request with an http Expect: 100-continue is received.
If this event isn&apos;t listened for, the server will automatically respond
with a 100 Continue as appropriate.

</p>
<p>每当收到Expect: 100-continue的http请求时触发。
如果未监听该事件，服务器会酌情自动发送100 Continue响应。

</p>
<p>Handling this event involves calling <code>response.writeContinue</code> if the client
should continue to send the request body, or generating an appropriate HTTP
response (e.g., 400 Bad Request) if the client should not continue to send the
request body.

</p>
<p>处理该事件时，如果客户端可以继续发送请求主体则调用<code>response.writeContinue</code>，
如果不能则生成合适的HTTP响应（例如，400 请求无效）。

</p>
<p>Note that when this event is emitted and handled, the <code>request</code> event will
not be emitted.

</p>
<p>需要注意到, 当这个事件触发并且被处理后, <code>request</code> 时间将不再会触发.

</p>
<h3>事件: &apos;connect&apos;<span><a href="all.html#all_connect_4" id="all_connect_4">#</a></span></h3>
<p><code>function (request, socket, head) { }</code>

</p>
<p><code>function (request, socket, head) { }</code>

</p>
<p>Emitted each time a client requests a http CONNECT method. If this event isn&apos;t
listened for, then clients requesting a CONNECT method will have their
connections closed.

</p>
<p>每当客户端发起CONNECT请求时出发。如果未监听该事件，客户端发起CONNECT请求时连接会被关闭。

</p>
<ul>
<li><code>request</code> is the arguments for the http request, as it is in the request
event.</li>
<li><code>socket</code> is the network socket between the server and client.</li>
<li><p><code>head</code> is an instance of Buffer, the first packet of the tunneling stream,
this may be empty.</p>
</li>
<li><p><code>request</code> 是该HTTP请求的参数，与request事件中的相同。</p>
</li>
<li><code>socket</code> 是服务端与客户端之间的网络套接字。</li>
<li><code>head</code> 是一个Buffer实例，隧道流的第一个包，该参数可能为空。</li>
</ul>
<p>After this event is emitted, the request&apos;s socket will not have a <code>data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.

</p>
<p>在这个事件被分发后，请求的套接字将不会有<code>data</code>事件监听器，也就是说你将需要绑定一个监听器到<code>data</code>事件，来处理在套接字上被发送到服务器的数据。

</p>
<h3>Event: &apos;upgrade&apos;<span><a href="all.html#all_event_upgrade_2" id="all_event_upgrade_2">#</a></span></h3>
<p><code>function (request, socket, head) { }</code>

</p>
<p><code>function (request, socket, head) { }</code>

</p>
<p>Emitted each time a client requests a http upgrade. If this event isn&apos;t
listened for, then clients requesting an upgrade will have their connections
closed.

</p>
<p>每当一个客户端请求http升级时，该事件被分发。如果这个事件没有被监听，那么这些请求升级的客户端的连接将会被关闭。

</p>
<ul>
<li><code>request</code> is the arguments for the http request, as it is in the request
event.</li>
<li><code>socket</code> is the network socket between the server and client.</li>
<li><p><code>head</code> is an instance of Buffer, the first packet of the upgraded stream,
this may be empty.</p>
</li>
<li><p><code>request</code> 是该HTTP请求的参数，与request事件中的相同。</p>
</li>
<li><code>socket</code> 是服务端与客户端之间的网络套接字。</li>
<li><code>head</code> 是一个Buffer实例，升级后流的第一个包，该参数可能为空。</li>
</ul>
<p>After this event is emitted, the request&apos;s socket will not have a <code>data</code>
event listener, meaning you will need to bind to it in order to handle data
sent to the server on that socket.

</p>
<p>在这个事件被分发后，请求的套接字将不会有<code>data</code>事件监听器，也就是说你将需要绑定一个监听器到<code>data</code>事件，来处理在套接字上被发送到服务器的数据。

</p>
<h3>Event: &apos;clientError&apos;<span><a href="all.html#all_event_clienterror_3" id="all_event_clienterror_3">#</a></span></h3>
<p><code>function (exception, socket) { }</code>

</p>
<p><code>function (exception, socket) { }</code>

</p>
<p>If a client connection emits an &apos;error&apos; event - it will forwarded here.

</p>
<p>如果一个客户端连接触发了一个 &apos;error&apos; 事件, 它就会转发到这里.

</p>
<p><code>socket</code> is the <code>net.Socket</code> object that the error originated from.

</p>
<p><code>socket</code> 是导致错误的 <code>net.Socket</code> 对象。

</p>
<h3>server.listen(port, [hostname], [backlog], [callback])<span><a href="all.html#all_server_listen_port_hostname_backlog_callback_1" id="all_server_listen_port_hostname_backlog_callback_1">#</a></span></h3>
<p>Begin accepting connections on the specified port and hostname.  If the
hostname is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>).

</p>
<p>开始在指定的主机名和端口接收连接。如果省略主机名，服务器会接收指向任意IPv4地址的链接（<code>INADDR_ANY</code>）。

</p>
<p>To listen to a unix socket, supply a filename instead of port and hostname.

</p>
<p>监听一个 unix socket, 需要提供一个文件名而不是端口号和主机名。

</p>
<p>Backlog is the maximum length of the queue of pending connections.
The actual length will be determined by your OS through sysctl settings such as
<code>tcp_max_syn_backlog</code> and <code>somaxconn</code> on linux. The default value of this
parameter is 511 (not 512).

</p>
<p>积压量 <code>backlog</code> 为连接等待队列的最大长度。实际长度由您的操作系统通过 sysctl 设置决定，比如 Linux 上的 <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。该参数缺省值为 511（不是 512）。

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.  See also <a href="net.html#net_server_listen_port_host_backlog_callback">net.Server.listen(port)</a>.

</p>
<p>这个函数是异步的。最后一个参数<code>callback</code>会被作为事件监听器添加到 <a href="net.html#net_event_listening">&apos;listening&apos;</a>事件。另见<a href="net.html#net_server_listen_port_host_backlog_callback">net.Server.listen(port)</a>。

</p>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback_5" id="all_server_listen_path_callback_5">#</a></span></h3>
<p>Start a UNIX socket server listening for connections on the given <code>path</code>.

</p>
<p>启动一个 UNIX 套接字服务器在所给路径 <code>path</code> 上监听连接。

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#net_event_listening">&apos;listening&apos;</a> event.  See also <a href="net.html#net_server_listen_path_callback">net.Server.listen(path)</a>.

</p>
<p>该函数是异步的.最后一个参数<code>callback</code>将会加入到[<code>listening</code>][]事件的监听队列中.又见<a href="net.html#net_server_listen_path_callback">net.Server.listen(path)</a>.

</p>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback_5" id="all_server_listen_handle_callback_5">#</a></span></h3>
<div><ul>
<li><code>handle</code> <span>Object</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>handle</code>处理器 <span>Object</span></p>
</li>
<li><code>callback</code>回调函数 <span>Function</span></li>
</div></ul>
<p>The <code>handle</code> object can be set to either a server or socket (anything
with an underlying <code>_handle</code> member), or a <code>{fd: &lt;n&gt;}</code> object.

</p>
<p><code>handle</code> 变量可以被设置为server 或者 socket(任一以下划线开头的成员 <code>_handle</code>), 或者一个 <code>{fd: &lt;n&gt;}</code> 对象

</p>
<p>This will cause the server to accept connections on the specified
handle, but it is presumed that the file descriptor or handle has
already been bound to a port or domain socket.

</p>
<p>这将使服务器用指定的句柄接受连接，但它假设文件描述符或者句柄已经被绑定在特定的端口或者域名套接字。

</p>
<p>Listening on a file descriptor is not supported on Windows.

</p>
<p>Windows 不支持监听一个文件描述符。

</p>
<p>This function is asynchronous. The last parameter <code>callback</code> will be added as
a listener for the <a href="net.html#event_listening_">&apos;listening&apos;</a> event.
See also <a href="net.html#net_server_listen_handle_callback">net.Server.listen()</a>.

</p>
<p>这个函数是异步的。最后一个参数<code>callback</code>会被作为事件监听器添加到<a href="net.html#event_listening_">&apos;listening&apos;</a>事件。另见<a href="net.html#net_server_listen_handle_callback">net.Server.listen()</a>。

</p>
<h3>server.close([callback])<span><a href="all.html#all_server_close_callback_4" id="all_server_close_callback_4">#</a></span></h3>
<p>Stops the server from accepting new connections.  See <a href="net.html#net_server_close_callback">net.Server.close()</a>.

</p>
<p>禁止服务端接收新的连接. 查看 <a href="net.html#net_server_close_callback">net.Server.close()</a>.

</p>
<h3>server.maxHeadersCount<span><a href="all.html#all_server_maxheaderscount_1" id="all_server_maxheaderscount_1">#</a></span></h3>
<p>Limits maximum incoming headers count, equal to 1000 by default. If set to 0 -
no limit will be applied.

</p>
<p>最大请求头数目限制, 默认 1000 个. 如果设置为0, 则代表不做任何限制.

</p>
<h3>server.setTimeout(msecs, callback)<span><a href="all.html#all_server_settimeout_msecs_callback_2" id="all_server_settimeout_msecs_callback_2">#</a></span></h3>
<div><ul>
<li><code>msecs</code> <span>Number</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>msecs</code> <span>Number</span></p>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Sets the timeout value for sockets, and emits a <code>&apos;timeout&apos;</code> event on
the Server object, passing the socket as an argument, if a timeout
occurs.

</p>
<p>为套接字设定超时值。如果一个超时发生，那么Server对象上会分发一个<code>&apos;timeout&apos;</code>事件，同时将套接字作为参数传递。

</p>
<p>If there is a <code>&apos;timeout&apos;</code> event listener on the Server object, then it
will be called with the timed-out socket as an argument.

</p>
<p>如果在Server对象上有一个<code>&apos;timeout&apos;</code>事件监听器，那么它将被调用，而超时的套接字会作为参数传递给这个监听器。

</p>
<p>By default, the Server&apos;s timeout value is 2 minutes, and sockets are
destroyed automatically if they time out.  However, if you assign a
callback to the Server&apos;s <code>&apos;timeout&apos;</code> event, then you are responsible
for handling socket timeouts.

</p>
<p>默认情况下，服务器的超时时间是2分钟，超时后套接字会自动销毁。
但是如果为‘timeout’事件指定了回调函数，你需要负责处理套接字超时。

</p>
<h3>server.timeout<span><a href="all.html#all_server_timeout_2" id="all_server_timeout_2">#</a></span></h3>
<div><ul>
<li><p><span>Number</span> Default = 120000 (2 minutes)</p>
</li>
<li><p><span>Number</span> 默认 120000 (2 分钟)</p>
</li>
</div></ul>
<p>The number of milliseconds of inactivity before a socket is presumed
to have timed out.

</p>
<p>一个套接字被判断为超时之前的闲置毫秒数。

</p>
<p>Note that the socket timeout logic is set up on connection, so
changing this value only affects <em>new</em> connections to the server, not
any existing connections.

</p>
<p>注意套接字的超时逻辑在连接时被设定，所以更改这个值只会影响<em>新创建的</em>连接，而不会影响到现有连接。

</p>
<p>Set to 0 to disable any kind of automatic timeout behavior on incoming
connections.

</p>
<p>设置为0将阻止之后建立的连接的一切自动超时行为。

</p>
<h2>Class: http.ServerResponse<span><a href="all.html#all_class_http_serverresponse_1" id="all_class_http_serverresponse_1">#</a></span></h2>
<p>This object is created internally by a HTTP server--not by the user. It is
passed as the second parameter to the <code>&apos;request&apos;</code> event.

</p>
<p>The response implements the <a href="stream.html#stream_writable_stream">Writable Stream</a> interface. This is an
<a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_14" id="all_close_14">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Indicates that the underlying connection was terminated before
<code>response.end()</code> was called or able to flush.

</p>
<h3>response.writeContinue()<span><a href="all.html#all_response_writecontinue_1" id="all_response_writecontinue_1">#</a></span></h3>
<p>Sends a HTTP/1.1 100 Continue message to the client, indicating that
the request body should be sent. See the <a href="all.html#http_event_checkcontinue">&apos;checkContinue&apos;</a> event on <code>Server</code>.

</p>
<h3>response.writeHead(statusCode, [reasonPhrase], [headers])<span><a href="all.html#all_response_writehead_statuscode_reasonphrase_headers_1" id="all_response_writehead_statuscode_reasonphrase_headers_1">#</a></span></h3>
<p>Sends a response header to the request. The status code is a 3-digit HTTP
status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.
Optionally one can give a human-readable <code>reasonPhrase</code> as the second
argument.

</p>
<p>向请求回复响应头. statusCode是一个三位是的HTTP状态码, 例如 <code>404</code>. 
最后一个参数, <code>headers</code>, 是响应头的内容.
可以选择性的，把人类可读的‘原因短句’作为第二个参数。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var body = &apos;hello world&apos;;
response.writeHead(200, {
  &apos;Content-Length&apos;: body.length,
  &apos;Content-Type&apos;: &apos;text/plain&apos; });</code></pre>
<p>This method must only be called once on a message and it must
be called before <code>response.end()</code> is called.

</p>
<p>这个方法只能在消息到来后使用一次 而且这必须在<code>response.end()</code>
之后调用。

</p>
<p>If you call <code>response.write()</code> or <code>response.end()</code> before calling this, the
implicit/mutable headers will be calculated and call this function for you.

</p>
<p>如果你在调用这之前调用了<code>response.write()</code>或者 <code>response.end()</code> , 
就会调用这个函数，并且 不明/容易混淆 的头将会被使用。

</p>
<p>Note: that Content-Length is given in bytes not characters. The above example
works because the string <code>&apos;hello world&apos;</code> contains only single byte characters.
If the body contains higher coded characters then <code>Buffer.byteLength()</code>
should be used to determine the number of bytes in a given encoding.
And Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.

</p>
<p>注意：Content-Length 是以字节(byte)计，而不是以字符(character)计。之前的例子奏效的原因是字符串&apos;hello world&apos;只包含了单字节的字符。如果body包含了多字节编码的字符，就应当使用Buffer.byteLength()来确定在多字节字符编码情况下字符串的字节数。需要进一步说明的是Node不检查Content-Lenth属性和已传输的body长度是否吻合。

</p>
<h3>response.setTimeout(msecs, callback)<span><a href="all.html#all_response_settimeout_msecs_callback_1" id="all_response_settimeout_msecs_callback_1">#</a></span></h3>
<div><ul>
<li><code>msecs</code> <span>Number</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>msecs</code> <span>Number</span></p>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Sets the Socket&apos;s timeout value to <code>msecs</code>.  If a callback is
provided, then it is added as a listener on the <code>&apos;timeout&apos;</code> event on
the response object.

</p>
<p>设定套接字的超时时间为<code>msecs</code>。如果提供了回调函数，会将其添加为响应对象的<code>&apos;timeout&apos;</code>事件的监听器。

</p>
<p>If no <code>&apos;timeout&apos;</code> listener is added to the request, the response, or
the server, then sockets are destroyed when they time out.  If you
assign a handler on the request, the response, or the server&apos;s
<code>&apos;timeout&apos;</code> events, then it is your responsibility to handle timed out
sockets.

</p>
<p>如果请求、响应、服务器均未添加<code>&apos;timeout&apos;</code>事件监听，套接字将在超时时被销毁。
如果监听了请求、响应、服务器之一的<code>&apos;timeout&apos;</code>事件，需要自行处理超时的套接字。

</p>
<h3>response.statusCode<span><a href="all.html#all_response_statuscode_1" id="all_response_statuscode_1">#</a></span></h3>
<p>When using implicit headers (not calling <code>response.writeHead()</code> explicitly), this property
controls the status code that will be sent to the client when the headers get
flushed.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>response.statusCode = 404;</code></pre>
<p>After response header was sent to the client, this property indicates the
status code which was sent out.

</p>
<h3>response.setHeader(name, value)<span><a href="all.html#all_response_setheader_name_value_1" id="all_response_setheader_name_value_1">#</a></span></h3>
<p>Sets a single header value for implicit headers.  If this header already exists
in the to-be-sent headers, its value will be replaced.  Use an array of strings
here if you need to send multiple headers with the same name.

</p>
<p>为默认或者已存在的头设置一条单独的头内容。如果这个头已经存在于
将被送出的头中，将会覆盖原来的内容。如果我想设置更多的头，
就使用一个相同名字的字符串数组

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>response.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;);</code></pre>
<p>or

</p>
<p>或者

</p>
<pre><code>response.setHeader(&quot;Set-Cookie&quot;, [&quot;type=ninja&quot;, &quot;language=javascript&quot;]);</code></pre>
<h3>response.headersSent<span><a href="all.html#all_response_headerssent_1" id="all_response_headerssent_1">#</a></span></h3>
<p>Boolean (read-only). True if headers were sent, false otherwise.

</p>
<p>Boolean值(只读).如果headers发送完毕,则为true,反之为false

</p>
<h3>response.sendDate<span><a href="all.html#all_response_senddate_1" id="all_response_senddate_1">#</a></span></h3>
<p>When true, the Date header will be automatically generated and sent in
the response if it is not already present in the headers. Defaults to true.

</p>
<p>若为true,则当headers里没有Date值时自动生成Date并发送.默认值为true

</p>
<p>This should only be disabled for testing; HTTP requires the Date header
in responses.

</p>
<p>只有在测试环境才禁用它; 因为 HTTP 要求响应包含 <code>Date</code> 头.

</p>
<h3>response.getHeader(name)<span><a href="all.html#all_response_getheader_name_1" id="all_response_getheader_name_1">#</a></span></h3>
<p>Reads out a header that&apos;s already been queued but not sent to the client.  Note
that the name is case insensitive.  This can only be called before headers get
implicitly flushed.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var contentType = response.getHeader(&apos;content-type&apos;);</code></pre>
<h3>response.removeHeader(name)<span><a href="all.html#all_response_removeheader_name_1" id="all_response_removeheader_name_1">#</a></span></h3>
<p>Removes a header that&apos;s queued for implicit sending.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>response.removeHeader(&quot;Content-Encoding&quot;);</code></pre>
<h3>response.write(chunk, [encoding])<span><a href="all.html#all_response_write_chunk_encoding_1" id="all_response_write_chunk_encoding_1">#</a></span></h3>
<p>If this method is called and <code>response.writeHead()</code> has not been called, it will
switch to implicit header mode and flush the implicit headers.

</p>
<p>This sends a chunk of the response body. This method may
be called multiple times to provide successive parts of the body.

</p>
<p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string,
the second parameter specifies how to encode it into a byte stream.
By default the <code>encoding</code> is <code>&apos;utf8&apos;</code>.

</p>
<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with
higher-level multi-part body encodings that may be used.

</p>
<p>The first time <code>response.write()</code> is called, it will send the buffered
header information and the first body to the client. The second time
<code>response.write()</code> is called, Node assumes you&apos;re going to be streaming
data, and sends that separately. That is, the response is buffered up to the
first chunk of body.

</p>
<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<p>如果所有数据被成功刷新到内核缓冲区，则返回<code>true</code>。如果所有或部分数据在用户内存里还处于队列中，则返回<code>false</code>。当缓冲区再次被释放时，<code>&apos;drain&apos;</code>事件会被分发。
<code>&apos;drain&apos;</code> will be emitted when the buffer is again free.

</p>
<h3>response.addTrailers(headers)<span><a href="all.html#all_response_addtrailers_headers_1" id="all_response_addtrailers_headers_1">#</a></span></h3>
<p>This method adds HTTP trailing headers (a header but at the end of the
message) to the response.

</p>
<p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the
response; if it is not (e.g., if the request was HTTP/1.0), they will
be silently discarded.

</p>
<p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to
emit trailers, with a list of the header fields in its value. E.g.,

</p>
<pre><code>response.writeHead(200, { &apos;Content-Type&apos;: &apos;text/plain&apos;,
                          &apos;Trailer&apos;: &apos;Content-MD5&apos; });
response.write(fileData);
response.addTrailers({&apos;Content-MD5&apos;: &quot;7895bf4b8828b55ceaf47747b4bca667&quot;});
response.end();</code></pre>
<h3>response.end([data], [encoding])<span><a href="all.html#all_response_end_data_encoding_1" id="all_response_end_data_encoding_1">#</a></span></h3>
<p>This method signals to the server that all of the response headers and body
have been sent; that server should consider this message complete.
The method, <code>response.end()</code>, MUST be called on each
response.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling <code>response.write(data, encoding)</code>
followed by <code>response.end()</code>.

</p>
<h2>http.request(options, callback)<span><a href="all.html#all_http_request_options_callback_1" id="all_http_request_options_callback_1">#</a></span></h2>
<p>Node maintains several connections per server to make HTTP requests.
This function allows one to transparently issue requests.

</p>
<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is
automatically parsed with <a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost">url.parse()</a>.

</p>
<p><code>options</code> 可以是一个对象或一个字符串。如果 <code>options</code>是一个字符串, 它将自动的使用<a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost">url.parse()</a>解析。

</p>
<p>Options:

</p>
<p>Options:

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code>&apos;localhost&apos;</code>.</li>
<li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li>
<li><code>port</code>: Port of remote server. Defaults to 80.</li>
<li><code>localAddress</code>: Local interface to bind for network connections.</li>
<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&apos;GET&apos;</code>.</li>
<li><code>path</code>: Request path. Defaults to <code>&apos;/&apos;</code>. Should include query string if any.
E.G. <code>&apos;/index.html?page=12&apos;</code>. An exception is thrown when the request path
contains illegal characters. Currently, only spaces are rejected but that
may change in the future.</li>
<li><code>headers</code>: An object containing request headers.</li>
<li><code>auth</code>: Basic authentication i.e. <code>&apos;user:password&apos;</code> to compute an
Authorization header.</li>
<li><code>agent</code>: Controls <a href="all.html#https_class_https_agent">Agent</a> behavior. When an Agent is used request will
default to <code>Connection: keep-alive</code>. Possible values:<ul>
<li><code>undefined</code> (default): use <a href="all.html#http_http_globalagent">global Agent</a> for this host and port.</li>
<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li>
</ul>
</li>
<li><code>keepAlive</code>: {Boolean} Keep sockets around in a pool to be used
by other requests in the future. Default = <code>false</code></li>
<li><p><code>keepAliveMsecs</code>: {Integer} When using HTTP KeepAlive, how often to
send TCP KeepAlive packets over sockets being kept alive.  Default =
<code>1000</code>.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.</p>
</li>
<li><p><code>host</code>: 要发送请求的服务端域名或IP地址。
默认为<code>&apos;localhost&apos;</code>。</p>
</li>
<li><code>hostname</code>: 要支持<code>url.parse()</code>的话，优先使用<code>hostname</code>而不是<code>host</code></li>
<li><code>port</code>: 远程服务器的端口。默认为80。</li>
<li><code>localAddress</code>: 本地接口，用来绑定网络连接。</li>
<li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</li>
<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&apos;GET&apos;</code>.</li>
<li><code>path</code>: Request path. Defaults to <code>&apos;/&apos;</code>. Should include query string if any.
E.G. <code>&apos;/index.html?page=12&apos;</code>. An exception is thrown when the request path
contains illegal characters. Currently, only spaces are rejected but that
may change in the future.</li>
<li><code>headers</code>: An object containing request headers.</li>
<li><code>auth</code>: Basic authentication i.e. <code>&apos;user:password&apos;</code> to compute an
Authorization header.</li>
<li><code>agent</code>: Controls <a href="all.html#https_class_https_agent">Agent</a> behavior. When an Agent is used request will
default to <code>Connection: keep-alive</code>. Possible values:<ul>
<li><code>undefined</code> (default): use <a href="all.html#http_http_globalagent">global Agent</a> for this host and port.</li>
<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li>
</ul>
</li>
<li><code>keepAlive</code>: {Boolean} Keep sockets around in a pool to be used
by other requests in the future. Default = <code>false</code></li>
<li><code>keepAliveMsecs</code>: {Integer} When using HTTP KeepAlive, how often to
send TCP KeepAlive packets over sockets being kept alive.  Default =
<code>1000</code>.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.</li>
</ul>
<p><code>http.request()</code> returns an instance of the <code>http.ClientRequest</code>
class. The <code>ClientRequest</code> instance is a writable stream. If one needs to
upload a file with a POST request, then write to the <code>ClientRequest</code> object.

</p>
<p><code>http.request()</code> 返回一个 <code>http.ClientRequest</code>类的实例。<code>ClientRequest</code>实例是一个可写流对象。如果需要用POST请求上传一个文件的话，就将其写入到<code>ClientRequest</code>对象。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// write data to request body
req.write(&apos;data\n&apos;);
req.write(&apos;data\n&apos;);
req.end();</code></pre>
<p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one
must always call <code>req.end()</code> to signify that you&apos;re done with the request -
even if there is no data being written to the request body.

</p>
<p>注意，例子里的<code>req.end()</code>被调用了。使用<code>http.request()</code>方法时都必须总是调用<code>req.end()</code>以表明这个请求已经完成，即使响应body里没有任何数据。

</p>
<p>If any error is encountered during the request (be that with DNS resolution,
TCP level errors, or actual HTTP parse errors) an <code>&apos;error&apos;</code> event is emitted
on the returned request object.

</p>
<p>There are a few special headers that should be noted.

</p>
<ul>
<li><p>Sending a &apos;Connection: keep-alive&apos; will notify Node that the connection to
the server should be persisted until the next request.</p>
</li>
<li><p>Sending a &apos;Content-length&apos; header will disable the default chunked encoding.</p>
</li>
<li><p>发送 &apos;Content-length&apos; 头将会禁用默认的 chunked 编码.</p>
</li>
<li><p>Sending an &apos;Expect&apos; header will immediately send the request headers.
Usually, when sending &apos;Expect: 100-continue&apos;, you should both set a timeout
and listen for the <code>continue</code> event. See RFC2616 Section 8.2.3 for more
information.</p>
</li>
<li><p>Sending an Authorization header will override using the <code>auth</code> option
to compute basic authentication.</p>
</li>
</ul>
<h2>http.get(options, callback)<span><a href="all.html#all_http_get_options_callback_1" id="all_http_get_options_callback_1">#</a></span></h2>
<p>Since most requests are GET requests without bodies, Node provides this
convenience method. The only difference between this method and <code>http.request()</code>
is that it sets the method to GET and calls <code>req.end()</code> automatically.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>http.get(&quot;http://www.google.com/index.html&quot;, function(res) {
  console.log(&quot;Got response: &quot; + res.statusCode);
}).on(&apos;error&apos;, function(e) {
  console.log(&quot;Got error: &quot; + e.message);
});</code></pre>
<h2>Class: http.Agent<span><a href="all.html#all_class_http_agent_1" id="all_class_http_agent_1">#</a></span></h2>
<p>The HTTP Agent is used for pooling sockets used in HTTP client
requests.

</p>
<p>The HTTP Agent also defaults client requests to using
Connection:keep-alive. If no pending HTTP requests are waiting on a
socket to become free the socket is closed. This means that Node&apos;s
pool has the benefit of keep-alive when under load but still does not
require developers to manually close the HTTP clients using
KeepAlive.

</p>
<p>If you opt into using HTTP KeepAlive, you can create an Agent object
with that flag set to <code>true</code>.  (See the <a href="all.html#http_new_agent_options">constructor
options</a> below.)  Then, the Agent will keep
unused sockets in a pool for later use.  They will be explicitly
marked so as to not keep the Node process running.  However, it is
still a good idea to explicitly <a href="all.html#http_agent_destroy"><code>destroy()</code></a>
KeepAlive agents when they are no longer in use, so that the Sockets
will be shut down.

</p>
<p>Sockets are removed from the agent&apos;s pool when the socket emits either
a &quot;close&quot; event or a special &quot;agentRemove&quot; event. This means that if
you intend to keep one HTTP request open for a long time and don&apos;t
want it to stay in the pool you can do something along the lines of:

</p>
<pre><code>http.get(options, function(res) {
  // Do stuff
}).on(&quot;socket&quot;, function (socket) {
  socket.emit(&quot;agentRemove&quot;);
});</code></pre>
<p>Alternatively, you could just opt out of pooling entirely using
<code>agent:false</code>:

</p>
<pre><code>http.get({
  hostname: &apos;localhost&apos;,
  port: 80,
  path: &apos;/&apos;,
  agent: false  // create a new agent just for this one request
}, function (res) {
  // Do stuff with response
})</code></pre>
<h3>new Agent([options])<span><a href="all.html#all_new_agent_options_1" id="all_new_agent_options_1">#</a></span></h3>
<div><ul>
<li><code>options</code> <span>Object</span> Set of configurable options to set on the agent.
Can have the following fields:<ul>
<li><code>keepAlive</code> <span>Boolean</span> Keep sockets around in a pool to be used by
other requests in the future. Default = <code>false</code></li>
<li><code>keepAliveMsecs</code> <span>Integer</span> When using HTTP KeepAlive, how often
to send TCP KeepAlive packets over sockets being kept alive.
Default = <code>1000</code>.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.</li>
<li><code>maxSockets</code> <span>Number</span> Maximum number of sockets to allow per
host.  Default = <code>Infinity</code>.</li>
<li><code>maxFreeSockets</code> <span>Number</span> Maximum number of sockets to leave open
in a free state.  Only relevant if <code>keepAlive</code> is set to <code>true</code>.
Default = <code>256</code>.</li>
</ul>
</li>
</div></ul>
<p>The default <code>http.globalAgent</code> that is used by <code>http.request</code> has all
of these values set to their respective defaults.

</p>
<p>To configure any of them, you must create your own <code>Agent</code> object.

</p>
<p>要配置这些值，你必须创建一个你自己的<code>Agent</code>对象。

</p>
<pre><code>var http = require(&apos;http&apos;);
var keepAliveAgent = new http.Agent({ keepAlive: true });
keepAliveAgent.request(options, onResponseCallback);</code></pre>
<h3>agent.maxSockets<span><a href="all.html#all_agent_maxsockets_1" id="all_agent_maxsockets_1">#</a></span></h3>
<p>By default set to Infinity. Determines how many concurrent sockets the
agent can have open per host.

</p>
<h3>agent.maxFreeSockets<span><a href="all.html#all_agent_maxfreesockets_1" id="all_agent_maxfreesockets_1">#</a></span></h3>
<p>By default set to 256.  For Agents supporting HTTP KeepAlive, this
sets the maximum number of sockets that will be left open in the free
state.

</p>
<h3>agent.sockets<span><a href="all.html#all_agent_sockets_1" id="all_agent_sockets_1">#</a></span></h3>
<p>An object which contains arrays of sockets currently in use by the
Agent.  Do not modify.

</p>
<h3>agent.freeSockets<span><a href="all.html#all_agent_freesockets_1" id="all_agent_freesockets_1">#</a></span></h3>
<p>An object which contains arrays of sockets currently awaiting use by
the Agent when HTTP KeepAlive is used.  Do not modify.

</p>
<h3>agent.requests<span><a href="all.html#all_agent_requests_1" id="all_agent_requests_1">#</a></span></h3>
<p>An object which contains queues of requests that have not yet been assigned to
sockets. Do not modify.

</p>
<h3>agent.destroy()<span><a href="all.html#all_agent_destroy_1" id="all_agent_destroy_1">#</a></span></h3>
<p>Destroy any sockets that are currently in use by the agent.

</p>
<p>销毁被此 agent 正在使用着的所有 sockets.

</p>
<p>It is usually not necessary to do this.  However, if you are using an
agent with KeepAlive enabled, then it is best to explicitly shut down
the agent when you know that it will no longer be used.  Otherwise,
sockets may hang open for quite a long time before the server
terminates them.

</p>
<h3>agent.getName(options)<span><a href="all.html#all_agent_getname_options_1" id="all_agent_getname_options_1">#</a></span></h3>
<p>Get a unique name for a set of request options, to determine whether a
connection can be reused.  In the http agent, this returns
<code>host:port:localAddress</code>.  In the https agent, the name includes the
CA, cert, ciphers, and other HTTPS/TLS-specific options that determine
socket reusability.

</p>
<h2>http.globalAgent<span><a href="all.html#all_http_globalagent_1" id="all_http_globalagent_1">#</a></span></h2>
<p>Global instance of Agent which is used as the default for all http client
requests.

</p>
<h2>Class: http.ClientRequest<span><a href="all.html#all_class_http_clientrequest_1" id="all_class_http_clientrequest_1">#</a></span></h2>
<p>This object is created internally and returned from <code>http.request()</code>.  It
represents an <em>in-progress</em> request whose header has already been queued.  The
header is still mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
<code>removeHeader(name)</code> API.  The actual header will be sent along with the first
data chunk or when closing the connection.

</p>
<p>To get the response, add a listener for <code>&apos;response&apos;</code> to the request object.
<code>&apos;response&apos;</code> will be emitted from the request object when the response
headers have been received.  The <code>&apos;response&apos;</code> event is executed with one
argument which is an instance of <code>http.IncomingMessage</code>.

</p>
<p>During the <code>&apos;response&apos;</code> event, one can add listeners to the
response object; particularly to listen for the <code>&apos;data&apos;</code> event.

</p>
<p>If no <code>&apos;response&apos;</code> handler is added, then the response will be
entirely discarded.  However, if you add a <code>&apos;response&apos;</code> event handler,
then you <strong>must</strong> consume the data from the response object, either by
calling <code>response.read()</code> whenever there is a <code>&apos;readable&apos;</code> event, or
by adding a <code>&apos;data&apos;</code> handler, or by calling the <code>.resume()</code> method.
Until the data is consumed, the <code>&apos;end&apos;</code> event will not fire.  Also, until
the data is read it will consume memory that can eventually lead to a
&apos;process out of memory&apos; error.

</p>
<p>Note: Node does not check whether Content-Length and the length of the body
which has been transmitted are equal or not.

</p>
<p>The request implements the <a href="stream.html#stream_writable_stream">Writable Stream</a> interface. This is an
<a href="events.html#events_class_events_eventemitter">EventEmitter</a> with the following events:

</p>
<h3>Event &apos;response&apos;<span><a href="all.html#all_event_response_1" id="all_event_response_1">#</a></span></h3>
<p><code>function (response) { }</code>

</p>
<p><code>function (response) { }</code>

</p>
<p>Emitted when a response is received to this request. This event is emitted only
once. The <code>response</code> argument will be an instance of <code>http.IncomingMessage</code>.

</p>
<p>Options:

</p>
<p>Options:

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>
<li><code>port</code>: Port of remote server.</li>
<li><p><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath)</p>
</li>
<li><p><code>host</code>: 请求要发送的域名或服务器的IP地址。</p>
</li>
<li><code>port</code>: 远程服务器的端口。</li>
<li><code>socketPath</code>: Unix Domain Socket （使用host:port或socketPath）</li>
</ul>
<h3>Event: &apos;socket&apos;<span><a href="all.html#all_event_socket_1" id="all_event_socket_1">#</a></span></h3>
<p><code>function (socket) { }</code>

</p>
<p><code>function (socket) { }</code>

</p>
<p>Emitted after a socket is assigned to this request.

</p>
<p>当一个套接字被分配到这个请求之后，该事件被分发。

</p>
<h3>事件: &apos;connect&apos;<span><a href="all.html#all_connect_5" id="all_connect_5">#</a></span></h3>
<p><code>function (response, socket, head) { }</code>

</p>
<p><code>function (response, socket, head) { }</code>

</p>
<p>Emitted each time a server responds to a request with a CONNECT method. If this
event isn&apos;t being listened for, clients receiving a CONNECT method will have
their connections closed.

</p>
<p>A client server pair that show you how to listen for the <code>connect</code> event.

</p>
<pre><code>    // make a request over an HTTP tunnel
    socket.write(&apos;GET / HTTP/1.1\r\n&apos; +
                 &apos;Host: www.google.com:80\r\n&apos; +
                 &apos;Connection: close\r\n&apos; +
                 &apos;\r\n&apos;);
    socket.on(&apos;data&apos;, function(chunk) {
      console.log(chunk.toString());
    });
    socket.on(&apos;end&apos;, function() {
      proxy.close();
    });
  });
});</code></pre>
<h3>Event: &apos;upgrade&apos;<span><a href="all.html#all_event_upgrade_3" id="all_event_upgrade_3">#</a></span></h3>
<p><code>function (response, socket, head) { }</code>

</p>
<p><code>function (response, socket, head) { }</code>

</p>
<p>Emitted each time a server responds to a request with an upgrade. If this
event isn&apos;t being listened for, clients receiving an upgrade header will have
their connections closed.

</p>
<p>A client server pair that show you how to listen for the <code>upgrade</code> event.

</p>
<pre><code>  req.on(&apos;upgrade&apos;, function(res, socket, upgradeHead) {
    console.log(&apos;got upgraded!&apos;);
    socket.end();
    process.exit(0);
  });
});</code></pre>
<h3>Event: &apos;continue&apos;<span><a href="all.html#all_event_continue_1" id="all_event_continue_1">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Emitted when the server sends a &apos;100 Continue&apos; HTTP response, usually because
the request contained &apos;Expect: 100-continue&apos;. This is an instruction that
the client should send the request body.

</p>
<h3>request.write(chunk, [encoding])<span><a href="all.html#all_request_write_chunk_encoding_1" id="all_request_write_chunk_encoding_1">#</a></span></h3>
<p>Sends a chunk of the body.  By calling this method
many times, the user can stream a request body to a
server--in that case it is suggested to use the
<code>[&apos;Transfer-Encoding&apos;, &apos;chunked&apos;]</code> header line when
creating the request.

</p>
<p>The <code>chunk</code> argument should be a <a href="buffer.html#buffer_buffer">Buffer</a> or a string.

</p>
<p><code>chunk</code> 参数必须是 <a href="buffer.html#buffer_buffer">Buffer</a> 或者 string.

</p>
<p>The <code>encoding</code> argument is optional and only applies when <code>chunk</code> is a string.
Defaults to <code>&apos;utf8&apos;</code>.

</p>
<p><code>encoding</code> 参数是可选的, 并且只能在 <code>chunk</code> 是 string 类型的时候才能设置.
默认是 <code>&apos;utf8&apos;</code>.

</p>
<h3>request.end([data], [encoding])<span><a href="all.html#all_request_end_data_encoding_1" id="all_request_end_data_encoding_1">#</a></span></h3>
<p>Finishes sending the request. If any parts of the body are
unsent, it will flush them to the stream. If the request is
chunked, this will send the terminating <code>&apos;0\r\n\r\n&apos;</code>.

</p>
<p>If <code>data</code> is specified, it is equivalent to calling
<code>request.write(data, encoding)</code> followed by <code>request.end()</code>.

</p>
<h3>request.abort()<span><a href="all.html#all_request_abort_1" id="all_request_abort_1">#</a></span></h3>
<p>Aborts a request.  (New since v0.3.8.)

</p>
<p>终止一个请求. (从 v0.3.8 开始新加.)

</p>
<h3>request.setTimeout(timeout, [callback])<span><a href="all.html#all_request_settimeout_timeout_callback_1" id="all_request_settimeout_timeout_callback_1">#</a></span></h3>
<p>Once a socket is assigned to this request and is connected
<a href="net.html#net_socket_settimeout_timeout_callback">socket.setTimeout()</a> will be called.

</p>
<h3>request.setNoDelay([noDelay])<span><a href="all.html#all_request_setnodelay_nodelay_1" id="all_request_setnodelay_nodelay_1">#</a></span></h3>
<p>Once a socket is assigned to this request and is connected
<a href="net.html#net_socket_setnodelay_nodelay">socket.setNoDelay()</a> will be called.

</p>
<h3>request.setSocketKeepAlive([enable], [initialDelay])<span><a href="all.html#all_request_setsocketkeepalive_enable_initialdelay_1" id="all_request_setsocketkeepalive_enable_initialdelay_1">#</a></span></h3>
<p>Once a socket is assigned to this request and is connected
<a href="net.html#net_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive()</a> will be called.

</p>
<p>一旦一个套接字被分配到这个请求，而且成功连接，那么<a href="net.html#net_socket_setkeepalive_enable_initialdelay">socket.setKeepAlive()</a>就会被调用。

</p>
<h2>http.IncomingMessage<span><a href="all.html#all_http_incomingmessage_1" id="all_http_incomingmessage_1">#</a></span></h2>
<p>An <code>IncomingMessage</code> object is created by <code>http.Server</code> or <code>http.ClientRequest</code>
and passed as the first argument to the <code>&apos;request&apos;</code> and <code>&apos;response&apos;</code> event
respectively. It may be used to access response status, headers and data.

</p>
<p>一个 <code>IncomingMessage</code>对象是由 <code>http.Server</code>或<code>http.ClientRequest</code>创建的，并作为第一参数分别传递给<code>&apos;request&apos;</code>和<code>&apos;response&apos;</code> 事件。它也可以被用来访问应答的状态，头文件和数据。

</p>
<p>It implements the <a href="stream.html#stream_readable_stream">Readable Stream</a> interface, as well as the
following additional events, methods, and properties.

</p>
<p>这个实现了 [可读流][]接口以及以下增加的事件，函数和属性。

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_15" id="all_close_15">#</a></span></h3>
<p><code>function () { }</code>

</p>
<p><code>function () { }</code>

</p>
<p>Indicates that the underlaying connection was terminated before
<code>response.end()</code> was called or able to flush.

</p>
<p>表示在<code>response.end()</code>被调用或强制刷新之前，底层的连接已经被终止了。

</p>
<p>Just like <code>&apos;end&apos;</code>, this event occurs only once per response. See
[http.ServerResponse][]&apos;s <code>&apos;close&apos;</code> event for more information.

</p>
<p>跟<code>&apos;end&apos;</code>一样，这个事件对于每个应答只会触发一次。详见[http.ServerResponse][]的 <code>&apos;close&apos;</code>事件。

</p>
<h3>message.httpVersion<span><a href="all.html#all_message_httpversion_1" id="all_message_httpversion_1">#</a></span></h3>
<p>In case of server request, the HTTP version sent by the client. In the case of
client response, the HTTP version of the connected-to server.
Probably either <code>&apos;1.1&apos;</code> or <code>&apos;1.0&apos;</code>.

</p>
<p>客户端向服务器发出请求时，客户端发送的HTTP版本；或是服务器向客户端返回应答时，服务器的HTTP版本。通常是 <code>&apos;1.1&apos;</code>或<code>&apos;1.0&apos;</code>。

</p>
<p>Also <code>response.httpVersionMajor</code> is the first integer and
<code>response.httpVersionMinor</code> is the second.

</p>
<h3>message.headers<span><a href="all.html#all_message_headers_1" id="all_message_headers_1">#</a></span></h3>
<p>The request/response headers object.

</p>
<p>请求/响应 头对象.

</p>
<p>Read only map of header names and values. Header names are lower-cased.
Example:

</p>
<p>只读的头文件名称和值的映射。头文件名称全小写。示例：

</p>
<pre><code>// 输出类似这样：
//
// { &apos;user-agent&apos;: &apos;curl/7.22.0&apos;,
//   host: &apos;127.0.0.1:8000&apos;,
//   accept: &apos;*/*&apos; }
console.log(request.headers);</code></pre>
<h3>message.rawHeaders<span><a href="all.html#all_message_rawheaders_1" id="all_message_rawheaders_1">#</a></span></h3>
<p>The raw request/response headers list exactly as they were received.

</p>
<p>Note that the keys and values are in the same list.  It is <em>not</em> a
list of tuples.  So, the even-numbered offsets are key values, and the
odd-numbered offsets are the associated values.

</p>
<p>Header names are not lowercased, and duplicates are not merged.

</p>
<pre><code>// Prints something like:
//
// [ &apos;user-agent&apos;,
//   &apos;this is invalid because there can be only one&apos;,
//   &apos;User-Agent&apos;,
//   &apos;curl/7.22.0&apos;,
//   &apos;Host&apos;,
//   &apos;127.0.0.1:8000&apos;,
//   &apos;ACCEPT&apos;,
//   &apos;*/*&apos; ]
console.log(request.rawHeaders);</code></pre>
<h3>message.trailers<span><a href="all.html#all_message_trailers_1" id="all_message_trailers_1">#</a></span></h3>
<p>The request/response trailers object. Only populated at the &apos;end&apos; event.

</p>
<h3>message.rawTrailers<span><a href="all.html#all_message_rawtrailers_1" id="all_message_rawtrailers_1">#</a></span></h3>
<p>The raw request/response trailer keys and values exactly as they were
received.  Only populated at the &apos;end&apos; event.

</p>
<h3>message.setTimeout(msecs, callback)<span><a href="all.html#all_message_settimeout_msecs_callback_1" id="all_message_settimeout_msecs_callback_1">#</a></span></h3>
<div><ul>
<li><code>msecs</code> <span>Number</span></li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>msecs</code> <span>Number</span></p>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Calls <code>message.connection.setTimeout(msecs, callback)</code>.

</p>
<p>调用message.connection.setTimeout(msecs, callback)

</p>
<h3>message.method<span><a href="all.html#all_message_method_1" id="all_message_method_1">#</a></span></h3>
<p><strong>Only valid for request obtained from <code>http.Server</code>.</strong>

</p>
<p><strong>仅对从<code>http.Server</code>获得到的请求(request)有效.</strong>

</p>
<p>The request method as a string. Read only. Example:
<code>&apos;GET&apos;</code>, <code>&apos;DELETE&apos;</code>.

</p>
<p>请求（request）方法如同一个只读的字符串，比如‘GET’、‘DELETE’。

</p>
<h3>message.url<span><a href="all.html#all_message_url_1" id="all_message_url_1">#</a></span></h3>
<p><strong>Only valid for request obtained from <code>http.Server</code>.</strong>

</p>
<p><strong>仅对从<code>http.Server</code>获得到的请求(request)有效.</strong>

</p>
<p>Request URL string. This contains only the URL that is
present in the actual HTTP request. If the request is:

</p>
<p>请求的URL字符串.它仅包含实际HTTP请求中所提供的URL.加入请求如下:

</p>
<pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n</code></pre>
<p>Then <code>request.url</code> will be:

</p>
<p>则<code>request.url</code> 为:

</p>
<pre><code>&apos;/status?name=ryan&apos;</code></pre>
<p>If you would like to parse the URL into its parts, you can use
<code>require(&apos;url&apos;).parse(request.url)</code>.  Example:

</p>
<p>如果你想要将URL分解出来,你可以用<code>require(&apos;url&apos;).parse(request.url)</code>.  例如:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: &apos;name=ryan&apos;,
  pathname: &apos;/status&apos; }</code></pre>
<p>If you would like to extract the params from the query string,
you can use the <code>require(&apos;querystring&apos;).parse</code> function, or pass
<code>true</code> as the second argument to <code>require(&apos;url&apos;).parse</code>.  Example:

</p>
<p>如果你想要提取出从请求字符串(query string)中的参数,你可以用<code>require(&apos;querystring&apos;).parse</code>函数, 或者将<code>true</code>作为第二个参数传递给<code>require(&apos;url&apos;).parse</code>.  例如:

</p>
<pre><code>node&gt; require(&apos;url&apos;).parse(&apos;/status?name=ryan&apos;, true)
{ href: &apos;/status?name=ryan&apos;,
  search: &apos;?name=ryan&apos;,
  query: { name: &apos;ryan&apos; },
  pathname: &apos;/status&apos; }</code></pre>
<h3>message.statusCode<span><a href="all.html#all_message_statuscode_1" id="all_message_statuscode_1">#</a></span></h3>
<p><strong>Only valid for response obtained from <code>http.ClientRequest</code>.</strong>

</p>
<p><strong>仅对从<code>http.ClientRequest</code>获得的响应(response)有效.</strong>

</p>
<p>The 3-digit HTTP response status code. E.G. <code>404</code>.

</p>
<p>三位数的HTTP响应状态码. 例如 <code>404</code>.

</p>
<h3>message.socket<span><a href="all.html#all_message_socket_1" id="all_message_socket_1">#</a></span></h3>
<p>The <code>net.Socket</code> object associated with the connection.

</p>
<p>与此连接(connection)关联的<code>net.Socket</code>对象.

</p>
<p>With HTTPS support, use request.connection.verifyPeer() and
request.connection.getPeerCertificate() to obtain the client&apos;s
authentication details.

</p>
<p>通过https的支持，使用 request.connection.verifyPeer()方法和request.connection.getPeerCertificate()方法来得到客户端的身份信息。

</p>
<h1>HTTPS<span><a href="all.html#all_https_1" id="all_https_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a
separate module.

</p>
<p>HTTPS 是建立在 TLS/SSL 之上的 HTTP 协议。在 Node 中被实现为单独的模块。

</p>
<h2>类: https.Server<span><a href="all.html#all_https_server_1" id="all_https_server_1">#</a></span></h2>
<p>This class is a subclass of <code>tls.Server</code> and emits events same as
<code>http.Server</code>. See <code>http.Server</code> for more information.

</p>
<p>该类是 <code>tls.Server</code> 的子类，并且发生和 <code>http.Server</code> 一样的事件。更多信息详见 <code>http.Server</code>。

</p>
<h3>server.setTimeout(msecs, callback)<span><a href="all.html#all_server_settimeout_msecs_callback_3" id="all_server_settimeout_msecs_callback_3">#</a></span></h3>
<p>See <a href="http.html#http_server_settimeout_msecs_callback">http.Server#setTimeout()</a>.

</p>
<p>详见 <a href="http.html#http_server_settimeout_msecs_callback">http.Server#setTimeout()</a>。

</p>
<h3>server.timeout<span><a href="all.html#all_server_timeout_3" id="all_server_timeout_3">#</a></span></h3>
<p>See <a href="http.html#http_server_timeout">http.Server#timeout</a>.

</p>
<p>详见 <a href="http.html#http_server_timeout">http.Server#timeout</a>。

</p>
<h2>https.createServer(options, [requestListener])<span><a href="all.html#all_https_createserver_options_requestlistener_1" id="all_https_createserver_options_requestlistener_1">#</a></span></h2>
<p>Returns a new HTTPS web server object. The <code>options</code> is similar to
<a href="tls.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer()</a>.  The <code>requestListener</code> is a function which is
automatically added to the <code>&apos;request&apos;</code> event.

</p>
<p>返回一个新的 HTTPS Web 服务器对象。其中 <code>options</code> 类似于 <a href="tls.html#tls_tls_createserver_options_secureconnectionlistener">tls.createServer()</a>；<code>requestListener</code> 是一个会被自动添加到 <code>request</code> 事件的函数。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<p>Or

</p>
<p>或者

</p>
<pre><code>https.createServer(options, function (req, res) {
  res.writeHead(200);
  res.end(&quot;hello world\n&quot;);
}).listen(8000);</code></pre>
<h3>server.listen(port, [host], [backlog], [callback])<span><a href="all.html#all_server_listen_port_host_backlog_callback_4" id="all_server_listen_port_host_backlog_callback_4">#</a></span></h3>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback_6" id="all_server_listen_path_callback_6">#</a></span></h3>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback_6" id="all_server_listen_handle_callback_6">#</a></span></h3>
<h3>server.listen(port, [host], [backlog], [callback])<span><a href="all.html#all_server_listen_port_host_backlog_callback_5" id="all_server_listen_port_host_backlog_callback_5">#</a></span></h3>
<h3>server.listen(path, [callback])<span><a href="all.html#all_server_listen_path_callback_7" id="all_server_listen_path_callback_7">#</a></span></h3>
<h3>server.listen(handle, [callback])<span><a href="all.html#all_server_listen_handle_callback_7" id="all_server_listen_handle_callback_7">#</a></span></h3>
<p>See <a href="http.html#http_server_listen_port_hostname_backlog_callback">http.listen()</a> for details.

</p>
<p>详见 <a href="http.html#http_server_listen_port_hostname_backlog_callback">http.listen()</a>。

</p>
<h3>server.close([callback])<span><a href="all.html#all_server_close_callback_5" id="all_server_close_callback_5">#</a></span></h3>
<p>See <a href="http.html#http_server_close_callback">http.close()</a> for details.

</p>
<p>详见 <a href="http.html#http_server_close_callback">http.close()</a>。

</p>
<h2>https.request(options, callback)<span><a href="all.html#all_https_request_options_callback_1" id="all_https_request_options_callback_1">#</a></span></h2>
<p>Makes a request to a secure web server.

</p>
<p>向一个安全 Web 服务器发送请求。

</p>
<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is
automatically parsed with <a href="url.html#url.parse">url.parse()</a>.

</p>
<p><code>options</code> 可以是一个对象或字符串。如果 <code>options</code> 是字符串，它会自动被 <a href="url.html#url.parse">url.parse()</a> 解析。

</p>
<p>All options from <a href="http.html#http_http_request_options_callback">http.request()</a> are valid.

</p>
<p>所有来自 <a href="http.html#http_http_request_options_callback">http.request()</a> 的选项都是经过验证的。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>req.on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<p>The options argument has the following options

</p>
<p>options 参数有如下选项

</p>
<ul>
<li><code>host</code>: A domain name or IP address of the server to issue the request to.
Defaults to <code>&apos;localhost&apos;</code>.</li>
<li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li>
<li><code>port</code>: Port of remote server. Defaults to 443.</li>
<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&apos;GET&apos;</code>.</li>
<li><code>path</code>: Request path. Defaults to <code>&apos;/&apos;</code>. Should include query string if any.
E.G. <code>&apos;/index.html?page=12&apos;</code></li>
<li><code>headers</code>: An object containing request headers.</li>
<li><code>auth</code>: Basic authentication i.e. <code>&apos;user:password&apos;</code> to compute an
Authorization header.</li>
<li><p><code>agent</code>: Controls <a href="all.html#https_class_https_agent">Agent</a> behavior. When an Agent is used request will
default to <code>Connection: keep-alive</code>. Possible values:</p>
<ul>
<li><code>undefined</code> (default): use <a href="all.html#https_https_globalagent">globalAgent</a> for this host and port.</li>
<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
<code>Connection: close</code>.</li>
</ul>
</li>
<li><p><code>host</code>：发送请求的服务器的域名或 IP 地址，缺省为 <code>&apos;localhost&apos;</code>。</p>
</li>
<li><code>hostname</code>：为了支持 <code>url.parse()</code>，<code>hostname</code> 优先于 <code>host</code>。</li>
<li><code>port</code>：远程服务器的端口，缺省为 443。</li>
<li><code>method</code>：指定 HTTP 请求方法的字符串，缺省为 `&apos;GET&apos;。</li>
<li><code>path</code>：请求路径，缺省为 <code>&apos;/&apos;</code>。如有查询字串则应包含，比如 <code>&apos;/index.html?page=12&apos;</code>。</li>
<li><code>headers</code>：包含请求头的对象。</li>
<li><code>auth</code>：基本认证，如 <code>&apos;user:password&apos;</code> 来计算 Authorization 头。</li>
<li><code>agent</code>：控制 <a href="all.html#https_class_https_agent">Agent</a> 行为。当使用 Agent 时请求会缺省为 <code>Connection: keep-alive</code>。可选值有：<ul>
<li><code>undefined</code>（缺省）：为该主机和端口使用 <a href="all.html#https_https_globalagent">globalAgent</a>。</li>
<li><code>Agent</code> 对象：明确使用传入的 <code>Agent</code>。</li>
<li><code>false</code>：不使用 Agent 连接池，缺省请求 <code>Connection: close</code>。</li>
</ul>
</li>
</ul>
<p>The following options from <a href="tls.html#tls_tls_connect_options_callback">tls.connect()</a> can also be specified. However, a
<a href="all.html#https_https_globalagent">globalAgent</a> silently ignores these.

</p>
<p>下列来自 <a href="tls.html#tls_tls_connect_options_callback">tls.connect()</a> 的选项也能够被指定，但一个 <a href="all.html#https_https_globalagent">globalAgent</a> 会忽略它们。

</p>
<ul>
<li><code>pfx</code>: Certificate, Private key and CA certificates to use for SSL. Default <code>null</code>.</li>
<li><code>key</code>: Private key to use for SSL. Default <code>null</code>.</li>
<li><code>passphrase</code>: A string of passphrase for the private key or pfx. Default <code>null</code>.</li>
<li><code>cert</code>: Public x509 certificate to use. Default <code>null</code>.</li>
<li><code>ca</code>: An authority certificate or array of authority certificates to check
the remote host against.</li>
<li><code>ciphers</code>: A string describing the ciphers to use or exclude. Consult
<a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a> for
details on the format.</li>
<li><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against
the list of supplied CAs. An <code>&apos;error&apos;</code> event is emitted if verification
fails. Verification happens at the connection level, <em>before</em> the HTTP
request is sent. Default <code>true</code>.</li>
<li><p><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force
SSL version 3. The possible values depend on your installation of
OpenSSL and are defined in the constant <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a>.</p>
</li>
<li><p><code>pfx</code>：证书，SSL 所用的私钥或 CA 证书。缺省为 <code>null</code>。</p>
</li>
<li><code>key</code>：SSL 所用私钥。缺省为 <code>null</code>。</li>
<li><code>passphrase</code>：私钥或 pfx 的口令字符串，缺省为 <code>null</code>。</li>
<li><code>cert</code>：所用公有 x509 证书，缺省为 <code>null</code>。</li>
<li><code>ca</code>：用于检查远程主机的证书颁发机构或包含一系列证书颁发机构的数组。</li>
<li><code>ciphers</code>：描述要使用或排除的密码的字符串，格式请参阅 <a href="http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>。</li>
<li><code>rejectUnauthorized</code>：如为 <code>true</code> 则服务器证书会使用所给 CA 列表验证。如果验证失败则会触发 <code>&apos;error&apos;</code> 时间。验证过程发生于连接层，在 HTTP 请求发送<em>之前</em>。缺省为 <code>true</code>。</li>
<li><code>secureProtocol</code>：所用 SSL 方法，比如 <code>SSLv3_method</code> 强制使用 SSL version 3。可取值取决于您安装的 OpenSSL 并被定义在 <a href="http://www.openssl.org/docs/ssl/ssl.html#DEALING_WITH_PROTOCOL_METHODS">SSL_METHODS</a> 常量。</li>
</ul>
<p>In order to specify these options, use a custom <code>Agent</code>.

</p>
<p>要指定这些选项，使用一个自定义 <code>Agent</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var req = https.request(options, function(res) {
  ...
}</code></pre>
<p>Or does not use an <code>Agent</code>.

</p>
<p>或不使用 <code>Agent</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var req = https.request(options, function(res) {
  ...
}</code></pre>
<h2>https.get(options, callback)<span><a href="all.html#all_https_get_options_callback_1" id="all_https_get_options_callback_1">#</a></span></h2>
<p>Like <code>http.get()</code> but for HTTPS.

</p>
<p>类似 <code>http.get()</code> 但为 HTTPS。

</p>
<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is
automatically parsed with <a href="url.html#url.parse">url.parse()</a>.

</p>
<p><code>options</code> 可以是一个对象或字符串。如果 <code>options</code> 是字符串，它会自动被 <a href="url.html#url.parse">url.parse()</a> 解析。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>}).on(&apos;error&apos;, function(e) {
  console.error(e);
});</code></pre>
<h2>类: https.Agent<span><a href="all.html#all_https_agent_1" id="all_https_agent_1">#</a></span></h2>
<p>An Agent object for HTTPS similar to <a href="http.html#http_class_http_agent">http.Agent</a>.  See <a href="all.html#https_https_request_options_callback">https.request()</a>
for more information.

</p>
<p>类似于 <a href="http.html#http_class_http_agent">http.Agent</a> 的 HTTPS Agent 对象。详见 <a href="all.html#https_https_request_options_callback">https.request()</a>。

</p>
<h2>https.globalAgent<span><a href="all.html#all_https_globalagent_1" id="all_https_globalagent_1">#</a></span></h2>
<p>Global instance of <a href="all.html#https_class_https_agent">https.Agent</a> for all HTTPS client requests.

</p>
<p>所有 HTTPS 客户端请求的全局 <a href="all.html#https_class_https_agent">https.Agent</a> 实例。

</p>
<h1>URL<span><a href="all.html#all_url_1" id="all_url_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>This module has utilities for URL resolution and parsing.
Call <code>require(&apos;url&apos;)</code> to use it.

</p>
<p>该模块包含用以 URL 解析的实用函数。
使用 <code>require(&apos;url&apos;)</code> 来调用该模块。

</p>
<p>Parsed URL objects have some or all of the following fields, depending on
whether or not they exist in the URL string. Any parts that are not in the URL
string will not be in the parsed object. Examples are shown for the URL

</p>
<p>不同的 URL 字符串解析后返回的对象会有一些额外的字段信息，仅当该部分出现在 URL 中才会有。以下是一个 URL 例子：

</p>
<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>

</p>
<p><code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code>

</p>
<ul>
<li><p><code>href</code>: The full URL that was originally parsed. Both the protocol and host are lowercased.</p>
</li>
<li><p><code>href</code>: 所解析的完整原始 URL。协议名和主机名都已转为小写。</p>
<p>  例如: <code>&apos;http://user:pass@host.com:8080/p/a/t/h?query=string#hash&apos;</code></p>
</li>
<li><p><code>protocol</code>: The request protocol, lowercased.</p>
</li>
<li><p><code>protocol</code>: 请求协议，小写</p>
<p>  例如: <code>&apos;http:&apos;</code></p>
</li>
<li><p><code>host</code>: The full lowercased host portion of the URL, including port
information.</p>
</li>
<li><p><code>host</code>: URL主机名已全部转换成小写, 包括端口信息</p>
<p>  例如: <code>&apos;host.com:8080&apos;</code></p>
</li>
<li><p><code>auth</code>: The authentication information portion of a URL.</p>
</li>
<li><p><code>auth</code>:URL中身份验证信息部分</p>
<p>  例如: <code>&apos;user:pass&apos;</code></p>
</li>
<li><p><code>hostname</code>: Just the lowercased hostname portion of the host.</p>
</li>
<li><p><code>hostname</code>:主机的主机名部分, 已转换成小写</p>
<p>  例如: <code>&apos;host.com&apos;</code></p>
</li>
<li><p><code>port</code>: The port number portion of the host.</p>
</li>
<li><p><code>port</code>: 主机的端口号部分</p>
<p>  例如: <code>&apos;8080&apos;</code></p>
</li>
<li><p><code>pathname</code>: The path section of the URL, that comes after the host and
before the query, including the initial slash if present.</p>
</li>
<li><p><code>pathname</code>: URL的路径部分,位于主机名之后请求查询之前, including the initial slash if present.</p>
<p>  例如: <code>&apos;/p/a/t/h&apos;</code></p>
</li>
<li><p><code>search</code>: The &apos;query string&apos; portion of the URL, including the leading
question mark.</p>
</li>
<li><p><code>search</code>: URL 的“查询字符串”部分，包括开头的问号。</p>
<p>  例如: <code>&apos;?query=string&apos;</code></p>
</li>
<li><p><code>path</code>: Concatenation of <code>pathname</code> and <code>search</code>.</p>
</li>
<li><p><code>path</code>: <code>pathname</code> 和 <code>search</code> 连在一起。</p>
<p>  例如: <code>&apos;/p/a/t/h?query=string&apos;</code></p>
</li>
<li><p><code>query</code>: Either the &apos;params&apos; portion of the query string, or a
querystring-parsed object.</p>
</li>
<li><p><code>query</code>: 查询字符串中的参数部分（问号后面部分字符串），或者使用  <code>querystring.parse()</code> 解析后返回的对象。</p>
<p>  例如: <code>&apos;query=string&apos;</code> or <code>{&apos;query&apos;:&apos;string&apos;}</code></p>
</li>
<li><p><code>hash</code>: The &apos;fragment&apos; portion of the URL including the pound-sign.</p>
</li>
<li><p><code>hash</code>: URL 的 “#” 后面部分（包括 # 符号） </p>
<p>  例如: <code>&apos;#hash&apos;</code></p>
</li>
</ul>
<p>The following methods are provided by the URL module:

</p>
<p>以下是 URL 模块提供的方法：

</p>
<h2>url.parse(urlStr, [parseQueryString], [slashesDenoteHost])<span><a href="all.html#all_url_parse_urlstr_parsequerystring_slashesdenotehost_1" id="all_url_parse_urlstr_parsequerystring_slashesdenotehost_1">#</a></span></h2>
<p>Take a URL string, and return an object.

</p>
<p>输入 URL 字符串，返回一个对象。

</p>
<p>Pass <code>true</code> as the second argument to also parse
the query string using the <code>querystring</code> module.
Defaults to <code>false</code>.

</p>
<p>将第二个参数设置为 <code>true</code> 则使用 <code>querystring</code> 模块来解析 URL 中德查询字符串部分，默认为 <code>false</code>。

</p>
<p>Pass <code>true</code> as the third argument to treat <code>//foo/bar</code> as
<code>{ host: &apos;foo&apos;, pathname: &apos;/bar&apos; }</code> rather than
<code>{ pathname: &apos;//foo/bar&apos; }</code>. Defaults to <code>false</code>.

</p>
<p>将第三个参数设置为 <code>true</code> 来把诸如 <code>//foo/bar</code> 这样的URL解析为
<code>{ host: &apos;foo&apos;, pathname: &apos;/bar&apos; }</code> 而不是
<code>{ pathname: &apos;//foo/bar&apos; }</code>。 默认为 <code>false</code>。

</p>
<h2>url.format(urlObj)<span><a href="all.html#all_url_format_urlobj_1" id="all_url_format_urlobj_1">#</a></span></h2>
<p>Take a parsed URL object, and return a formatted URL string.

</p>
<p>输入一个 URL 对象，返回格式化后的 URL 字符串。

</p>
<ul>
<li><code>href</code> will be ignored.</li>
<li><code>protocol</code>is treated the same with or without the trailing <code>:</code> (colon).<ul>
<li>The protocols <code>http</code>, <code>https</code>, <code>ftp</code>, <code>gopher</code>, <code>file</code> will be
postfixed with <code>://</code> (colon-slash-slash).</li>
<li>All other protocols <code>mailto</code>, <code>xmpp</code>, <code>aim</code>, <code>sftp</code>, <code>foo</code>, etc will
be postfixed with <code>:</code> (colon)</li>
</ul>
</li>
<li><code>auth</code> will be used if present.</li>
<li><code>hostname</code> will only be used if <code>host</code> is absent.</li>
<li><code>port</code> will only be used if <code>host</code> is absent.</li>
<li><code>host</code> will be used in place of <code>hostname</code> and <code>port</code></li>
<li><code>pathname</code> is treated the same with or without the leading <code>/</code> (slash)</li>
<li><code>search</code> will be used in place of <code>query</code></li>
<li><code>query</code> (object; see <code>querystring</code>) will only be used if <code>search</code> is absent.</li>
<li><code>search</code> is treated the same with or without the leading <code>?</code> (question mark)</li>
<li><p><code>hash</code> is treated the same with or without the leading <code>#</code> (pound sign, anchor)</p>
</li>
<li><p><code>href</code> 属性会被忽略处理.</p>
</li>
<li><code>protocol</code>无论是否有末尾的 <code>:</code> (冒号)，会同样的处理<ul>
<li>这些协议包括 <code>http</code>, <code>https</code>, <code>ftp</code>, <code>gopher</code>, <code>file</code> 
后缀是 <code>://</code> (冒号-斜杠-斜杠).</li>
<li>所有其他的协议如 <code>mailto</code>, <code>xmpp</code>, <code>aim</code>, <code>sftp</code>, <code>foo</code>, 等
 会加上后缀 <code>:</code> (冒号)</li>
</ul>
</li>
<li><code>auth</code> 如果有将会出现.</li>
<li><code>hostname</code> 如果 <code>host</code> 属性没被定义，则会使用此属性.</li>
<li><code>port</code> 如果 <code>host</code> 属性没被定义，则会使用此属性.</li>
<li><code>host</code> 优先使用，将会替代 <code>hostname</code> 和<code>port</code></li>
<li><code>pathname</code> 将会同样处理无论结尾是否有<code>/</code> (斜杠)</li>
<li><code>search</code> 将会替代 <code>query</code>属性</li>
<li><code>query</code> (object类型; 详细请看 <code>querystring</code>) 如果没有 <code>search</code>,将会使用此属性.</li>
<li><code>search</code> 无论前面是否有 <code>?</code> (问号)，都会同样的处理</li>
<li><code>hash</code>无论前面是否有<code>#</code> (井号, 锚点)，都会同样处理</li>
</ul>
<h2>url.resolve(from, to)<span><a href="all.html#all_url_resolve_from_to_1" id="all_url_resolve_from_to_1">#</a></span></h2>
<p>Take a base URL, and a href URL, and resolve them as a browser would for
an anchor tag.  Examples:

</p>
<p>给定一个基础URL路径，和一个href URL路径，并且象浏览器那样处理他们可以带上锚点。 例子：

</p>
<pre><code>url.resolve(&apos;/one/two/three&apos;, &apos;four&apos;)         // &apos;/one/two/four&apos;
url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;


url.resolve(&apos;/one/two/three&apos;, &apos;four&apos;)         // &apos;/one/two/four&apos;
url.resolve(&apos;http://example.com/&apos;, &apos;/one&apos;)    // &apos;http://example.com/one&apos;
url.resolve(&apos;http://example.com/one&apos;, &apos;/two&apos;) // &apos;http://example.com/two&apos;</code></pre>
<h1>Query String<span><a href="all.html#all_query_string_1" id="all_query_string_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!--name=querystring-->

<p>This module provides utilities for dealing with query strings.
It provides the following methods:

</p>
<p>这个模块提供一些处理 query string 的工具。它提供下列方法：

</p>
<h2>querystring.stringify(obj, [sep], [eq])<span><a href="all.html#all_querystring_stringify_obj_sep_eq_1" id="all_querystring_stringify_obj_sep_eq_1">#</a></span></h2>
<p>Serialize an object to a query string.
Optionally override the default separator (<code>&apos;&amp;&apos;</code>) and assignment (<code>&apos;=&apos;</code>)
characters.

</p>
<p>序列化一个对象到一个 query string。可以选择是否覆盖默认的分割符（<code>&apos;&amp;&apos;</code>）和分配符（<code>&apos;=&apos;</code>）。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>querystring.stringify({foo: &apos;bar&apos;, baz: &apos;qux&apos;}, &apos;;&apos;, &apos;:&apos;)
// 返回如下字串
&apos;foo:bar;baz:qux&apos;</code></pre>
<h2>querystring.parse(str, [sep], [eq], [options])<span><a href="all.html#all_querystring_parse_str_sep_eq_options_1" id="all_querystring_parse_str_sep_eq_options_1">#</a></span></h2>
<p>Deserialize a query string to an object.
Optionally override the default separator (<code>&apos;&amp;&apos;</code>) and assignment (<code>&apos;=&apos;</code>)
characters.

</p>
<p>将一个 query string 反序列化为一个对象。可以选择是否覆盖默认的分割符（<code>&apos;&amp;&apos;</code>）和分配符（<code>&apos;=&apos;</code>）。

</p>
<p>Options object may contain <code>maxKeys</code> property (equal to 1000 by default), it&apos;ll
be used to limit processed keys. Set it to 0 to remove key count limitation.

</p>
<p>options对象可能包含<code>maxKeys</code>属性(默认为1000),它可以用来限制处理过的键(key)的数量.设为0可以去除键(key)的数量限制.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>querystring.parse(&apos;foo=bar&amp;baz=qux&amp;baz=quux&amp;corge&apos;)
// returns
{ foo: &apos;bar&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], corge: &apos;&apos; }</code></pre>
<h2>querystring.escape<span><a href="all.html#all_querystring_escape_1" id="all_querystring_escape_1">#</a></span></h2>
<p>The escape function used by <code>querystring.stringify</code>,
provided so that it could be overridden if necessary.

</p>
<p>供 <code>querystring.stringify</code> 使用的转意函数，在必要的时候可被重写。

</p>
<h2>querystring.unescape<span><a href="all.html#all_querystring_unescape_1" id="all_querystring_unescape_1">#</a></span></h2>
<p>The unescape function used by <code>querystring.parse</code>,
provided so that it could be overridden if necessary.


</p>
<p>供 <code>querystring.parse</code> 使用的反转意函数，在必要的时候可被重写。

</p>
<h1>punycode<span><a href="all.html#all_punycode_1" id="all_punycode_1">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p><a href="http://mths.be/punycode">Punycode.js</a> is bundled with Node.js v0.6.2+. Use
<code>require(&apos;punycode&apos;)</code> to access it. (To use it with other Node.js versions,
use npm to install the <code>punycode</code> module first.)

</p>
<p><a href="http://mths.be/punycode">Punycode.js</a> 自 Node.js v0.6.2+ 开始被内置，通过 <code>require(&apos;punycode&apos;)</code> 引入。（要在其它 Node.js 版本中使用它，请先使用 npm 安装 <code>punycode</code> 模块。）

</p>
<h2>punycode.decode(string)<span><a href="all.html#all_punycode_decode_string_1" id="all_punycode_decode_string_1">#</a></span></h2>
<p>Converts a Punycode string of ASCII-only symbols to a string of Unicode symbols.

</p>
<p>将一个纯 ASCII 符号的 Punycode 字符串转换为 Unicode 符号的字符串。

</p>
<pre><code>// 解码域名部分
punycode.decode(&apos;maana-pta&apos;); // &apos;mañana&apos;
punycode.decode(&apos;--dqo34k&apos;); // &apos;☃-⌘&apos;</code></pre>
<h2>punycode.encode(string)<span><a href="all.html#all_punycode_encode_string_1" id="all_punycode_encode_string_1">#</a></span></h2>
<p>Converts a string of Unicode symbols to a Punycode string of ASCII-only symbols.

</p>
<p>将一个 Unicode 符号的字符串转换为纯 ASCII 符号的 Punycode 字符串。

</p>
<pre><code>// 编码域名部分
punycode.encode(&apos;mañana&apos;); // &apos;maana-pta&apos;
punycode.encode(&apos;☃-⌘&apos;); // &apos;--dqo34k&apos;</code></pre>
<h2>punycode.toUnicode(domain)<span><a href="all.html#all_punycode_tounicode_domain_1" id="all_punycode_tounicode_domain_1">#</a></span></h2>
<p>Converts a Punycode string representing a domain name to Unicode. Only the
Punycoded parts of the domain name will be converted, i.e. it doesn&apos;t matter if
you call it on a string that has already been converted to Unicode.

</p>
<p>将一个表示域名的 Punycode 字符串转换为 Unicode。只有域名中的 Punycode 部分会转换，也就是说您在一个已经转换为 Unicode 的字符串上调用它也是没问题的。

</p>
<pre><code>// 解码域名
punycode.toUnicode(&apos;xn--maana-pta.com&apos;); // &apos;mañana.com&apos;
punycode.toUnicode(&apos;xn----dqo34k.com&apos;); // &apos;☃-⌘.com&apos;</code></pre>
<h2>punycode.toASCII(domain)<span><a href="all.html#all_punycode_toascii_domain_1" id="all_punycode_toascii_domain_1">#</a></span></h2>
<p>Converts a Unicode string representing a domain name to Punycode. Only the
non-ASCII parts of the domain name will be converted, i.e. it doesn&apos;t matter if
you call it with a domain that&apos;s already in ASCII.

</p>
<p>将一个表示域名的 Unicode 字符串转换为 Punycode。只有域名的非 ASCII 部分会被转换，也就是说您在一个已经是 ASCII 的域名上调用它也是没问题的。

</p>
<pre><code>// 编码域名
punycode.toASCII(&apos;mañana.com&apos;); // &apos;xn--maana-pta.com&apos;
punycode.toASCII(&apos;☃-⌘.com&apos;); // &apos;xn----dqo34k.com&apos;</code></pre>
<h2>punycode.ucs2<span><a href="all.html#all_punycode_ucs2_1" id="all_punycode_ucs2_1">#</a></span></h2>
<h3>punycode.ucs2.decode(string)<span><a href="all.html#all_punycode_ucs2_decode_string_1" id="all_punycode_ucs2_decode_string_1">#</a></span></h3>
<p>Creates an array containing the numeric code point values of each Unicode
symbol in the string. While <a href="http://mathiasbynens.be/notes/javascript-encoding">JavaScript uses UCS-2
internally</a>, this function
will convert a pair of surrogate halves (each of which UCS-2 exposes as
separate characters) into a single code point, matching UTF-16.

</p>
<p>创建一个数组，包含字符串中每个 Unicode 符号的数字编码点。由于 <a href="http://mathiasbynens.be/notes/javascript-encoding">JavaScript 在内部使用 UCS-2</a>，
该函数会按照 UTF-16 将一对代半数（UCS-2 暴露的单独的字符）转换为单独一个编码点。

</p>
<pre><code>punycode.ucs2.decode(&apos;abc&apos;); // [0x61, 0x62, 0x63]
// surrogate pair for U+1D306 tetragram for centre:
punycode.ucs2.decode(&apos;\uD834\uDF06&apos;); // [0x1D306]</code></pre>
<h3>punycode.ucs2.encode(codePoints)<span><a href="all.html#all_punycode_ucs2_encode_codepoints_1" id="all_punycode_ucs2_encode_codepoints_1">#</a></span></h3>
<p>Creates a string based on an array of numeric code point values.

</p>
<p>以数字编码点的值的数组创建一个字符串。

</p>
<pre><code>punycode.ucs2.encode([0x61, 0x62, 0x63]); // &apos;abc&apos;
punycode.ucs2.encode([0x1D306]); // &apos;\uD834\uDF06&apos;</code></pre>
<h2>punycode.version<span><a href="all.html#all_punycode_version_1" id="all_punycode_version_1">#</a></span></h2>
<p>A string representing the current Punycode.js version number.


</p>
<p>表示当前 Punycode.js 版本号的字符串。
</p>
<h1>Readline<span><a href="all.html#all_readline_1" id="all_readline_1">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p>To use this module, do <code>require(&apos;readline&apos;)</code>. Readline allows reading of a
stream (such as <code>process.stdin</code>) on a line-by-line basis.

</p>
<p>要使用此模块，需要<code>require(&apos;readline&apos;)</code>.Readline程序允许逐行读取一个流内容(例如<code>process.stdin</code>).

</p>
<p>Note that once you&apos;ve invoked this module, your node program will not
terminate until you&apos;ve closed the interface. Here&apos;s how to allow your
program to gracefully exit:

</p>
<p>需要注意的是你一旦调用了这个模块，你的node程序将不会终止直到你关闭此接口。下面是如何让你的程序正常退出的方法:

</p>
<pre><code>  rl.close();
});</code></pre>
<h2>readline.createInterface(options)<span><a href="all.html#all_readline_createinterface_options_1" id="all_readline_createinterface_options_1">#</a></span></h2>
<p>Creates a readline <code>Interface</code> instance. Accepts an &quot;options&quot; Object that takes
the following values:

</p>
<p>创建一个readline的接口实例. 接受一个Object类型参数，可传递以下几个值:

</p>
<ul>
<li><p><code>input</code> - the readable stream to listen to (Required).</p>
</li>
<li><p><code>input</code> - 要监听的可读流 (必需).</p>
</li>
<li><p><code>output</code> - the writable stream to write readline data to (Required).</p>
</li>
<li><p><code>output</code> - 要写入 readline 的可写流 (必须).</p>
</li>
<li><p><code>completer</code> - an optional function that is used for Tab autocompletion. See
below for an example of using this.</p>
</li>
<li><p><code>completer</code> - 用于 Tab 自动补全的可选函数。见下面使用的例子。</p>
</li>
<li><p><code>terminal</code> - pass <code>true</code> if the <code>input</code> and <code>output</code> streams should be
treated like a TTY, and have ANSI/VT100 escape codes written to it.
Defaults to checking <code>isTTY</code> on the <code>output</code> stream upon instantiation.</p>
</li>
<li><p><code>terminal</code> - 如果希望 <code>input</code> 和 <code>output</code> 流像 TTY 一样对待，那么传递参数 <code>true</code> ，并且经由 ANSI/VT100 转码。
默认情况下检查 <code>isTTY</code> 是否在 <code>output</code> 流上实例化。</p>
</li>
</ul>
<p>The <code>completer</code> function is given a the current line entered by the user, and
is supposed to return an Array with 2 entries:

</p>
<p>通过用户 <code>completer</code> 函数给定了一个当前行入口，并且期望返回一个包含两个条目的数组：

</p>
<ol>
<li><p>An Array with matching entries for the completion.</p>
</li>
<li><p>一个匹配当前输入补全的字符串数组.</p>
</li>
<li><p>The substring that was used for the matching.</p>
</li>
<li><p>一个用于匹配的子字符串。</p>
</li>
</ol>
<p>Which ends up looking something like:
<code>[[substr1, substr2, ...], originalsubstring]</code>.

</p>
<p>最终像这种形式:
<code>[[substr1, substr2, ...], originalsubstring]</code>.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>function completer(line) {
  var completions = &apos;.help .error .exit .quit .q&apos;.split(&apos; &apos;)
  var hits = completions.filter(function(c) { return c.indexOf(line) == 0 })
  // show all completions if none found
  return [hits.length ? hits : completions, line]
}</code></pre>
<p>Also <code>completer</code> can be run in async mode if it accepts two arguments:

</p>
<p><code>completer</code> 也可以运行在异步模式下，此时接受两个参数：

</p>
<pre><code>function completer(linePartial, callback) {
  callback(null, [[&apos;123&apos;], linePartial]);
}</code></pre>
<p><code>createInterface</code> is commonly used with <code>process.stdin</code> and
<code>process.stdout</code> in order to accept user input:

</p>
<p>为了接受用户的输入，<code>createInterface</code> 通常跟 <code>process.stdin</code> 和 <code>process.stdout</code> 一块使用：

</p>
<pre><code>var readline = require(&apos;readline&apos;);
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});</code></pre>
<p>Once you have a readline instance, you most commonly listen for the
<code>&quot;line&quot;</code> event.

</p>
<p>一旦你有一个 readline 实例，你通常会监听 &quot;line&quot; 事件。

</p>
<p>If <code>terminal</code> is <code>true</code> for this instance then the <code>output</code> stream will get
the best compatibility if it defines an <code>output.columns</code> property, and fires
a <code>&quot;resize&quot;</code> event on the <code>output</code> if/when the columns ever change
(<code>process.stdout</code> does this automatically when it is a TTY).

</p>
<p>如果这个实例中<code>terminal</code>为<code>true</code>，而且<code>output</code>流定义了一个<code>output.columns</code>属性，那么<code>output</code>流将获得最好的兼容性，并且，当columns变化时(当它是TTY时，<code>process.stdout</code>会自动这样做)，会在<code>output</code>上触发一个 <code>&quot;resize&quot;</code>事件。

</p>
<h2>类: 接口<span><a href="all.html#all_79" id="all_79">#</a></span></h2>
<p>The class that represents a readline interface with an input and output
stream.

</p>
<p>代表一个有输入输出流的 readline 接口的类。

</p>
<h3>rl.setPrompt(prompt)<span><a href="all.html#all_rl_setprompt_prompt_1" id="all_rl_setprompt_prompt_1">#</a></span></h3>
<p>Sets the prompt, for example when you run <code>node</code> on the command line, you see
<code>&gt; </code>, which is node&apos;s prompt.

</p>
<p>设置提示符，例如当你在命令行运行 <code>node</code> 时，你会看到 <code>&gt; </code> ，这就是 node 的提示符。

</p>
<h3>rl.prompt([preserveCursor])<span><a href="all.html#all_rl_prompt_preservecursor_1" id="all_rl_prompt_preservecursor_1">#</a></span></h3>
<p>Readies readline for input from the user, putting the current <code>setPrompt</code>
options on a new line, giving the user a new spot to write. Set <code>preserveCursor</code>
to <code>true</code> to prevent the cursor placement being reset to <code>0</code>.

</p>
<p>为用户输入准备好readline，将现有的<code>setPrompt</code>选项放到新的一行，让用户有一个新的地方开始输入。将<code>preserveCursor</code>设为<code>true</code>来防止光标位置被重新设定成<code>0</code>。

</p>
<p>This will also resume the <code>input</code> stream used with <code>createInterface</code> if it has
been paused.

</p>
<p>如果暂停，也会使用 <code>createInterface</code> 重置 <code>input</code> 流。

</p>
<h3>rl.question(query, callback)<span><a href="all.html#all_rl_question_query_callback_1" id="all_rl_question_query_callback_1">#</a></span></h3>
<p>Prepends the prompt with <code>query</code> and invokes <code>callback</code> with the user&apos;s
response. Displays the query to the user, and then invokes <code>callback</code>
with the user&apos;s response after it has been typed.

</p>
<p>预处理 <code>query</code>提示 ，用户应答时调用 <code>callback</code> . 当类型被确定后，将查询结果显示给用户, 然后在用户应答时调用 <code>callback</code>.

</p>
<p>This will also resume the <code>input</code> stream used with <code>createInterface</code> if
it has been paused.

</p>
<p>如果暂停，也会使用 <code>createInterface</code> 重置 <code>input</code> 流。

</p>
<p>Example usage:

</p>
<p>使用示例：

</p>
<pre><code>interface.question(&apos;What is your favorite food?&apos;, function(answer) {
  console.log(&apos;Oh, so your favorite food is &apos; + answer);
});</code></pre>
<h3>rl.pause()<span><a href="all.html#all_rl_pause_1" id="all_rl_pause_1">#</a></span></h3>
<p>Pauses the readline <code>input</code> stream, allowing it to be resumed later if needed.

</p>
<p>暂停 readline 的输入流 (<code>input</code> stream), 如果有需要稍后还可以恢复。

</p>
<h3>rl.resume()<span><a href="all.html#all_rl_resume_1" id="all_rl_resume_1">#</a></span></h3>
<p>Resumes the readline <code>input</code> stream.

</p>
<p>恢复 readline 的输入流 (<code>input</code> stream).

</p>
<h3>rl.close()<span><a href="all.html#all_rl_close_1" id="all_rl_close_1">#</a></span></h3>
<p>Closes the <code>Interface</code> instance, relinquishing control on the <code>input</code> and
<code>output</code> streams. The &quot;close&quot; event will also be emitted.

</p>
<p>关闭接口实例 (<code>Interface</code> instance), 放弃控制输入输出流。&quot;close&quot; 事件会被触发。

</p>
<h3>rl.write(data, [key])<span><a href="all.html#all_rl_write_data_key_1" id="all_rl_write_data_key_1">#</a></span></h3>
<p>Writes <code>data</code> to <code>output</code> stream. <code>key</code> is an object literal to represent a key
sequence; available if the terminal is a TTY.

</p>
<p>将 <code>data</code> 写入到 <code>output</code> 流。<code>key</code> 是一个代表键序列的对象；当终端是一个 TTY 时可用。

</p>
<p>This will also resume the <code>input</code> stream if it has been paused.

</p>
<p>如果暂停，也会重置 <code>input</code> 流。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>rl.write(&apos;Delete me!&apos;);
// 模仿 ctrl+u快捷键，删除之前所写行 
rl.write(null, {ctrl: true, name: &apos;u&apos;});</code></pre>
<h2>Events<span><a href="all.html#all_events_1" id="all_events_1">#</a></span></h2>
<h3>Event: &apos;line&apos;<span><a href="all.html#all_event_line_1" id="all_event_line_1">#</a></span></h3>
<p><code>function (line) {}</code>

</p>
<p><code>function (line) {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream receives a <code>\n</code>, usually received when the
user hits enter, or return. This is a good hook to listen for user input.

</p>
<p>在 <code>input</code> 流接受了一个 <code>\n</code> 时触发，通常在用户敲击回车或者返回时接收。
这是一个监听用户输入的利器。

</p>
<p>Example of listening for <code>line</code>:

</p>
<p>监听 <code>line</code> 事件的示例:

</p>
<pre><code>rl.on(&apos;line&apos;, function (cmd) {
  console.log(&apos;You just typed: &apos;+cmd);
});</code></pre>
<h3>事件: &apos;pause&apos;<span><a href="all.html#all_pause_1" id="all_pause_1">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream is paused.

</p>
<p>不论何时，只要输入流被暂停就会触发。

</p>
<p>Also emitted whenever the <code>input</code> stream is not paused and receives the
<code>SIGCONT</code> event. (See events <code>SIGTSTP</code> and <code>SIGCONT</code>)

</p>
<p>而在输入流未被暂停，但收到 <code>SIGCONT</code> 信号时也会触发。 (详见 <code>SIGTSTP</code> 和 <code>SIGCONT</code> 事件)

</p>
<p>Example of listening for <code>pause</code>:

</p>
<p>监听 <code>pause</code> 事件的示例：

</p>
<pre><code>rl.on(&apos;pause&apos;, function() {
  console.log(&apos;Readline 输入暂停.&apos;);
});</code></pre>
<h3>事件: &apos;resume&apos;<span><a href="all.html#all_resume_1" id="all_resume_1">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream is resumed.

</p>
<p>不论何时，只要输入流重新启用就会触发。

</p>
<p>Example of listening for <code>resume</code>:

</p>
<p>监听 <code>resume</code> 事件的示例：

</p>
<pre><code>rl.on(&apos;resume&apos;, function() {
  console.log(&apos;Readline 恢复.&apos;);
});</code></pre>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_16" id="all_close_16">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted when <code>close()</code> is called.

</p>
<p>当 <code>close()</code> 被调用时触发。

</p>
<p>Also emitted when the <code>input</code> stream receives its &quot;end&quot; event. The <code>Interface</code>
instance should be considered &quot;finished&quot; once this is emitted. For example, when
the <code>input</code> stream receives <code>^D</code>, respectively known as <code>EOT</code>.

</p>
<p>当 <code>input</code>流接收到&quot;结束&quot;事件时也会被触发. 一旦触发，应当认为<code>Interface</code>实例
 &quot;结束&quot; . 例如, 当<code>input</code>流接收到<code>^D</code>时, 分别被认为<code>EOT</code>.

</p>
<p>This event is also called if there is no <code>SIGINT</code> event listener present when
the <code>input</code> stream receives a <code>^C</code>, respectively known as <code>SIGINT</code>.

</p>
<p>当 <code>input</code> 流接收到一个 <code>^C</code> 时，即使没有 <code>SIGINT</code> 监听器，也会触发这个事件，分别被称为 <code>SIGINT</code> 。

</p>
<h3>Event: &apos;SIGINT&apos;<span><a href="all.html#all_event_sigint_1" id="all_event_sigint_1">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted whenever the <code>input</code> stream receives a <code>^C</code>, respectively known as
<code>SIGINT</code>. If there is no <code>SIGINT</code> event listener present when the <code>input</code>
stream receives a <code>SIGINT</code>, <code>pause</code> will be triggered.

</p>
<p>只要 <code>input</code>流 接收到<code>^C</code>就会被触发, 分别被认为<code>SIGINT</code>.当<code>input</code>流接收到<code>SIGINT</code>时, 
 如果没有 <code>SIGINT</code> 事件监听器，<code>pause</code> 将会被触发.

</p>
<p>Example of listening for <code>SIGINT</code>:

</p>
<p>监听 <code>SIGINT</code> 信号的示例：

</p>
<pre><code>rl.on(&apos;SIGINT&apos;, function() {
  rl.question(&apos;Are you sure you want to exit?&apos;, function(answer) {
    if (answer.match(/^y(es)?$/i)) rl.pause();
  });
});</code></pre>
<h3>Event: &apos;SIGTSTP&apos;<span><a href="all.html#all_event_sigtstp_1" id="all_event_sigtstp_1">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p><strong>This does not work on Windows.</strong>

</p>
<p><strong>该功能不支持 windows 操作系统</strong>

</p>
<p>Emitted whenever the <code>input</code> stream receives a <code>^Z</code>, respectively known as
<code>SIGTSTP</code>. If there is no <code>SIGTSTP</code> event listener present when the <code>input</code>
stream receives a <code>SIGTSTP</code>, the program will be sent to the background.

</p>
<p>只要<code>input</code>流接收到<code>^Z</code>时就被触发, 分别被认为<code>SIGTSTP</code>. 当<code>input</code>流接收到
 <code>SIGTSTP</code>时，如果没有<code>SIGTSTP</code> 事件监听器 ,程序会被发送到后台 .

</p>
<p>When the program is resumed with <code>fg</code>, the <code>pause</code> and <code>SIGCONT</code> events will be
emitted. You can use either to resume the stream.

</p>
<p>当程序使用参数 <code>fg</code> 重启，<code>pause</code> 和 <code>SIGCONT</code> 事件将会被触发。
你可以使用两者中任一事件来恢复流。

</p>
<p>The <code>pause</code> and <code>SIGCONT</code> events will not be triggered if the stream was paused
before the program was sent to the background.

</p>
<p>在程序被发送到后台之前，如果流暂停，<code>pause</code> 和 <code>SIGCONT</code> 事件将不会被触发。

</p>
<p>Example of listening for <code>SIGTSTP</code>:

</p>
<p>监听 <code>SIGTSTP</code> 的示例：

</p>
<pre><code>rl.on(&apos;SIGTSTP&apos;, function() {
  // 这将重载 SIGTSTP并防止程序转到
  // 后台.
  console.log(&apos;Caught SIGTSTP.&apos;);
});</code></pre>
<h3>Event: &apos;SIGCONT&apos;<span><a href="all.html#all_event_sigcont_1" id="all_event_sigcont_1">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p><strong>This does not work on Windows.</strong>

</p>
<p><strong>该功能不支持 windows 操作系统</strong>

</p>
<p>Emitted whenever the <code>input</code> stream is sent to the background with <code>^Z</code>,
respectively known as <code>SIGTSTP</code>, and then continued with <code>fg(1)</code>. This event
only emits if the stream was not paused before sending the program to the
background.

</p>
<p>一旦 <code>input</code>流中含有 <code>^Z</code>并被发送到后台就会触发,分别被认为
 <code>SIGTSTP</code>, 然后继续执行<code>fg(1)</code>. 这一事件只有在流被发送后台之前没有暂停才会触发.

</p>
<p>Example of listening for <code>SIGCONT</code>:

</p>
<p>监听 <code>SIGCONT</code> 的示例:

</p>
<pre><code>rl.on(&apos;SIGCONT&apos;, function() {
  // `prompt` 将会自动恢复流
  rl.prompt();
});</code></pre>
<h2>示例: Tiny CLI<span><a href="all.html#all_tiny_cli_1" id="all_tiny_cli_1">#</a></span></h2>
<p>Here&apos;s an example of how to use all these together to craft a tiny command
line interface:

</p>
<p>这里有一个使用所有方法精心设计的小命令行程序：

</p>
<pre><code>rl.on(&apos;line&apos;, function(line) {
  switch(line.trim()) {
    case &apos;hello&apos;:
      console.log(&apos;world!&apos;);
      break;
    default:
      console.log(&apos;Say what? I might have heard `&apos; + line.trim() + &apos;`&apos;);
      break;
  }
  rl.prompt();
}).on(&apos;close&apos;, function() {
  console.log(&apos;Have a great day!&apos;);
  process.exit(0);
});</code></pre>
<h1>REPL<span><a href="all.html#all_repl_2" id="all_repl_2">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and
easily includable in other programs. The REPL provides a way to interactively
run JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.

</p>
<p>一个 Read-Eval-Print-Loop（REPL，读取-执行-输出循环）既可用于独立程序也可很容易地被集成到其它程序中。REPL 提供了一种交互地执行 JavaScript 并查看输出的方式。它可以被用作调试、测试或仅仅尝试某些东西。

</p>
<p>By executing <code>node</code> without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editing.

</p>
<p>在命令行中不带任何参数执行 <code>node</code> 您便会进入 REPL。它提供了一个简单的 Emacs 行编辑。

</p>
<pre><code>mjr:~$ node
Type &apos;.help&apos; for options.
&gt; a = [ 1, 2, 3];
[ 1, 2, 3 ]
&gt; a.forEach(function (v) {
...   console.log(v);
...   });
1
2
3</code></pre>
<p>For advanced line-editors, start node with the environmental variable
<code>NODE_NO_READLINE=1</code>. This will start the main and debugger REPL in canonical
terminal settings which will allow you to use with <code>rlwrap</code>.

</p>
<p>若想使用高级的编辑模式，设置环境变量 <code>NODE_NO_READLINE=1</code> 后运行 node。这将在允许你在可以使用 <code>rlwrap</code> 的终端上，启动高级的 REPL 模式 (the main and debugger REPL)。

</p>
<p>For example, you could add this to your bashrc file:

</p>
<p>例如，您可以将下列代码加入到您的 bashrc 文件：

</p>
<pre><code>alias node=&quot;env NODE_NO_READLINE=1 rlwrap node&quot;</code></pre>
<h2>repl.start(options)<span><a href="all.html#all_repl_start_options_1" id="all_repl_start_options_1">#</a></span></h2>
<p>Returns and starts a <code>REPLServer</code> instance. Accepts an &quot;options&quot; Object that
takes the following values:

</p>
<p>启动并返回一个 <code>REPLServer</code> 实例。接受一个包含如下内容的 &quot;options&quot; 对象：

</p>
<ul>
<li><p><code>prompt</code> - the prompt and <code>stream</code> for all I/O. Defaults to <code>&gt; </code>.</p>
</li>
<li><p><code>prompt</code> - 所有输入输出的提示符。默认是 <code>&gt; </code>.</p>
</li>
<li><p><code>input</code> - the readable stream to listen to. Defaults to <code>process.stdin</code>.</p>
</li>
<li><p><code>input</code> - 监听的可读流。默认指向标准输入流 <code>process.stdin</code>。</p>
</li>
<li><p><code>output</code> - the writable stream to write readline data to. Defaults to
<code>process.stdout</code>.</p>
</li>
<li><p><code>output</code> - 用来输出数据的可写流。默认指向标准输出流 <code>process.stdout</code>。</p>
</li>
<li><p><code>terminal</code> - pass <code>true</code> if the <code>stream</code> should be treated like a TTY, and
have ANSI/VT100 escape codes written to it. Defaults to checking <code>isTTY</code>
on the <code>output</code> stream upon instantiation.</p>
</li>
<li><p><code>terminal</code> - 如果 <code>stream</code> 应该被当做 TTY 来对待并且有 ANSI/VT100 转义时，则传 <code>true</code>。 默认使用 <code>output</code> 实例的 <code>isTTY</code>来检查。</p>
</li>
<li><p><code>eval</code> - function that will be used to eval each given line. Defaults to
an async wrapper for <code>eval()</code>. See below for an example of a custom <code>eval</code>.</p>
</li>
<li><p><code>eval</code> - 用来对每一行进行求值的函数。 默认为<code>eval()</code>的一个异步包装函数。下面给出一个自定义<code>eval</code>的例子。</p>
</li>
<li><p><code>useColors</code> - a boolean which specifies whether or not the <code>writer</code> function
should output colors. If a different <code>writer</code> function is set then this does
nothing. Defaults to the repl&apos;s <code>terminal</code> value.</p>
</li>
<li><p><code>useColors</code> - 一个布尔值，表明了<code>writer</code>函数是否会输出颜色。如果设定了一个不同的<code>writer</code>函数，那么这不会产生任何影响。默认为repl的<code>terminal</code>值。</p>
</li>
<li><p><code>useGlobal</code> - if set to <code>true</code>, then the repl will use the <code>global</code> object,
instead of running scripts in a separate context. Defaults to <code>false</code>.</p>
</li>
<li><p><code>useGlobal</code> - 如果设定为<code>true</code>，那么repl就会使用<code>global</code>对象而不是在一个独立环境里运行脚本。默认为<code>false</code>。</p>
</li>
<li><p><code>ignoreUndefined</code> - if set to <code>true</code>, then the repl will not output the
return value of command if it&apos;s <code>undefined</code>. Defaults to <code>false</code>.</p>
</li>
<li><p><code>ignoreUndefined</code> - 如果设定为<code>true</code>，那么repl将不会输出未定义命令的返回值。默认为<code>false</code>。</p>
</li>
<li><p><code>writer</code> - the function to invoke for each command that gets evaluated which
returns the formatting (including coloring) to display. Defaults to
<code>util.inspect</code>.</p>
</li>
<li><p><code>writer</code> - 每一个命令被求值时都会调用此函数，而该函数会返回显示的格式（包括颜色）。默认为<code>util.inspect</code>。
<code>util.inspect</code>.</p>
</li>
</ul>
<p>You can use your own <code>eval</code> function if it has following signature:

</p>
<p>你可以使用你自己的<code>eval</code>函数，只有它有如下的签名：

</p>
<pre><code>function eval(cmd, context, filename, callback) {
  callback(null, result);
}</code></pre>
<p>Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.

</p>
<p>多个REPL可以在同一个运行的节点实例上打开。它们共享同一个global对象，但分别有各自的I/O。

</p>
<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:

</p>
<p>以下是通过标准输入流（stdin）、Unix socket 以及 TCP socket 三种情况来启动 REPL 的例子:

</p>
<pre><code>net.createServer(function (socket) {
  connections += 1;
  repl.start({
    prompt: &quot;node via TCP socket&gt; &quot;,
    input: socket,
    output: socket
  }).on(&apos;exit&apos;, function() {
    socket.end();
  });
}).listen(5001);</code></pre>
<p>Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. <code>telnet</code> is useful
for connecting to TCP sockets, and <code>socat</code> can be used to connect to both Unix and
TCP sockets.

</p>
<p>从命令行运行该程序，将会从标准输入流启动 REPL 模式。 其他的 REPL 客户端也可以通过 Unix socket 或者 TCP socket 连接。 <code>telnet</code> 常用于连接 TCP sockets，而 <code>socat</code> 则可以同时用来连接 Unix 和 TCP sockets。

</p>
<p>By starting a REPL from a Unix socket-based server instead of stdin, you can
connect to a long-running node process without restarting it.

</p>
<p>通过从一个Unix的套接字服务器而不是stdin来启动REPL, 你可以连接到一个长久运行的node进程而不不需要重启。

</p>
<p>For an example of running a &quot;full-featured&quot; (<code>terminal</code>) REPL over
a <code>net.Server</code> and <code>net.Socket</code> instance, see: <a href="https://gist.github.com/2209310">https://gist.github.com/2209310</a>

</p>
<p>一个在<code>net.Server</code>和<code>net.Socket</code>实例上运行的&quot;全功能&quot;(<code>terminal</code>)REPL的例子可以查看这里： <a href="https://gist.github.com/2209310">https://gist.github.com/2209310</a>

</p>
<p>For an example of running a REPL instance over <code>curl(1)</code>,
see: <a href="https://gist.github.com/2053342">https://gist.github.com/2053342</a>

</p>
<p>一个在<code>curl(1)</code>上运行的REPL实例的例子可以查看这里： <a href="https://gist.github.com/2053342">https://gist.github.com/2053342</a>

</p>
<h3>事件: &apos;exit&apos;<span><a href="all.html#all_exit_6" id="all_exit_6">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted when the user exits the REPL in any of the defined ways. Namely, typing
<code>.exit</code> at the repl, pressing Ctrl+C twice to signal SIGINT, or pressing Ctrl+D
to signal &quot;end&quot; on the <code>input</code> stream.

</p>
<p>当用户通过任意预定义的方式退出REPL，该事件被分发。比如，在repl里输入<code>.exit</code>，按Ctrl+C两次来发送SIGINT信号，或者在<code>input</code>流上按Ctrl+D来发送&quot;end&quot;。

</p>
<p>Example of listening for <code>exit</code>:

</p>
<p>监听 <code>exit</code> 事件的例子：

</p>
<pre><code>r.on(&apos;exit&apos;, function () {
  console.log(&apos;从 REPL 得到 &quot;exit&quot; 事件！&apos;);
  process.exit();
});</code></pre>
<h3>事件: &apos;reset&apos;<span><a href="all.html#all_reset_1" id="all_reset_1">#</a></span></h3>
<p><code>function (context) {}</code>

</p>
<p><code>function (context) {}</code>

</p>
<p>Emitted when the REPL&apos;s context is reset. This happens when you type <code>.clear</code>.
If you start the repl with <code>{ useGlobal: true }</code> then this event will never
be emitted.

</p>
<p>当REPL的上下文被重置时，该事件被分发。当你打<code>.clear</code>命令时这种情况就会发生。如果你以<code>{ useGlobal: true }</code>来启动repl，那么这个事件就永远不会被分发。

</p>
<p>Example of listening for <code>reset</code>:

</p>
<p>监听<code>reset</code>的例子：

</p>
<pre><code>// 当一个新的上下文被创建时，扩充这个上下文。
r.on(&apos;reset&apos;, function (context) {
  console.log(&apos;repl有一个新的上下文&apos;);
  someExtension.extend(context);
});</code></pre>
<h2>REPL 特性<span><a href="all.html#all_repl_3" id="all_repl_3">#</a></span></h2>
<!-- type=misc -->

<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.
Tab completion is supported for both global and local variables.

</p>
<p>在REPL里，Control+D会退出。可以输入多行表达式。对于全局变量和本地变量都支持自动缩进。

</p>
<p>The special variable <code>_</code> (underscore) contains the result of the last expression.

</p>
<p>特殊变量 <code>_</code> (下划线)储存了上一个表达式的结果。

</p>
<pre><code>&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
[ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
&gt; _.length
3
&gt; _ += 1
4</code></pre>
<p>The REPL provides access to any variables in the global scope. You can expose
a variable to the REPL explicitly by assigning it to the <code>context</code> object
associated with each <code>REPLServer</code>.  For example:

</p>
<p>REPL提供了访问global域里所有变量的权限。通过将一个变量赋值给与每一个<code>REPLServer</code>关联的<code>context</code>对象，你可以显式地将一个变量暴露给REPL。例如：

</p>
<pre><code>repl.start(&quot;&gt; &quot;).context.m = msg;</code></pre>
<p>Things in the <code>context</code> object appear as local within the REPL:

</p>
<p>在<code>context</code>对象里的东西，会在REPL以本地变量的形式出现。

</p>
<pre><code>mjr:~$ node repl_test.js
&gt; m
&apos;message&apos;</code></pre>
<p>There are a few special REPL commands:

</p>
<p>有几个特殊的REPL命令：

</p>
<ul>
<li><code>.break</code> - While inputting a multi-line expression, sometimes you get lost
or just don&apos;t care about completing it. <code>.break</code> will start over.</li>
<li><code>.clear</code> - Resets the <code>context</code> object to an empty object and clears any
multi-line expression.</li>
<li><code>.exit</code> - Close the I/O stream, which will cause the REPL to exit.</li>
<li><code>.help</code> - Show this list of special commands.</li>
<li><code>.save</code> - Save the current REPL session to a file<blockquote>
<p>.save ./file/to/save.js</p>
</blockquote>
</li>
<li><p><code>.load</code> - Load a file into the current REPL session.</p>
<blockquote>
<p>.load ./file/to/load.js</p>
</blockquote>
</li>
<li><p><code>.break</code> - 当你输入一个多行表达式时，有时你会脑子突然断路或者你不想完成这个表达式了。<code>break</code>让你可以重头再来。</p>
</li>
<li><code>.clear</code> - 重置<code>context</code>对象为一个空对象，并且清除所有的多行表达式。</li>
<li><code>.exit</code> - 关闭I/O流，使得REPL退出。</li>
<li><code>.help</code> - 显示这个特殊命令的列表。</li>
<li><code>.save</code> - 将当前的REPL会话保存到一个文件<blockquote>
<p>.save ./file/to/save.js</p>
</blockquote>
</li>
<li><code>.load</code> - 将一个文件装载到当前的REPL会话。<blockquote>
<p>.load ./file/to/load.js</p>
</blockquote>
</li>
</ul>
<p>The following key combinations in the REPL have these special effects:

</p>
<p>下面的组合键在REPL中有以下效果：

</p>
<ul>
<li><code>&lt;ctrl&gt;C</code> - Similar to the <code>.break</code> keyword.  Terminates the current
command.  Press twice on a blank line to forcibly exit.</li>
<li><p><code>&lt;ctrl&gt;D</code> - Similar to the <code>.exit</code> keyword.</p>
</li>
<li><p><code>&lt;ctrl&gt;C</code> - 与<code>.break</code>关键字类似。终止正在执行的命令。在一个空行连按两次会强制退出。</p>
</li>
<li><p><code>&lt;ctrl&gt;D</code> - 与<code>.exit</code>关键字类似。</p>
<h1>执行 JavaScript<span><a href="all.html#all_javascript_1" id="all_javascript_1">#</a></span></h1>
<p>稳定度: 3 - 稳定</p>
</li>
</ul>
<!--name=vm-->

<p>You can access this module with:

</p>
<p>你可以这样引入此模块：

</p>
<pre><code>var vm = require(&apos;vm&apos;);</code></pre>
<p>JavaScript code can be compiled and run immediately or compiled, saved, and run
later.

</p>
<p>JavaScript 代码可以被编译并立即执行，也可以在编译后保存，留到稍后执行。

</p>
<h2>vm.runInThisContext(code, [options])<span><a href="all.html#all_vm_runinthiscontext_code_options_1" id="all_vm_runinthiscontext_code_options_1">#</a></span></h2>
<p><code>vm.runInThisContext()</code> compiles <code>code</code>, runs it and returns the result. Running
code does not have access to local scope, but does have access to the current
<code>global</code> object.

</p>
<p><code>vm.runInThisContext()</code> 对 <code>code</code> 进行编译、运行并返回结果。
 被运行的代码没有对本地作用域 (local scope) 的访问权限，但是可以访问当前的 <code>global</code> 对象。

</p>
<p>Example of using <code>vm.runInThisContext</code> and <code>eval</code> to run the same code:

</p>
<p>使用 <code>vm.runInThisContext</code> 和 <code>eval</code> 分别执行相同的代码：

</p>
<pre><code>// vmResult: &apos;vm&apos;, localVar: &apos;initial value&apos;
// evalResult: &apos;eval&apos;, localVar: &apos;eval&apos;</code></pre>
<p><code>vm.runInThisContext</code> does not have access to the local scope, so <code>localVar</code> is
unchanged. <code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.

</p>
<p><code>vm.runInThisContext</code> 无法访问本地作用域，因此 <code>localVar</code> 没有被改变。
<code>eval</code> 可以访问本地作用域，因此 <code>localVar</code> 被改变。

</p>
<p>In this way <code>vm.runInThisContext</code> is much like an <a href="http://es5.github.io/#x10.4.2">indirect <code>eval</code> call</a>,
e.g. <code>(0,eval)(&apos;code&apos;)</code>. However, it also has the following additional options:

</p>
<p>这种情况下 <code>vm.runInThisContext</code> 可以看作一种 <a href="http://es5.github.io/#x10.4.2">间接的 <code>eval</code> 调用</a>，
如 <code>(0,eval)(&apos;code&apos;)</code>。但是 <code>vm.runInThisContext</code> 也提供下面几个额外的参数：

</p>
<ul>
<li><code>filename</code>: allows you to control the filename that shows up in any stack
traces produced.</li>
<li><code>displayErrors</code>: whether or not to print any errors to stderr, with the
line of code that caused them highlighted, before throwing an exception.
Will capture both syntax errors from compiling <code>code</code> and runtime errors
thrown by executing the compiled code. Defaults to <code>true</code>.</li>
<li><p><code>timeout</code>: a number of milliseconds to execute <code>code</code> before terminating
execution. If execution is terminated, an <code>Error</code> will be thrown.</p>
</li>
<li><p><code>filename</code>: 允许您更改显示在站追踪 (stack trace) 中的文件名</p>
</li>
<li><code>displayErrors</code>: 是否在抛出异常前输出带高亮错误代码行的错误信息到 stderr。
将会捕捉所有在编译 <code>code</code> 的过程中产生的语法错误以及执行过程中产生的运行时错误。
默认为 <code>true</code></li>
<li><code>timeout</code>: 以毫秒为单位规定 <code>code</code> 允许执行的时间。在执行过程中被终止时会有 <code>Error</code> 抛出。</li>
</ul>
<h2>vm.createContext([sandbox])<span><a href="all.html#all_vm_createcontext_sandbox_1" id="all_vm_createcontext_sandbox_1">#</a></span></h2>
<p>If given a <code>sandbox</code> object, will &quot;contextify&quot; that sandbox so that it can be
used in calls to <code>vm.runInContext</code> or <code>script.runInContext</code>. Inside scripts run
as such, <code>sandbox</code> will be the global object, retaining all its existing
properties but also having the built-in objects and functions any standard
<a href="http://es5.github.io/#x15.1">global object</a> has. Outside of scripts run by the vm module, <code>sandbox</code> will
be unchanged.

</p>
<p>如提供 <code>sandbox</code> 对象则将沙箱 (sandbox) 对象 “上下文化 (contextify)” 供 <code>vm.runInContext</code> 或者 <code>script.runInContext</code> 使用。
以此方式运行的脚本将以 <code>sandbox</code> 作为全局对象，该对象将在保留其所有的属性的基础上拥有标准 <a href="http://es5.github.io/#x15.1">全局对象</a> 所拥有的内置对象和函数。
在由 vm 模块运行的脚本之外的地方 <code>sandbox</code> 将不会被改变。

</p>
<p>If not given a sandbox object, returns a new, empty contextified sandbox object
you can use.

</p>
<p>如果没有提供沙箱对象，则返回一个新建的、没有任何对象被上下文化的可用沙箱。

</p>
<p>This function is useful for creating a sandbox that can be used to run multiple
scripts, e.g. if you were emulating a web browser it could be used to create a
single sandbox representing a window&apos;s global object, then run all <code>&lt;script&gt;</code>
tags together inside that sandbox.

</p>
<p>此函数可用于创建可执行多个脚本的沙箱，
比如，在模拟浏览器的时候可以使用该函数创建一个用于表示 window 全局对象的沙箱，
并将所有 <code>&lt;script&gt;</code> 标签放入沙箱执行。

</p>
<h2>vm.isContext(sandbox)<span><a href="all.html#all_vm_iscontext_sandbox_1" id="all_vm_iscontext_sandbox_1">#</a></span></h2>
<p>Returns whether or not a sandbox object has been contextified by calling
<code>vm.createContext</code> on it.

</p>
<p>返回沙箱对象是否已经通过 <code>vm.createContext</code> 上下文化 (contextified)

</p>
<h2>vm.runInContext(code, contextifiedSandbox, [options])<span><a href="all.html#all_vm_runincontext_code_contextifiedsandbox_options_1" id="all_vm_runincontext_code_contextifiedsandbox_options_1">#</a></span></h2>
<p><code>vm.runInContext</code> compiles <code>code</code>, then runs it in <code>contextifiedSandbox</code> and
returns the result. Running code does not have access to local scope. The
<code>contextifiedSandbox</code> object must have been previously contextified via
<code>vm.createContext</code>; it will be used as the global object for <code>code</code>.

</p>
<p><code>vm.runInContext</code> 编译 <code>code</code> 放入 <code>contextifiedSandbox</code> 执行并返回执行结果。
被执行的代码对 本地作用域 (local scope) 没有访问权。
<code>contextifiedSandbox</code> 必须在使用前通过 <code>vm.createContext</code> 上下文化，用作 <code>code</code> 的全局对象。

</p>
<p><code>vm.runInContext</code> takes the same options as <code>vm.runInThisContext</code>.

</p>
<p><code>vm.runInContext</code> 使用与 <code>vm.runInThisContext</code> 相同的 选项 (<code>options</code>)

</p>
<p>Example: compile and execute differnt scripts in a single existing context.

</p>
<p>示例：在同一个上下文中编译并执行不同的脚本

</p>
<pre><code>// { globalVar: 1024 }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>vm.runInContext</code> is quite useful, but safely running untrusted code requires a
separate process.

</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>vm.runInContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。

</p>
<h2>vm.runInNewContext(code, [sandbox], [options])<span><a href="all.html#all_vm_runinnewcontext_code_sandbox_options_1" id="all_vm_runinnewcontext_code_sandbox_options_1">#</a></span></h2>
<p><code>vm.runInNewContext</code> compiles <code>code</code>, contextifies <code>sandbox</code> if passed or
creates a new contextified sandbox if it&apos;s omitted, and then runs the code with
the sandbox as the global object and returns the result.

</p>
<p><code>vm.runInNewContext</code> 首先编译 <code>code</code>，若提供 <code>sandbox</code> 则将 <code>sandbox</code> 上下文化，若未提供则创建一个新的沙箱并上下文化，
然后将代码放入沙箱作为全局对象的上下文内执行并返回结果。

</p>
<p><code>vm.runInNewContext</code> takes the same options as <code>vm.runInThisContext</code>.

</p>
<p><code>vm.runInNewContext</code> 使用与 <code>vm.runInThisContext</code> 相同的 选项 (<code>options</code>)

</p>
<p>Example: compile and execute code that increments a global variable and sets a
new one. These globals are contained in the sandbox.

</p>
<p>示例: 编译并执行一段“自增一个全局变量然后创建一个全局变量”的代码。这些被操作的全局变量会被保存在沙箱中。

</p>
<pre><code>// { animal: &apos;cat&apos;, count: 3, name: &apos;kitty&apos; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>vm.runInNewContext</code> is quite useful, but safely running untrusted code requires
a separate process.

</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>vm.runInNewContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。

</p>
<h2>类: Script<span><a href="all.html#all_script_1" id="all_script_1">#</a></span></h2>
<p>A class for holding precompiled scripts, and running them in specific sandboxes.

</p>
<p>用于存放预编译脚本的类，可将预编译代码放入沙箱执行。

</p>
<h3>new vm.Script(code, options)<span><a href="all.html#all_new_vm_script_code_options_1" id="all_new_vm_script_code_options_1">#</a></span></h3>
<p>Creating a new <code>Script</code> compiles <code>code</code> but does not run it. Instead, the
created <code>vm.Script</code> object represents this compiled code. This script can be run
later many times using methods below. The returned script is not bound to any
global object. It is bound before each run, just for that run.

</p>
<p>创建一个新的 <code>Script</code> 用于编译 <code>code</code> 但是不执行。使用被创建的 <code>vm.Script</code> 用来表示完成编译的代码。
这份可以在后面的代码中执行多次。
返回的脚本是未绑定任何全局对象 (上下文 context) 的，全局对象仅在每一次执行的时候被绑定，执行结束后即释放绑定。

</p>
<p>The options when creating a script are:

</p>
<p>创建脚本的选项 (option) 有：

</p>
<ul>
<li><code>filename</code>: allows you to control the filename that shows up in any stack
traces produced from this script.</li>
<li><p><code>displayErrors</code>: whether or not to print any errors to stderr, with the
line of code that caused them highlighted, before throwing an exception.
Applies only to syntax errors compiling the code; errors while running the
code are controlled by the options to the script&apos;s methods.</p>
</li>
<li><p><code>filename</code>: 允许您更改显示在站追踪 (stack trace) 中的文件名</p>
</li>
<li><code>displayErrors</code>: 是否在抛出异常前输出带高亮错误代码行的错误信息到 stderr。
仅捕捉所有在编译过程中产生的语法错误（运行时错误由运行脚本选项控制）。</li>
</ul>
<h3>script.runInThisContext([options])<span><a href="all.html#all_script_runinthiscontext_options_1" id="all_script_runinthiscontext_options_1">#</a></span></h3>
<p>Similar to <code>vm.runInThisContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInThisContext</code> runs <code>script</code>&apos;s compiled code and returns the result.
Running code does not have access to local scope, but does have access to the
current <code>global</code> object.

</p>
<p>类似 <code>vm.runInThisContext</code> 只是作为预编译的 <code>Script</code> 对象方法。
<code>script.runInThisContext</code> 执行被编译的 <code>script</code> 并返回结果。
被运行的代码没有对本地作用域 (local scope) 的访问权限，但是可以访问当前的 <code>global</code> 对象。

</p>
<p>Example of using <code>script.runInThisContext</code> to compile code once and run it
multiple times:

</p>
<p>示例: 使用 <code>script.runInThisContext</code> 编译代码并多次执行: 

</p>
<pre><code>// 1000</code></pre>
<p>The options for running a script are:

</p>
<p>运行脚本的选项 (option) 有: 

</p>
<ul>
<li><code>displayErrors</code>: whether or not to print any runtime errors to stderr, with
the line of code that caused them highlighted, before throwing an exception.
Applies only to runtime errors executing the code; it is impossible to create
a <code>Script</code> instance with syntax errors, as the constructor will throw.</li>
<li><p><code>timeout</code>: a number of milliseconds to execute the script before terminating
execution. If execution is terminated, an <code>Error</code> will be thrown.</p>
</li>
<li><p><code>displayErrors</code>: 是否在抛出异常前输出带高亮错误代码行的错误信息到 stderr。
仅捕捉所有执行过程中产生的运行时错误（语法错误会在 <code>Script</code> 示例创建时就发生，因此不可能创建出带语法错误的 <code>Script</code> 对象）。</p>
</li>
<li><code>timeout</code>: 以毫秒为单位规定 <code>code</code> 允许执行的时间。在执行过程中被终止时会有 <code>Error</code> 抛出。</li>
</ul>
<h3>script.runInContext(contextifiedSandbox, [options])<span><a href="all.html#all_script_runincontext_contextifiedsandbox_options_1" id="all_script_runincontext_contextifiedsandbox_options_1">#</a></span></h3>
<p>Similar to <code>vm.runInContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInContext</code> runs <code>script</code>&apos;s compiled code in <code>contextifiedSandbox</code>
and returns the result. Running code does not have access to local scope.

</p>
<p>类似 <code>vm.runInContext</code> 只是作为预编译的 <code>Script</code> 对象方法。
<code>script.runInContext</code> 在 <code>contextifiedSandbox</code> 中执行 <code>script</code> 编译出的代码，并返回结果。
被运行的代码没有对本地作用域 (local scope) 的访问权限。

</p>
<p><code>script.runInContext</code> takes the same options as <code>script.runInThisContext</code>.

</p>
<p><code>script.runInContext</code> 使用与 <code>script.runInThisContext</code> 相同的 选项 (option)。

</p>
<p>Example: compile code that increments a global variable and sets one, then
execute the code multiple times. These globals are contained in the sandbox.

</p>
<p>示例: 编译一段“自增一个全局变量然后创建一个全局变量”的代码，然后多次执行此代码，
被操作的全局变量会被保存在沙箱中。

</p>
<pre><code>// { animal: &apos;cat&apos;, count: 12, name: &apos;kitty&apos; }</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>script.runInContext</code> is quite useful, but safely running untrusted code
requires a separate process.

</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>script.runInContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。

</p>
<h3>script.runInNewContext([sandbox], [options])<span><a href="all.html#all_script_runinnewcontext_sandbox_options_1" id="all_script_runinnewcontext_sandbox_options_1">#</a></span></h3>
<p>Similar to <code>vm.runInNewContext</code> but a method of a precompiled <code>Script</code> object.
<code>script.runInNewContext</code> contextifies <code>sandbox</code> if passed or creates a new
contextified sandbox if it&apos;s omitted, and then runs <code>script</code>&apos;s compiled code
with the sandbox as the global object and returns the result. Running code does
not have access to local scope.

</p>
<p>类似 <code>vm.runInNewContext</code> 但是作为预编译的 <code>Script</code> 对象方法。
若提供 <code>sandbox</code> 则 <code>script.runInNewContext</code> 将 <code>sandbox</code> 上下文化，若未提供，则创建一个新的上下文化的沙箱，
然后将代码放入沙箱作为全局对象的上下文内执行并返回结果。

</p>
<p><code>script.runInNewContext</code> takes the same options as <code>script.runInThisContext</code>.

</p>
<p><code>script.runInNewContext</code> 使用与 <code>script.runInThisContext</code> 相同的 选项 (option)。

</p>
<p>Example: compile code that sets a global variable, then execute the code
multiple times in different contexts. These globals are set on and contained in
the sandboxes.

</p>
<p>示例: 编译一段“写入一个全局变量”的代码，然后将代码放入不同的上下文 (context) 执行，这些被操作的全局变量会被保存在沙箱中。

</p>
<pre><code>// [{ globalVar: &apos;set&apos; }, { globalVar: &apos;set&apos; }, { globalVar: &apos;set&apos; }]</code></pre>
<p>Note that running untrusted code is a tricky business requiring great care.
<code>script.runInNewContext</code> is quite useful, but safely running untrusted code
requires a separate process.


</p>
<p>执行不可信代码 (untrusted code) 是一件充满技巧而且需要非常小心的工作。
<code>script.runInNewContext</code> 十分好用，但是安全地运行不可信代码还需要将这些代码放入单独的进程里面执行。
</p>
<h1>子进程<span><a href="all.html#all_80" id="all_80">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>Node provides a tri-directional <code>popen(3)</code> facility through the
<code>child_process</code> module.

</p>
<p>Node 通过 <code>child_process</code> 模块提供了类似 <code>popen(3)</code> 的处理三向数据流（stdin/stdout/stderr）的功能。

</p>
<p>It is possible to stream data through a child&apos;s <code>stdin</code>, <code>stdout</code>, and
<code>stderr</code> in a fully non-blocking way.  (Note that some programs use
line-buffered I/O internally.  That doesn&apos;t affect node.js but it means
data you send to the child process is not immediately consumed.)

</p>
<p>它能够以完全非阻塞的方式与子进程的 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code> 以流式传递数据。（请注意，某些程序在内部使用行缓冲 I/O。这不会影响到 node.js，但您发送到子进程的数据不会被立即消费。）

</p>
<p>To create a child process use <code>require(&apos;child_process&apos;).spawn()</code> or
<code>require(&apos;child_process&apos;).fork()</code>.  The semantics of each are slightly
different, and explained below.

</p>
<p>使用 <code>require(&apos;child_process&apos;).spawn()</code> 或 <code>require(&apos;child_process&apos;).fork()</code> 创建子进程。这两种方法的语义有些区别，下文将会解释。

</p>
<h2>类: ChildProcess<span><a href="all.html#all_childprocess_1" id="all_childprocess_1">#</a></span></h2>
<p><code>ChildProcess</code> is an <a href="events.html#events_class_events_eventemitter">EventEmitter</a>.

</p>
<p><code>ChildProcess</code> 是一个 <a href="events.html#events_class_events_eventemitter">EventEmitter</a>。

</p>
<p>Child processes always have three streams associated with them. <code>child.stdin</code>,
<code>child.stdout</code>, and <code>child.stderr</code>.  These may be shared with the stdio
streams of the parent process, or they may be separate stream objects
which can be piped to and from.

</p>
<p>子进程有三个与之关联的流：<code>child.stdin</code>、<code>child.stdout</code> 和 <code>child.stderr</code>。它们可以共享父进程的 stdio 流，也可以作为独立的被导流的流对象。

</p>
<p>The ChildProcess class is not intended to be used directly.  Use the
<code>spawn()</code> or <code>fork()</code> methods to create a Child Process instance.

</p>
<p>ChildProcess 类不能直接被使用， 使用 <code>spawn()</code> 或者 <code>fork()</code> 方法创建一个 Child Process 实例。

</p>
<h3>事件:  &apos;error&apos;<span><a href="all.html#all_error_13" id="all_error_13">#</a></span></h3>
<div><ul>
<li><p><code>err</code> <span>Error Object</span> the error.</p>
</li>
<li><p><code>err</code> <span>Error Object</span> 错误。</p>
</li>
</div></ul>
<p>Emitted when:

</p>
<p>发生于：

</p>
<ol>
<li>The process could not be spawned, or</li>
<li>The process could not be killed, or</li>
<li>Sending a message to the child process failed for whatever reason.</li>
</ol>
<ol>
<li>进程不能被创建, 或者</li>
<li>进程不能被终止掉, 或者</li>
<li>由任何原因引起的数据发送到子进程失败.</li>
</ol>
<p>See also <a href="all.html#child_process_child_kill_signal"><code>ChildProcess#kill()</code></a> and
<a href="all.html#child_process_child_send_message_sendhandle"><code>ChildProcess#send()</code></a>.

</p>
<p>参阅 <a href="all.html#child_process_child_kill_signal"><code>ChildProcess#kill()</code></a> 和
<a href="all.html#child_process_child_send_message_sendhandle"><code>ChildProcess#send()</code></a>。

</p>
<h3>事件:  &apos;exit&apos;<span><a href="all.html#all_exit_7" id="all_exit_7">#</a></span></h3>
<div><ul>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the signal passed to kill the child process, if it
was killed by the parent.</p>
</li>
<li><p><code>code</code> <span>Number</span> 假如进程正常退出，则为它的退出代码。</p>
</li>
<li><code>signal</code> <span>String</span> 假如是被父进程终止，则为所传入的终止子进程的信号。</li>
</div></ul>
<p>This event is emitted after the child process ends. If the process terminated
normally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If
the process terminated due to receipt of a signal, <code>signal</code> is the string name
of the signal, otherwise <code>null</code>.

</p>
<p>这个事件是在子进程被结束的时候触发的. 假如进程被正常结束，‘code’就是退出进程的指令代码, 否则为&apos;null&apos;. 假如进程是由于接受到signal结束的, <code>signal</code> 就代表着信号的名称, 否则为<code>null</code>.

</p>
<p>Note that the child process stdio streams might still be open.

</p>
<p>注意子进程的 stdio 流可能仍为开启状态。

</p>
<p>See <code>waitpid(2)</code>.

</p>
<p>参阅<code>waitpid(2)</code>.

</p>
<h3>事件: &apos;close&apos;<span><a href="all.html#all_close_17" id="all_close_17">#</a></span></h3>
<div><ul>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the signal passed to kill the child process, if it
was killed by the parent.</p>
</li>
<li><p><code>code</code> <span>Number</span> 假如进程正常退出，则为它的退出代码。</p>
</li>
<li><code>signal</code> <span>String</span> 假如是被父进程终止，则为所传入的终止子进程的信号。</li>
</div></ul>
<p>This event is emitted when the stdio streams of a child process have all
terminated.  This is distinct from &apos;exit&apos;, since multiple processes
might share the same stdio streams.

</p>
<p>这个事件会在一个子进程的所有stdio流被终止时触发， 这和&apos;exit&apos;事件有明显的不同，因为多进程有时候会共享同一个stdio流

</p>
<h3>事件: &apos;disconnect&apos;<span><a href="all.html#all_disconnect_3" id="all_disconnect_3">#</a></span></h3>
<p>This event is emitted after using the <code>.disconnect()</code> method in the parent or
in the child. After disconnecting it is no longer possible to send messages.
An alternative way to check if you can send messages is to see if the
<code>child.connected</code> property is <code>true</code>.

</p>
<p>在子进程或父进程中使用使用.disconnect()方法后，这个事件会被触发，在断开之后，就不可能再相互发送信息了。可以通过检查子进程的child.connected属性是否为true去检查是否可以发送信息

</p>
<h3>事件: &apos;message&apos;<span><a href="all.html#all_message_4" id="all_message_4">#</a></span></h3>
<div><ul>
<li><code>message</code> <span>Object</span> a parsed JSON object or primitive value</li>
<li><p><code>sendHandle</code> <span>Handle object</span> a Socket or Server object</p>
</li>
<li><p><code>message</code> <span>Object</span> 一个已解析的JSON对象或者原始类型值</p>
</li>
<li><code>sendHandle</code> <span>Handle object</span> 一个socket 或者 server对象</li>
</div></ul>
<p>Messages send by <code>.send(message, [sendHandle])</code> are obtained using the
<code>message</code> event.

</p>
<p>通过.send()发送的信息可以通过监听&apos;message&apos;事件获取到

</p>
<h3>child.stdin<span><a href="all.html#all_child_stdin_1" id="all_child_stdin_1">#</a></span></h3>
<div><ul>
<li><p><span>Stream object</span></p>
</li>
<li><p><span>Stream object</span></p>
</li>
</div></ul>
<p>A <code>Writable Stream</code> that represents the child process&apos;s <code>stdin</code>.
Closing this stream via <code>end()</code> often causes the child process to terminate.

</p>
<p>子进程的&apos;stdin&apos;是一个‘可写流’，通过end()方法关闭该可写流可以终止子进程，

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<p>假如子进程的stdio流与父线程共享，这个child.stdin不会被设置

</p>
<h3>child.stdout<span><a href="all.html#all_child_stdout_1" id="all_child_stdout_1">#</a></span></h3>
<div><ul>
<li><p><span>Stream object</span></p>
</li>
<li><p><span>Stream object</span></p>
</li>
</div></ul>
<p>A <code>Readable Stream</code> that represents the child process&apos;s <code>stdout</code>.

</p>
<p>子进程的<code>stdout</code>是个可读流.

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<p>假如子进程的stdio流与父线程共享，这个child.stdin不会被设置

</p>
<h3>child.stderr<span><a href="all.html#all_child_stderr_1" id="all_child_stderr_1">#</a></span></h3>
<div><ul>
<li><p><span>Stream object</span></p>
</li>
<li><p><span>Stream object</span></p>
</li>
</div></ul>
<p>A <code>Readable Stream</code> that represents the child process&apos;s <code>stderr</code>.

</p>
<p>子进程的stderr是一个可读流

</p>
<p>If the child stdio streams are shared with the parent, then this will
not be set.

</p>
<p>假如子进程的stdio流与父线程共享，这个child.stdin不会被设置

</p>
<h3>child.pid<span><a href="all.html#all_child_pid_1" id="all_child_pid_1">#</a></span></h3>
<div><ul>
<li><p><span>Integer</span></p>
</li>
<li><p><span>Integer</span></p>
</li>
</div></ul>
<p>The PID of the child process.

</p>
<p>子进程的PID

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>console.log(&apos;Spawned child pid: &apos; + grep.pid);
grep.stdin.end();</code></pre>
<h3>child.kill([signal])<span><a href="all.html#all_child_kill_signal_1" id="all_child_kill_signal_1">#</a></span></h3>
<div><ul>
<li><p><code>signal</code> <span>String</span></p>
</li>
<li><p><code>signal</code> <span>String</span></p>
</li>
</div></ul>
<p>Send a signal to the child process. If no argument is given, the process will
be sent <code>&apos;SIGTERM&apos;</code>. See <code>signal(7)</code> for a list of available signals.

</p>
<p>发送一个信号给子线程. 假如没有给参数, 将会发送 <code>&apos;SIGTERM&apos;</code>. 参阅 <code>signal(7)</code> 查看所有可用的signals列表

</p>
<pre><code>// send SIGHUP to process
grep.kill(&apos;SIGHUP&apos;);</code></pre>
<p>May emit an <code>&apos;error&apos;</code> event when the signal cannot be delivered. Sending a
signal to a child process that has already exited is not an error but may
have unforeseen consequences: if the PID (the process ID) has been reassigned
to another process, the signal will be delivered to that process instead.
What happens next is anyone&apos;s guess.

</p>
<p>当一个signal不能被传递的时候，会触发一个&apos;error&apos;事件， 发送一个信号到已终止的子线程不会发生错误，但是可能引起不可预见的后果， 假如该子进程的ID已经重新分配给了其他进程，signal将会被发送到其他进程上面，大家可以猜想到这发生什么后果。

</p>
<p>Note that while the function is called <code>kill</code>, the signal delivered to the
child process may not actually kill it.  <code>kill</code> really just sends a signal
to a process.

</p>
<p>注意，当函数调用‘kill’, 传递给子进程的信号不会去终结子进程， ‘kill’实际上只是发送一个信号到进程而已。

</p>
<p>See <code>kill(2)</code>

</p>
<p>See <code>kill(2)</code>

</p>
<h3>child.send(message, [sendHandle])<span><a href="all.html#all_child_send_message_sendhandle_1" id="all_child_send_message_sendhandle_1">#</a></span></h3>
<div><ul>
<li><code>message</code> <span>Object</span></li>
<li><p><code>sendHandle</code> <span>Handle object</span></p>
</li>
<li><p><code>message</code> <span>Object</span></p>
</li>
<li><code>sendHandle</code> <span>Handle object</span></li>
</div></ul>
<p>When using <code>child_process.fork()</code> you can write to the child using
<code>child.send(message, [sendHandle])</code> and messages are received by
a <code>&apos;message&apos;</code> event on the child.

</p>
<p>当使用 <code>child_process.fork()</code> 你可以使用 
<code>child.send(message, [sendHandle])</code>向子进程写数据 and 数据将通过子进程上的‘message’事件接受.

</p>
<p>For example:

</p>
<p>例如：

</p>
<pre><code>n.send({ hello: &apos;world&apos; });</code></pre>
<p>And then the child script, <code>&apos;sub.js&apos;</code> might look like this:

</p>
<p>然后是子进程脚本的代码, <code>&apos;sub.js&apos;</code> 代码如下:

</p>
<pre><code>process.send({ foo: &apos;bar&apos; });</code></pre>
<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>
will emit objects each time it receives a message on its channel.

</p>
<p>在子进程脚本中&apos;process&apos;对象有‘send()’方法， ‘process’每次通过它的信道接收到信息都会触发事件，信息以对象形式返回。

</p>
<p>There is a special case when sending a <code>{cmd: &apos;NODE_foo&apos;}</code> message. All messages
containing a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in
the <code>message</code> event, since they are internal messages used by node core.
Messages containing the prefix are emitted in the <code>internalMessage</code> event, you
should by all means avoid using this feature, it is subject to change without notice.

</p>
<p>不过发送<code>{cmd: &apos;NODE_foo&apos;}</code> 信息是个比较特殊的情况. 所有在‘cmd’属性中包含 a <code>NODE_</code>前缀的信息将不会触发‘message’事件, 因为他们是由node 核心使用的内部信息.
相反这种信息会触发 <code>internalMessage</code> 事件, 你应该通过各种方法避免使用这种特性, 他改变的时候不会接收到通知.

</p>
<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a TCP server or
socket object to another process. The child will receive the object as its
second argument to the <code>message</code> event.

</p>
<p><code>child.send()</code>的<code>sendHandle</code> 选项是用来发送一个TCP服务或者socket对象到另一个线程的，子进程将会接收这个参数作为‘message’事件的第二个参数。

</p>
<p>Emits an <code>&apos;error&apos;</code> event if the message cannot be sent, for example because
the child process has already exited.

</p>
<p>假如信息不能被发送，将会触发一个‘error’事件， 比如说因为子线程已经退出了。

</p>
<h4>例子: 发送一个server对象<span><a href="all.html#all_server_1" id="all_server_1">#</a></span></h4>
<p>Here is an example of sending a server:

</p>
<p>这里是一个发送一个server对象的例子:

</p>
<pre><code>// 创建一个handle对象，发送一个句柄.
var server = require(&apos;net&apos;).createServer();
server.on(&apos;connection&apos;, function (socket) {
  socket.end(&apos;handled by parent&apos;);
});
server.listen(1337, function() {
  child.send(&apos;server&apos;, server);
});</code></pre>
<p>And the child would the receive the server object as:

</p>
<p>同时子进程将会以如下方式接收到这个server对象:

</p>
<pre><code>process.on(&apos;message&apos;, function(m, server) {
  if (m === &apos;server&apos;) {
    server.on(&apos;connection&apos;, function (socket) {
      socket.end(&apos;handled by child&apos;);
    });
  }
});</code></pre>
<p>Note that the server is now shared between the parent and child, this means
that some connections will be handled by the parent and some by the child.

</p>
<p>注意，server对象现在有父进程和子进程共享，这意味着某些连接将会被父进程和子进程处理。

</p>
<p>For <code>dgram</code> servers the workflow is exactly the same.  Here you listen on
a <code>message</code> event instead of <code>connection</code> and use <code>server.bind</code> instead of
<code>server.listen</code>.  (Currently only supported on UNIX platforms.)

</p>
<p>对‘dgram’服务器，工作流程是一样的, 你监听的是‘message’事件，而不是 ‘connection’事件， 使用‘server.bind’ ,而不是‘server.listen’.(当前仅在UNIX平台支持)

</p>
<h4>示例: 发送socket对象<span><a href="all.html#all_socket_1" id="all_socket_1">#</a></span></h4>
<p>Here is an example of sending a socket. It will spawn two children and handle
connections with the remote address <code>74.125.127.100</code> as VIP by sending the
socket to a &quot;special&quot; child process. Other sockets will go to a &quot;normal&quot; process.

</p>
<p>这是个发送socket的例子. 他将创建两个子线程 ，同时处理连接，这是通过使用远程地址 <code>74.125.127.100</code> 作为 VIP 发送socket到一个‘特殊’的子线程. 其他的socket将会发送到‘正常’的线程里.

</p>
<pre><code>  // if this is a VIP
  if (socket.remoteAddress === &apos;74.125.127.100&apos;) {
    special.send(&apos;socket&apos;, socket);
    return;
  }
  // just the usual dudes
  normal.send(&apos;socket&apos;, socket);
});
server.listen(1337);</code></pre>
<p>The <code>child.js</code> could look like this:

</p>
<p> <code>child.js</code> 文件代码如下:

</p>
<pre><code>process.on(&apos;message&apos;, function(m, socket) {
  if (m === &apos;socket&apos;) {
    socket.end(&apos;You were handled as a &apos; + process.argv[2] + &apos; person&apos;);
  }
});</code></pre>
<p>Note that once a single socket has been sent to a child the parent can no
longer keep track of when the socket is destroyed. To indicate this condition
the <code>.connections</code> property becomes <code>null</code>.
It is also recommended not to use <code>.maxConnections</code> in this condition.

</p>
<p>注意，一旦单个的socket被发送到子进程，当这个socket被删除之后，父进程将不再对它保存跟踪，这表明了这个条件下‘.connetions’属性将变成&apos;null&apos;， 在这个条件下同时也不推荐时间‘.maxConnections’

</p>
<h3>child.disconnect()<span><a href="all.html#all_child_disconnect_1" id="all_child_disconnect_1">#</a></span></h3>
<p>To close the IPC connection between parent and child use the
<code>child.disconnect()</code> method. This allows the child to exit gracefully since
there is no IPC channel keeping it alive. When calling this method the
<code>disconnect</code> event will be emitted in both parent and child, and the
<code>connected</code> flag will be set to <code>false</code>. Please note that you can also call
<code>process.disconnect()</code> in the child process.

</p>
<p>使用<code>child.disconnect()</code> 方法关闭父进程与子进程的IPC连接. 他让子进程非常优雅的退出，因为已经没有活跃的IPC信道. 当调用这个方法，‘disconnect’事件将会同时在父进程和子进程内被触发，‘connected’的标签将会被设置成‘flase’， 请注意，你也可以在子进程中调用‘process.disconnect()’


</p>
<h2>child_process.spawn(command, [args], [options])<span><a href="all.html#all_child_process_spawn_command_args_options_1" id="all_child_process_spawn_command_args_options_1">#</a></span></h2>
<div><ul>
<li><code>command</code> <span>String</span> The command to run</li>
<li><code>args</code> <span>Array</span> List of string arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>stdio</code> <span>Array|String</span> Child&apos;s stdio configuration. (See below)</li>
<li><code>customFds</code> <span>Array</span> <strong>Deprecated</strong> File descriptors for the child to use
for stdio.  (See below)</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>detached</code> <span>Boolean</span> The child will be a process group leader.  (See below)</li>
<li><code>uid</code> <span>Number</span> Sets the user identity of the process. (See setuid(2).)</li>
<li><code>gid</code> <span>Number</span> Sets the group identity of the process. (See setgid(2).)</li>
</ul>
</li>
<li>return: <span>ChildProcess object</span></li>
</div></ul>
<ul>
<li><code>command</code> {String}要运行的命令</li>
<li><code>args</code> {Array} 字符串参数列表</li>
<li><code>options</code> {Object}<ul>
<li><code>cwd</code> {String} 子进程的当前的工作目录</li>
<li><code>stdio</code> {Array|String} 子进程 stdio 配置. (参阅下文)</li>
<li><code>customFds</code> {Array} <strong>Deprecated</strong> 作为子进程 stdio 使用的 文件标示符.  (参阅下文)</li>
<li><code>env</code> {Object} 环境变量的键值对</li>
<li><code>detached</code> {Boolean} 子进程将会变成一个进程组的领导者.  (参阅下文)</li>
<li><code>uid</code> {Number} 设置用户进程的ID. (See setuid(2).)</li>
<li><code>gid</code> {Number} 设置进程组的ID. (See setgid(2).)</li>
</ul>
</li>
<li>返回: {ChildProcess object}</li>
</ul>
<p>Launches a new process with the given <code>command</code>, with  command line arguments in <code>args</code>.
If omitted, <code>args</code> defaults to an empty Array.

</p>
<p>用给定的命令发布一个子进程，带有‘args’命令行参数，如果省略的话，‘args’默认为一个空数组

</p>
<p>The third argument is used to specify additional options, which defaults to:

</p>
<p>第三个参数被用来指定额外的设置，默认是:

</p>
<pre><code>{ cwd: undefined,
  env: process.env
}</code></pre>
<p><code>cwd</code> allows you to specify the working directory from which the process is spawned.
Use <code>env</code> to specify environment variables that will be visible to the new process.

</p>
<p><code>cwd</code>允许你从被创建的子进程中指定一个工作目录.
使用 <code>env</code> 去指定在新进程中可用的环境变量.

</p>
<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:

</p>
<p>一个运行 <code>ls -lh /usr</code>的例子, 获取<code>stdout</code>, <code>stderr</code>, 和退出代码:

</p>
<pre><code>ls.on(&apos;close&apos;, function (code) {
  console.log(&apos;child process exited with code &apos; + code);
});</code></pre>
<p>Example: A very elaborate way to run &apos;ps ax | grep ssh&apos;

</p>
<p>例子: 一个非常精巧的方法执行 &apos;ps ax | grep ssh&apos;

</p>
<pre><code>grep.on(&apos;close&apos;, function (code) {
  if (code !== 0) {
    console.log(&apos;grep process exited with code &apos; + code);
  }
});</code></pre>
<p>Example of checking for failed exec:

</p>
<p>检查执行错误的例子:

</p>
<pre><code>child.stderr.setEncoding(&apos;utf8&apos;);
child.stderr.on(&apos;data&apos;, function (data) {
  if (/^execvp\(\)/.test(data)) {
    console.log(&apos;Failed to start child process.&apos;);
  }
});</code></pre>
<p>Note that if spawn receives an empty options object, it will result in
spawning the process with an empty environment rather than using
<code>process.env</code>. This due to backwards compatibility issues with a deprecated
API.

</p>
<p>注意，当在spawn过程中接收一个空对象,这会导致创建的进程使用空的环境变量而不是使用‘process.env’.这是由于与一个废弃API向后兼容的问题.

</p>
<p>The &apos;stdio&apos; option to <code>child_process.spawn()</code> is an array where each
index corresponds to a fd in the child.  The value is one of the following:

</p>
<p><code>child_process.spawn()</code> 中的 <code>stdio</code> 选项是一个数组，每个索引对应子进程中的一个文件标识符。可以是下列值之一：

</p>
<ol>
<li><code>&apos;pipe&apos;</code> - Create a pipe between the child process and the parent process.
The parent end of the pipe is exposed to the parent as a property on the
<code>child_process</code> object as <code>ChildProcess.stdio[fd]</code>. Pipes created for
fds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout
and ChildProcess.stderr, respectively.</li>
<li><code>&apos;ipc&apos;</code> - Create an IPC channel for passing messages/file descriptors
between parent and child. A ChildProcess may have at most <em>one</em> IPC stdio
file descriptor. Setting this option enables the ChildProcess.send() method.
If the child writes JSON messages to this file descriptor, then this will
trigger ChildProcess.on(&apos;message&apos;).  If the child is a Node.js program, then
the presence of an IPC channel will enable process.send() and
process.on(&apos;message&apos;).</li>
<li><code>&apos;ignore&apos;</code> - Do not set this file descriptor in the child. Note that Node
will always open fd 0 - 2 for the processes it spawns. When any of these is
ignored node will open <code>/dev/null</code> and attach it to the child&apos;s fd.</li>
<li><code>Stream</code> object - Share a readable or writable stream that refers to a tty,
file, socket, or a pipe with the child process. The stream&apos;s underlying
file descriptor is duplicated in the child process to the fd that 
corresponds to the index in the <code>stdio</code> array.</li>
<li>Positive integer - The integer value is interpreted as a file descriptor 
that is is currently open in the parent process. It is shared with the child
process, similar to how <code>Stream</code> objects can be shared.</li>
<li><code>null</code>, <code>undefined</code> - Use default value. For stdio fds 0, 1 and 2 (in other
words, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the
default is <code>&apos;ignore&apos;</code>.</li>
</ol>
<ol>
<li><p><code>&apos;pipe&apos;</code> -在子进程与父进程之间创建一个管道，管道的父进程端以 <code>child_process</code> 的属性的形式暴露给父进程，如 <code>ChildProcess.stdio[fd]</code>。
为 文件标识（fds） 0 - 2 建立的管道也可以通过 ChildProcess.stdin，ChildProcess.stdout 及 ChildProcess.stderr 分别访问。</p>
</li>
<li><p><code>&apos;ipc&apos;</code> - 创建一个IPC通道以在父进程与子进程之间传递 消息/文件标识符。一个子进程只能有最多<em>一个</em> IPC stdio 文件标识。
设置该选项激活 ChildProcess.send() 方法。如果子进程向此文件标识符写JSON消息，则会触发 ChildProcess.on(&quot;message&quot;)。
如果子进程是一个nodejs程序，那么IPC通道的存在会激活process.send()和process.on(&apos;message&apos;)</p>
</li>
<li><p><code>&apos;ignore&apos;</code> - 不在子进程中设置该文件标识。注意，Node 总是会为其spawn的进程打开 文件标识（fd） 0 - 2。 
当其中任意一项被 ignored，node 会打开 <code>/dev/null</code> 并将其附给子进程的文件标识（fd）。</p>
</li>
<li><p><code>Stream</code> 对象 - 与子进程共享一个与tty，文件，socket，或者管道(pipe)相关的可读或可写流。
 该流底层（underlying）的文件标识在子进程中被复制给stdio数组索引对应的文件标识（fd）</p>
</li>
<li><p>正数 - 该整形值被解释为父进程中打开的文件标识符。他与子进程共享，和<code>Stream</code>被共享的方式相似。</p>
</li>
<li><p><code>null</code>, <code>undefined</code> - 使用默认值。 对于stdio fds 0,1,2（或者说stdin,stdout和stderr），pipe管道被建立。对于fd 3及往后，默认为<code>ignore</code></p>
</li>
</ol>
<p>As a shorthand, the <code>stdio</code> argument may also be one of the following
strings, rather than an array:

</p>
<p>作为快捷方式，<code>stdio</code> 参数除了数组也可以是下列字符串之一：

</p>
<ul>
<li><code>ignore</code> - <code>[&apos;ignore&apos;, &apos;ignore&apos;, &apos;ignore&apos;]</code></li>
<li><code>pipe</code> - <code>[&apos;pipe&apos;, &apos;pipe&apos;, &apos;pipe&apos;]</code></li>
<li><p><code>inherit</code> - <code>[process.stdin, process.stdout, process.stderr]</code> or <code>[0,1,2]</code></p>
</li>
<li><p><code>ignore</code> - <code>[&apos;ignore&apos;, &apos;ignore&apos;, &apos;ignore&apos;]</code></p>
</li>
<li><code>pipe</code> - <code>[&apos;pipe&apos;, &apos;pipe&apos;, &apos;pipe&apos;]</code></li>
<li><code>inherit</code> - <code>[process.stdin, process.stdout, process.stderr]</code> 或 <code>[0,1,2]</code></li>
</ul>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>// 开启一个额外的 fd=4 来与提供 startd 风格接口的程序进行交互。
spawn(&apos;prg&apos;, [], { stdio: [&apos;pipe&apos;, null, null, null, &apos;pipe&apos;] });</code></pre>
<p>If the <code>detached</code> option is set, the child process will be made the leader of a
new process group.  This makes it possible for the child to continue running 
after the parent exits.

</p>
<p>如果 <code>detached</code> 选项被设置，则子进程会被作为新进程组的 leader。这使得子进程可以在父进程退出后继续运行。

</p>
<p>By default, the parent will wait for the detached child to exit.  To prevent
the parent from waiting for a given <code>child</code>, use the <code>child.unref()</code> method,
and the parent&apos;s event loop will not include the child in its reference count.

</p>
<p>缺省情况下，父进程会等待脱离了的子进程退出。要阻止父进程等待一个给出的子进程 <code>child</code>，使用 <code>child.unref()</code> 方法，则父进程的事件循环引用计数中将不会包含这个子进程。

</p>
<p>Example of detaching a long-running process and redirecting its output to a
file:

</p>
<p>脱离一个长时间运行的进程并将它的输出重定向到一个文件的例子：

</p>
<pre><code> child.unref();</code></pre>
<p>When using the <code>detached</code> option to start a long-running process, the process
will not stay running in the background unless it is provided with a <code>stdio</code>
configuration that is not connected to the parent.  If the parent&apos;s <code>stdio</code> is
inherited, the child will remain attached to the controlling terminal.

</p>
<p>当使用 <code>detached</code> 选项来启动一个长时间运行的进程，该进程不会在后台保持运行，除非向它提供了一个不连接到父进程的 <code>stdio</code> 配置。如果继承了父进程的 <code>stdio</code>，则子进程会继续附着在控制终端。

</p>
<p>There is a deprecated option called <code>customFds</code> which allows one to specify
specific file descriptors for the stdio of the child process. This API was
not portable to all platforms and therefore removed.
With <code>customFds</code> it was possible to hook up the new process&apos; <code>[stdin, stdout,
stderr]</code> to existing streams; <code>-1</code> meant that a new stream should be created.
Use at your own risk.

</p>
<p>有一个已废弃的选项 <code>customFds</code> 允许指定特定文件描述符作为子进程的 stdio。该 API 无法移植到所有平台，因此被移除。使用 <code>customFds</code> 可以将新进程的 <code>[stdin, stdout, stderr]</code> 钩到已有流上；<code>-1</code> 表示创建新流。自己承担使用风险。

</p>
<p>See also: <code>child_process.exec()</code> and <code>child_process.fork()</code>

</p>
<p>参阅：<code>child_process.exec()</code> 和 <code>child_process.fork()</code>

</p>
<h2>child_process.exec(command, [options], callback)<span><a href="all.html#all_child_process_exec_command_options_callback_1" id="all_child_process_exec_command_options_callback_1">#</a></span></h2>
<div><ul>
<li><code>command</code> <span>String</span> The command to run, with space-separated arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span>String</span> (Default: &apos;utf8&apos;)</li>
<li><code>shell</code> <span>String</span> Shell to execute the command with
(Default: &apos;/bin/sh&apos; on UNIX, &apos;cmd.exe&apos; on Windows,  The shell should
 understand the <code>-c</code> switch on UNIX or <code>/s /c</code> on Windows. On Windows,
 command line parsing should be compatible with <code>cmd.exe</code>.)</li>
<li><code>timeout</code> <span>Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span>Number</span> (Default: 200*1024)</li>
<li><code>killSignal</code> <span>String</span> (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> called with the output when process terminates<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li><p>Return: ChildProcess object</p>
</li>
<li><p><code>command</code> <span>String</span> 将要执行的命令，用空格分隔参数</p>
</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> 子进程的当前工作目录</li>
<li><code>env</code> <span>Object</span> 环境变量键值对</li>
<li><code>encoding</code> <span>String</span> 编码（缺省为 &apos;utf8&apos;）</li>
<li><code>shell</code> <span>String</span> 运行命令的 shell（UNIX 上缺省为 &apos;/bin/sh&apos;，Windows 上缺省为 &apos;cmd.exe&apos;。该 shell 在 UNIX 上应当接受 <code>-c</code> 开关，在 Windows 上应当接受 <code>/s /c</code> 开关。在 Windows 中，命令行解析应当兼容 <code>cmd.exe</code>。）</li>
<li><code>timeout</code> <span>Number</span> 超时（缺省为 0）</li>
<li><code>maxBuffer</code> <span>Number</span> 最大缓冲（缺省为 200*1024）</li>
<li><code>killSignal</code> <span>String</span> 结束信号（缺省为 &apos;SIGTERM&apos;）</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> 进程结束时回调并带上输出<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li>返回：ChildProcess 对象</li>
</div></ul>
<p>Runs a command in a shell and buffers the output.

</p>
<p>在 shell 中执行一个命令并缓冲输出。

</p>
<pre><code>child = exec(&apos;cat *.js bad_file | wc -l&apos;,
  function (error, stdout, stderr) {
    console.log(&apos;stdout: &apos; + stdout);
    console.log(&apos;stderr: &apos; + stderr);
    if (error !== null) {
      console.log(&apos;exec error: &apos; + error);
    }
});</code></pre>
<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>
will be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>err.code</code>
will be the exit code of the child process, and <code>err.signal</code> will be set to the
signal that terminated the process.

</p>
<p>回调参数为 <code>(error, stdout, stderr)</code>。当成功时，<code>error</code> 会是 <code>null</code>。当遇到错误时，<code>error</code> 会是一个 <code>Error</code> 实例，并且 <code>err.code</code> 会是子进程的退出代码，同时 <code>err.signal</code> 会被设置为结束进程的信号名。

</p>
<p>There is a second optional argument to specify several options. The
default options are

</p>
<p>第二个可选的参数用于指定一些选项，缺省选项为：

</p>
<pre><code>{ encoding: &apos;utf8&apos;,
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: &apos;SIGTERM&apos;,
  cwd: null,
  env: null }</code></pre>
<p>If <code>timeout</code> is greater than 0, then it will kill the child process
if it runs longer than <code>timeout</code> milliseconds. The child process is killed with
<code>killSignal</code> (default: <code>&apos;SIGTERM&apos;</code>). <code>maxBuffer</code> specifies the largest
amount of data allowed on stdout or stderr - if this value is exceeded then
the child process is killed.

</p>
<p>如果 <code>timeout</code> 大于 0，则当进程运行超过 <code>timeout</code> 毫秒后会被终止。子进程使用 <code>killSignal</code> 信号结束（缺省为 <code>&apos;SIGTERM&apos;</code>）。<code>maxBuffer</code> 指定了 stdout 或 stderr 所允许的最大数据量，如果超出这个值则子进程会被终止。

</p>
<h2>child_process.execFile(file, args, options, callback)<span><a href="all.html#all_child_process_execfile_file_args_options_callback_1" id="all_child_process_execfile_file_args_options_callback_1">#</a></span></h2>
<div><ul>
<li><code>file</code> <span>String</span> The filename of the program to run</li>
<li><code>args</code> <span>Array</span> List of string arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span>String</span> (Default: &apos;utf8&apos;)</li>
<li><code>timeout</code> <span>Number</span> (Default: 0)</li>
<li><code>maxBuffer</code> <span>Number</span> (Default: 200*1024)</li>
<li><code>killSignal</code> <span>String</span> (Default: &apos;SIGTERM&apos;)</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> called with the output when process terminates<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li><p>Return: ChildProcess object</p>
</li>
<li><p><code>file</code> <span>String</span> 要运行的程序的文件名</p>
</li>
<li><code>args</code> <span>Array</span> 字符串参数列表</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> 子进程的当前工作目录</li>
<li><code>env</code> <span>Object</span> 环境变量键值对</li>
<li><code>encoding</code> <span>String</span> 编码（缺省为 &apos;utf8&apos;）</li>
<li><code>timeout</code> <span>Number</span> 超时（缺省为 0）</li>
<li><code>maxBuffer</code> <span>Number</span> 最大缓冲（缺省为 200*1024）</li>
<li><code>killSignal</code> <span>String</span> 结束信号（缺省为 &apos;SIGTERM&apos;）</li>
</ul>
</li>
<li><code>callback</code> <span>Function</span> 进程结束时回调并带上输出<ul>
<li><code>error</code> <span>Error</span></li>
<li><code>stdout</code> <span>Buffer</span></li>
<li><code>stderr</code> <span>Buffer</span></li>
</ul>
</li>
<li>返回：ChildProcess 对象</li>
</div></ul>
<p>This is similar to <code>child_process.exec()</code> except it does not execute a
subshell but rather the specified file directly. This makes it slightly
leaner than <code>child_process.exec</code>. It has the same options.

</p>
<p>该方法类似于 <code>child_process.exec()</code>，但是它不会执行一个子 shell，而是直接执行所指定的文件。因此它稍微比 <code>child_process.exec</code> 精简，参数与之一致。

</p>
<h2>child_process.fork(modulePath, [args], [options])<span><a href="all.html#all_child_process_fork_modulepath_args_options_1" id="all_child_process_fork_modulepath_args_options_1">#</a></span></h2>
<div><ul>
<li><code>modulePath</code> <span>String</span> The module to run in the child</li>
<li><code>args</code> <span>Array</span> List of string arguments</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> Current working directory of the child process</li>
<li><code>env</code> <span>Object</span> Environment key-value pairs</li>
<li><code>encoding</code> <span>String</span> (Default: &apos;utf8&apos;)</li>
<li><code>execPath</code> <span>String</span> Executable used to create the child process</li>
</ul>
</li>
<li><p>Return: ChildProcess object</p>
</li>
<li><p><code>modulePath</code> <span>String</span> 子进程中运行的模块</p>
</li>
<li><code>args</code> <span>Array</span> 字符串参数列表</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>cwd</code> <span>String</span> 子进程的当前工作目录</li>
<li><code>env</code> <span>Object</span> 环境变量键值对</li>
<li><code>encoding</code> <span>String</span> 编码（缺省为 &apos;utf8&apos;）</li>
<li><code>execPath</code> <span>String</span> 创建子进程的可执行文件</li>
</ul>
</li>
<li>返回：ChildProcess 对象</li>
</div></ul>
<p>This is a special case of the <code>spawn()</code> functionality for spawning Node
processes. In addition to having all the methods in a normal ChildProcess
instance, the returned object has a communication channel built-in. See
<code>child.send(message, [sendHandle])</code> for details.

</p>
<p>该方法是 <code>spawn()</code> 的特殊情景，用于派生 Node 进程。除了普通 ChildProcess 实例所具有的所有方法，所返回的对象还具有内建的通讯通道。详见 <code>child.send(message, [sendHandle])</code>。

</p>
<p>By default the spawned Node process will have the stdout, stderr associated
with the parent&apos;s. To change this behavior set the <code>silent</code> property in the
<code>options</code> object to <code>true</code>.

</p>
<p>缺省情况下所派生的 Node 进程的 stdout、stderr 会关联到父进程。要更改该行为，可将 <code>options</code> 对象中的 <code>silent</code> 属性设置为 <code>true</code>。

</p>
<p>The child process does not automatically exit once it&apos;s done, you need to call
<code>process.exit()</code> explicitly. This limitation may be lifted in the future.

</p>
<p>子进程运行完成时并不会自动退出，您需要明确地调用 <code>process.exit()</code>。该限制可能会在未来版本里接触。

</p>
<p>These child Nodes are still whole new instances of V8. Assume at least 30ms
startup and 10mb memory for each new Node. That is, you cannot create many
thousands of them.

</p>
<p>这些子 Node 是全新的 V8 实例，假设每个新的 Node 需要至少 30 毫秒的启动时间和 10MB 内存，就是说您不能创建成百上千个这样的实例。

</p>
<p>The <code>execPath</code> property in the <code>options</code> object allows for a process to be
created for the child rather than the current <code>node</code> executable. This should be
done with care and by default will talk over the fd represented an
environmental variable <code>NODE_CHANNEL_FD</code> on the child process. The input and
output on this fd is expected to be line delimited JSON objects.

</p>
<p><code>options</code> 对象中的 <code>execPath</code> 属性可以用非当前 <code>node</code> 可执行文件来创建子进程。这需要小心使用，并且缺省情况下会使用子进程上的 <code>NODE_CHANNEL_FD</code> 环境变量所指定的文件描述符来通讯。该文件描述符的输入和输出假定为以行分割的 JSON 对象。

</p>
<h1>断言 (assert)<span><a href="all.html#all_assert_1" id="all_assert_1">#</a></span></h1>
<pre><code>稳定度: 5 - 已锁定</code></pre>
<p>This module is used for writing unit tests for your applications, you can
access it with <code>require(&apos;assert&apos;)</code>.

</p>
<p>此模块主要用于对您的程序进行单元测试，要使用它，请 <code>require(&apos;assert&apos;)</code>。

</p>
<h2>assert.fail(actual, expected, message, operator)<span><a href="all.html#all_assert_fail_actual_expected_message_operator_1" id="all_assert_fail_actual_expected_message_operator_1">#</a></span></h2>
<p>Throws an exception that displays the values for <code>actual</code> and <code>expected</code> separated by the provided operator.

</p>
<p>抛出异常：显示为被 <code>operator</code> （分隔符）所分隔的 <code>actual</code> （实际值）和 <code>expected</code> （期望值）。

</p>
<h2>assert(value, message), assert.ok(value, [message])<span><a href="all.html#all_assert_value_message_assert_ok_value_message_1" id="all_assert_value_message_assert_ok_value_message_1">#</a></span></h2>
<p>Tests if value is truthy, it is equivalent to <code>assert.equal(true, !!value, message);</code>

</p>
<p>测试结果是否为真（true），相当于 <code>assert.equal(true, !!value, message);</code>

</p>
<h2>assert.equal(actual, expected, [message])<span><a href="all.html#all_assert_equal_actual_expected_message_1" id="all_assert_equal_actual_expected_message_1">#</a></span></h2>
<p>Tests shallow, coercive equality with the equal comparison operator ( <code>==</code> ).

</p>
<p>浅测试, 强制相等就像使用相等操作符( <code>==</code> ).

</p>
<h2>assert.notEqual(actual, expected, [message])<span><a href="all.html#all_assert_notequal_actual_expected_message_1" id="all_assert_notequal_actual_expected_message_1">#</a></span></h2>
<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).

</p>
<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).

</p>
<h2>assert.deepEqual(actual, expected, [message])<span><a href="all.html#all_assert_deepequal_actual_expected_message_1" id="all_assert_deepequal_actual_expected_message_1">#</a></span></h2>
<p>Tests for deep equality.

</p>
<p>用于深度匹配测试。

</p>
<h2>assert.notDeepEqual(actual, expected, [message])<span><a href="all.html#all_assert_notdeepequal_actual_expected_message_1" id="all_assert_notdeepequal_actual_expected_message_1">#</a></span></h2>
<p>Tests for any deep inequality.

</p>
<p>用于深度非匹配测试。

</p>
<h2>assert.strictEqual(actual, expected, [message])<span><a href="all.html#all_assert_strictequal_actual_expected_message_1" id="all_assert_strictequal_actual_expected_message_1">#</a></span></h2>
<p>Tests strict equality, as determined by the strict equality operator ( <code>===</code> )

</p>
<p>用于严格相等匹配测试，由（<code>===</code>）的结果决定

</p>
<h2>assert.notStrictEqual(actual, expected, [message])<span><a href="all.html#all_assert_notstrictequal_actual_expected_message_1" id="all_assert_notstrictequal_actual_expected_message_1">#</a></span></h2>
<p>Tests strict non-equality, as determined by the strict not equal operator ( <code>!==</code> )

</p>
<p>严格不相等测试, 强制不相等就像使用严格不相等操作符( <code>!==</code> ).

</p>
<h2>assert.throws(block, [error], [message])<span><a href="all.html#all_assert_throws_block_error_message_1" id="all_assert_throws_block_error_message_1">#</a></span></h2>
<p>Expects <code>block</code> to throw an error. <code>error</code> can be constructor, regexp or 
validation function.

</p>
<p>输出一个错误的 <code>block</code>。 <code>error</code> 可以是构造函数，正则或者验证函数

</p>
<p>Validate instanceof using constructor:

</p>
<p>使用验证实例的构造函数

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;错误值&quot;);
  },
  Error
);</code></pre>
<p>Validate error message using RegExp:

</p>
<p>用正则表达式验证错误消息。

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;错误值&quot;);
  },
  /value/
);</code></pre>
<p>Custom error validation:

</p>
<p>自定义错误校验：

</p>
<pre><code>assert.throws(
  function() {
    throw new Error(&quot;Wrong value&quot;);
  },
  function(err) {
    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {
      return true;
    }
  },
  &quot;unexpected error&quot;
);</code></pre>
<h2>assert.doesNotThrow(block, [message])<span><a href="all.html#all_assert_doesnotthrow_block_message_1" id="all_assert_doesnotthrow_block_message_1">#</a></span></h2>
<p>Expects <code>block</code> not to throw an error, see assert.throws for details.

</p>
<p>预期 <code>block</code> 不会抛出错误，详见 assert.throws。

</p>
<h2>assert.ifError(value)<span><a href="all.html#all_assert_iferror_value_1" id="all_assert_iferror_value_1">#</a></span></h2>
<p>Tests if value is not a false value, throws if it is a true value. Useful when
testing the first argument, <code>error</code> in callbacks.


</p>
<p>测试值是否不为 false，当为 true 时抛出。常用于回调中第一个 error 参数的检查。
</p>
<h1>TTY<span><a href="all.html#all_tty_1" id="all_tty_1">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p>The <code>tty</code> module houses the <code>tty.ReadStream</code> and <code>tty.WriteStream</code> classes. In
most cases, you will not need to use this module directly.

</p>
<p><code>tty</code> 模块提供了 <code>tty.ReadStream</code> 和 <code>tty.WriteStream</code> 类。在大部分情况下，您都不会需要直接使用此模块。

</p>
<p>When node detects that it is being run inside a TTY context, then <code>process.stdin</code>
will be a <code>tty.ReadStream</code> instance and <code>process.stdout</code> will be
a <code>tty.WriteStream</code> instance. The preferred way to check if node is being run in
a TTY context is to check <code>process.stdout.isTTY</code>:

</p>
<p>当 node 检测到它正运行于 TTY 上下文中时，<code>process.stdin</code> 将会是一个 <code>tty.ReadStream</code> 实例，且 <code>process.stdout</code> 也将会是一个 <code>tty.WriteStream</code> 实例。检查 node 是否运行于 TTY 上下文的首选方式是检查 <code>process.stdout.isTTY</code>：

</p>
<pre><code>$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;
true
$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat
false</code></pre>
<h2>tty.isatty(fd)<span><a href="all.html#all_tty_isatty_fd_1" id="all_tty_isatty_fd_1">#</a></span></h2>
<p>Returns <code>true</code> or <code>false</code> depending on if the <code>fd</code> is associated with a
terminal.

</p>
<p>若 <code>fd</code> 关联于中端则返回 <code>true</code>，反之返回 <code>false</code>。

</p>
<h2>tty.setRawMode(mode)<span><a href="all.html#all_tty_setrawmode_mode_1" id="all_tty_setrawmode_mode_1">#</a></span></h2>
<p>Deprecated. Use <code>tty.ReadStream#setRawMode()</code>
(i.e. <code>process.stdin.setRawMode()</code>) instead.

</p>
<p>已废弃，请使用 <code>tty.ReadStream#setRawMode()</code>（如 <code>process.stdin.setRawMode()</code>）。

</p>
<h2>类: ReadStream<span><a href="all.html#all_readstream_1" id="all_readstream_1">#</a></span></h2>
<p>A <code>net.Socket</code> subclass that represents the readable portion of a tty. In normal
circumstances, <code>process.stdin</code> will be the only <code>tty.ReadStream</code> instance in any
node program (only when <code>isatty(0)</code> is true).

</p>
<p>一个 <code>net.Socket</code> 子类，代表 TTY 的可读部分。通常情况下在所有 node 程序中 <code>process.stdin</code> 会是仅有的 <code>tty.ReadStream</code> 实例（进当 <code>isatty(0)</code> 为 true 时）。

</p>
<h3>rs.isRaw<span><a href="all.html#all_rs_israw_1" id="all_rs_israw_1">#</a></span></h3>
<p>A <code>Boolean</code> that is initialized to <code>false</code>. It represents the current &quot;raw&quot; state
of the <code>tty.ReadStream</code> instance.

</p>
<p>一个 <code>Boolean</code>，初始为 <code>false</code>，代表 <code>tty.ReadStream</code> 实例的当前 &quot;raw&quot; 状态。

</p>
<h3>rs.setRawMode(mode)<span><a href="all.html#all_rs_setrawmode_mode_1" id="all_rs_setrawmode_mode_1">#</a></span></h3>
<p><code>mode</code> should be <code>true</code> or <code>false</code>. This sets the properties of the
<code>tty.ReadStream</code> to act either as a raw device or default. <code>isRaw</code> will be set
to the resulting mode.

</p>
<p><code>mode</code> 可以是 <code>true</code> 或 <code>false</code>。它设定 <code>tty.ReadStream</code> 的属性表现为原始设备或缺省。<code>isRaw</code> 会被设置为结果模式。

</p>
<h2>类: WriteStream<span><a href="all.html#all_writestream_1" id="all_writestream_1">#</a></span></h2>
<p>A <code>net.Socket</code> subclass that represents the writable portion of a tty. In normal
circumstances, <code>process.stdout</code> will be the only <code>tty.WriteStream</code> instance
ever created (and only when <code>isatty(1)</code> is true).

</p>
<p>一个 <code>net.Socket</code> 子类，代表 TTY 的可写部分。通常情况下 <code>process.stdout</code> 会是仅有的 <code>tty.WriteStream</code> 实例（进当 <code>isatty(1)</code> 为 true 时）。

</p>
<h3>ws.columns<span><a href="all.html#all_ws_columns_1" id="all_ws_columns_1">#</a></span></h3>
<p>A <code>Number</code> that gives the number of columns the TTY currently has. This property
gets updated on &quot;resize&quot; events.

</p>
<p>一个 `Number，表示 TTY 当前的列数。该属性会在 &quot;resize&quot; 事件中被更新。

</p>
<h3>ws.rows<span><a href="all.html#all_ws_rows_1" id="all_ws_rows_1">#</a></span></h3>
<p>A <code>Number</code> that gives the number of rows the TTY currently has. This property
gets updated on &quot;resize&quot; events.

</p>
<p>一个 `Number，表示 TTY 当前的行数。该属性会在 &quot;resize&quot; 事件中被更新。

</p>
<h3>事件: &apos;resize&apos;<span><a href="all.html#all_resize_1" id="all_resize_1">#</a></span></h3>
<p><code>function () {}</code>

</p>
<p><code>function () {}</code>

</p>
<p>Emitted by <code>refreshSize()</code> when either of the <code>columns</code> or <code>rows</code> properties
has changed.

</p>
<p>由 <code>refreshSize()</code> 在 <code>columns</code> 或 <code>rows</code> 属性被改变时触发。

</p>
<pre><code>process.stdout.on(&apos;resize&apos;, function() {
  console.log(&apos;screen size has changed!&apos;);
  console.log(process.stdout.columns + &apos;x&apos; + process.stdout.rows);
});


process.stdout.on(&apos;resize&apos;, function() {
  console.log(&apos;屏幕大小已改变！&apos;);
  console.log(process.stdout.columns + &apos;x&apos; + process.stdout.rows);
});</code></pre>
<h1>Zlib<span><a href="all.html#all_zlib_1" id="all_zlib_1">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<p>You can access this module with:

</p>
<p>你可以这样引入此模块：

</p>
<pre><code>var zlib = require(&apos;zlib&apos;);</code></pre>
<p>This provides bindings to Gzip/Gunzip, Deflate/Inflate, and
DeflateRaw/InflateRaw classes.  Each class takes the same options, and
is a readable/writable Stream.

</p>
<p>这个模块提供了对Gzip/Gunzip, Deflate/Inflate和DeflateRaw/InflateRaw类的绑定。每一个类都可以接收相同的选项，并且本身也是一个可读写的Stream类。

</p>
<h2>例子<span><a href="all.html#all_81" id="all_81">#</a></span></h2>
<p>Compressing or decompressing a file can be done by piping an
fs.ReadStream into a zlib stream, then into an fs.WriteStream.

</p>
<p>压缩或解压缩一个文件可以通过导流一个 fs.ReadStream 到一个 zlib 流，然后到一个 fs.WriteStream 来完成。

</p>
<pre><code>inp.pipe(gzip).pipe(out);</code></pre>
<p>Compressing or decompressing data in one step can be done by using
the convenience methods.

</p>
<p>一步压缩或解压缩数据可以通过快捷方法来完成。

</p>
<pre><code>var buffer = new Buffer(&apos;eJzT0yMAAGTvBe8=&apos;, &apos;base64&apos;);
zlib.unzip(buffer, function(err, buffer) {
  if (!err) {
    console.log(buffer.toString());
  }
});</code></pre>
<p>To use this module in an HTTP client or server, use the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a>
on requests, and the
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a>
header on responses.

</p>
<p>要在 HTTP 客户端或服务器中使用此模块，请在请求和响应中使用 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3">accept-encoding</a> 和 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11">content-encoding</a> 头。

</p>
<p><strong>Note: these examples are drastically simplified to show
the basic concept.</strong>  Zlib encoding can be expensive, and the results
ought to be cached.  See <a href="all.html#zlib_memory_usage_tuning">Memory Usage Tuning</a>
below for more information on the speed/memory/compression
tradeoffs involved in zlib usage.

</p>
<p><strong>注意：这些例子只是极其简单地展示了基础的概念</strong> 
Zlib 编码消耗非常大,结果需要缓存.看下面的<a href="all.html#zlib_memory_usage_tuning">内存调优</a>
中更多的关于Zlib用法中 速度/内存/压缩 的权衡取舍。

</p>
<pre><code>  // 注意: 这不是一个不合格的 accept-encoding 解析器
  // 详见 http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3
  if (acceptEncoding.match(/\bdeflate\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;deflate&apos; });
    raw.pipe(zlib.createDeflate()).pipe(response);
  } else if (acceptEncoding.match(/\bgzip\b/)) {
    response.writeHead(200, { &apos;content-encoding&apos;: &apos;gzip&apos; });
    raw.pipe(zlib.createGzip()).pipe(response);
  } else {
    response.writeHead(200, {});
    raw.pipe(response);
  }
}).listen(1337);</code></pre>
<h2>zlib.createGzip([options])<span><a href="all.html#all_zlib_creategzip_options_1" id="all_zlib_creategzip_options_1">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_gzip">Gzip</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_gzip">Gzip</a> 对象。

</p>
<h2>zlib.createGunzip([options])<span><a href="all.html#all_zlib_creategunzip_options_1" id="all_zlib_creategunzip_options_1">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_gunzip">Gunzip</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_gunzip">Gunzip</a> 对象。

</p>
<h2>zlib.createDeflate([options])<span><a href="all.html#all_zlib_createdeflate_options_1" id="all_zlib_createdeflate_options_1">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_deflate">Deflate</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_deflate">Deflate</a> 对象。

</p>
<h2>zlib.createInflate([options])<span><a href="all.html#all_zlib_createinflate_options_1" id="all_zlib_createinflate_options_1">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_inflate">Inflate</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_inflate">Inflate</a> 对象。

</p>
<h2>zlib.createDeflateRaw([options])<span><a href="all.html#all_zlib_createdeflateraw_options_1" id="all_zlib_createdeflateraw_options_1">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_deflateraw">DeflateRaw</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_deflateraw">DeflateRaw</a> 对象。

</p>
<h2>zlib.createInflateRaw([options])<span><a href="all.html#all_zlib_createinflateraw_options_1" id="all_zlib_createinflateraw_options_1">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_inflateraw">InflateRaw</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_inflateraw">InflateRaw</a> 对象。

</p>
<h2>zlib.createUnzip([options])<span><a href="all.html#all_zlib_createunzip_options_1" id="all_zlib_createunzip_options_1">#</a></span></h2>
<p>Returns a new <a href="all.html#zlib_class_zlib_unzip">Unzip</a> object with an
<a href="all.html#zlib_options">options</a>.

</p>
<p>以 <a href="all.html#zlib_options">options</a> 所给选项返回一个新的 <a href="all.html#zlib_class_zlib_unzip">Unzip</a> 对象。

</p>
<h2>类: zlib.Zlib<span><a href="all.html#all_zlib_zlib_1" id="all_zlib_zlib_1">#</a></span></h2>
<p>Not exported by the <code>zlib</code> module. It is documented here because it is the base
class of the compressor/decompressor classes.

</p>
<p>这个类未被 <code>zlib</code> 模块导出，编入此文档是因为它是其它压缩器/解压缩器的基类。

</p>
<h3>zlib.flush([kind], callback)<span><a href="all.html#all_zlib_flush_kind_callback_1" id="all_zlib_flush_kind_callback_1">#</a></span></h3>
<p><code>kind</code> defaults to <code>zlib.Z_FULL_FLUSH</code>.

</p>
<p><code>kind</code> 缺省为 <code>zlib.Z_FULL_FLUSH</code>。

</p>
<p>Flush pending data. Don&apos;t call this frivolously, premature flushes negatively
impact the effectiveness of the compression algorithm.

</p>
<p>写入缓冲数据。请勿轻易调用此方法，过早的写入会对压缩算法的作用产生影响。

</p>
<h3>zlib.params(level, strategy, callback)<span><a href="all.html#all_zlib_params_level_strategy_callback_1" id="all_zlib_params_level_strategy_callback_1">#</a></span></h3>
<p>Dynamically update the compression level and compression strategy.
Only applicable to deflate algorithm.

</p>
<p>动态更新压缩级别和压缩策略。仅对 deflate 算法有效。

</p>
<h3>zlib.reset()<span><a href="all.html#all_zlib_reset_1" id="all_zlib_reset_1">#</a></span></h3>
<p>Reset the compressor/decompressor to factory defaults. Only applicable to
the inflate and deflate algorithms.

</p>
<p>将压缩器/解压缩器重置为缺省值。仅对 inflate 和 deflate 算法有效。

</p>
<h2>类: zlib.Gzip<span><a href="all.html#all_zlib_gzip_1" id="all_zlib_gzip_1">#</a></span></h2>
<p>Compress data using gzip.

</p>
<p>使用 gzip 压缩数据。

</p>
<h2>类: zlib.Gunzip<span><a href="all.html#all_zlib_gunzip_1" id="all_zlib_gunzip_1">#</a></span></h2>
<p>Decompress a gzip stream.

</p>
<p>解压缩一个 gzip 流。

</p>
<h2>类: zlib.Deflate<span><a href="all.html#all_zlib_deflate_1" id="all_zlib_deflate_1">#</a></span></h2>
<p>Compress data using deflate.

</p>
<p>使用 deflate 压缩数据。

</p>
<h2>类: zlib.Inflate<span><a href="all.html#all_zlib_inflate_1" id="all_zlib_inflate_1">#</a></span></h2>
<p>Decompress a deflate stream.

</p>
<p>解压缩一个 deflate 流。

</p>
<h2>类: zlib.DeflateRaw<span><a href="all.html#all_zlib_deflateraw_1" id="all_zlib_deflateraw_1">#</a></span></h2>
<p>Compress data using deflate, and do not append a zlib header.

</p>
<p>使用 deflate 压缩数据，并且不附带 zlib 头。

</p>
<h2>类: zlib.InflateRaw<span><a href="all.html#all_zlib_inflateraw_1" id="all_zlib_inflateraw_1">#</a></span></h2>
<p>Decompress a raw deflate stream.

</p>
<p>解压缩一个原始 deflate 流。

</p>
<h2>类: zlib.Unzip<span><a href="all.html#all_zlib_unzip_1" id="all_zlib_unzip_1">#</a></span></h2>
<p>Decompress either a Gzip- or Deflate-compressed stream by auto-detecting
the header.

</p>
<p>自动识别头部来解压缩一个以 gzip 或 deflate 压缩的流。

</p>
<h2>快捷方法<span><a href="all.html#all_82" id="all_82">#</a></span></h2>
<!--type=misc-->

<p>All of these take a string or buffer as the first argument, an optional second
argument to supply options to the zlib classes and will call the supplied
callback with <code>callback(error, result)</code>.

</p>
<p>所有这些方法的第一个参数都可以是字符串或 Buffer；可选地可以将传给 zlib 类的选项作为第二个参数传入；回调格式为 <code>callback(error, result)</code>。

</p>
<h2>zlib.deflate(buf, [options], callback)<span><a href="all.html#all_zlib_deflate_buf_options_callback_1" id="all_zlib_deflate_buf_options_callback_1">#</a></span></h2>
<p>Compress a string with Deflate.

</p>
<p>使用 Deflate 压缩一个字符串。

</p>
<h2>zlib.deflateRaw(buf, [options], callback)<span><a href="all.html#all_zlib_deflateraw_buf_options_callback_1" id="all_zlib_deflateraw_buf_options_callback_1">#</a></span></h2>
<p>Compress a string with DeflateRaw.

</p>
<p>使用 DeflateRaw 压缩一个字符串。

</p>
<h2>zlib.Gzip(buf, [options], callback)<span><a href="all.html#all_zlib_gzip_buf_options_callback_1" id="all_zlib_gzip_buf_options_callback_1">#</a></span></h2>
<p>Compress a string with Gzip.

</p>
<p>使用 Gzip 压缩一个字符串。

</p>
<h2>zlib.gunzip(buf, [options], callback)<span><a href="all.html#all_zlib_gunzip_buf_options_callback_1" id="all_zlib_gunzip_buf_options_callback_1">#</a></span></h2>
<p>Decompress a raw Buffer with Gunzip.

</p>
<p>使用 Gunzip 解压缩一个原始的 Buffer。

</p>
<h2>zlib.inflate(buf, [options], callback)<span><a href="all.html#all_zlib_inflate_buf_options_callback_1" id="all_zlib_inflate_buf_options_callback_1">#</a></span></h2>
<p>Decompress a raw Buffer with Inflate.

</p>
<p>使用 Inflate 解压缩一个原始的 Buffer。

</p>
<h2>zlib.inflateRaw(buf, [options], callback)<span><a href="all.html#all_zlib_inflateraw_buf_options_callback_1" id="all_zlib_inflateraw_buf_options_callback_1">#</a></span></h2>
<p>Decompress a raw Buffer with InflateRaw.

</p>
<p>使用 InflateRaw 解压缩一个原始的 Buffer。

</p>
<h2>zlib.unzip(buf, [options], callback)<span><a href="all.html#all_zlib_unzip_buf_options_callback_1" id="all_zlib_unzip_buf_options_callback_1">#</a></span></h2>
<p>Decompress a raw Buffer with Unzip.

</p>
<p>使用 Unzip 解压缩一个原始的 Buffer。

</p>
<h2>选项<span><a href="all.html#all_83" id="all_83">#</a></span></h2>
<!--type=misc-->

<p>Each class takes an options object.  All options are optional.

</p>
<p>各个类都有一个选项对象。所有选项都是可选的。

</p>
<p>Note that some options are only relevant when compressing, and are
ignored by the decompression classes.

</p>
<p>请注意有些选项仅对压缩有效，并会被解压缩类所忽略。

</p>
<ul>
<li>flush (default: <code>zlib.Z_NO_FLUSH</code>)</li>
<li>chunkSize (default: 16*1024)</li>
<li>windowBits</li>
<li>level (compression only)</li>
<li>memLevel (compression only)</li>
<li>strategy (compression only)</li>
<li><p>dictionary (deflate/inflate only, empty dictionary by default)</p>
</li>
<li><p>flush（缺省：<code>zlib.Z_NO_FLUSH</code>）</p>
</li>
<li>chunkSize（缺省：16*1024）</li>
<li>windowBits</li>
<li>level（仅用于压缩）</li>
<li>memLevel（仅用于压缩）</li>
<li>strategy（仅用于压缩）</li>
<li>dictionary（仅用于 deflate/inflate，缺省为空目录）</li>
</ul>
<p>See the description of <code>deflateInit2</code> and <code>inflateInit2</code> at
</p>
<p><a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> for more information on these.

</p>
<p>详情请参阅 <a href="http://zlib.net/manual.html#Advanced">http://zlib.net/manual.html#Advanced</a> 的 <code>deflateInit2</code> 和 <code>inflateInit2</code>。

</p>
<h2>内存使用调优<span><a href="all.html#all_84" id="all_84">#</a></span></h2>
<!--type=misc-->

<p>From <code>zlib/zconf.h</code>, modified to node&apos;s usage:

</p>
<p>来自 <code>zlib/zconf.h</code>，修改为 node 的用法：

</p>
<p>The memory requirements for deflate are (in bytes):

</p>
<p>deflate 的内存需求（按字节）：

</p>
<pre><code>(1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))</code></pre>
<p>that is: 128K for windowBits=15  +  128K for memLevel = 8
(default values) plus a few kilobytes for small objects.

</p>
<p>表示：windowBits = 15 的 128K + memLevel = 8 的 128K（缺省值）加上其它对象的若干 KB。

</p>
<p>For example, if you want to reduce
the default memory requirements from 256K to 128K, set the options to:

</p>
<p>举个例子，如果您需要将缺省内存需求从 256K 减少到 128K，设置选项：

</p>
<pre><code>{ windowBits: 14, memLevel: 7 }</code></pre>
<p>Of course this will generally degrade compression (there&apos;s no free lunch).

</p>
<p>当然这通常会降低压缩等级（天底下没有免费午餐）。

</p>
<p>The memory requirements for inflate are (in bytes)

</p>
<p>inflate 的内存需求（按字节）：

</p>
<pre><code>1 &lt;&lt; windowBits</code></pre>
<p>that is, 32K for windowBits=15 (default value) plus a few kilobytes
for small objects.

</p>
<p>表示 windowBits = 15（缺省值）的 32K 加上其它对象的若干 KB。

</p>
<p>This is in addition to a single internal output slab buffer of size
<code>chunkSize</code>, which defaults to 16K.

</p>
<p>这是除了内部输出缓冲外 <code>chunkSize</code> 的大小，缺省为 16K。

</p>
<p>The speed of zlib compression is affected most dramatically by the
<code>level</code> setting.  A higher level will result in better compression, but
will take longer to complete.  A lower level will result in less
compression, but will be much faster.

</p>
<p>zlib 压缩的速度主要受压缩级别 <code>level</code> 的影响。更高的压缩级别会有更好的压缩率，但也要花费更长时间。更低的压缩级别会有较低压缩率，但速度更快。

</p>
<p>In general, greater memory usage options will mean that node has to make
fewer calls to zlib, since it&apos;ll be able to process more data in a
single <code>write</code> operation.  So, this is another factor that affects the
speed, at the cost of memory usage.

</p>
<p>通常，使用更多内存的选项意味着 node 能减少对 zlib 的调用，因为单次 <code>write</code>操作能处理更多数据。因此，这是另一个影响速度和内存占用的因素。

</p>
<h2>常量<span><a href="all.html#all_85" id="all_85">#</a></span></h2>
<!--type=misc-->

<p>All of the constants defined in zlib.h are also defined on
<code>require(&apos;zlib&apos;)</code>.
In the normal course of operations, you will not need to ever set any of
these.  They are documented here so that their presence is not
surprising.  This section is taken almost directly from the <a href="http://zlib.net/manual.html#Constants">zlib
documentation</a>.  See
</p>
<p><a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a> for more details.

</p>
<p>所有在 zlib.h 中定义的常量同样也定义在 <code>require(&apos;zlib&apos;)</code> 中。
在通常情况下您几乎不会用到它们，编入文档只是为了让您不会对它们的存在感到惊讶。该章节几乎完全来自 <a href="http://zlib.net/manual.html#Constants">zlib 的文档</a>。详见 <a href="http://zlib.net/manual.html#Constants">http://zlib.net/manual.html#Constants</a>。

</p>
<p>Allowed flush values.

</p>
<p>允许的 flush 取值。

</p>
<ul>
<li><code>zlib.Z_NO_FLUSH</code></li>
<li><code>zlib.Z_PARTIAL_FLUSH</code></li>
<li><code>zlib.Z_SYNC_FLUSH</code></li>
<li><code>zlib.Z_FULL_FLUSH</code></li>
<li><code>zlib.Z_FINISH</code></li>
<li><code>zlib.Z_BLOCK</code></li>
<li><p><code>zlib.Z_TREES</code></p>
</li>
<li><p><code>zlib.Z_NO_FLUSH</code></p>
</li>
<li><code>zlib.Z_PARTIAL_FLUSH</code></li>
<li><code>zlib.Z_SYNC_FLUSH</code></li>
<li><code>zlib.Z_FULL_FLUSH</code></li>
<li><code>zlib.Z_FINISH</code></li>
<li><code>zlib.Z_BLOCK</code></li>
<li><code>zlib.Z_TREES</code></li>
</ul>
<p>Return codes for the compression/decompression functions. Negative
values are errors, positive values are used for special but normal
events.

</p>
<p>压缩/解压缩函数的返回值。负数代表错误，正数代表特殊但正常的事件。

</p>
<ul>
<li><code>zlib.Z_OK</code></li>
<li><code>zlib.Z_STREAM_END</code></li>
<li><code>zlib.Z_NEED_DICT</code></li>
<li><code>zlib.Z_ERRNO</code></li>
<li><code>zlib.Z_STREAM_ERROR</code></li>
<li><code>zlib.Z_DATA_ERROR</code></li>
<li><code>zlib.Z_MEM_ERROR</code></li>
<li><code>zlib.Z_BUF_ERROR</code></li>
<li><p><code>zlib.Z_VERSION_ERROR</code></p>
</li>
<li><p><code>zlib.Z_OK</code></p>
</li>
<li><code>zlib.Z_STREAM_END</code></li>
<li><code>zlib.Z_NEED_DICT</code></li>
<li><code>zlib.Z_ERRNO</code></li>
<li><code>zlib.Z_STREAM_ERROR</code></li>
<li><code>zlib.Z_DATA_ERROR</code></li>
<li><code>zlib.Z_MEM_ERROR</code></li>
<li><code>zlib.Z_BUF_ERROR</code></li>
<li><code>zlib.Z_VERSION_ERROR</code></li>
</ul>
<p>Compression levels.

</p>
<p>压缩级别。

</p>
<ul>
<li><code>zlib.Z_NO_COMPRESSION</code></li>
<li><code>zlib.Z_BEST_SPEED</code></li>
<li><code>zlib.Z_BEST_COMPRESSION</code></li>
<li><p><code>zlib.Z_DEFAULT_COMPRESSION</code></p>
</li>
<li><p><code>zlib.Z_NO_COMPRESSION</code></p>
</li>
<li><code>zlib.Z_BEST_SPEED</code></li>
<li><code>zlib.Z_BEST_COMPRESSION</code></li>
<li><code>zlib.Z_DEFAULT_COMPRESSION</code></li>
</ul>
<p>Compression strategy.

</p>
<p>压缩策略。

</p>
<ul>
<li><code>zlib.Z_FILTERED</code></li>
<li><code>zlib.Z_HUFFMAN_ONLY</code></li>
<li><code>zlib.Z_RLE</code></li>
<li><code>zlib.Z_FIXED</code></li>
<li><p><code>zlib.Z_DEFAULT_STRATEGY</code></p>
</li>
<li><p><code>zlib.Z_FILTERED</code></p>
</li>
<li><code>zlib.Z_HUFFMAN_ONLY</code></li>
<li><code>zlib.Z_RLE</code></li>
<li><code>zlib.Z_FIXED</code></li>
<li><code>zlib.Z_DEFAULT_STRATEGY</code></li>
</ul>
<p>Possible values of the data_type field.

</p>
<p>data_type 字段的可能值。

</p>
<ul>
<li><code>zlib.Z_BINARY</code></li>
<li><code>zlib.Z_TEXT</code></li>
<li><code>zlib.Z_ASCII</code></li>
<li><p><code>zlib.Z_UNKNOWN</code></p>
</li>
<li><p><code>zlib.Z_BINARY</code></p>
</li>
<li><code>zlib.Z_TEXT</code></li>
<li><code>zlib.Z_ASCII</code></li>
<li><code>zlib.Z_UNKNOWN</code></li>
</ul>
<p>The deflate compression method (the only one supported in this version).

</p>
<p>deflate 压缩方法（该版本仅支持一种）。

</p>
<ul>
<li><p><code>zlib.Z_DEFLATED</code></p>
</li>
<li><p><code>zlib.Z_DEFLATED</code></p>
</li>
</ul>
<p>For initializing zalloc, zfree, opaque.

</p>
<p>初始化 zalloc/zfree/opaque。

</p>
<ul>
<li><code>zlib.Z_NULL</code></li>
</ul>
<ul>
<li><code>zlib.Z_NULL</code></li>
</ul>
<h1>操作系统<span><a href="all.html#all_86" id="all_86">#</a></span></h1>
<pre><code>稳定度: 4 - 冻结</code></pre>
<p>Provides a few basic operating-system related utility functions.

</p>
<p>提供一些基本的操作系统相关函数。

</p>
<p>Use <code>require(&apos;os&apos;)</code> to access this module.

</p>
<p>使用 <code>require(&apos;os&apos;)</code> 来调用这个模块。

</p>
<h2>os.tmpdir()<span><a href="all.html#all_os_tmpdir_1" id="all_os_tmpdir_1">#</a></span></h2>
<p>Returns the operating system&apos;s default directory for temp files.

</p>
<p>返回操作系统默认的临时文件目录

</p>
<h2>os.endianness()<span><a href="all.html#all_os_endianness_1" id="all_os_endianness_1">#</a></span></h2>
<p>Returns the endianness of the CPU. Possible values are <code>&quot;BE&quot;</code> or <code>&quot;LE&quot;</code>.

</p>
<p>返回 CPU 的字节序，可能的是 <code>&quot;BE&quot;</code> 或 <code>&quot;LE&quot;</code>。

</p>
<h2>os.hostname()<span><a href="all.html#all_os_hostname_1" id="all_os_hostname_1">#</a></span></h2>
<p>Returns the hostname of the operating system.

</p>
<p>返回操作系统的主机名。

</p>
<h2>os.type()<span><a href="all.html#all_os_type_1" id="all_os_type_1">#</a></span></h2>
<p>Returns the operating system name.

</p>
<p>返回操作系统名称。

</p>
<h2>os.platform()<span><a href="all.html#all_os_platform_1" id="all_os_platform_1">#</a></span></h2>
<p>Returns the operating system platform.

</p>
<p>返回操作系统平台

</p>
<h2>os.arch()<span><a href="all.html#all_os_arch_1" id="all_os_arch_1">#</a></span></h2>
<p>Returns the operating system CPU architecture. Possible values are <code>&quot;x64&quot;</code>,
<code>&quot;arm&quot;</code> and <code>&quot;ia32&quot;</code>.

</p>
<p>返回操作系统 CPU 架构，可能的值有 <code>&quot;x64&quot;</code>、<code>&quot;arm&quot;</code> 和 <code>&quot;ia32&quot;</code>。

</p>
<h2>os.release()<span><a href="all.html#all_os_release_1" id="all_os_release_1">#</a></span></h2>
<p>Returns the operating system release.

</p>
<p>返回操作系统的发行版本。

</p>
<h2>os.uptime()<span><a href="all.html#all_os_uptime_1" id="all_os_uptime_1">#</a></span></h2>
<p>Returns the system uptime in seconds.

</p>
<p>返回操作系统运行的时间，以秒为单位。

</p>
<h2>os.loadavg()<span><a href="all.html#all_os_loadavg_1" id="all_os_loadavg_1">#</a></span></h2>
<p>Returns an array containing the 1, 5, and 15 minute load averages.

</p>
<p>返回一个包含 1、5、15 分钟平均负载的数组。

</p>
<h2>os.totalmem()<span><a href="all.html#all_os_totalmem_1" id="all_os_totalmem_1">#</a></span></h2>
<p>Returns the total amount of system memory in bytes.

</p>
<p>返回系统内存总量，单位为字节。

</p>
<h2>os.freemem()<span><a href="all.html#all_os_freemem_1" id="all_os_freemem_1">#</a></span></h2>
<p>Returns the amount of free system memory in bytes.

</p>
<p>返回操作系统空闲内存量，单位是字节。

</p>
<h2>os.cpus()<span><a href="all.html#all_os_cpus_1" id="all_os_cpus_1">#</a></span></h2>
<p>Returns an array of objects containing information about each CPU/core
installed: model, speed (in MHz), and times (an object containing the number of
milliseconds the CPU/core spent in: user, nice, sys, idle, and irq).

</p>
<p>返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。

</p>
<p>Example inspection of os.cpus:

</p>
<p>os.cpus 的示例：

</p>
<pre><code>[ { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 252020,
       nice: 0,
       sys: 30340,
       idle: 1070356870,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 306960,
       nice: 0,
       sys: 26980,
       idle: 1071569080,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 248450,
       nice: 0,
       sys: 21750,
       idle: 1070919370,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 256880,
       nice: 0,
       sys: 19430,
       idle: 1070905480,
       irq: 20 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 511580,
       nice: 20,
       sys: 40900,
       idle: 1070842510,
       irq: 0 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 291660,
       nice: 0,
       sys: 34360,
       idle: 1070888000,
       irq: 10 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 308260,
       nice: 0,
       sys: 55410,
       idle: 1071129970,
       irq: 880 } },
  { model: &apos;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&apos;,
    speed: 2926,
    times:
     { user: 266450,
       nice: 1480,
       sys: 34920,
       idle: 1072572010,
       irq: 30 } } ]</code></pre>
<h2>os.networkInterfaces()<span><a href="all.html#all_os_networkinterfaces_1" id="all_os_networkinterfaces_1">#</a></span></h2>
<p>Get a list of network interfaces:

</p>
<p>获取网络接口的一个列表信息：

</p>
<pre><code>{ lo:
   [ { address: &apos;127.0.0.1&apos;,
       netmask: &apos;255.0.0.0&apos;,
       family: &apos;IPv4&apos;,
       mac: &apos;00:00:00:00:00:00&apos;,
       internal: true },
     { address: &apos;::1&apos;,
       netmask: &apos;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&apos;,
       family: &apos;IPv6&apos;,
       mac: &apos;00:00:00:00:00:00&apos;,
       internal: true } ],
  eth0:
   [ { address: &apos;192.168.1.108&apos;,
       netmask: &apos;255.255.255.0&apos;,
       family: &apos;IPv4&apos;,
       mac: &apos;01:02:03:0a:0b:0c&apos;,
       internal: false },
     { address: &apos;fe80::a00:27ff:fe4e:66a1&apos;,
       netmask: &apos;ffff:ffff:ffff:ffff::&apos;,
       family: &apos;IPv6&apos;,
       mac: &apos;01:02:03:0a:0b:0c&apos;,
       internal: false } ] }</code></pre>
<h2>os.EOL<span><a href="all.html#all_os_eol_1" id="all_os_eol_1">#</a></span></h2>
<p>A constant defining the appropriate End-of-line marker for the operating system.


</p>
<p>一个定义了操作系统的一行结束的标识的常量。
</p>
<h1>调试器<span><a href="all.html#all_87" id="all_87">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!-- type=misc -->

<p>V8 comes with an extensive debugger which is accessible out-of-process via a
simple <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP protocol</a>.
Node has a built-in client for this debugger. To use this, start Node with the
<code>debug</code> argument; a prompt will appear:

</p>
<p>V8 提供了一个强大的调试器，可以通过 <a href="http://code.google.com/p/v8/wiki/DebuggerProtocol">TCP 协议</a>从外部访问。Node 内建了这个调试器的客户端。要使用调试器，以 <code>debug</code> 参数启动 Node，出现提示符：

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt;</code></pre>
<p>Node&apos;s debugger client doesn&apos;t support the full range of commands, but
simple step and inspection is possible. By putting the statement <code>debugger;</code>
into the source code of your script, you will enable a breakpoint.

</p>
<p>Node 的调试器客户端并未完整支持所有命令，但简单的步进和检查是可行的。通过脚本的源代码中放置 <code>debugger;</code> 语句，您便可启用一个断点。

</p>
<p>For example, suppose <code>myscript.js</code> looked like this:

</p>
<p>比如，假设有一个类似这样的 <code>myscript.js</code>：

</p>
<pre><code>// myscript.js
x = 5;
setTimeout(function () {
  debugger;
  console.log(&quot;world&quot;);
}, 1000);
console.log(&quot;hello&quot;);</code></pre>
<p>Then once the debugger is run, it will break on line 4.

</p>
<p>那么，当调试器运行时，它会在第 4 行中断：

</p>
<pre><code>% node debug myscript.js
&lt; debugger listening on port 5858
connecting... ok
break in /home/indutny/Code/git/indutny/myscript.js:1
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
debug&gt; cont
&lt; hello
break in /home/indutny/Code/git/indutny/myscript.js:3
  1 x = 5;
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
debug&gt; next
break in /home/indutny/Code/git/indutny/myscript.js:4
  2 setTimeout(function () {
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
debug&gt; repl
Press Ctrl + C to leave debug repl
&gt; x
5
&gt; 2+2
4
debug&gt; next
&lt; world
break in /home/indutny/Code/git/indutny/myscript.js:5
  3   debugger;
  4   console.log(&quot;world&quot;);
  5 }, 1000);
  6 console.log(&quot;hello&quot;);
  7
debug&gt; quit
%</code></pre>
<p>The <code>repl</code> command allows you to evaluate code remotely. The <code>next</code> command
steps over to the next line. There are a few other commands available and more
to come. Type <code>help</code> to see others.

</p>
<p><code>repl</code> 命令允许您远程执行代码；<code>next</code> 命令步进到下一行。此外还有一些其它命令，输入 <code>help</code> 查看。

</p>
<h2>监视器<span><a href="all.html#all_88" id="all_88">#</a></span></h2>
<p>You can watch expression and variable values while debugging your code.
On every breakpoint each expression from the watchers list will be evaluated
in the current context and displayed just before the breakpoint&apos;s source code
listing.

</p>
<p>调试代码时您可以监视表达式或变量值。在每个断点中监视器列表中的各个表达式会被以当前上下文执行，并在断点的源代码前显示。

</p>
<p>To start watching an expression, type <code>watch(&quot;my_expression&quot;)</code>. <code>watchers</code>
prints the active watchers. To remove a watcher, type
<code>unwatch(&quot;my_expression&quot;)</code>.

</p>
<p>输入 <code>watch(&quot;my_expression&quot;)</code> 开始监视一个表达式；<code>watchers</code> 显示活动监视器；<code>unwatch(&quot;my_expression&quot;)</code> 移除一个监视器。

</p>
<h2>命令参考<span><a href="all.html#all_89" id="all_89">#</a></span></h2>
<h3>步进<span><a href="all.html#all_90" id="all_90">#</a></span></h3>
<ul>
<li><code>cont</code>, <code>c</code> - Continue execution</li>
<li><code>next</code>, <code>n</code> - Step next</li>
<li><code>step</code>, <code>s</code> - Step in</li>
<li><code>out</code>, <code>o</code> - Step out</li>
<li><p><code>pause</code> - Pause running code (like pause button in Developer Tools)</p>
</li>
<li><p><code>cont</code>, <code>c</code> - 继续执行</p>
</li>
<li><code>next</code>, <code>n</code> - Step next</li>
<li><code>step</code>, <code>s</code> - Step in</li>
<li><code>out</code>, <code>o</code> - Step out</li>
<li><code>pause</code> - 暂停执行代码（类似开发者工具中的暂停按钮）</li>
</ul>
<h3>断点<span><a href="all.html#all_91" id="all_91">#</a></span></h3>
<div><ul>
<li><code>setBreakpoint()</code>, <code>sb()</code> - Set breakpoint on current line</li>
<li><code>setBreakpoint(line)</code>, <code>sb(line)</code> - Set breakpoint on specific line</li>
<li><code>setBreakpoint(&apos;fn()&apos;)</code>, <code>sb(...)</code> - Set breakpoint on a first statement in
functions body</li>
<li><code>setBreakpoint(&apos;script.js&apos;, 1)</code>, <code>sb(...)</code> - Set breakpoint on first line of
script.js</li>
<li><p><code>clearBreakpoint</code>, <code>cb(...)</code> - Clear breakpoint</p>
</li>
<li><p><code>setBreakpoint()</code>, <code>sb()</code> - 在当前行设置断点</p>
</li>
<li><code>setBreakpoint(line)</code>, <code>sb(line)</code> - 在指定行设置断点</li>
<li><code>setBreakpoint(&apos;fn()&apos;)</code>, <code>sb(...)</code> - 在函数体的第一条语句设置断点</li>
<li><code>setBreakpoint(&apos;script.js&apos;, 1)</code>, <code>sb(...)</code> - 在 script.js 的第一行设置断点</li>
<li><code>clearBreakpoint</code>, <code>cb(...)</code> - 清除断点</li>
</div></ul>
<p>It is also possible to set a breakpoint in a file (module) that
isn&apos;t loaded yet:

</p>
<p>在一个尚未被加载的文件（模块）中设置断点也是可行的：

</p>
<pre><code>% ./node debug test/fixtures/break-in-module/main.js
&lt; debugger listening on port 5858
connecting to port 5858... ok
break in test/fixtures/break-in-module/main.js:1
  1 var mod = require(&apos;./mod.js&apos;);
  2 mod.hello();
  3 mod.hello();
debug&gt; setBreakpoint(&apos;mod.js&apos;, 23)
Warning: script &apos;mod.js&apos; was not loaded yet.
  1 var mod = require(&apos;./mod.js&apos;);
  2 mod.hello();
  3 mod.hello();
debug&gt; c
break in test/fixtures/break-in-module/mod.js:23
 21
 22 exports.hello = function() {
 23   return &apos;hello from module&apos;;
 24 };
 25
debug&gt;</code></pre>
<h3>信息<span><a href="all.html#all_92" id="all_92">#</a></span></h3>
<div><ul>
<li><code>backtrace</code>, <code>bt</code> - Print backtrace of current execution frame</li>
<li><code>list(5)</code> - List scripts source code with 5 line context (5 lines before and
after)</li>
<li><code>watch(expr)</code> - Add expression to watch list</li>
<li><code>unwatch(expr)</code> - Remove expression from watch list</li>
<li><code>watchers</code> - List all watchers and their values (automatically listed on each
breakpoint)</li>
<li><p><code>repl</code> - Open debugger&apos;s repl for evaluation in debugging script&apos;s context</p>
</li>
<li><p><code>backtrace</code>, <code>bt</code> - 显示当前执行框架的回溯</p>
</li>
<li><code>list(5)</code> - 显示脚本源代码的 5 行上下文（之前 5 行和之后 5 行）</li>
<li><code>watch(expr)</code> - 向监视列表添加表达式</li>
<li><code>unwatch(expr)</code> - 从监视列表移除表达式</li>
<li><code>watchers</code> - 列出所有监视器和它们的值（每个断点会自动列出）</li>
<li><code>repl</code> - 在所调试的脚本的上下文中打开调试器的 repl 执行代码</li>
</div></ul>
<h3>执行控制<span><a href="all.html#all_93" id="all_93">#</a></span></h3>
<div><ul>
<li><code>run</code> - Run script (automatically runs on debugger&apos;s start)</li>
<li><code>restart</code> - Restart script</li>
<li><p><code>kill</code> - Kill script</p>
</li>
<li><p><code>run</code> - 运行脚本（调试器开始时自动运行）</p>
</li>
<li><code>restart</code> - 重新运行脚本</li>
<li><code>kill</code> - 终止脚本</li>
</div></ul>
<h3>杂项<span><a href="all.html#all_94" id="all_94">#</a></span></h3>
<div><ul>
<li><code>scripts</code> - List all loaded scripts</li>
<li><p><code>version</code> - Display v8&apos;s version</p>
</li>
<li><p><code>scripts</code> - 列出所有已加载的脚本</p>
</li>
<li><code>version</code> - 显示 V8 的版本</li>
</div></ul>
<h2>高级使用<span><a href="all.html#all_95" id="all_95">#</a></span></h2>
<p>The V8 debugger can be enabled and accessed either by starting Node with
the <code>--debug</code> command-line flag or by signaling an existing Node process
with <code>SIGUSR1</code>.

</p>
<p>V8 调试器可以从两种方式启用和访问：以 <code>--debug</code> 命令行标志启动 Node；或者向已存在的 Node 进程发送 <code>SIGUSR1</code> 信号。

</p>
<p>Once a process has been set in debug mode with this it can be connected to
with the node debugger. Either connect to the <code>pid</code> or the URI to the debugger.
The syntax is:

</p>
<p>一旦一个进程进入了调试模式，它便可被 Node 调试器连接。调试器可以通过 <code>pid</code> 或 URI 来连接，语法是：

</p>
<ul>
<li><code>node debug -p &lt;pid&gt;</code> - Connects to the process via the <code>pid</code></li>
<li><code>node debug &lt;URI&gt;</code> - Connects to the process via the URI such as localhost:5858</li>
</ul>
<ul>
<li><code>node debug -p &lt;pid&gt;</code> - 通过 <code>pid</code> 连接进程</li>
<li><code>node debug &lt;URI&gt;</code> - 通过类似 localhost:5858 的 URI 连接进程</li>
</ul>
<h1>集群<span><a href="all.html#all_96" id="all_96">#</a></span></h1>
<pre><code>稳定度: 1 - 实验性</code></pre>
<p>A single instance of Node runs in a single thread. To take advantage of
multi-core systems the user will sometimes want to launch a cluster of Node
processes to handle the load.

</p>
<p>单个 Node 实例运行在单个线程中。要发挥多核系统的能力，用户有时候需要启动一个 Node 进程集群来处理负载。

</p>
<p>The cluster module allows you to easily create a network of processes that
all share server ports.

</p>
<p>集群模块允许你方便地创建一个共享服务器端口的进程网络。

</p>
<pre><code>  cluster.on(&apos;exit&apos;, function(worker, code, signal) {
    console.log(&apos;工作进程 &apos; + worker.process.pid + &apos; 被终止&apos;);
  });
} else {
  // 工作进程可以共享任意 TCP 连接
  // 本例中为 HTTP 服务器
  http.createServer(function(req, res) {
    res.writeHead(200);
    res.end(&quot;你好，操蛋的世界\n&quot;);
  }).listen(8000);
}</code></pre>
<p>Running node will now share port 8000 between the workers:

</p>
<p>现在，运行 node 将会在所有工作进程间共享 8000 端口：

</p>
<pre><code>% NODE_DEBUG=cluster node server.js
23521,Master Worker 23524 online
23521,Master Worker 23526 online
23521,Master Worker 23523 online
23521,Master Worker 23528 online</code></pre>
<p>This feature was introduced recently, and may change in future versions.
Please try it out and provide feedback.

</p>
<p>这是一个近期推出的功能，在未来版本中可能会有所改变。请尝试并提供反馈。

</p>
<p>Also note that, on Windows, it is not yet possible to set up a named pipe
server in a worker.

</p>
<p>还要注意的是，在 Windows 中尚不能在工作进程中建立一个被命名的管道服务器。

</p>
<h2>它是如何工作的<span><a href="all.html#all_97" id="all_97">#</a></span></h2>
<!--type=misc-->

<p>The worker processes are spawned using the <code>child_process.fork</code> method,
so that they can communicate with the parent via IPC and pass server
handles back and forth.

</p>
<p>工作进程是通过使用 <code>child_process.fork</code> 方法派生的，因此它们可以通过 IPC（进程间通讯）与父进程通讯并互相传递服务器句柄。

</p>
<p>The cluster module supports two methods of distributing incoming
connections.

</p>
<p>集群模块支持两种分配传入连接的方式。

</p>
<p>The first one (and the default one on all platforms except Windows),
is the round-robin approach, where the master process listens on a
port, accepts new connections and distributes them across the workers
in a round-robin fashion, with some built-in smarts to avoid
overloading a worker process.

</p>
<p>第一种（同时也是除 Windows 外所有平台的缺省方式）为循环式：主进程监听一个端口，接受新连接，并以轮流的方式分配给工作进程，并以一些内建机制来避免单个工作进程的超载。

</p>
<p>The second approach is where the master process creates the listen
socket and sends it to interested workers. The workers then accept
incoming connections directly.

</p>
<p>第二种方式是，主进程建立监听嵌套字，并将它发送给感兴趣的工作进程，由工作进程直接接受传入连接。

</p>
<p>The second approach should, in theory, give the best performance.
In practice however, distribution tends to be very unbalanced due
to operating system scheduler vagaries. Loads have been observed
where over 70% of all connections ended up in just two processes,
out of a total of eight.

</p>
<p>第二种方式理论上有最好的性能。然而在实践中，由于操作系统的调度变幻莫测，分配往往十分不平衡。负载曾被观测到超过 70% 的连接结束于总共八个进程中的两个。

</p>
<p>Because <code>server.listen()</code> hands off most of the work to the master
process, there are three cases where the behavior between a normal
node.js process and a cluster worker differs:

</p>
<p>因为 <code>server.listen()</code> 将大部分工作交给了主进程，所以一个普通的node.js进程和一个集群工作进程会在三种情况下有所区别：

</p>
<ol>
<li><code>server.listen({fd: 7})</code> Because the message is passed to the master,
file descriptor 7 <strong>in the parent</strong> will be listened on, and the
handle passed to the worker, rather than listening to the worker&apos;s
idea of what the number 7 file descriptor references.</li>
<li><code>server.listen(handle)</code> Listening on handles explicitly will cause
the worker to use the supplied handle, rather than talk to the master
process.  If the worker already has the handle, then it&apos;s presumed
that you know what you are doing.</li>
<li><code>server.listen(0)</code> Normally, this will cause servers to listen on a
random port.  However, in a cluster, each worker will receive the
same &quot;random&quot; port each time they do <code>listen(0)</code>.  In essence, the
port is random the first time, but predictable thereafter.  If you
want to listen on a unique port, generate a port number based on the
cluster worker ID.</li>
</ol>
<ol>
<li><code>server.listen({fd: 7})</code> 由于消息被传递到主进程，<strong>父进程中的</strong>文件描述符 7 会被监听，并且句柄会被传递给工作进程，而不是监听工作进程中文件描述符 7 所引用的东西。</li>
<li><code>server.listen(handle)</code> 明确地监听一个句柄会使得工作进程使用所给句柄，而不是与主进程通讯。如果工作进程已经拥有了该句柄，则假定您知道您在做什么。</li>
<li><code>server.listen(0)</code> 通常，这会让服务器监听一个随机端口。然而，在集群中，各个工作进程每次 <code>listen(0)</code> 都会得到一样的“随机”端口。实际上，端口在第一次时是随机的，但在那之后却是可预知的。如果您想要监听一个唯一的端口，则请根据集群工作进程 ID 来生成端口号。</li>
</ol>
<p>There is no routing logic in Node.js, or in your program, and no shared
state between the workers.  Therefore, it is important to design your
program such that it does not rely too heavily on in-memory data objects
for things like sessions and login.

</p>
<p>由于在 Node.js 或您的程序中并没有路由逻辑，工作进程之间也没有共享的状态，因此在您的程序中，诸如会话和登录等功能应当被设计成不能太过依赖于内存中的数据对象。

</p>
<p>Because workers are all separate processes, they can be killed or
re-spawned depending on your program&apos;s needs, without affecting other
workers.  As long as there are some workers still alive, the server will
continue to accept connections.  Node does not automatically manage the
number of workers for you, however.  It is your responsibility to manage
the worker pool for your application&apos;s needs.

</p>
<p>由于工作进程都是独立的进程，因此它们会根据您的程序的需要被终止或重新派生，并且不会影响到其它工作进程。只要还有工作进程存在，服务器就会继续接受连接。但是，Node 不会自动为您管理工作进程的数量，根据您的程序所需管理工作进程池是您的责任。

</p>
<h2>cluster.schedulingPolicy<span><a href="all.html#all_cluster_schedulingpolicy_1" id="all_cluster_schedulingpolicy_1">#</a></span></h2>
<p>The scheduling policy, either <code>cluster.SCHED_RR</code> for round-robin or
<code>cluster.SCHED_NONE</code> to leave it to the operating system. This is a
global setting and effectively frozen once you spawn the first worker
or call <code>cluster.setupMaster()</code>, whatever comes first.

</p>
<p>调度策略 <code>cluster.SCHED_RR</code> 表示轮流制，<code>cluster.SCHED_NONE</code> 表示由操作系统处理。这是一个全局设定，并且一旦您派生了第一个工作进程或调用了 <code>cluster.setupMaster()</code> 后便不可更改。

</p>
<p><code>SCHED_RR</code> is the default on all operating systems except Windows.
Windows will change to <code>SCHED_RR</code> once libuv is able to effectively
distribute IOCP handles without incurring a large performance hit.

</p>
<p><code>SCHED_RR</code> 是除 Windows 外所有操作系统上的缺省方式。只要 libuv 能够有效地分配 IOCP 句柄并且不产生巨大的性能损失，Windows 也将会更改为 <code>SCHED_RR</code> 方式。

</p>
<p><code>cluster.schedulingPolicy</code> can also be set through the
<code>NODE_CLUSTER_SCHED_POLICY</code> environment variable. Valid
values are <code>&quot;rr&quot;</code> and <code>&quot;none&quot;</code>.

</p>
<p><code>cluster.schedulingPolicy</code> 也可以通过环境变量 <code>NODE_CLUSTER_SCHED_POLICY</code> 设定。有效值为 <code>&quot;rr&quot;</code> 和 <code>&quot;none&quot;</code>。

</p>
<h2>cluster.settings<span><a href="all.html#all_cluster_settings_1" id="all_cluster_settings_1">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> file path to worker file.  (Default=<code>__filename</code>)</li>
<li><code>args</code> <span>Array</span> string arguments passed to worker.
(Default=<code>process.argv.slice(2)</code>)</li>
<li><code>silent</code> <span>Boolean</span> whether or not to send output to parent&apos;s stdio.
(Default=<code>false</code>)</li>
</ul>
</li>
<li><p><span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> 工作进程文件的路径。（缺省为 <code>__filename</code>）</li>
<li><code>args</code> <span>Array</span> 传递给工作进程的字符串参数。（缺省为 <code>process.argv.slice(2)</code>）</li>
<li><code>silent</code> <span>Boolean</span> 是否将输出发送到父进程的 stdio。（缺省为 <code>false</code>）</li>
</ul>
</li>
</div></ul>
<p>All settings set by the <code>.setupMaster</code> is stored in this settings object.
This object is not supposed to be changed or set manually, by you.

</p>
<p>所有由 <code>.setupMaster</code> 设定的设置都会储存在此设置对象中。这个对象不应由您手动更改或设定。

</p>
<h2>集群的主进程(判断当前进程是否是主进程)<span><a href="all.html#all_98" id="all_98">#</a></span></h2>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>True if the process is a master. This is determined
by the <code>process.env.NODE_UNIQUE_ID</code>. If <code>process.env.NODE_UNIQUE_ID</code> is
undefined, then <code>isMaster</code> is <code>true</code>.

</p>
<p>如果进程为主进程则为 <code>true</code>。这是由 <code>process.env.NODE_UNIQUE_ID</code> 判断的，如果 <code>process.env.NODE_UNIQUE_ID</code> 为 undefined，则 <code>isMaster</code> 为 <code>true</code>。

</p>
<h2>集群的主线程(判断当前线程是否是主线程)<span><a href="all.html#all_99" id="all_99">#</a></span></h2>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>This boolean flag is true if the process is a worker forked from a master.
If the <code>process.env.NODE_UNIQUE_ID</code> is set to a value, then
<code>isWorker</code> is <code>true</code>.

</p>
<p>如果当前进程是分支自主进程的工作进程，则该布尔标识的值为 <code>true</code>。如果 <code>process.env.NODE_UNIQUE_ID</code> 被设定为一个值，则 <code>isWorker</code> 为 <code>true</code>。

</p>
<h2>事件: &apos;fork&apos;<span><a href="all.html#all_fork_1" id="all_fork_1">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>When a new worker is forked the cluster module will emit a &apos;fork&apos; event.
This can be used to log worker activity, and create you own timeout.

</p>
<p>当一个新的工作进程被分支出来，cluster 模块会产生一个 &apos;fork&apos; 事件。这可被用于记录工作进程活动，以及创建您自己的超时判断。

</p>
<pre><code>cluster.on(&apos;fork&apos;, function(worker) {
  timeouts[worker.id] = setTimeout(errorMsg, 2000);
});
cluster.on(&apos;listening&apos;, function(worker, address) {
  clearTimeout(timeouts[worker.id]);
});
cluster.on(&apos;exit&apos;, function(worker, code, signal) {
  clearTimeout(timeouts[worker.id]);
  errorMsg();
});</code></pre>
<h2>事件: &apos;online&apos;<span><a href="all.html#all_online_2" id="all_online_2">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>After forking a new worker, the worker should respond with a online message.
When the master receives a online message it will emit such event.
The difference between &apos;fork&apos; and &apos;online&apos; is that fork is emitted when the
master tries to fork a worker, and &apos;online&apos; is emitted when the worker is
being executed.

</p>
<p>分支出一个新的工作进程后，工作进程会响应一个在线消息。当主进程收到一个在线消息后，它会触发该事件。&apos;fork&apos; 和 &apos;online&apos; 的区别在于前者发生于主进程尝试分支出工作进程时，而后者发生于工作进程被执行时。

</p>
<pre><code>cluster.on(&apos;online&apos;, function(worker) {
  console.log(&quot;嘿嘿，工作进程完成分支并发出回应了&quot;);
});</code></pre>
<h2>事件: &apos;listening&apos;<span><a href="all.html#all_listening_6" id="all_listening_6">#</a></span></h2>
<div><ul>
<li><code>worker</code> <span>Worker object</span></li>
<li><p><code>address</code> <span>Object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><code>address</code> <span>Object</span></li>
</div></ul>
<p>When calling <code>listen()</code> from a worker, a &apos;listening&apos; event is automatically assigned
to the server instance. When the server is listening a message is send to the master
where the &apos;listening&apos; event is emitted.

</p>
<p>当工作进程调用 <code>listen()</code> 时，一个 <code>listening</code> 事件会被自动分配到服务器实例中。当服务器处于监听时，一个消息会被发送到那个&apos;listening&apos;事件被分发的主进程。

</p>
<p>The event handler is executed with two arguments, the <code>worker</code> contains the worker
object and the <code>address</code> object contains the following connection properties:
<code>address</code>, <code>port</code> and <code>addressType</code>. This is very useful if the worker is listening
on more than one address.

</p>
<p>事件处理器被执行时会带上两个参数。其中 <code>worker</code> 包含了工作进程对象，<code>address</code> 对象包含了下列连接属性：地址 <code>address</code>、端口号 <code>port</code> 和地址类型 <code>addressType</code>。如果工作进程监听多个地址，那么这些信息将十分有用。

</p>
<pre><code>cluster.on(&apos;listening&apos;, function(worker, address) {
  console.log(&quot;一个工作进程刚刚连接到 &quot; + address.address + &quot;:&quot; + address.port);
});</code></pre>
<h2>事件: &apos;disconnect&apos;<span><a href="all.html#all_disconnect_4" id="all_disconnect_4">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>When a workers IPC channel has disconnected this event is emitted.
This will happen when the worker dies, usually after calling
<code>.kill()</code>.

</p>
<p>当一个工作进程的 IPC 通道断开时此事件会发生。这发生于工作进程结束时，通常是调用 <code>.kill()</code> 之后。

</p>
<p>When calling <code>.disconnect()</code>, there may be a delay between the
<code>disconnect</code> and <code>exit</code> events.  This event can be used to detect if
the process is stuck in a cleanup or if there are long-living
connections.

</p>
<p>当调用 <code>.disconnect()</code> 后，<code>disconnect</code> 和 <code>exit</code> 事件之间可能存在延迟。该事件可被用于检测进程是否被卡在清理过程或存在长连接。

</p>
<pre><code>cluster.on(&apos;disconnect&apos;, function(worker) {
  console.log(&apos;工作进程 #&apos; + worker.id + &apos; 断开了连接&apos;);
});</code></pre>
<h2>事件: &apos;exit&apos;<span><a href="all.html#all_exit_8" id="all_exit_8">#</a></span></h2>
<div><ul>
<li><code>worker</code> <span>Worker object</span></li>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the name of the signal (eg. <code>&apos;SIGHUP&apos;</code>) that caused
the process to be killed.</p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><code>code</code> <span>Number</span> 如果是正常退出则为退出代码。</li>
<li><code>signal</code> <span>String</span> 使得进程被终止的信号的名称（比如 <code>&apos;SIGHUP&apos;</code>）。</li>
</div></ul>
<p>When any of the workers die the cluster module will emit the &apos;exit&apos; event.
This can be used to restart the worker by calling <code>fork()</code> again.

</p>
<p>当任意工作进程被结束时，集群模块会分发<code>exit</code> 事件。通过再次调用<code>fork()</code>函数，可以使用这个事件来重启工作进程。

</p>
<pre><code>cluster.on(&apos;exit&apos;, function(worker, code, signal) {
  var exitCode = worker.process.exitCode;
  console.log(&apos;工作进程 &apos; + worker.process.pid + &apos; 被结束（&apos;+exitCode+&apos;）。正在重启...&apos;);
  cluster.fork();
});</code></pre>
<h2>事件: &apos;setup&apos;<span><a href="all.html#all_setup_1" id="all_setup_1">#</a></span></h2>
<div><ul>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
<li><p><code>worker</code> <span>Worker object</span></p>
</li>
</div></ul>
<p>When the <code>.setupMaster()</code> function has been executed this event emits.
If <code>.setupMaster()</code> was not executed before <code>fork()</code> this function will
call <code>.setupMaster()</code> with no arguments.

</p>
<p>当 <code>.setupMaster()</code> 函数被执行时触发此事件。如果 <code>.setupMaster()</code> 在 <code>fork()</code> 之前没被执行，那么它会不带参数调用 <code>.setupMaster()</code>。

</p>
<h2>cluster.setupMaster([settings])<span><a href="all.html#all_cluster_setupmaster_settings_1" id="all_cluster_setupmaster_settings_1">#</a></span></h2>
<div><ul>
<li><p><code>settings</code> <span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> file path to worker file.  (Default=<code>__filename</code>)</li>
<li><code>args</code> <span>Array</span> string arguments passed to worker.
(Default=<code>process.argv.slice(2)</code>)</li>
<li><code>silent</code> <span>Boolean</span> whether or not to send output to parent&apos;s stdio.
(Default=<code>false</code>)</li>
</ul>
</li>
<li><p><code>settings</code> <span>Object</span></p>
<ul>
<li><code>exec</code> <span>String</span> 工作进程文件的路径。（缺省为 <code>__filename</code>）</li>
<li><code>args</code> <span>Array</span> 传给工作进程的字符串参数。（缺省为 <code>process.argv.slice(2)</code>）</li>
<li><code>silent</code> <span>Boolean</span> 是否将输出发送到父进程的 stdio。（缺省为 <code>false</code>）</li>
</ul>
</li>
</div></ul>
<p><code>setupMaster</code> is used to change the default &apos;fork&apos; behavior. The new settings
are effective immediately and permanently, they cannot be changed later on.

</p>
<p><code>setupMaster</code> 被用于更改缺省的 <code>fork</code> 行为。新的设置会立即永久生效，并且在之后不能被更改。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var cluster = require(&quot;cluster&quot;);
cluster.setupMaster({
  exec : &quot;worker.js&quot;,
  args : [&quot;--use&quot;, &quot;https&quot;],
  silent : true
});
cluster.fork();</code></pre>
<h2>cluster.fork([env])<span><a href="all.html#all_cluster_fork_env_1" id="all_cluster_fork_env_1">#</a></span></h2>
<div><ul>
<li><code>env</code> <span>Object</span> Key/value pairs to add to child process environment.</li>
<li><p>return <span>Worker object</span></p>
</li>
<li><p><code>env</code> <span>Object</span> 添加到子进程环境变量中的键值对。</p>
</li>
<li>返回 <span>Worker object</span></li>
</div></ul>
<p>Spawn a new worker process. This can only be called from the master process.

</p>
<p>派生一个新的工作进程。这个函数只能在主进程中被调用。

</p>
<h2>cluster.disconnect([callback])<span><a href="all.html#all_cluster_disconnect_callback_1" id="all_cluster_disconnect_callback_1">#</a></span></h2>
<div><ul>
<li><p><code>callback</code> <span>Function</span> called when all workers are disconnected and handlers are closed</p>
</li>
<li><p><code>callback</code> <span>Function</span> 当所有工作进程都断开连接并且句柄被关闭时被调用</p>
</li>
</div></ul>
<p>When calling this method, all workers will commit a graceful suicide. When they are
disconnected all internal handlers will be closed, allowing the master process to
die graceful if no other event is waiting.

</p>
<p>调用此方法时，所有的工作进程都会优雅地将自己结束掉。当它们都断开连接时，所有的内部处理器都会被关闭，使得主进程可以可以在没有其它事件等待时优雅地结束。

</p>
<p>The method takes an optional callback argument which will be called when finished.

</p>
<p>该方法带有一个可选的回调参数，会在完成时被调用。

</p>
<h2>cluster.worker<span><a href="all.html#all_cluster_worker_1" id="all_cluster_worker_1">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>A reference to the current worker object. Not available in the master process.

</p>
<p>对当前工作进程对象的引用。在主进程中不可用。

</p>
<pre><code>if (cluster.isMaster) {
  console.log(&apos;我是主进程&apos;);
  cluster.fork();
  cluster.fork();
} else if (cluster.isWorker) {
  console.log(&apos;我是工作进程 #&apos; + cluster.worker.id);
}</code></pre>
<h2>cluster.workers<span><a href="all.html#all_cluster_workers_1" id="all_cluster_workers_1">#</a></span></h2>
<div><ul>
<li><p><span>Object</span></p>
</li>
<li><p><span>Object</span></p>
</li>
</div></ul>
<p>A hash that stores the active worker objects, keyed by <code>id</code> field. Makes it
easy to loop through all the workers. It is only available in the master
process.

</p>
<p>一个储存活动工作进程对象的哈希表，以 <code>id</code> 字段作为主键。它能被用作遍历所有工作进程，仅在主进程中可用。

</p>
<pre><code>// 遍历所有工作进程
function eachWorker(callback) {
  for (var id in cluster.workers) {
    callback(cluster.workers[id]);
  }
}
eachWorker(function(worker) {
  worker.send(&apos;向一线工作者们致以亲切问候！&apos;);
});</code></pre>
<p>Should you wish to reference a worker over a communication channel, using
the worker&apos;s unique id is the easiest way to find the worker.

</p>
<p>如果您希望通过通讯通道引用一个工作进程，那么使用工作进程的唯一标识是找到那个工作进程的最简单的办法。

</p>
<pre><code>socket.on(&apos;data&apos;, function(id) {
  var worker = cluster.workers[id];
});</code></pre>
<h2>类: Worker<span><a href="all.html#all_worker_1" id="all_worker_1">#</a></span></h2>
<p>A Worker object contains all public information and method about a worker.
In the master it can be obtained using <code>cluster.workers</code>. In a worker
it can be obtained using <code>cluster.worker</code>.

</p>
<p>一个 Worker 对象包含了工作进程的所有公开信息和方法。可通过主进程中的 <code>cluster.workers</code> 或工作进程中的 <code>cluster.worker</code> 取得。

</p>
<h3>worker.id<span><a href="all.html#all_worker_id_1" id="all_worker_id_1">#</a></span></h3>
<div><ul>
<li><p><span>String</span></p>
</li>
<li><p><span>String</span></p>
</li>
</div></ul>
<p>Each new worker is given its own unique id, this id is stored in the
<code>id</code>.

</p>
<p>每个新的工作进程都被赋予一个唯一的标识，这个标识被储存在 <code>id</code> 中。

</p>
<p>While a worker is alive, this is the key that indexes it in
cluster.workers

</p>
<p>当一个工作进程可用时，这就是它被索引在 cluster.workers 中的主键。

</p>
<h3>worker.process<span><a href="all.html#all_worker_process_1" id="all_worker_process_1">#</a></span></h3>
<div><ul>
<li><p><span>ChildProcess object</span></p>
</li>
<li><p><span>ChildProcess object</span></p>
</li>
</div></ul>
<p>All workers are created using <code>child_process.fork()</code>, the returned object
from this function is stored in process.

</p>
<p>所有工作进程都是使用 <code>child_process.fork()</code> 创建的，该函数返回的对象被储存在 process 中。

</p>
<p>See: <a href="child_process.html">Child Process module</a>

</p>
<p>参考：<a href="child_process.html">Child Process 模块</a>

</p>
<h3>worker.suicide<span><a href="all.html#all_worker_suicide_1" id="all_worker_suicide_1">#</a></span></h3>
<div><ul>
<li><p><span>Boolean</span></p>
</li>
<li><p><span>Boolean</span></p>
</li>
</div></ul>
<p>This property is a boolean. It is set when a worker dies after calling
<code>.kill()</code> or immediately after calling the <code>.disconnect()</code> method.
Until then it is <code>undefined</code>.

</p>
<p>该属性是一个布尔值。它会在工作进程调用 <code>.kill()</code> 后终止时或调用 <code>.disconnect()</code> 方法时被设置。在此之前它的值是 <code>undefined</code>。

</p>
<h3>worker.send(message, [sendHandle])<span><a href="all.html#all_worker_send_message_sendhandle_1" id="all_worker_send_message_sendhandle_1">#</a></span></h3>
<div><ul>
<li><code>message</code> <span>Object</span></li>
<li><p><code>sendHandle</code> <span>Handle object</span></p>
</li>
<li><p><code>message</code> <span>Object</span></p>
</li>
<li><code>sendHandle</code> <span>Handle object</span></li>
</div></ul>
<p>This function is equal to the send methods provided by
<code>child_process.fork()</code>.  In the master you should use this function to
send a message to a specific worker.  However in a worker you can also use
<code>process.send(message)</code>, since this is the same function.

</p>
<p>该函数等同于 <code>child_process.fork()</code> 提供的 send 方法。在主进程中您可以用该函数向特定工作进程发送消息。当然，在工作进程中您也能使用 <code>process.send(message)</code>，因为它们是同一个函数。

</p>
<p>This example will echo back all messages from the master:

</p>
<p>这个例子会回应来自主进程的所有消息：

</p>
<pre><code>} else if (cluster.isWorker) {
  process.on(&apos;message&apos;, function(msg) {
    process.send(msg);
  });
}</code></pre>
<h3>worker.kill([signal=&apos;SIGTERM&apos;])<span><a href="all.html#all_worker_kill_signal_sigterm_1" id="all_worker_kill_signal_sigterm_1">#</a></span></h3>
<div><ul>
<li><p><code>signal</code> <span>String</span> Name of the kill signal to send to the worker
process.</p>
</li>
<li><p><code>signal</code> <span>String</span> 发送给工作进程的终止信号的名称</p>
</li>
</div></ul>
<p>This function will kill the worker, and inform the master to not spawn a
new worker.  The boolean <code>suicide</code> lets you distinguish between voluntary
and accidental exit.

</p>
<p>该函数会终止工作进程，并告知主进程不要派生一个新工作进程。布尔值 <code>suicide</code> 让您区分自行退出和意外退出。

</p>
<pre><code>// 终止工作进程
worker.kill();</code></pre>
<p>This method is aliased as <code>worker.destroy()</code> for backwards
compatibility.

</p>
<p>该方法的别名是 <code>worker.destroy()</code>，以保持向后兼容。

</p>
<h3>worker.disconnect()<span><a href="all.html#all_worker_disconnect_1" id="all_worker_disconnect_1">#</a></span></h3>
<p>When calling this function the worker will no longer accept new connections, but
they will be handled by any other listening worker. Existing connection will be
allowed to exit as usual. When no more connections exist, the IPC channel to the worker
will close allowing it to die graceful. When the IPC channel is closed the <code>disconnect</code>
event will emit, this is then followed by the <code>exit</code> event, there is emitted when
the worker finally die.

</p>
<p>调用该函数后工作进程将不再接受新连接，但新连接仍会被其它正在监听的工作进程处理。已存在的连接允许正常退出。当没有连接存在，连接到工作进程的 IPC 通道会被关闭，以便工作进程安全地结束。当 IPC 通道关闭时 <code>disconnect</code> 事件会被触发，然后则是工作进程最终结束时触发的 <code>exit</code> 事件。

</p>
<p>Because there might be long living connections, it is useful to implement a timeout.
This example ask the worker to disconnect and after 2 seconds it will destroy the
server. An alternative would be to execute <code>worker.kill()</code> after 2 seconds, but
that would normally not allow the worker to do any cleanup if needed.

</p>
<p>由于可能存在长连接，通常会实现一个超时机制。这个例子会告知工作进程断开连接，并且在 2 秒后销毁服务器。另一个备选方案是 2 秒后执行 <code>worker.kill()</code>，但那样通常会使得工作进程没有机会进行必要的清理。

</p>
<pre><code>  process.on(&apos;message&apos;, function(msg) {
    if (msg === &apos;force kill&apos;) {
      server.close();
    }
  });
}</code></pre>
<h3>事件: &apos;message&apos;<span><a href="all.html#all_message_5" id="all_message_5">#</a></span></h3>
<div><ul>
<li><p><code>message</code> <span>Object</span></p>
</li>
<li><p><code>message</code> <span>Object</span></p>
</li>
</div></ul>
<p>This event is the same as the one provided by <code>child_process.fork()</code>.
In the master you should use this event, however in a worker you can also use
<code>process.on(&apos;message&apos;)</code>

</p>
<p>该事件和 <code>child_process.fork()</code> 所提供的一样。在主进程中您应当使用该事件，而在工作进程中您也可以使用 <code>process.on(&apos;message&apos;)</code>。

</p>
<p>As an example, here is a cluster that keeps count of the number of requests
in the master process using the message system:

</p>
<p>举个例子，这里有一个集群，使用消息系统在主进程中统计请求的数量：

</p>
<pre><code>    // 将请求通知主进程
    process.send({ cmd: &apos;notifyRequest&apos; });
  }).listen(8000);
}</code></pre>
<h3>事件: &apos;online&apos;<span><a href="all.html#all_online_3" id="all_online_3">#</a></span></h3>
<p>Same as the <code>cluster.on(&apos;online&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<p>和 <code>cluster.on(&apos;online&apos;)</code> 事件一样，但仅当特定工作进程的状态改变时发生。

</p>
<pre><code>cluster.fork().on(&apos;online&apos;, function() {
  // 工作进程在线
});</code></pre>
<h3>事件: &apos;listening&apos;<span><a href="all.html#all_listening_7" id="all_listening_7">#</a></span></h3>
<div><ul>
<li><p><code>address</code> <span>Object</span></p>
</li>
<li><p><code>address</code> <span>Object</span></p>
</li>
</div></ul>
<p>Same as the <code>cluster.on(&apos;listening&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<p>和 <code>cluster.on(&apos;listening&apos;)</code> 事件一样，但仅当特定工作进程的状态改变时发生。

</p>
<pre><code>cluster.fork().on(&apos;listening&apos;, function(address) {
  // 工作进程正在监听
});</code></pre>
<h3>事件: &apos;disconnect&apos;<span><a href="all.html#all_disconnect_5" id="all_disconnect_5">#</a></span></h3>
<p>Same as the <code>cluster.on(&apos;disconnect&apos;)</code> event, but emits only when the state change
on the specified worker.

</p>
<p>和 <code>cluster.on(&apos;disconnect&apos;)</code> 事件一样，但仅当特定工作进程的状态改变时发生。

</p>
<pre><code>cluster.fork().on(&apos;disconnect&apos;, function() {
  // 工作进程断开了连接
});</code></pre>
<h3>事件: &apos;exit&apos;<span><a href="all.html#all_exit_9" id="all_exit_9">#</a></span></h3>
<div><ul>
<li><code>code</code> <span>Number</span> the exit code, if it exited normally.</li>
<li><p><code>signal</code> <span>String</span> the name of the signal (eg. <code>&apos;SIGHUP&apos;</code>) that caused
the process to be killed.</p>
</li>
<li><p><code>code</code> <span>Number</span> 如果是正常退出则为退出代码。</p>
</li>
<li><code>signal</code> <span>String</span> 使得进程被终止的信号的名称（比如 <code>&apos;SIGHUP&apos;</code>）。</li>
</div></ul>
<p>Emitted by the individual worker instance, when the underlying child process
is terminated.  See <a href="child_process.html#child_process_event_exit">child_process event: &apos;exit&apos;</a>.

</p>
<p>由单个工作进程实例在底层子进程被结束时触发。详见<a href="child_process.html#child_process_event_exit">子进程事件: &apos;exit&apos;</a>。

</p>
<pre><code>var worker = cluster.fork();
worker.on(&apos;exit&apos;, function(code, signal) {
  if( signal ) {
    console.log(&quot;worker was killed by signal: &quot;+signal);
  } else if( code !== 0 ) {
    console.log(&quot;worker exited with error code: &quot;+code);
  } else {
    console.log(&quot;worker success!&quot;);
  }
});


var worker = cluster.fork();
worker.on(&apos;exit&apos;, function(code, signal) {
  if( signal ) {
    console.log(&quot;工人被信号 &quot; + signal + &quot; 杀掉了&quot;);
  } else if( code !== 0 ) {
    console.log(&quot;工作进程退出，错误码：&quot; + code);
  } else {
    console.log(&quot;劳动者的胜利！&quot;);
  }
});</code></pre>
<h1>Smalloc<span><a href="all.html#all_smalloc_1" id="all_smalloc_1">#</a></span></h1>
<pre><code>稳定度: 1 - 实验性</code></pre>
<h2>smalloc.alloc(length[, receiver][, type])<span><a href="all.html#all_smalloc_alloc_length_receiver_type_1" id="all_smalloc_alloc_length_receiver_type_1">#</a></span></h2>
<div><ul>
<li><code>length</code> <span>Number</span> <code>&lt;= smalloc.kMaxLength</code></li>
<li><code>receiver</code> <span>Object</span>, Optional, Default: <code>new Object</code></li>
<li><p><code>type</code> <span>Enum</span>, Optional, Default: <code>Uint8</code></p>
</li>
<li><p><code>length</code> <span>Number</span> <code>&lt;= smalloc.kMaxLength</code></p>
</li>
<li><code>receiver</code> <span>Object</span> 可选，缺省为 <code>new Object</code></li>
<li><code>type</code> <span>Enum</span> 可选，缺省为 <code>Uint8</code></li>
</div></ul>
<p>Returns <code>receiver</code> with allocated external array data. If no <code>receiver</code> is
passed then a new Object will be created and returned.

</p>
<p>返回 <code>receiver</code> 及所分配的外部数组数据。如果未传入 <code>receiver</code> 则会创建并返回一个新的 Object。

</p>
<p>Buffers are backed by a simple allocator that only handles the assignation of
external raw memory. Smalloc exposes that functionality.

</p>
<p>Buffer 后端为一个只处理外部原始内存的分配的简易分配器所支撑。Smalloc 暴露了该功能。

</p>
<p>This can be used to create your own Buffer-like classes. No other properties are
set, so the user will need to keep track of other necessary information (e.g.
<code>length</code> of the allocation).

</p>
<p>这可用于创建你自己的类似 Buffer 的类。由于不会设置其它属性，因此使用者需要自行跟踪其它所需信息（比如所分配的长度 <code>length</code>）。

</p>
<pre><code>SimpleData.prototype = { /* ... */ };</code></pre>
<p>It only checks if the <code>receiver</code> is an Object, and also not an Array. Because of
this it is possible to allocate external array data to more than a plain Object.

</p>
<p>它只检查 <code>receiver</code> 是否为一个非 Array 的 Object。因此，可以分配外部数组数据的不止纯 Object。

</p>
<pre><code>// { [Function allocMe] &apos;0&apos;: 0, &apos;1&apos;: 0, &apos;2&apos;: 0 }</code></pre>
<p>v8 does not support allocating external array data to an Array, and if passed
will throw.

</p>
<p>V8 不支持向一个 Array 分配外部数组数据，如果这么做将会抛出异常。

</p>
<p>It&apos;s possible is to specify the type of external array data you would like. All
possible options are listed in <code>smalloc.Types</code>. Example usage:

</p>
<p>您可以指定您想要的外部数组数据的类型。所有可取的值都已在 <code>smalloc.Types</code> 中列出。使用示例：

</p>
<pre><code>// { &apos;0&apos;: 0, &apos;1&apos;: 0.1, &apos;2&apos;: 0.2 }</code></pre>
<h2>smalloc.copyOnto(source, sourceStart, dest, destStart, copyLength);<span><a href="all.html#all_smalloc_copyonto_source_sourcestart_dest_deststart_copylength_1" id="all_smalloc_copyonto_source_sourcestart_dest_deststart_copylength_1">#</a></span></h2>
<div><ul>
<li><code>source</code> Object with external array allocation</li>
<li><code>sourceStart</code> Position to begin copying from</li>
<li><code>dest</code> Object with external array allocation</li>
<li><code>destStart</code> Position to begin copying onto</li>
<li><p><code>copyLength</code> Length of copy</p>
</li>
<li><p><code>source</code> 分配了外部数组的来源对象</p>
</li>
<li><code>sourceStart</code> 从这个位置开始拷贝</li>
<li><code>dest</code> 分配了外部数组的目标对象</li>
<li><code>destStart</code> 拷贝到这个位置</li>
<li><code>copyLength</code> 拷贝的长度</li>
</div></ul>
<p>Copy memory from one external array allocation to another. No arguments are
optional, and any violation will throw.

</p>
<p>从一个外部数组向另一个拷贝内存。所有参数都是必填，否则将会抛出异常。

</p>
<pre><code>// { &apos;0&apos;: 4, &apos;1&apos;: 6, &apos;2&apos;: 2, &apos;3&apos;: 3 }</code></pre>
<p><code>copyOnto</code> automatically detects the length of the allocation internally, so no
need to set any additional properties for this to work.

</p>
<p><code>copyOnto</code> 会在内部自动检测分配的长度，因此无需对此给出额外的参数。

</p>
<h2>smalloc.dispose(obj)<span><a href="all.html#all_smalloc_dispose_obj_1" id="all_smalloc_dispose_obj_1">#</a></span></h2>
<div><ul>
<li><p><code>obj</code> Object</p>
</li>
<li><p><code>obj</code> 对象</p>
</li>
</div></ul>
<p>Free memory that has been allocated to an object via <code>smalloc.alloc</code>.

</p>
<p>释放已使用 <code>smalloc.alloc</code> 分配到一个对象的内存。

</p>
<pre><code>// {}</code></pre>
<p>This is useful to reduce strain on the garbage collector, but developers must be
careful. Cryptic errors may arise in applications that are difficult to trace.

</p>
<p>这对于减轻垃圾回收器的负担有所帮助，但开发者务必小心。难以跟踪的应用程序可能会发生奇怪的错误。

</p>
<pre><code>// 将导致：
// Error: source has no external array data</code></pre>
<p><code>dispose()</code> does not support Buffers, and will throw if passed.

</p>
<p><code>dispose()</code> 不支持 Buffer，传入将会抛出异常。

</p>
<h2>smalloc.kMaxLength<span><a href="all.html#all_smalloc_kmaxlength_1" id="all_smalloc_kmaxlength_1">#</a></span></h2>
<p>Size of maximum allocation. This is also applicable to Buffer creation.

</p>
<p>最大的分配大小。该值同时也适用于 Buffer 的创建。

</p>
<h2>smalloc.Types<span><a href="all.html#all_smalloc_types_1" id="all_smalloc_types_1">#</a></span></h2>
<p>Enum of possible external array types. Contains:

</p>
<p>外部数组类型的可取值，包含：

</p>
<ul>
<li><code>Int8</code></li>
<li><code>Uint8</code></li>
<li><code>Int16</code></li>
<li><code>Uint16</code></li>
<li><code>Int32</code></li>
<li><code>Uint32</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Uint8Clamped</code></li>
</ul>
<ul>
<li><code>Int8</code></li>
<li><code>Uint8</code></li>
<li><code>Int16</code></li>
<li><code>Uint16</code></li>
<li><code>Int32</code></li>
<li><code>Uint32</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Uint8Clamped</code></li>
</ul>

          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://joyent.com" class="joyent-logo">Joyent</a>
        <ul class="clearfix">
            <li><a href="http://nodejs.org/">Node.js</a></li>
            <li><a href="http://nodejs.org/download/">Download</a></li>
            <li><a href="http://nodejs.org/about/">About</a></li>
            <li><a href="http://npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="http://nodejs.org/community/">Community</a></li>
            <li><a href="http://nodejs.org/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="http://jixiangac.com/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.10.18/LICENSE">license</a>.</p>
    </div>

  <script src="public/api_assets/sh_main.js"></script>
  <script src="public/api_assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <!--
  <script>
    window._gaq = [['_setAccount', 'UA-10874194-2'], ['_trackPageview']];
    (function(d, t) {
      var g = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      g.src = '//www.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g, s);
    }(document, 'script'));
  </script>
  -->
</body>
</html>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26599868-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>