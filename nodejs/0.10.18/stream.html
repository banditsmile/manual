<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>流 Node.js v0.10.18 文档 中文版</title>
  <link rel="stylesheet" href="public/api_assets/style.css">
  <link rel="stylesheet" href="public/api_assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/stream.html">
</head>
<body class="alt apidoc" id="api-section-stream">

    <div id="intro" class="interior">
        <a href="http://xudafeng.github.io/nodejs/" title="返回首页">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <li><a href="http://xudafeng.github.io/nodejs/" class="docs current">文档首页</a></li>
                <li><a href="http://nodejs.org/api/">英文版文档</a></li>
            </ul>
            <div style="margin-top:44px; font-size:12px;">
              <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">知识共享署名-非商业性使用 3.0 未本地化版本许可协议</a>进行许可。
            </div>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.10.18 手册 &amp; 文档</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">索引</a> |
                <a href="all.html">在单一页面中浏览</a> |
                <a href="http://jixiangac.com/doc/node/stream.json">JSON格式</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>目录</h2>
            <ul>
<li><a href="stream.html#stream">流</a><ul>
<li><a href="stream.html#stream_api">面向流消费者的 API</a><ul>
<li><a href="stream.html#stream_stream_readable">类: stream.Readable</a><ul>
<li><a href="stream.html#stream_readable">事件: &apos;readable&apos;</a></li>
<li><a href="stream.html#stream_data">事件: &apos;data&apos;</a></li>
<li><a href="stream.html#stream_end">事件: &apos;end&apos;</a></li>
<li><a href="stream.html#stream_close">事件: &apos;close&apos;</a></li>
<li><a href="stream.html#stream_error">事件: &apos;error&apos;</a></li>
<li><a href="stream.html#stream_readable_read_size">readable.read([size])</a></li>
<li><a href="stream.html#stream_readable_setencoding_encoding">readable.setEncoding(encoding)</a></li>
<li><a href="stream.html#stream_readable_resume">readable.resume()</a></li>
<li><a href="stream.html#stream_readable_pause">readable.pause()</a></li>
<li><a href="stream.html#stream_readable_pipe_destination_options">readable.pipe(destination, [options])</a></li>
<li><a href="stream.html#stream_readable_unpipe_destination">readable.unpipe([destination])</a></li>
<li><a href="stream.html#stream_readable_unshift_chunk">readable.unshift(chunk)</a></li>
<li><a href="stream.html#stream_readable_wrap_stream">readable.wrap(stream)</a></li>
</ul>
</li>
<li><a href="stream.html#stream_stream_writable">类: stream.Writable</a><ul>
<li><a href="stream.html#stream_writable_write_chunk_encoding_callback">writable.write(chunk, [encoding], [callback])</a></li>
<li><a href="stream.html#stream_drain">事件: &apos;drain&apos;</a></li>
<li><a href="stream.html#stream_writable_cork">writable.cork()</a></li>
<li><a href="stream.html#stream_writable_uncork">writable.uncork()</a></li>
<li><a href="stream.html#stream_writable_end_chunk_encoding_callback">writable.end([chunk], [encoding], [callback])</a></li>
<li><a href="stream.html#stream_finish">事件: &apos;finish&apos;</a></li>
<li><a href="stream.html#stream_pipe">事件: &apos;pipe&apos;</a></li>
<li><a href="stream.html#stream_unpipe">事件: &apos;unpipe&apos;</a></li>
</ul>
</li>
<li><a href="stream.html#stream_stream_duplex">类: stream.Duplex</a></li>
<li><a href="stream.html#stream_stream_transform">类: stream.Transform</a></li>
</ul>
</li>
<li><a href="stream.html#stream_api_1">面向流实现者的 API</a><ul>
<li><a href="stream.html#stream_stream_readable_1">类: stream.Readable</a><ul>
<li><a href="stream.html#stream_1">例子: 一个计数流</a></li>
<li><a href="stream.html#stream_simpleprotocol_v1_sub_optimal">例子: SimpleProtocol v1 (Sub-optimal)</a></li>
<li><a href="stream.html#stream_new_stream_readable_options">new stream.Readable([options])</a></li>
<li><a href="stream.html#stream_readable_read_size_1">readable._read(size)</a></li>
<li><a href="stream.html#stream_readable_push_chunk_encoding">readable.push(chunk, [encoding])</a></li>
</ul>
</li>
<li><a href="stream.html#stream_stream_writable_1">类: stream.Writable</a><ul>
<li><a href="stream.html#stream_new_stream_writable_options">new stream.Writable([options])</a></li>
<li><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">writable._write(chunk, encoding, callback)</a></li>
</ul>
</li>
<li><a href="stream.html#stream_writable_writev_chunks_callback">writable._writev(chunks, callback)</a></li>
<li><a href="stream.html#stream_stream_duplex_1">类: stream.Duplex</a><ul>
<li><a href="stream.html#stream_new_stream_duplex_options">new stream.Duplex(options)</a></li>
</ul>
</li>
<li><a href="stream.html#stream_stream_transform_1">类: stream.Transform</a><ul>
<li><a href="stream.html#stream_new_stream_transform_options">new stream.Transform([options])</a></li>
<li><a href="stream.html#stream_transform_transform_chunk_encoding_callback">transform._transform(chunk, encoding, callback)</a></li>
<li><a href="stream.html#stream_transform_flush_callback">transform._flush(callback)</a></li>
<li><a href="stream.html#stream_simpleprotocol_v2">例子: <code>SimpleProtocol</code> 解析器 v2</a></li>
</ul>
</li>
<li><a href="stream.html#stream_stream_passthrough">类: stream.PassThrough</a></li>
</ul>
</li>
<li><a href="stream.html#stream_2">流：内部细节</a><ul>
<li><a href="stream.html#stream_3">缓冲</a></li>
<li><a href="stream.html#stream_stream_read_0"><code>stream.read(0)</code></a></li>
<li><a href="stream.html#stream_stream_push"><code>stream.push(&apos;&apos;)</code></a></li>
<li><a href="stream.html#stream_node">与 Node 早期版本的兼容性</a></li>
<li><a href="stream.html#stream_4">对象模式</a></li>
<li><a href="stream.html#stream_5">状态对象</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>流<span><a href="stream.html#stream" id="stream">#</a></span></h1>
<pre><code>稳定度: 2 - 不稳定</code></pre>
<p>A stream is an abstract interface implemented by various objects in
Node.  For example a <a href="http.html#http_http_incomingmessage">request to an HTTP
server</a> is a stream, as is
<a href="process.html#process_process_stdout">stdout</a>. Streams are readable, writable, or both. All streams are
instances of <a href="events.html#events_class_events_eventemitter">EventEmitter</a>

</p>
<p>流是一个抽象接口，被 Node 中的很多对象所实现。比如<a href="http.html#http_http_incomingmessage">对一个 HTTP 服务器的请求</a>是一个流，<a href="process.html#process_process_stdout">stdout</a> 也是一个流。流是可读、可写或兼具两者的。所有流都是 <a href="events.html#events_class_events_eventemitter">EventEmitter</a> 的实例。

</p>
<p>You can load the Stream base classes by doing <code>require(&apos;stream&apos;)</code>.
There are base classes provided for <a href="stream.html#stream_class_stream_readable">Readable</a> streams, <a href="stream.html#stream_class_stream_writable">Writable</a>
streams, <a href="stream.html#stream_class_stream_duplex">Duplex</a> streams, and <a href="stream.html#stream_class_stream_transform">Transform</a> streams.

</p>
<p>您可以通过 <code>require(&apos;stream&apos;)</code> 加载 Stream 基类，其中包括了 <a href="stream.html#stream_class_stream_readable">Readable</a> 流、<a href="stream.html#stream_class_stream_writable">Writable</a> 流、<a href="stream.html#stream_class_stream_duplex">Duplex</a> 流和 <a href="stream.html#stream_class_stream_transform">Transform</a> 流的基类。

</p>
<p>This document is split up into 3 sections.  The first explains the
parts of the API that you need to be aware of to use streams in your
programs.  If you never implement a streaming API yourself, you can
stop there.

</p>
<p>本文档分为三个章节。第一章节解释了您在您的程序中使用流时需要了解的那部分 API，如果您不打算自己实现一个流式 API，您可以只阅读这一章节。

</p>
<p>The second section explains the parts of the API that you need to use
if you implement your own custom streams yourself.  The API is
designed to make this easy for you to do.

</p>
<p>第二章节解释了当您自己实现一个流时需要用到的那部分 API，这些 API 是为了方便您这么做而设计的。

</p>
<p>The third section goes into more depth about how streams work,
including some of the internal mechanisms and functions that you
should probably not modify unless you definitely know what you are
doing.

</p>
<p>第三章节深入讲解了流的工作方式，包括一些内部机制和函数，除非您明确知道您在做什么，否则尽量不要改动它们。

</p>
<h2>面向流消费者的 API<span><a href="stream.html#stream_api" id="stream_api">#</a></span></h2>
<!--type=misc-->

<p>Streams can be either <a href="stream.html#stream_class_stream_readable">Readable</a>, <a href="stream.html#stream_class_stream_writable">Writable</a>, or both (<a href="stream.html#stream_class_stream_duplex">Duplex</a>).

</p>
<p>流可以是可读（<a href="stream.html#stream_class_stream_readable">Readable</a>）或可写（<a href="stream.html#stream_class_stream_writable">Writable</a>），或者兼具两者（<a href="stream.html#stream_class_stream_duplex">Duplex</a>，双工）的。

</p>
<p>All streams are EventEmitters, but they also have other custom methods
and properties depending on whether they are Readable, Writable, or
Duplex.

</p>
<p>所有流都是 EventEmitter，但它们也具有其它自定义方法和属性，取决于它们是 Readable、Writable 或 Duplex。

</p>
<p>If a stream is both Readable and Writable, then it implements all of
the methods and events below.  So, a <a href="stream.html#stream_class_stream_duplex">Duplex</a> or <a href="stream.html#stream_class_stream_transform">Transform</a> stream is
fully described by this API, though their implementation may be
somewhat different.

</p>
<p>如果一个流既可读（Readable）也可写（Writable），则它实现了下文所述的所有方法和事件。因此，这些 API 同时也涵盖了 <a href="stream.html#stream_class_stream_duplex">Duplex</a> 或 <a href="stream.html#stream_class_stream_transform">Transform</a> 流，即便它们的实现可能有点不同。

</p>
<p>It is not necessary to implement Stream interfaces in order to consume
streams in your programs.  If you <strong>are</strong> implementing streaming
interfaces in your own program, please also refer to
<a href="stream.html#stream_api_for_stream_implementors">API for Stream Implementors</a> below.

</p>
<p>为了消费流而在您的程序中自己实现 Stream 接口是没有必要的。如果您<strong>确实</strong>正在您自己的程序中实现流式接口，请同时参考下文<a href="stream.html#stream_api_for_stream_implementors">面向流实现者的 API</a>。

</p>
<p>Almost all Node programs, no matter how simple, use Streams in some
way.  Here is an example of using Streams in a Node program:

</p>
<p>几乎所有 Node 程序，无论多简单，都在某种途径用到了流。这里有一个使用流的 Node 程序的例子：

</p>
<pre><code>var http = require(&apos;http&apos;);

var server = http.createServer(function (req, res) {
  // req is an http.IncomingMessage, which is a Readable Stream
  // res is an http.ServerResponse, which is a Writable Stream

var server = http.createServer(function (req, res) {
  // req 为 http.IncomingMessage，是一个可读流（Readable Stream）
  // res 为 http.ServerResponse，是一个可写流（Writable Stream）

  var body = &apos;&apos;;
  // we want to get the data as utf8 strings
  // If you don&apos;t set an encoding, then you&apos;ll get Buffer objects
  req.setEncoding(&apos;utf8&apos;);

  var body = &apos;&apos;;
  // 我们打算以 UTF-8 字符串的形式获取数据
  // 如果您不设置编码，您将得到一个 Buffer 对象
  req.setEncoding(&apos;utf8&apos;);

  // Readable streams emit &apos;data&apos; events once a listener is added
  req.on(&apos;data&apos;, function (chunk) {
    body += chunk;
  })

  // 一旦监听器被添加，可读流会触发 &apos;data&apos; 事件
  req.on(&apos;data&apos;, function (chunk) {
    body += chunk;
  })

  // the end event tells you that you have entire body
  req.on(&apos;end&apos;, function () {
    try {
      var data = JSON.parse(body);
    } catch (er) {
      // uh oh!  bad json!
      res.statusCode = 400;
      return res.end(&apos;error: &apos; + er.message);
    }

  // &apos;end&apos; 事件表明您已经得到了完整的 body
  req.on(&apos;end&apos;, function () {
    try {
      var data = JSON.parse(body);
    } catch (er) {
      // uh oh!  bad json!
      res.statusCode = 400;
      return res.end(&apos;错误: &apos; + er.message);
    }

    // write back something interesting to the user:
    res.write(typeof data);
    res.end();
  })
})

    // 向用户回写一些有趣的信息
    res.write(typeof data);
    res.end();
  })
})

server.listen(1337);

server.listen(1337);

// $ curl localhost:1337 -d &apos;{}&apos;
// object
// $ curl localhost:1337 -d &apos;&quot;foo&quot;&apos;
// string
// $ curl localhost:1337 -d &apos;not json&apos;
// 错误: Unexpected token o</code></pre>
<h3>类: stream.Readable<span><a href="stream.html#stream_stream_readable" id="stream_stream_readable">#</a></span></h3>
<!--type=class-->

<p>The Readable stream interface is the abstraction for a <em>source</em> of
data that you are reading from.  In other words, data comes <em>out</em> of a
Readable stream.

</p>
<p>Readable（可读）流接口是对您正在读取的数据的<em>来源</em>的抽象。换言之，数据<em>出自</em>一个 Readable 流。

</p>
<p>A Readable stream will not start emitting data until you indicate that
you are ready to receive it.

</p>
<p>在您表明您就绪接收之前，Readable 流并不会开始发生数据。

</p>
<p>Readable streams have two &quot;modes&quot;: a <strong>flowing mode</strong> and a <strong>paused
mode</strong>.  When in flowing mode, data is read from the underlying system
and provided to your program as fast as possible.  In paused mode, you
must explicitly call <code>stream.read()</code> to get chunks of data out.
Streams start out in paused mode.

</p>
<p>Readable 流有两种“模式”：<strong>流动模式</strong>和<strong>暂停模式</strong>。当处于流动模式时，数据由底层系统读出，并尽可能快地提供给您的程序；当处于暂停模式时，您必须明确地调用 <code>stream.read()</code> 来取出若干数据块。流默认处于暂停模式。

</p>
<p><strong>Note</strong>: If no data event handlers are attached, and there are no
<a href="stream.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> destinations, and the stream is switched into flowing
mode, then data will be lost.

</p>
<p><strong>注意</strong>：如果没有绑定 data 事件处理器，并且没有 <a href="stream.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> 目标，同时流被切换到流动模式，那么数据会流失。

</p>
<p>You can switch to flowing mode by doing any of the following:

</p>
<p>您可以通过下面几种做法切换到流动模式：

</p>
<ul>
<li>Adding a <a href="stream.html#stream_event_data"><code>&apos;data&apos;</code> event</a> handler to listen for data.</li>
<li>Calling the <a href="stream.html#stream_readable_resume"><code>resume()</code></a> method to explicitly open the flow.</li>
<li><p>Calling the <a href="stream.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> method to send the data to a <a href="stream.html#stream_class_stream_writable">Writable</a>.</p>
</li>
<li><p>添加一个 <a href="stream.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>处理器来监听数据。</p>
</li>
<li>调用 <a href="stream.html#stream_readable_resume"><code>resume()</code></a> 方法来明确开启数据流。</li>
<li>调用 <a href="stream.html#stream_readable_pipe_destination_options"><code>pipe()</code></a> 方法将数据发送到一个 <a href="stream.html#stream_class_stream_writable">Writable</a>。</li>
</ul>
<p>You can switch back to paused mode by doing either of the following:

</p>
<p>您可以通过下面其中一种做法切换回暂停模式：

</p>
<ul>
<li>If there are no pipe destinations, by calling the <a href="stream.html#stream_readable_pause"><code>pause()</code></a>
method.</li>
<li><p>If there are pipe destinations, by removing any <a href="stream.html#stream_event_data"><code>&apos;data&apos;</code> event</a>
handlers, and removing all pipe destinations by calling the
<a href="stream.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> method.</p>
</li>
<li><p>如果没有导流目标，调用 <a href="stream.html#stream_readable_pause"><code>pause()</code></a> 方法。</p>
</li>
<li>如果有导流目标，移除所有 [<code>&apos;data&apos;</code> 事件][] 处理器、调用 <a href="stream.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> 方法移除所有导流目标。</li>
</ul>
<p>Note that, for backwards compatibility reasons, removing <code>&apos;data&apos;</code>
event handlers will <strong>not</strong> automatically pause the stream.  Also, if
there are piped destinations, then calling <code>pause()</code> will not
guarantee that the stream will <em>remain</em> paused once those
destinations drain and ask for more data.

</p>
<p>请注意，为了向后兼容考虑，移除 <code>&apos;data&apos;</code> 事件监听器并<strong>不会</strong>自动暂停流。同样的，当有导流目标时，调用 <code>pause()</code> 并不能保证流在那些目标排空并请求更多数据时<em>维持</em>暂停状态。

</p>
<p>Examples of readable streams include:

</p>
<p>一些可读流的例子：

</p>
<ul>
<li><a href="http.html#http_http_incomingmessage">http responses, on the client</a></li>
<li><a href="http.html#http_http_incomingmessage">http requests, on the server</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs read streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdout">child process stdout and stderr</a></li>
<li><a href="process.html#process_process_stdin">process.stdin</a></li>
</ul>
<ul>
<li><a href="http.html#http_http_incomingmessage">客户端上的 HTTP 响应</a></li>
<li><a href="http.html#http_http_incomingmessage">服务器上的 HTTP 请求</a></li>
<li><a href="fs.html#fs_class_fs_readstream">fs 读取流</a></li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
<li><a href="net.html#net_class_net_socket">TCP 嵌套字</a></li>
<li><a href="child_process.html#child_process_child_stdout">子进程的 stdout 和 stderr</a></li>
<li><a href="process.html#process_process_stdin">process.stdin</a></li>
</ul>
<h4>事件: &apos;readable&apos;<span><a href="stream.html#stream_readable" id="stream_readable">#</a></span></h4>
<p>When a chunk of data can be read from the stream, it will emit a
<code>&apos;readable&apos;</code> event.

</p>
<p>当一个数据块可以从流中被读出时，它会触发一个 <code>&apos;readable&apos;</code> 事件。

</p>
<p>In some cases, listening for a <code>&apos;readable&apos;</code> event will cause some data
to be read into the internal buffer from the underlying system, if it
hadn&apos;t already.

</p>
<p>在某些情况下，假如未准备好，监听一个 <code>&apos;readable&apos;</code> 事件会使得一些数据从底层系统被读出到内部缓冲区中。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;readable&apos;, function() {
  // 现在有数据可以读了
})</code></pre>
<p>Once the internal buffer is drained, a <code>readable</code> event will fire
again when more data is available.

</p>
<p>当内部缓冲区被排空后，一旦更多数据时，一个 <code>readable</code> 事件会被再次触发。

</p>
<h4>事件: &apos;data&apos;<span><a href="stream.html#stream_data" id="stream_data">#</a></span></h4>
<div><ul>
<li><p><code>chunk</code> <span>Buffer | String</span> The chunk of data.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 数据块。</p>
</li>
</div></ul>
<p>Attaching a <code>data</code> event listener to a stream that has not been
explicitly paused will switch the stream into flowing mode. Data will
then be passed as soon as it is available.

</p>
<p>绑定一个 <code>data</code> 事件监听器到一个未被明确暂停的流会将流切换到流动模式，数据会被尽可能地传递。

</p>
<p>If you just want to get all the data out of the stream as fast as
possible, this is the best way to do so.

</p>
<p>如果您想从流尽快取出所有数据，这是最理想的方式。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
})</code></pre>
<h4>事件: &apos;end&apos;<span><a href="stream.html#stream_end" id="stream_end">#</a></span></h4>
<p>This event fires when no more data will be provided.

</p>
<p>该事件会在没有更多数据能够提供时被触发。

</p>
<p>Note that the <code>end</code> event <strong>will not fire</strong> unless the data is
completely consumed.  This can be done by switching into flowing mode,
or by calling <code>read()</code> repeatedly until you get to the end.

</p>
<p>请注意，<code>end</code> 事件在数据被完全消费之前<strong>不会被触发</strong>。这可通过切换到流动模式，或者在到达末端前不断调用 <code>read()</code> 来实现。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
})
readable.on(&apos;end&apos;, function() {
  console.log(&apos;读取完毕。&apos;);
});</code></pre>
<h4>事件: &apos;close&apos;<span><a href="stream.html#stream_close" id="stream_close">#</a></span></h4>
<p>Emitted when the underlying resource (for example, the backing file
descriptor) has been closed. Not all streams will emit this.

</p>
<p>当底层数据源（比如，源头的文件描述符）被关闭时触发。并不是所有流都会触发这个事件。

</p>
<h4>事件: &apos;error&apos;<span><a href="stream.html#stream_error" id="stream_error">#</a></span></h4>
<p>Emitted if there was an error receiving data.

</p>
<p>当数据接收时发生错误时触发。

</p>
<h4>readable.read([size])<span><a href="stream.html#stream_readable_read_size" id="stream_readable_read_size">#</a></span></h4>
<div><ul>
<li><code>size</code> <span>Number</span> Optional argument to specify how much data to read.</li>
<li><p>Return <span>String | Buffer | null</span></p>
</li>
<li><p><code>size</code> <span>Number</span> 可选参数，指定要读取多少数据。</p>
</li>
<li>返回 <span>String | Buffer | null</span></li>
</div></ul>
<p>The <code>read()</code> method pulls some data out of the internal buffer and
returns it.  If there is no data available, then it will return
<code>null</code>.

</p>
<p><code>read()</code> 方法从内部缓冲区中拉取并返回若干数据。当没有更多数据可用时，它会返回 <code>null</code>。

</p>
<p>If you pass in a <code>size</code> argument, then it will return that many
bytes.  If <code>size</code> bytes are not available, then it will return <code>null</code>.

</p>
<p>若您传入了一个 <code>size</code> 参数，那么它会返回相当字节的数据；当 <code>size</code> 字节不可用时，它则返回 <code>null</code>。

</p>
<p>If you do not specify a <code>size</code> argument, then it will return all the
data in the internal buffer.

</p>
<p>若您没有指定 <code>size</code> 参数，那么它会返回内部缓冲区中的所有数据。

</p>
<p>This method should only be called in paused mode.  In flowing mode,
this method is called automatically until the internal buffer is
drained.

</p>
<p>该方法仅应在暂停模式时被调用。在流动模式中，该方法会被自动调用直到内部缓冲区排空。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;readable&apos;, function() {
  var chunk;
  while (null !== (chunk = readable.read())) {
    console.log(&apos;得到了 %d 字节的数据&apos;, chunk.length);
  }
});</code></pre>
<p>If this method returns a data chunk, then it will also trigger the
emission of a <a href="stream.html#stream_event_data"><code>&apos;data&apos;</code> event</a>.

</p>
<p>当该方法返回了一个数据块，它同时也会触发 <a href="stream.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>。

</p>
<h4>readable.setEncoding(encoding)<span><a href="stream.html#stream_readable_setencoding_encoding" id="stream_readable_setencoding_encoding">#</a></span></h4>
<div><ul>
<li><code>encoding</code> <span>String</span> The encoding to use.</li>
<li><p>Return: <code>this</code></p>
</li>
<li><p><code>encoding</code> <span>String</span> 要使用的编码。</p>
</li>
<li>返回: <code>this</code></li>
</div></ul>
<p>Call this function to cause the stream to return strings of the
specified encoding instead of Buffer objects.  For example, if you do
<code>readable.setEncoding(&apos;utf8&apos;)</code>, then the output data will be
interpreted as UTF-8 data, and returned as strings.  If you do
<code>readable.setEncoding(&apos;hex&apos;)</code>, then the data will be encoded in
hexadecimal string format.

</p>
<p>调用此函数会使得流返回指定编码的字符串而不是 Buffer 对象。比如，当您 <code>readable.setEncoding(&apos;utf8&apos;)</code>，那么输出数据会被作为 UTF-8 数据解析，并以字符串返回。如果您 <code>readable.setEncoding(&apos;hex&apos;)</code>，那么数据会被编码成十六进制字符串格式。

</p>
<p>This properly handles multi-byte characters that would otherwise be
potentially mangled if you simply pulled the Buffers directly and
called <code>buf.toString(encoding)</code> on them.  If you want to read the data
as strings, always use this method.

</p>
<p>该方法能正确处理多字节字符。假如您不这么做，仅仅直接取出 Buffer 并对它们调用 <code>buf.toString(encoding)</code>，很可能会导致字节错位。因此如果您打算以字符串读取数据，请总是使用这个方法。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.setEncoding(&apos;utf8&apos;);
readable.on(&apos;data&apos;, function(chunk) {
  assert.equal(typeof chunk, &apos;string&apos;);
  console.log(&apos;得到了 %d 个字符的字符串数据&apos;, chunk.length);
})</code></pre>
<h4>readable.resume()<span><a href="stream.html#stream_readable_resume" id="stream_readable_resume">#</a></span></h4>
<div><ul>
<li><p>Return: <code>this</code></p>
</li>
<li><p>返回: <code>this</code></p>
</li>
</div></ul>
<p>This method will cause the readable stream to resume emitting <code>data</code>
events.

</p>
<p>该方法让可读流继续触发 <code>data</code> 事件。

</p>
<p>This method will switch the stream into flowing mode.  If you do <em>not</em>
want to consume the data from a stream, but you <em>do</em> want to get to
its <code>end</code> event, you can call <a href="stream.html#stream_readable_resume"><code>readable.resume()</code></a> to open the flow of
data.

</p>
<p>该方法会将流切换到流动模式。如果您<em>不想</em>从流中消费数据，但您<em>想</em>得到它的 <code>end</code> 事件，您可以调用 <a href="stream.html#stream_readable_resume"><code>readable.resume()</code></a> 来启动数据流。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.resume();
readable.on(&apos;end&apos;, function(chunk) {
  console.log(&apos;到达末端，但并未读取任何东西&apos;);
})</code></pre>
<h4>readable.pause()<span><a href="stream.html#stream_readable_pause" id="stream_readable_pause">#</a></span></h4>
<div><ul>
<li><p>Return: <code>this</code></p>
</li>
<li><p>返回: <code>this</code></p>
</li>
</div></ul>
<p>This method will cause a stream in flowing mode to stop emitting
<code>data</code> events, switching out of flowing mode.  Any data that becomes
available will remain in the internal buffer.

</p>
<p>该方法会使一个处于流动模式的流停止触发 <code>data</code> 事件，切换到非流动模式，并让后续可用数据留在内部缓冲区中。

</p>
<pre><code>var readable = getReadableStreamSomehow();
readable.on(&apos;data&apos;, function(chunk) {
  console.log(&apos;取得 %d 字节数据&apos;, chunk.length);
  readable.pause();
  console.log(&apos;接下来 1 秒内不会有数据&apos;);
  setTimeout(function() {
    console.log(&apos;现在数据会再次开始流动&apos;);
    readable.resume();
  }, 1000);
})</code></pre>
<h4>readable.pipe(destination, [options])<span><a href="stream.html#stream_readable_pipe_destination_options" id="stream_readable_pipe_destination_options">#</a></span></h4>
<div><ul>
<li><code>destination</code> <span><a href="stream.html#stream_class_stream_writable">Writable</a> Stream</span> The destination for writing data</li>
<li><p><code>options</code> <span>Object</span> Pipe options</p>
<ul>
<li><code>end</code> <span>Boolean</span> End the writer when the reader ends. Default = <code>true</code></li>
</ul>
</li>
<li><p><code>destination</code> <span><a href="stream.html#stream_class_stream_writable">Writable</a> Stream</span> 写入数据的目标</p>
</li>
<li><code>options</code> <span>Object</span> 导流选项<ul>
<li><code>end</code> <span>Boolean</span> 在读取者结束时结束写入者。缺省为 <code>true</code></li>
</ul>
</li>
</div></ul>
<p>This method pulls all the data out of a readable stream, and writes it
to the supplied destination, automatically managing the flow so that
the destination is not overwhelmed by a fast readable stream.

</p>
<p>该方法从可读流中拉取所有数据，并写入到所提供的目标。该方法能自动控制流量以避免目标被快速读取的可读流所淹没。

</p>
<p>Multiple destinations can be piped to safely.

</p>
<p>可以导流到多个目标。

</p>
<pre><code>var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&apos;file.txt&apos;);
// 所有来自 readable 的数据会被写入到 &apos;file.txt&apos;
readable.pipe(writable);</code></pre>
<p>This function returns the destination stream, so you can set up pipe
chains like so:

</p>
<p>该函数返回目标流，因此您可以建立导流链：

</p>
<pre><code>var r = fs.createReadStream(&apos;file.txt&apos;);
var z = zlib.createGzip();
var w = fs.createWriteStream(&apos;file.txt.gz&apos;);
r.pipe(z).pipe(w);</code></pre>
<p>For example, emulating the Unix <code>cat</code> command:

</p>
<p>例如，模拟 Unix 的 <code>cat</code> 命令：

</p>
<pre><code>process.stdin.pipe(process.stdout);</code></pre>
<p>By default <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> is called on the destination when the source stream
emits <code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end:
false }</code> as <code>options</code> to keep the destination stream open.

</p>
<p>缺省情况下当来源流触发 <code>end</code> 时目标的 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 会被调用，所以此时 <code>destination</code> 不再可写。传入 <code>{ end: false }</code> 作为 <code>options</code> 可以让目标流保持开启状态。

</p>
<p>This keeps <code>writer</code> open so that &quot;Goodbye&quot; can be written at the
end.

</p>
<p>这将让 <code>writer</code> 保持开启，因此最后可以写入 &quot;Goodbye&quot;。

</p>
<pre><code>reader.pipe(writer, { end: false });
reader.on(&apos;end&apos;, function() {
  writer.end(&apos;Goodbye\n&apos;);
});</code></pre>
<p>Note that <code>process.stderr</code> and <code>process.stdout</code> are never closed until
the process exits, regardless of the specified options.

</p>
<p>请注意 <code>process.stderr</code> 和 <code>process.stdout</code> 在进程结束前都不会被关闭，无论是否指定选项。

</p>
<h4>readable.unpipe([destination])<span><a href="stream.html#stream_readable_unpipe_destination" id="stream_readable_unpipe_destination">#</a></span></h4>
<div><ul>
<li><p><code>destination</code> <span><a href="stream.html#stream_class_stream_writable">Writable</a> Stream</span> Optional specific stream to unpipe</p>
</li>
<li><p><code>destination</code> <span><a href="stream.html#stream_class_stream_writable">Writable</a> Stream</span> 可选，指定解除导流的流</p>
</li>
</div></ul>
<p>This method will remove the hooks set up for a previous <code>pipe()</code> call.

</p>
<p>该方法会移除之前调用 <code>pipe()</code> 所设定的钩子。

</p>
<p>If the destination is not specified, then all pipes are removed.

</p>
<p>如果不指定目标，所有导流都会被移除。

</p>
<p>If the destination is specified, but no pipe is set up for it, then
this is a no-op.

</p>
<p>如果指定了目标，但并没有与之建立导流，则什么事都不会发生。

</p>
<pre><code>var readable = getReadableStreamSomehow();
var writable = fs.createWriteStream(&apos;file.txt&apos;);
// 来自 readable 的所有数据都会被写入 &apos;file.txt&apos;,
// 但仅发生在第 1 秒
readable.pipe(writable);
setTimeout(function() {
  console.log(&apos;停止写入到 file.txt&apos;);
  readable.unpipe(writable);
  console.log(&apos;自行关闭文件流&apos;);
  writable.end();
}, 1000);</code></pre>
<h4>readable.unshift(chunk)<span><a href="stream.html#stream_readable_unshift_chunk" id="stream_readable_unshift_chunk">#</a></span></h4>
<div><ul>
<li><p><code>chunk</code> <span>Buffer | String</span> Chunk of data to unshift onto the read queue</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要插回读取队列开头的数据块</p>
</li>
</div></ul>
<p>This is useful in certain cases where a stream is being consumed by a
parser, which needs to &quot;un-consume&quot; some data that it has
optimistically pulled out of the source, so that the stream can be
passed on to some other party.

</p>
<p>该方法在许多场景中都很有用，比如一个流正在被一个解析器消费，解析器可能需要将某些刚拉取出的数据“逆消费”回来源，以便流能将它传递给其它消费者。

</p>
<p>If you find that you must often call <code>stream.unshift(chunk)</code> in your
programs, consider implementing a <a href="stream.html#stream_class_stream_transform">Transform</a> stream instead.  (See API
for Stream Implementors, below.)

</p>
<p>如果您发现您需要在您的程序中频繁调用 <code>stream.unshift(chunk)</code>，请考虑实现一个 <a href="stream.html#stream_class_stream_transform">Transform</a> 流。（详见下文面向流实现者的 API。）

</p>
<pre><code>// 取出以 \n\n 分割的头部并将多余部分 unshift() 回去
// callback 以 (error, header, stream) 形式调用
var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;
function parseHeader(stream, callback) {
  stream.on(&apos;error&apos;, callback);
  stream.on(&apos;readable&apos;, onReadable);
  var decoder = new StringDecoder(&apos;utf8&apos;);
  var header = &apos;&apos;;
  function onReadable() {
    var chunk;
    while (null !== (chunk = stream.read())) {
      var str = decoder.write(chunk);
      if (str.match(/\n\n/)) {
        // 找到头部边界
        var split = str.split(/\n\n/);
        header += split.shift();
        var remaining = split.join(&apos;\n\n&apos;);
        var buf = new Buffer(remaining, &apos;utf8&apos;);
        if (buf.length)
          stream.unshift(buf);
        stream.removeListener(&apos;error&apos;, callback);
        stream.removeListener(&apos;readable&apos;, onReadable);
        // 现在可以从流中读取消息的主体了
        callback(null, header, stream);
      } else {
        // 仍在读取头部
        header += str;
      }
    }
  }
}</code></pre>
<h4>readable.wrap(stream)<span><a href="stream.html#stream_readable_wrap_stream" id="stream_readable_wrap_stream">#</a></span></h4>
<div><ul>
<li><p><code>stream</code> <span>Stream</span> An &quot;old style&quot; readable stream</p>
</li>
<li><p><code>stream</code> <span>Stream</span> 一个“旧式”可读流</p>
</li>
</div></ul>
<p>Versions of Node prior to v0.10 had streams that did not implement the
entire Streams API as it is today.  (See &quot;Compatibility&quot; below for
more information.)

</p>
<p>Node v0.10 版本之前的流并未实现现今所有流 API。（更多信息详见下文“兼容性”章节。）

</p>
<p>If you are using an older Node library that emits <code>&apos;data&apos;</code> events and
has a <a href="stream.html#stream_readable_pause"><code>pause()</code></a> method that is advisory only, then you can use the
<code>wrap()</code> method to create a <a href="stream.html#stream_class_stream_readable">Readable</a> stream that uses the old stream
as its data source.

</p>
<p>如果您正在使用早前版本的 Node 库，它触发 <code>&apos;data&apos;</code> 事件并且有一个仅作查询用途的 <a href="stream.html#stream_readable_pause"><code>pause()</code></a> 方法，那么您可以使用 <code>wrap()</code> 方法来创建一个使用旧式流作为数据源的 <a href="stream.html#stream_class_stream_readable">Readable</a> 流。

</p>
<p>You will very rarely ever need to call this function, but it exists
as a convenience for interacting with old Node programs and libraries.

</p>
<p>您可能很少需要用到这个函数，但它会作为与旧 Node 程序和库交互的简便方法存在。

</p>
<p>For example:

</p>
<p>例如：

</p>
<pre><code>myReader.on(&apos;readable&apos;, function() {
myReader.read(); // etc.
});</code></pre>
<h3>类: stream.Writable<span><a href="stream.html#stream_stream_writable" id="stream_stream_writable">#</a></span></h3>
<!--type=class-->

<p>The Writable stream interface is an abstraction for a <em>destination</em>
that you are writing data <em>to</em>.

</p>
<p>Writable（可写）流接口是对您正在写入数据<em>至一个目标</em>的抽象。

</p>
<p>Examples of writable streams include:

</p>
<p>一些可写流的例子：

</p>
<ul>
<li><a href="http.html#http_class_http_clientrequest">http requests, on the client</a></li>
<li><a href="http.html#http_class_http_serverresponse">http responses, on the server</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="process.html#process_process_stdout">process.stdout</a>, <a href="process.html#process_process_stderr">process.stderr</a></li>
</ul>
<ul>
<li><a href="http.html#http_class_http_clientrequest">http requests, on the client</a></li>
<li><a href="http.html#http_class_http_serverresponse">http responses, on the server</a></li>
<li><a href="fs.html#fs_class_fs_writestream">fs write streams</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><a href="crypto.html">crypto streams</a></li>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="child_process.html#child_process_child_stdin">child process stdin</a></li>
<li><a href="process.html#process_process_stdout">process.stdout</a>, <a href="process.html#process_process_stderr">process.stderr</a></li>
</ul>
<h4>writable.write(chunk, [encoding], [callback])<span><a href="stream.html#stream_writable_write_chunk_encoding_callback" id="stream_writable_write_chunk_encoding_callback">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>String | Buffer</span> The data to write</li>
<li><code>encoding</code> <span>String</span> The encoding, if <code>chunk</code> is a String</li>
<li><code>callback</code> <span>Function</span> Callback for when this chunk of data is flushed</li>
<li>Returns: <span>Boolean</span> True if the data was handled completely.</li>
</div></ul>
<ul>
<li><code>chunk</code> {String | Buffer} 要写入的数据</li>
<li><code>encoding</code> {String} 编码，假如 <code>chunk</code> 是一个字符串</li>
<li><code>callback</code> {Function} 数据块写入后的回调</li>
<li>返回: {Boolean} 如果数据已被全部处理则 <code>true</code>。</li>
</ul>
<p>This method writes some data to the underlying system, and calls the
supplied callback once the data has been fully handled.

</p>
<p>该方法向底层系统写入数据，并在数据被处理完毕后调用所给的回调。

</p>
<p>The return value indicates if you should continue writing right now.
If the data had to be buffered internally, then it will return
<code>false</code>.  Otherwise, it will return <code>true</code>.

</p>
<p>返回值表明您是否应该立即继续写入。如果数据需要滞留在内部，则它会返回 <code>false</code>；否则，返回 <code>true</code>。

</p>
<p>This return value is strictly advisory.  You MAY continue to write,
even if it returns <code>false</code>.  However, writes will be buffered in
memory, so it is best not to do this excessively.  Instead, wait for
the <code>drain</code> event before writing more data.

</p>
<p>返回值所表示的状态仅供参考，您【可以】在即便返回 <code>false</code> 的时候继续写入。但是，写入的数据会被滞留在内存中，所以最好不要过分地这么做。最好的做法是等待 <code>drain</code> 事件发生后再继续写入更多数据。

</p>
<h4>事件: &apos;drain&apos;<span><a href="stream.html#stream_drain" id="stream_drain">#</a></span></h4>
<p>If a <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> call returns false, then the <code>drain</code>
event will indicate when it is appropriate to begin writing more data
to the stream.

</p>
<p>如果一个 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>writable.write(chunk)</code></a> 调用返回 <code>false</code>，那么 <code>drain</code> 事件则表明可以继续向流写入更多数据。

</p>
<pre><code>// 向所给可写流写入 1000000 次数据。
// 注意后端压力。
function writeOneMillionTimes(writer, data, encoding, callback) {
  var i = 1000000;
  write();
  function write() {
    var ok = true;
    do {
      i -= 1;
      if (i === 0) {
        // 最后一次！
        writer.write(data, encoding, callback);
      } else {
        // 检查我们应该继续还是等待
        // 不要传递回调，因为我们还没完成。
        ok = writer.write(data, encoding);
      }
    } while (i &gt; 0 &amp;&amp; ok);
    if (i &gt; 0) {
      // 不得不提前停止！
      // 一旦它排空，继续写入数据
      writer.once(&apos;drain&apos;, write);
    }
  }
}</code></pre>
<h4>writable.cork()<span><a href="stream.html#stream_writable_cork" id="stream_writable_cork">#</a></span></h4>
<p>Forces buffering of all writes.

</p>
<p>强行滞留所有写入。

</p>
<p>Buffered data will be flushed either at <code>.uncork()</code> or at <code>.end()</code> call.

</p>
<p>滞留的数据会在 <code>.uncork()</code> 或 <code>.end()</code> 调用时被写入。

</p>
<h4>writable.uncork()<span><a href="stream.html#stream_writable_uncork" id="stream_writable_uncork">#</a></span></h4>
<p>Flush all data, buffered since <code>.cork()</code> call.

</p>
<p>写入所有 <code>.cork()</code> 调用之后滞留的数据。

</p>
<h4>writable.end([chunk], [encoding], [callback])<span><a href="stream.html#stream_writable_end_chunk_encoding_callback" id="stream_writable_end_chunk_encoding_callback">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>String | Buffer</span> Optional data to write</li>
<li><code>encoding</code> <span>String</span> The encoding, if <code>chunk</code> is a String</li>
<li><p><code>callback</code> <span>Function</span> Optional callback for when the stream is finished</p>
</li>
<li><p><code>chunk</code> <span>String | Buffer</span> 可选，要写入的数据</p>
</li>
<li><code>encoding</code> <span>String</span> 编码，假如 chunk 是一个字符串</li>
<li><code>callback</code> <span>Function</span> 可选，流结束后的回调</li>
</div></ul>
<p>Call this method when no more data will be written to the stream.  If
supplied, the callback is attached as a listener on the <code>finish</code> event.

</p>
<p>当没有更多数据会被写入到流时调用此方法。如果给出，回调会被用作 <code>finish</code> 事件的监听器。

</p>
<p>Calling <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> after calling <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> will raise an error.

</p>
<p>在调用 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 后调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> 会产生错误。

</p>
<pre><code>// 写入 &apos;hello, &apos; 然后以 &apos;world!&apos; 结束
http.createServer(function (req, res) {
  res.write(&apos;hello, &apos;);
  res.end(&apos;world!&apos;);
  // 现在不允许继续写入了
});</code></pre>
<h4>事件: &apos;finish&apos;<span><a href="stream.html#stream_finish" id="stream_finish">#</a></span></h4>
<p>When the <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> method has been called, and all data has been flushed
to the underlying system, this event is emitted.

</p>
<p>当 <a href="stream.html#stream_writable_end_chunk_encoding_callback"><code>end()</code></a> 方法被调用，并且所有数据已被写入到底层系统，此事件会被触发。

</p>
<pre><code>var writer = getWritableStreamSomehow();
for (var i = 0; i &lt; 100; i ++) {
  writer.write(&apos;hello, #&apos; + i + &apos;!\n&apos;);
}
writer.end(&apos;this is the end\n&apos;);
write.on(&apos;finish&apos;, function() {
  console.error(&apos;已完成所有写入。&apos;);
});</code></pre>
<h4>事件: &apos;pipe&apos;<span><a href="stream.html#stream_pipe" id="stream_pipe">#</a></span></h4>
<div><ul>
<li><p><code>src</code> <span><a href="stream.html#stream_class_stream_readable">Readable</a> Stream</span> source stream that is piping to this writable</p>
</li>
<li><p><code>src</code> <span><a href="stream.html#stream_class_stream_readable">Readable</a> Stream</span> 导流到本可写流的来源流</p>
</li>
</div></ul>
<p>This is emitted whenever the <code>pipe()</code> method is called on a readable
stream, adding this writable to its set of destinations.

</p>
<p>该事件发生于可读流的 <code>pipe()</code> 方法被调用并添加本可写流作为它的目标时。

</p>
<pre><code>var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&apos;pipe&apos;, function(src) {
  console.error(&apos;某些东西正被导流到 writer&apos;);
  assert.equal(src, reader);
});
reader.pipe(writer);</code></pre>
<h4>事件: &apos;unpipe&apos;<span><a href="stream.html#stream_unpipe" id="stream_unpipe">#</a></span></h4>
<div><ul>
<li><p><code>src</code> <span><a href="stream.html#stream_class_stream_readable">Readable</a> Stream</span> The source stream that <a href="stream.html#stream_readable_unpipe_destination">unpiped</a> this writable</p>
</li>
<li><p><code>src</code> <span><a href="stream.html#stream_class_stream_readable">Readable</a> Stream</span> <a href="stream.html#stream_readable_unpipe_destination">unpiped</a> 本可写流的来源流</p>
</li>
</div></ul>
<p>This is emitted whenever the <a href="stream.html#stream_readable_unpipe_destination"><code>unpipe()</code></a> method is called on a
readable stream, removing this writable from its set of destinations.

</p>
<p>该事件发生于可读流的 <code>unpipe()</code> 方法被调用并将本可写流从它的目标移除时。

</p>
<pre><code>var writer = getWritableStreamSomehow();
var reader = getReadableStreamSomehow();
writer.on(&apos;unpipe&apos;, function(src) {
  console.error(&apos;某写东西停止导流到 writer 了&apos;);
  assert.equal(src, reader);
});
reader.pipe(writer);
reader.unpipe(writer);</code></pre>
<h3>类: stream.Duplex<span><a href="stream.html#stream_stream_duplex" id="stream_stream_duplex">#</a></span></h3>
<p>Duplex streams are streams that implement both the <a href="stream.html#stream_class_stream_readable">Readable</a> and
<a href="stream.html#stream_class_stream_writable">Writable</a> interfaces.  See above for usage.

</p>
<p>双工（Duplex）流同时实现了 <a href="stream.html#stream_class_stream_readable">Readable</a> 和 <a href="stream.html#stream_class_stream_writable">Writable</a> 的接口。详见下文用例。

</p>
<p>Examples of Duplex streams include:

</p>
<p>一些双工流的例子：

</p>
<ul>
<li><a href="net.html#net_class_net_socket">tcp sockets</a></li>
<li><a href="zlib.html">zlib streams</a></li>
<li><p><a href="crypto.html">crypto streams</a></p>
</li>
<li><p><a href="net.html#net_class_net_socket">TCP 嵌套字</a></p>
</li>
<li><a href="zlib.html">zlib 流</a></li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h3>类: stream.Transform<span><a href="stream.html#stream_stream_transform" id="stream_stream_transform">#</a></span></h3>
<p>Transform streams are <a href="stream.html#stream_class_stream_duplex">Duplex</a> streams where the output is in some way
computed from the input.  They implement both the <a href="stream.html#stream_class_stream_readable">Readable</a> and
<a href="stream.html#stream_class_stream_writable">Writable</a> interfaces.  See above for usage.

</p>
<p>转换（Transform）流是一种输出由输入计算所得的<a href="stream.html#stream_class_stream_duplex">双工</a>流。它们同时实现了 <a href="stream.html#stream_class_stream_readable">Readable</a> 和 <a href="stream.html#stream_class_stream_writable">Writable</a> 的接口。详见下文用例。

</p>
<p>Examples of Transform streams include:

</p>
<p>一些转换流的例子：

</p>
<ul>
<li><a href="zlib.html">zlib streams</a></li>
<li><p><a href="crypto.html">crypto streams</a></p>
</li>
<li><p><a href="zlib.html">zlib 流</a></p>
</li>
<li><a href="crypto.html">crypto 流</a></li>
</ul>
<h2>面向流实现者的 API<span><a href="stream.html#stream_api_1" id="stream_api_1">#</a></span></h2>
<!--type=misc-->

<p>To implement any sort of stream, the pattern is the same:

</p>
<p>无论实现任何形式的流，模式都是一样的：

</p>
<ol>
<li>Extend the appropriate parent class in your own subclass.  (The
<a href="util.html#util_util_inherits_constructor_superconstructor"><code>util.inherits</code></a> method is particularly helpful for this.)</li>
<li>Call the appropriate parent class constructor in your constructor,
to be sure that the internal mechanisms are set up properly.</li>
<li><p>Implement one or more specific methods, as detailed below.</p>
</li>
<li><p>在您的子类中扩充适合的父类。（<a href="util.html#util_util_inherits_constructor_superconstructor"><code>util.inherits</code></a> 方法对此很有帮助。）</p>
</li>
<li>在您的构造函数中调用父类的构造函数，以确保内部的机制被正确初始化。</li>
<li>实现一个或多个特定的方法，参见下面的细节。</li>
</ol>
<p>The class to extend and the method(s) to implement depend on the sort
of stream class you are writing:

</p>
<p>所扩充的类和要实现的方法取决于您要编写的流类的形式：

</p>
<table>
  <thead>
    <tr>
      <th>
        <p>Use-case</p>
      </th>
      <th>
        <p>Class</p>
      </th>
      <th>
        <p>Method(s) to implement</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>Reading only</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_readable_1">Readable</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_readable_read_size_1">_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Writing only</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_writable_1">Writable</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Reading and writing</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_duplex_1">Duplex</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_readable_read_size_1">_read</a></code>, <code><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>Operate on written data, then read the result</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_transform_1">Transform</a></p>
    </td>
    <td>
      <p><code>_transform</code>, <code>_flush</code></p>
    </td>
  </tr>
</table>

<table>
  <thead>
    <tr>
      <th>
        <p>使用情景</p>
      </th>
      <th>
        <p>类</p>
      </th>
      <th>
        <p>要实现的方法</p>
      </th>
    </tr>
  </thead>
  <tr>
    <td>
      <p>只读</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_readable_1">Readable</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_readable_read_size_1">_read</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>只写</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_writable_1">Writable</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>读写</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_duplex_1">Duplex</a></p>
    </td>
    <td>
      <p><code><a href="stream.html#stream_readable_read_size_1">_read</a></code>, <code><a href="stream.html#stream_writable_write_chunk_encoding_callback_1">_write</a></code></p>
    </td>
  </tr>
  <tr>
    <td>
      <p>操作被写入数据，然后读出结果</p>
    </td>
    <td>
      <p><a href="stream.html#stream_class_stream_transform_1">Transform</a></p>
    </td>
    <td>
      <p><code>_transform</code>, <code>_flush</code></p>
    </td>
  </tr>
</table>

<p>In your implementation code, it is very important to never call the
methods described in <a href="stream.html#stream_api_for_stream_consumers">API for Stream Consumers</a> above.  Otherwise, you
can potentially cause adverse side effects in programs that consume
your streaming interfaces.

</p>
<p>在您的实现代码中，十分重要的一点是绝对不要调用上文<a href="stream.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 中所描述的方法，否则可能在消费您的流接口的程序中产生潜在的副作用。

</p>
<h3>类: stream.Readable<span><a href="stream.html#stream_stream_readable_1" id="stream_stream_readable_1">#</a></span></h3>
<!--type=class-->

<p><code>stream.Readable</code> is an abstract class designed to be extended with an
underlying implementation of the <a href="stream.html#stream_readable_read_size_1"><code>_read(size)</code></a> method.

</p>
<p><code>stream.Readable</code> 是一个可被扩充的、实现了底层方法 <a href="stream.html#stream_readable_read_size_1"><code>_read(size)</code></a> 的抽象类。

</p>
<p>Please see above under <a href="stream.html#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
streams in your programs.  What follows is an explanation of how to
implement Readable streams in your programs.

</p>
<p>请阅读前文<a href="stream.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 章节了解如何在您的程序中消费流。文将解释如何在您的程序中自己实现 Readable 流。

</p>
<h4>例子: 一个计数流<span><a href="stream.html#stream_1" id="stream_1">#</a></span></h4>
<!--type=example-->

<p>This is a basic example of a Readable stream.  It emits the numerals
from 1 to 1,000,000 in ascending order, and then ends.

</p>
<p>这是一个 Readable 流的基本例子。它将从 1 至 1,000,000 递增地触发数字，然后结束。

</p>
<pre><code>var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);
util.inherits(Counter, Readable);

function Counter(opt) {
  Readable.call(this, opt);
  this._max = 1000000;
  this._index = 1;
}

function Counter(opt) {
  Readable.call(this, opt);
  this._max = 1000000;
  this._index = 1;
}

Counter.prototype._read = function() {
  var i = this._index++;
  if (i &gt; this._max)
    this.push(null);
  else {
    var str = &apos;&apos; + i;
    var buf = new Buffer(str, &apos;ascii&apos;);
    this.push(buf);
  }
};</code></pre>
<h4>例子: SimpleProtocol v1 (Sub-optimal)<span><a href="stream.html#stream_simpleprotocol_v1_sub_optimal" id="stream_simpleprotocol_v1_sub_optimal">#</a></span></h4>
<p>This is similar to the <code>parseHeader</code> function described above, but
implemented as a custom stream.  Also, note that this implementation
does not convert the incoming data to a string.

</p>
<p>这个有点类似上文提到的 <code>parseHeader</code> 函数，但它被实现成一个自定义流。同样地，请注意这个实现并未将传入数据转换成字符串。

</p>
<p>However, this would be better implemented as a <a href="stream.html#stream_class_stream_transform">Transform</a> stream.  See
below for a better implementation.

</p>
<p>实际上，更好的办法是将它实现成一个 <a href="stream.html#stream_class_stream_transform">Transform</a> 流。更好的实现详见下文。

</p>
<pre><code>// 简易数据协议的解析器。
// “header”是一个 JSON 对象，后面紧跟 2 个 \n 字符，以及
// 消息主体。
//
// 注意: 使用 Transform 流能更简单地实现这个功能！
// 直接使用 Readable 并不是最佳方式，详见 Transform
// 章节下的备选例子。

var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);

var Readable = require(&apos;stream&apos;).Readable;
var util = require(&apos;util&apos;);

util.inherits(SimpleProtocol, Readable);

util.inherits(SimpleProtocol, Readable);

function SimpleProtocol(source, options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

function SimpleProtocol(source, options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

  Readable.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;

  Readable.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;

  // source is a readable stream, such as a socket or file
  this._source = source;

  // source 是一个可读流，比如嵌套字或文件
  this._source = source;

  var self = this;
  source.on(&apos;end&apos;, function() {
    self.push(null);
  });

  var self = this;
  source.on(&apos;end&apos;, function() {
    self.push(null);
  });

  // give it a kick whenever the source is readable
  // read(0) will not consume any bytes
  source.on(&apos;readable&apos;, function() {
    self.read(0);
  });

  // 当 source 可读时做点什么
  // read(0) 不会消费任何字节
  source.on(&apos;readable&apos;, function() {
    self.read(0);
  });

  this._rawHeader = [];
  this.header = null;
}

  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._read = function(n) {
  if (!this._inBody) {
    var chunk = this._source.read();

SimpleProtocol.prototype._read = function(n) {
  if (!this._inBody) {
    var chunk = this._source.read();

    if (split === -1) {
      // 继续等待 \n\n
      // 暂存数据块，并再次尝试
      this._rawHeader.push(chunk);
      this.push(&apos;&apos;);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
        return;
      }
      // 现在，我们得到了一些多余的数据，所以需要 unshift
      // 将多余的数据放回读取队列以便我们的消费者能够读取
      var b = chunk.slice(split);
      this.unshift(b);

      // and let them know that we are done parsing the header.
      this.emit(&apos;header&apos;, this.header);
    }
  } else {
    // from there on, just provide the data to our consumer.
    // careful not to push(null), since that would indicate EOF.
    var chunk = this._source.read();
    if (chunk) this.push(chunk);
  }
};

      // 并让它们知道我们完成了头部解析。
      this.emit(&apos;header&apos;, this.header);
    }
  } else {
    // 从现在开始，仅需向我们的消费者提供数据。
    // 注意不要 push(null)，因为它表明 EOF。
    var chunk = this._source.read();
    if (chunk) this.push(chunk);
  }
};

// 用法:
// var parser = new SimpleProtocol(source);
// 现在 parser 是一个会触发 &apos;header&apos; 事件并提供已解析
// 的头部的可读流。</code></pre>
<h4>new stream.Readable([options])<span><a href="stream.html#stream_new_stream_readable_options" id="stream_new_stream_readable_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> The maximum number of bytes to store in
the internal buffer before ceasing to read from the underlying
resource.  Default=16kb, or 16 for <code>objectMode</code> streams</li>
<li><code>encoding</code> <span>String</span> If specified, then buffers will be decoded to
strings using the specified encoding.  Default=null</li>
<li><code>objectMode</code> <span>Boolean</span> Whether this stream should behave
as a stream of objects. Meaning that stream.read(n) returns
a single value instead of a Buffer of size n</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> 停止从底层资源读取前内部缓冲区最多能存放的字节数。缺省为 16kb，对于 objectMode 流则是 16</li>
<li><code>encoding</code> <span>String</span> 若给出，则 Buffer 会被解码成所给编码的字符串。缺省为 <code>null</code></li>
<li><code>objectMode</code> <span>Boolean</span> 该流是否应该表现为对象的流。意思是说 <code>stream.read(n)</code> 返回一个单独的对象，而不是大小为 n 的 Buffer</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Readable class, make sure to call the
Readable constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Readable 类的类中调用 Readable 构造函数以便缓冲设定能被正确初始化。

</p>
<h4>readable._read(size)<span><a href="stream.html#stream_readable_read_size_1" id="stream_readable_read_size_1">#</a></span></h4>
<div><ul>
<li><p><code>size</code> <span>Number</span> Number of bytes to read asynchronously</p>
</li>
<li><p><code>size</code> <span>Number</span> 异步读取的字节数</p>
</li>
</div></ul>
<p>Note: <strong>Implement this function, but do NOT call it directly.</strong>

</p>
<p>注意：<strong>实现这个函数，但【不要】直接调用它。</strong>

</p>
<p>This function should NOT be called directly.  It should be implemented
by child classes, and only called by the internal Readable class
methods.

</p>
<p>这个函数【不应该】被直接调用。它应该被子类所实现，并仅被 Readable 类内部方法所调用。

</p>
<p>All Readable stream implementations must provide a <code>_read</code> method to
fetch data from the underlying resource.

</p>
<p>所有 Readable 流的实现都必须提供一个 <code>_read</code> 方法来从底层资源抓取数据。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<p>When data is available, put it into the read queue by calling
<code>readable.push(chunk)</code>.  If <code>push</code> returns false, then you should stop
reading.  When <code>_read</code> is called again, you should start pushing more
data.

</p>
<p>当数据可用时，调用 <code>readable.push(chunk)</code> 将它加入到读取队列。如果 <code>push</code> 返回 <code>false</code>，那么您应该停止读取。当 <code>_read</code> 被再次调用，您应该继续推出更多数据。

</p>
<p>The <code>size</code> argument is advisory.  Implementations where a &quot;read&quot; is a
single call that returns data can use this to know how much data to
fetch.  Implementations where that is not relevant, such as TCP or
TLS, may ignore this argument, and simply provide data whenever it
becomes available.  There is no need, for example to &quot;wait&quot; until
<code>size</code> bytes are available before calling <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.

</p>
<p>参数 <code>size</code> 仅作查询。“read”调用返回数据的实现可以通过这个参数来知道应当抓取多少数据；其余与之无关的实现，比如 TCP 或 TLS，则可忽略这个参数，并在可用时返回数据。例如，没有必要“等到” <code>size</code> 个字节可用时才调用 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>。

</p>
<h4>readable.push(chunk, [encoding])<span><a href="stream.html#stream_readable_push_chunk_encoding" id="stream_readable_push_chunk_encoding">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | null | String</span> Chunk of data to push into the read queue</li>
<li><code>encoding</code> <span>String</span> Encoding of String chunks.  Must be a valid
Buffer encoding, such as <code>&apos;utf8&apos;</code> or <code>&apos;ascii&apos;</code></li>
<li><p>return <span>Boolean</span> Whether or not more pushes should be performed</p>
</li>
<li><p><code>chunk</code> <span>Buffer | null | String</span> 推入读取队列的数据块</p>
</li>
<li><code>encoding</code> <span>String</span> 字符串块的编码。必须是有效的 Buffer 编码，比如 <code>utf8</code> 或 <code>ascii</code></li>
<li>返回 <span>Boolean</span> 是否应该继续推入</li>
</div></ul>
<p>Note: <strong>This function should be called by Readable implementors, NOT
by consumers of Readable streams.</strong>

</p>
<p>注意：<strong>这个函数应该被 Readable 实现者调用，【而不是】Readable 流的消费者。</strong>

</p>
<p>The <code>_read()</code> function will not be called again until at least one
<code>push(chunk)</code> call is made.

</p>
<p>函数 <code>_read()</code> 不会被再次调用，直到至少调用了一次 <code>push(chunk)</code>。

</p>
<p>The <code>Readable</code> class works by putting data into a read queue to be
pulled out later by calling the <code>read()</code> method when the <code>&apos;readable&apos;</code>
event fires.

</p>
<p><code>Readable</code> 类的工作方式是，将数据读入一个队列，当 <code>&apos;readable&apos;</code> 事件发生、调用 <code>read()</code> 方法时，数据会被从队列中取出。

</p>
<p>The <code>push()</code> method will explicitly insert some data into the read
queue.  If it is called with <code>null</code> then it will signal the end of the
data (EOF).

</p>
<p><code>push()</code> 方法会明确地向读取队列中插入一些数据。如果调用它时传入了 <code>null</code> 参数，那么它会触发数据结束信号（EOF）。

</p>
<p>This API is designed to be as flexible as possible.  For example,
you may be wrapping a lower-level source which has some sort of
pause/resume mechanism, and a data callback.  In those cases, you
could wrap the low-level source object by doing something like this:

</p>
<p>这个 API 被设计成尽可能地灵活。比如说，您可以包装一个低级别的具备某种暂停/恢复机制和数据回调的数据源。这种情况下，您可以通过这种方式包装低级别来源对象：

</p>
<pre><code>// source 是一个带 readStop() 和 readStart() 方法的类，
// 以及一个当有数据时会被调用的 `ondata` 成员、一个
// 当数据结束时会被调用的 `onend` 成员。

util.inherits(SourceWrapper, Readable);

util.inherits(SourceWrapper, Readable);

function SourceWrapper(options) {
  Readable.call(this, options);

function SourceWrapper(options) {
  Readable.call(this, options);

  this._source = getLowlevelSourceObject();
  var self = this;

  this._source = getLowlevelSourceObject();
  var self = this;

  // Every time there&apos;s data, we push it into the internal buffer.
  this._source.ondata = function(chunk) {
    // if push() returns false, then we need to stop reading from source
    if (!self.push(chunk))
      self._source.readStop();
  };

  // 每当有数据时，我们将它推入到内部缓冲区中
  this._source.ondata = function(chunk) {
    // 如果 push() 返回 false，我们就需要暂停读取 source
    if (!self.push(chunk))
      self._source.readStop();
  };

  // When the source ends, we push the EOF-signalling `null` chunk
  this._source.onend = function() {
    self.push(null);
  };
}

  // 当来源结束时，我们 push 一个 `null` 块以表示 EOF
  this._source.onend = function() {
    self.push(null);
  };
}

// _read 会在流想要拉取更多数据时被调用
// 本例中忽略 size 参数
SourceWrapper.prototype._read = function(size) {
  this._source.readStart();
};</code></pre>
<h3>类: stream.Writable<span><a href="stream.html#stream_stream_writable_1" id="stream_stream_writable_1">#</a></span></h3>
<!--type=class-->

<p><code>stream.Writable</code> is an abstract class designed to be extended with an
underlying implementation of the <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method.

</p>
<p><code>stream.Writable</code> 是一个可被扩充的、实现了底层方法 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 的抽象类。

</p>
<p>Please see above under <a href="stream.html#stream_api_for_stream_consumers">API for Stream Consumers</a> for how to consume
writable streams in your programs.  What follows is an explanation of
how to implement Writable streams in your programs.

</p>
<p>请阅读前文<a href="stream.html#stream_api_for_stream_consumers">面向流消费者的 API</a> 章节了解如何在您的程序中消费可读流。下文将解释如何在您的程序中自己实现 Writable 流。

</p>
<h4>new stream.Writable([options])<span><a href="stream.html#stream_new_stream_writable_options" id="stream_new_stream_writable_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> Buffer level when <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> starts
returning false. Default=16kb, or 16 for <code>objectMode</code> streams</li>
<li><code>decodeStrings</code> <span>Boolean</span> Whether or not to decode strings into
Buffers before passing them to <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>.  Default=true</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span></p>
<ul>
<li><code>highWaterMark</code> <span>Number</span> <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>write()</code></a> 开始返回 <code>false</code> 的缓冲级别。缺省为 16kb，对于 <code>objectMode</code> 流则是 16</li>
<li><code>decodeStrings</code> <span>Boolean</span> 是否在传递给 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 前将字符串解码成 Buffer。缺省为 <code>true</code></li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Writable class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Writable 类的类中调用构造函数以便缓冲设定能被正确初始化。

</p>
<h4>writable._write(chunk, encoding, callback)<span><a href="stream.html#stream_writable_write_chunk_encoding_callback_1" id="stream_writable_write_chunk_encoding_callback_1">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | String</span> The chunk to be written.  Will always
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <span>String</span> If the chunk is a string, then this is the
encoding type.  Ignore if chunk is a buffer.  Note that chunk will
<strong>always</strong> be a buffer unless the <code>decodeStrings</code> option is
explicitly set to <code>false</code>.</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要被写入的数据块。总会是一个 Buffer，除非 <code>decodeStrings</code> 选项被设定为 <code>false</code>。</p>
</li>
<li><code>encoding</code> <span>String</span> 如果数据块是字符串，则这里指定它的编码类型。如果数据块是 Buffer 则忽略此设定。请注意数据块<strong>总会是</strong>一个 Buffer，除非 <code>decodeStrings</code> 选项被明确设定为 <code>false</code>。</li>
<li><code>callback</code> <span>Function</span> 当您处理完所给数据块时调用此函数（可选地可附上一个错误参数）。</li>
</div></ul>
<p>All Writable stream implementations must provide a <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a>
method to send data to the underlying resource.

</p>
<p>所有 Writable 流的实现必须提供一个 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 方法来将数据发送到底层资源。

</p>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Writable 内部方法所调用。

</p>
<p>Call the callback using the standard <code>callback(error)</code> pattern to
signal that the write completed successfully or with an error.

</p>
<p>使用标准的 <code>callback(error)</code> 形式来调用回调以表明写入成功完成或遇到错误。

</p>
<p>If the <code>decodeStrings</code> flag is set in the constructor options, then
<code>chunk</code> may be a string rather than a Buffer, and <code>encoding</code> will
indicate the sort of string that it is.  This is to support
implementations that have an optimized handling for certain string
data encodings.  If you do not explicitly set the <code>decodeStrings</code>
option to <code>false</code>, then you can safely ignore the <code>encoding</code> argument,
and assume that <code>chunk</code> will always be a Buffer.

</p>
<p>如果构造函数选项中设定了 <code>decodeStrings</code> 标志，则 <code>chunk</code> 可能会是字符串而不是 Buffer，并且 <code>encoding</code> 表明了字符串的格式。这种设计是为了支持对某些字符串数据编码提供优化处理的实现。如果您没有明确地将 <code>decodeStrings</code> 选项设定为 <code>false</code>，那么您可以安全地忽略 <code>encoding</code> 参数，并假定 <code>chunk</code> 总是一个 Buffer。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h3>writable._writev(chunks, callback)<span><a href="stream.html#stream_writable_writev_chunks_callback" id="stream_writable_writev_chunks_callback">#</a></span></h3>
<div><ul>
<li><code>chunks</code> <span>Array</span> The chunks to be written.  Each chunk has following
format: <code>&lt;span class=&quot;type&quot;&gt; chunk: ..., encoding: ... &lt;/span&gt;</code>.</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunks.</p>
</li>
<li><p><code>chunks</code> <span>Array</span> 要写入的块。每个块都遵循这种格式：<code>{ chunk: ..., encoding: ... }</code>。</p>
</li>
<li><code>callback</code> <span>Function</span> 当您处理完所给数据块时调用此函数（可选地可附上一个错误参数）。</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It may be
implemented by child classes, and called by the internal Writable
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Writable 内部方法所调用。

</p>
<p>This function is completely optional to implement. In most cases it is
unnecessary.  If implemented, it will be called with all the chunks
that are buffered in the write queue.

</p>
<p>该函数的实现完全是可选的，在大多数情况下都是不必要的。如果实现，它会被以所有滞留在写入队列中的数据块调用。

</p>
<h3>类: stream.Duplex<span><a href="stream.html#stream_stream_duplex_1" id="stream_stream_duplex_1">#</a></span></h3>
<!--type=class-->

<p>A &quot;duplex&quot; stream is one that is both Readable and Writable, such as a
TCP socket connection.

</p>
<p>“双工”（duplex）流同时兼具可读和可写特性，比如一个 TCP 嵌套字连接。

</p>
<p>Note that <code>stream.Duplex</code> is an abstract class designed to be extended
with an underlying implementation of the <code>_read(size)</code> and
<a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> methods as you would with a
Readable or Writable stream class.

</p>
<p>值得注意的是，<code>stream.Duplex</code> 是一个可以像 Readable 或 Writable 一样被扩充、实现了底层方法 <code>_read(sise)</code> 和 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 的抽象类。

</p>
<p>Since JavaScript doesn&apos;t have multiple prototypal inheritance, this
class prototypally inherits from Readable, and then parasitically from
Writable.  It is thus up to the user to implement both the lowlevel
<code>_read(n)</code> method as well as the lowlevel
<a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> method on extension duplex classes.

</p>
<p>由于 JavaScript 并不具备多原型继承能力，这个类实际上继承自 Readable，并寄生自 Writable，从而让用户在双工类的扩充中能同时实现低级别的 <code>_read(n)</code> 方法和 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write(chunk, encoding, callback)</code></a> 方法。

</p>
<h4>new stream.Duplex(options)<span><a href="stream.html#stream_new_stream_duplex_options" id="stream_new_stream_duplex_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors. Also has the following fields:</p>
<ul>
<li><code>allowHalfOpen</code> <span>Boolean</span> Default=true.  If set to <code>false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
</ul>
</li>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors. Also has the following fields:</p>
<ul>
<li><code>allowHalfOpen</code> <span>Boolean</span> Default=true.  If set to <code>false</code>, then
the stream will automatically end the readable side when the
writable side ends and vice versa.</li>
</ul>
</li>
</div></ul>
<p>In classes that extend the Duplex class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Duplex 类的类中调用构造函数以便缓冲设定能被正确初始化。

</p>
<h3>类: stream.Transform<span><a href="stream.html#stream_stream_transform_1" id="stream_stream_transform_1">#</a></span></h3>
<p>A &quot;transform&quot; stream is a duplex stream where the output is causally
connected in some way to the input, such as a <a href="zlib.html">zlib</a> stream or a
<a href="crypto.html">crypto</a> stream.

</p>
<p>“转换”（transform）流实际上是一个输出与输入存在因果关系的双工流，比如 <a href="zlib.html">zlib</a> 流或 <a href="crypto.html">crypto</a> 流。

</p>
<p>There is no requirement that the output be the same size as the input,
the same number of chunks, or arrive at the same time.  For example, a
Hash stream will only ever have a single chunk of output which is
provided when the input is ended.  A zlib stream will produce output
that is either much smaller or much larger than its input.

</p>
<p>输入和输出并无要求相同大小、相同块数或同时到达。举个例子，一个 Hash 流只会在输入结束时产生一个数据块的输出；一个 zlib 流会产生比输入小得多或大得多的输出。

</p>
<p>Rather than implement the <a href="stream.html#stream_readable_read_size_1"><code>_read()</code></a> and <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> methods, Transform
classes must implement the <code>_transform()</code> method, and may optionally
also implement the <code>_flush()</code> method.  (See below.)

</p>
<p>转换类必须实现 <code>_transform()</code> 方法，而不是 <a href="stream.html#stream_readable_read_size_1"><code>_read()</code></a> 和 <a href="stream.html#stream_writable_write_chunk_encoding_callback_1"><code>_write()</code></a> 方法。可选的，也可以实现 <code>_flush()</code> 方法。（详见下文。）

</p>
<h4>new stream.Transform([options])<span><a href="stream.html#stream_new_stream_transform_options" id="stream_new_stream_transform_options">#</a></span></h4>
<div><ul>
<li><p><code>options</code> <span>Object</span> Passed to both Writable and Readable
constructors.</p>
</li>
<li><p><code>options</code> <span>Object</span> 传递给 Writable 和 Readable 构造函数。</p>
</li>
</div></ul>
<p>In classes that extend the Transform class, make sure to call the
constructor so that the buffering settings can be properly
initialized.

</p>
<p>请确保在扩充 Transform 类的类中调用了构造函数，以使得缓冲设定能被正确初始化。

</p>
<h4>transform._transform(chunk, encoding, callback)<span><a href="stream.html#stream_transform_transform_chunk_encoding_callback" id="stream_transform_transform_chunk_encoding_callback">#</a></span></h4>
<div><ul>
<li><code>chunk</code> <span>Buffer | String</span> The chunk to be transformed.  Will always
be a buffer unless the <code>decodeStrings</code> option was set to <code>false</code>.</li>
<li><code>encoding</code> <span>String</span> If the chunk is a string, then this is the
encoding type.  (Ignore if <code>decodeStrings</code> chunk is a buffer.)</li>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done processing the supplied chunk.</p>
</li>
<li><p><code>chunk</code> <span>Buffer | String</span> 要被转换的数据块。总是 Buffer，除非 <code>decodeStrings</code> 选项被设定为 <code>false</code>。</p>
</li>
<li><code>encoding</code> <span>String</span> 如果数据块是一个字符串，那么这就是它的编码类型。（数据块是 Buffer 则会忽略此参数。）</li>
<li><code>callback</code> <span>Function</span> 当您处理完所提供的数据块时调用此函数（可选地附上一个错误参数）。</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be
implemented by child classes, and called by the internal Transform
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它应该被子类所实现，并仅被 Transform 内部方法所调用。

</p>
<p>All Transform stream implementations must provide a <code>_transform</code>
method to accept input and produce output.

</p>
<p>所有转换流的实现都必须提供一个 <code>_transform</code> 方法来接受输入并产生输出。

</p>
<p><code>_transform</code> should do whatever has to be done in this specific
Transform class, to handle the bytes being written, and pass them off
to the readable portion of the interface.  Do asynchronous I/O,
process things, and so on.

</p>
<p><code>_transform</code> 应当承担特定 Transform 类中所有处理被写入的字节、并将它们丢给接口的可写端的职责，进行异步 I/O，处理其它事情等等。

</p>
<p>Call <code>transform.push(outputChunk)</code> 0 or more times to generate output
from this input chunk, depending on how much data you want to output
as a result of this chunk.

</p>
<p>调用 <code>transform.push(outputChunk)</code> 0 或多次来从输入块生成输出，取决于您想从这个数据块输出多少数据。

</p>
<p>Call the callback function only when the current chunk is completely
consumed.  Note that there may or may not be output as a result of any
particular input chunk.

</p>
<p>仅当当前数据块被完全消费时调用回调函数。注意，任何特定的输入块都有可能或可能不会产生输出。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h4>transform._flush(callback)<span><a href="stream.html#stream_transform_flush_callback" id="stream_transform_flush_callback">#</a></span></h4>
<div><ul>
<li><p><code>callback</code> <span>Function</span> Call this function (optionally with an error
argument) when you are done flushing any remaining data.</p>
</li>
<li><p><code>callback</code> <span>Function</span> 当您写入完毕剩下的数据后调用此函数（可选地可附上一个错误对象）。</p>
</li>
</div></ul>
<p>Note: <strong>This function MUST NOT be called directly.</strong>  It MAY be implemented
by child classes, and if so, will be called by the internal Transform
class methods only.

</p>
<p>注意：<strong>该函数【禁止】被直接调用。</strong>它【可以】被子类所实现，并且如果实现，仅被 Transform 内部方法所调用。

</p>
<p>In some cases, your transform operation may need to emit a bit more
data at the end of the stream.  For example, a <code>Zlib</code> compression
stream will store up some internal state so that it can optimally
compress the output.  At the end, however, it needs to do the best it
can with what is left, so that the data will be complete.

</p>
<p>在一些情景中，您的转换操作可能需要在流的末尾多发生一点点数据。例如，一个 <code>Zlib</code> 压缩流会储存一些内部状态以便更好地压缩输出，但在最后它需要尽可能好地处理剩下的东西以使数据完整。

</p>
<p>In those cases, you can implement a <code>_flush</code> method, which will be
called at the very end, after all the written data is consumed, but
before emitting <code>end</code> to signal the end of the readable side.  Just
like with <code>_transform</code>, call <code>transform.push(chunk)</code> zero or more
times, as appropriate, and call <code>callback</code> when the flush operation is
complete.

</p>
<p>在这种情况中，您可以实现一个 <code>_flush</code> 方法，它会在最后被调用，在所有写入数据被消费、但在触发 <code>end</code> 表示可读端到达末尾之前。和 <code>_transform</code> 一样，只需在写入操作完成时适当地调用 <code>transform.push(chunk)</code> 零或多次。

</p>
<p>This method is prefixed with an underscore because it is internal to
the class that defines it, and should not be called directly by user
programs.  However, you <strong>are</strong> expected to override this method in
your own extension classes.

</p>
<p>该方法以下划线开头是因为它对于定义它的类是内部的，并且不应该被用户程序直接调用。但是，你<strong>应当</strong>在您的扩充类中覆盖这个方法。

</p>
<h4>例子: <code>SimpleProtocol</code> 解析器 v2<span><a href="stream.html#stream_simpleprotocol_v2" id="stream_simpleprotocol_v2">#</a></span></h4>
<p>The example above of a simple protocol parser can be implemented
simply by using the higher level <a href="stream.html#stream_class_stream_transform">Transform</a> stream class, similar to
the <code>parseHeader</code> and <code>SimpleProtocol v1</code> examples above.

</p>
<p>上文的简易协议解析器例子能够很简单地使用高级别 <a href="stream.html#stream_class_stream_transform">Transform</a> 流类实现，类似于前文 <code>parseHeader</code> 和 <code>SimpleProtocal v1</code> 示例。

</p>
<p>In this example, rather than providing the input as an argument, it
would be piped into the parser, which is a more idiomatic Node stream
approach.

</p>
<p>在这个示例中，输入会被导流到解析器中，而不是作为参数提供。这种做法更符合 Node 流的惯例。

</p>
<pre><code>var util = require(&apos;util&apos;);
var Transform = require(&apos;stream&apos;).Transform;
util.inherits(SimpleProtocol, Transform);

function SimpleProtocol(options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

function SimpleProtocol(options) {
  if (!(this instanceof SimpleProtocol))
    return new SimpleProtocol(options);

  Transform.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;
  this._rawHeader = [];
  this.header = null;
}

  Transform.call(this, options);
  this._inBody = false;
  this._sawFirstCr = false;
  this._rawHeader = [];
  this.header = null;
}

SimpleProtocol.prototype._transform = function(chunk, encoding, done) {
  if (!this._inBody) {
    // check if the chunk has a \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &apos;\n&apos;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

SimpleProtocol.prototype._transform = function(chunk, encoding, done) {
  if (!this._inBody) {
    // 检查数据块是否有 \n\n
    var split = -1;
    for (var i = 0; i &lt; chunk.length; i++) {
      if (chunk[i] === 10) { // &apos;\n&apos;
        if (this._sawFirstCr) {
          split = i;
          break;
        } else {
          this._sawFirstCr = true;
        }
      } else {
        this._sawFirstCr = false;
      }
    }

    if (split === -1) {
      // 仍旧等待 \n\n
      // 暂存数据块并重试。
      this._rawHeader.push(chunk);
    } else {
      this._inBody = true;
      var h = chunk.slice(0, split);
      this._rawHeader.push(h);
      var header = Buffer.concat(this._rawHeader).toString();
      try {
        this.header = JSON.parse(header);
      } catch (er) {
        this.emit(&apos;error&apos;, new Error(&apos;invalid simple protocol data&apos;));
        return;
      }
      // 并让它们知道我们完成了头部解析。
      this.emit(&apos;header&apos;, this.header);

      // now, because we got some extra data, emit this first.
      this.push(chunk.slice(split));
    }
  } else {
    // from there on, just provide the data to our consumer as-is.
    this.push(chunk);
  }
  done();
};

      // 现在，由于我们获得了一些额外的数据，先触发这个。
      this.push(chunk.slice(split));
    }
  } else {
    // 之后，仅需向我们的消费者原样提供数据。
    this.push(chunk);
  }
  done();
};

// 用法:
// var parser = new SimpleProtocol();
// source.pipe(parser)
// 现在 parser 是一个会触发 &apos;header&apos; 并带上解析后的
// 头部数据的可读流。</code></pre>
<h3>类: stream.PassThrough<span><a href="stream.html#stream_stream_passthrough" id="stream_stream_passthrough">#</a></span></h3>
<p>This is a trivial implementation of a <a href="stream.html#stream_class_stream_transform">Transform</a> stream that simply
passes the input bytes across to the output.  Its purpose is mainly
for examples and testing, but there are occasionally use cases where
it can come in handy as a building block for novel sorts of streams.

</p>
<p>这是 <a href="stream.html#stream_class_stream_transform">Transform</a> 流的一个简单实现，将输入的字节简单地传递给输出。它的主要用途是演示和测试，但偶尔要构建某种特殊流的时候也能派上用场。

</p>
<h2>流：内部细节<span><a href="stream.html#stream_2" id="stream_2">#</a></span></h2>
<!--type=misc-->

<h3>缓冲<span><a href="stream.html#stream_3" id="stream_3">#</a></span></h3>
<!--type=misc-->

<p>Both Writable and Readable streams will buffer data on an internal
object called <code>_writableState.buffer</code> or <code>_readableState.buffer</code>,
respectively.

</p>
<p>无论 Writable 或 Readable 流都会在内部分别叫做 <code>_writableState.buffer</code> 和 <code>_readableState.buffer</code> 的对象中缓冲数据。

</p>
<p>The amount of data that will potentially be buffered depends on the
<code>highWaterMark</code> option which is passed into the constructor.

</p>
<p>被缓冲的数据量取决于传递给构造函数的 <code>highWaterMark</code>（最高水位线）选项。

</p>
<p>Buffering in Readable streams happens when the implementation calls
<a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a>.  If the consumer of the Stream does not call
<code>stream.read()</code>, then the data will sit in the internal queue until it
is consumed.

</p>
<p>Readable 流的滞留发生于当实现调用 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(chunk)</code></a> 的时候。如果流的消费者没有调用 <code>stream.read()</code>，那么数据将会一直待在内部队列，直到它被消费。

</p>
<p>Buffering in Writable streams happens when the user calls
<a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> repeatedly, even when <code>write()</code> returns <code>false</code>.

</p>
<p>Writable 流的滞留发生于当用户重复调用 <a href="stream.html#stream_writable_write_chunk_encoding_callback"><code>stream.write(chunk)</code></a> 即便此时 <code>write()</code> 返回 <code>false</code> 时。

</p>
<p>The purpose of streams, especially with the <code>pipe()</code> method, is to
limit the buffering of data to acceptable levels, so that sources and
destinations of varying speed will not overwhelm the available memory.

</p>
<p>流，尤其是 <code>pipe()</code> 方法的初衷，是将数据的滞留量限制到一个可接受的水平，以使得不同速度的来源和目标不会淹没可用内存。

</p>
<h3><code>stream.read(0)</code><span><a href="stream.html#stream_stream_read_0" id="stream_stream_read_0">#</a></span></h3>
<p>There are some cases where you want to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data.  In that case, you can call <code>stream.read(0)</code>, which will always
return null.

</p>
<p>在某写情景中，您可能需要触发底层可读流机制的刷新，但不真正消费任何数据。在这中情况下，您可以调用 <code>stream.read(0)</code>，它总会返回 <code>null</code>。

</p>
<p>If the internal read buffer is below the <code>highWaterMark</code>, and the
stream is not currently reading, then calling <code>read(0)</code> will trigger
a low-level <code>_read</code> call.

</p>
<p>如果内部读取缓冲低于 <code>highWaterMark</code> 水位线，并且流当前不在读取状态，那么调用 <code>read(0)</code> 会触发一个低级 <code>_read</code> 调用。

</p>
<p>There is almost never a need to do this.  However, you will see some
cases in Node&apos;s internals where this is done, particularly in the
Readable stream class internals.

</p>
<p>虽然几乎没有必要这么做，但您可以在 Node 内部的某些地方看到它确实这么做了，尤其是在 Readable 流类的内部。

</p>
<h3><code>stream.push(&apos;&apos;)</code><span><a href="stream.html#stream_stream_push" id="stream_stream_push">#</a></span></h3>
<p>Pushing a zero-byte string or Buffer (when not in <a href="stream.html#stream_object_mode">Object mode</a>) has an
interesting side effect.  Because it <em>is</em> a call to
<a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push()</code></a>, it will end the <code>reading</code> process.  However, it
does <em>not</em> add any data to the readable buffer, so there&apos;s nothing for
a user to consume.

</p>
<p>推入一个零字节字符串或 Buffer（当不在 <a href="stream.html#stream_object_mode">对象模式</a> 时）有一个有趣的副作用。因为<em>它是</em>一个对 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push()</code></a> 的调用，它会结束 <code>reading</code> 进程。然而，它<em>没有</em>添加任何数据到可读缓冲中，所以没有东西可以被用户消费。

</p>
<p>Very rarely, there are cases where you have no data to provide now,
but the consumer of your stream (or, perhaps, another bit of your own
code) will know when to check again, by calling <code>stream.read(0)</code>.  In
those cases, you <em>may</em> call <code>stream.push(&apos;&apos;)</code>.

</p>
<p>在极少数情况下，您当时没有数据提供，但您的流的消费者（或您的代码的其它部分）会通过调用 <code>stream.read(0)</code> 得知何时再次检查。在这中情况下，您<em>可以</em>调用 <code>stream.push(&apos;&apos;)</code>。

</p>
<p>So far, the only use case for this functionality is in the
<a href="tls.html#tls_class_cryptostream">tls.CryptoStream</a> class, which is deprecated in Node v0.12.  If you
find that you have to use <code>stream.push(&apos;&apos;)</code>, please consider another
approach, because it almost certainly indicates that something is
horribly wrong.

</p>
<p>到目前为止，这个功能唯一一个使用情景是在 <a href="tls.html#tls_class_cryptostream">tls.CryptoStream</a> 类中，但它将在 Node v0.12 中被废弃。如果您发现您不得不使用 <code>stream.push(&apos;&apos;)</code>，请考虑另一种方式，因为几乎可以明确表明这是某种可怕的错误。

</p>
<h3>与 Node 早期版本的兼容性<span><a href="stream.html#stream_node" id="stream_node">#</a></span></h3>
<!--type=misc-->

<p>In versions of Node prior to v0.10, the Readable stream interface was
simpler, but also less powerful and less useful.

</p>
<p>在 v0.10 之前版本的 Node 中，Readable 流的接口较为简单，同时功能和实用性也较弱。

</p>
<ul>
<li>Rather than waiting for you to call the <code>read()</code> method, <code>&apos;data&apos;</code>
events would start emitting immediately.  If you needed to do some
I/O to decide how to handle data, then you had to store the chunks
in some kind of buffer so that they would not be lost.</li>
<li><p>The <a href="stream.html#stream_readable_pause"><code>pause()</code></a> method was advisory, rather than guaranteed.  This
meant that you still had to be prepared to receive <code>&apos;data&apos;</code> events
even when the stream was in a paused state.</p>
</li>
<li><p><code>&apos;data&apos;</code> 事件会开始立即开始发生，而不会等待您调用 <code>read()</code> 方法。如果您需要进行某些 I/O 来决定如何处理数据，那么您只能将数据块储存到某种缓冲区中以防它们流失。</p>
</li>
<li><a href="stream.html#stream_readable_pause"><code>pause()</code></a> 方法仅起提议作用，而不保证生效。这意味着，即便当流处于暂停状态时，您仍然需要准备接收 <code>&apos;data&apos;</code> 事件。</li>
</ul>
<p>In Node v0.10, the Readable class described below was added.  For
backwards compatibility with older Node programs, Readable streams
switch into &quot;flowing mode&quot; when a <code>&apos;data&apos;</code> event handler is added, or
when the <a href="stream.html#stream_readable_resume"><code>resume()</code></a> method is called.  The effect is that, even if
you are not using the new <code>read()</code> method and <code>&apos;readable&apos;</code> event, you
no longer have to worry about losing <code>&apos;data&apos;</code> chunks.

</p>
<p>在 Node v0.10 中，下文所述的 Readable 类被加入进来。为了向后兼容考虑，Readable 流会在添加了 <code>&apos;data&apos;</code> 事件监听器、或 <a href="stream.html#stream_readable_resume"><code>resume()</code></a> 方法被调用时切换至“流动模式”。其作用是，即便您不使用新的 <code>read()</code> 方法和 <code>&apos;readable&apos;</code> 事件，您也不必担心丢失 <code>&apos;data&apos;</code> 数据块。

</p>
<p>Most programs will continue to function normally.  However, this
introduces an edge case in the following conditions:

</p>
<p>大多数程序会维持正常功能，然而，这也会在下列条件下引入一种边界情况：

</p>
<ul>
<li>No <a href="stream.html#stream_event_data"><code>&apos;data&apos;</code> event</a> handler is added.</li>
<li>The <a href="stream.html#stream_readable_resume"><code>resume()</code></a> method is never called.</li>
<li><p>The stream is not piped to any writable destination.</p>
</li>
<li><p>没有添加 <a href="stream.html#stream_event_data"><code>&apos;data&apos;</code> 事件</a>处理器。</p>
</li>
<li><a href="stream.html#stream_readable_resume"><code>resume()</code></a> 方法从未被调用。</li>
<li>流未被导流到任何可写目标。</li>
</ul>
<p>For example, consider the following code:

</p>
<p>举个例子，请留意下面代码：

</p>
<pre><code>// 警告！不能用！
net.createServer(function(socket) {

  // we add an &apos;end&apos; method, but never consume the data
  socket.on(&apos;end&apos;, function() {
    // It will never get here.
    socket.end(&apos;I got your message (but didnt read it)\n&apos;);
  });

  // 我们添加了一个 &apos;end&apos; 事件，但从未消费数据
  socket.on(&apos;end&apos;, function() {
    // 它永远不会到达这里
    socket.end(&apos;我收到了您的来信（但我没看它）\n&apos;);
  });

}).listen(1337);</code></pre>
<p>In versions of node prior to v0.10, the incoming message data would be
simply discarded.  However, in Node v0.10 and beyond, the socket will
remain paused forever.

</p>
<p>在 Node v0.10 之前的版本中，传入消息数据会被简单地丢弃。然而在 Node v0.10 及之后，socket 会一直保持暂停。

</p>
<p>The workaround in this situation is to call the <code>resume()</code> method to
start the flow of data:

</p>
<p>对于这种情形的妥协方式是调用 <code>resume()</code> 方法来开启数据流：

</p>
<pre><code>// 妥协
net.createServer(function(socket) {

  socket.on(&apos;end&apos;, function() {
    socket.end(&apos;I got your message (but didnt read it)\n&apos;);
  });

  socket.on(&apos;end&apos;, function() {
    socket.end(&apos;我收到了您的来信（但我没看它）\n&apos;);
  });

  // start the flow of data, discarding it.
  socket.resume();

  // 开启数据流，并丢弃它们。
  socket.resume();

}).listen(1337);</code></pre>
<p>In addition to new Readable streams switching into flowing mode,
pre-v0.10 style streams can be wrapped in a Readable class using the
<code>wrap()</code> method.

</p>
<p>额外的，对于切换到流动模式的新 Readable 流，v0.10 之前风格的流可以通过 <code>wrap()</code> 方法被包装成 Readable 类。

</p>
<h3>对象模式<span><a href="stream.html#stream_4" id="stream_4">#</a></span></h3>
<!--type=misc-->

<p>Normally, Streams operate on Strings and Buffers exclusively.

</p>
<p>通常情况下，流只操作字符串和 Buffer。

</p>
<p>Streams that are in <strong>object mode</strong> can emit generic JavaScript values
other than Buffers and Strings.

</p>
<p>处于<strong>对象模式</strong>的流除了 Buffer 和字符串外还能读出普通的 JavaScript 值。

</p>
<p>A Readable stream in object mode will always return a single item from
a call to <code>stream.read(size)</code>, regardless of what the size argument
is.

</p>
<p>一个处于对象模式的 Readable 流调用 <code>stream.read(size)</code> 时总会返回单个项目，无论传入什么 size 参数。

</p>
<p>A Writable stream in object mode will always ignore the <code>encoding</code>
argument to <code>stream.write(data, encoding)</code>.

</p>
<p>一个处于对象模式的 Writable 流总是会忽略传给 <code>stream.write(data, encoding)</code> 的 <code>encoding</code> 参数。

</p>
<p>The special value <code>null</code> still retains its special value for object
mode streams.  That is, for object mode readable streams, <code>null</code> as a
return value from <code>stream.read()</code> indicates that there is no more
data, and <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(null)</code></a> will signal the end of stream data
(<code>EOF</code>).

</p>
<p>特殊值 <code>null</code> 在对象模式流中依旧保持它的特殊性。也就说，对于对象模式的可读流，<code>stream.read()</code> 返回 <code>null</code> 意味着没有更多数据，同时 <a href="stream.html#stream_readable_push_chunk_encoding"><code>stream.push(null)</code></a> 会告知流数据到达末端（<code>EOF</code>）。

</p>
<p>No streams in Node core are object mode streams.  This pattern is only
used by userland streaming libraries.

</p>
<p>Node 核心不存在对象模式的流，这种设计只被某些用户态流式库所使用。

</p>
<p>You should set <code>objectMode</code> in your stream child class constructor on
the options object.  Setting <code>objectMode</code> mid-stream is not safe.

</p>
<p>您应该在您的流子类构造函数的选项对象中设置 <code>objectMode</code>。在流的过程中设置 <code>objectMode</code> 是不安全的。

</p>
<h3>状态对象<span><a href="stream.html#stream_5" id="stream_5">#</a></span></h3>
<p><a href="stream.html#stream_class_stream_readable">Readable</a> streams have a member object called <code>_readableState</code>.
<a href="stream.html#stream_class_stream_writable">Writable</a> streams have a member object called <code>_writableState</code>.
<a href="stream.html#stream_class_stream_duplex">Duplex</a> streams have both.

</p>
<p><a href="stream.html#stream_class_stream_readable">Readable</a> 流有一个成员对象叫作 <code>_readableState</code>。
<a href="stream.html#stream_class_stream_writable">Writable</a> 流有一个成员对象叫作 <code>_writableState</code>。
<a href="stream.html#stream_class_stream_duplex">Duplex</a> 流二者兼备。

</p>
<p><strong>These objects should generally not be modified in child classes.</strong>
However, if you have a Duplex or Transform stream that should be in
<code>objectMode</code> on the readable side, and not in <code>objectMode</code> on the
writable side, then you may do this in the constructor by setting the
flag explicitly on the appropriate state object.

</p>
<p><strong>这些对象通常不应该被子类所更改。</strong>然而，如果您有一个 Duplex 或 Transform 流，它的可读端应该是 <code>objectMode</code>，但可写端却又不是 <code>objectMode</code>，那么您可以在构造函数里明确地设定合适的状态对象的标记来达到此目的。

</p>
<pre><code>var util = require(&apos;util&apos;);
var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;
var Transform = require(&apos;stream&apos;).Transform;
util.inherits(JSONParseStream, Transform);

// Gets \n-delimited JSON string data, and emits the parsed objects
function JSONParseStream(options) {
  if (!(this instanceof JSONParseStream))
    return new JSONParseStream(options);

// 获取以 \n 分隔的 JSON 字符串数据，并丢出解析后的对象
function JSONParseStream(options) {
  if (!(this instanceof JSONParseStream))
    return new JSONParseStream(options);

  Transform.call(this, options);
  this._writableState.objectMode = false;
  this._readableState.objectMode = true;
  this._buffer = &apos;&apos;;
  this._decoder = new StringDecoder(&apos;utf8&apos;);
}

  Transform.call(this, options);
  this._writableState.objectMode = false;
  this._readableState.objectMode = true;
  this._buffer = &apos;&apos;;
  this._decoder = new StringDecoder(&apos;utf8&apos;);
}

JSONParseStream.prototype._transform = function(chunk, encoding, cb) {
  this._buffer += this._decoder.write(chunk);
  // split on newlines
  var lines = this._buffer.split(/\r?\n/);
  // keep the last partial line buffered
  this._buffer = lines.pop();
  for (var l = 0; l &lt; lines.length; l++) {
    var line = lines[l];
    try {
      var obj = JSON.parse(line);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // push the parsed object out to the readable consumer
    this.push(obj);
  }
  cb();
};

JSONParseStream.prototype._transform = function(chunk, encoding, cb) {
  this._buffer += this._decoder.write(chunk);
  // 以新行分割
  var lines = this._buffer.split(/\r?\n/);
  // 保留最后一行被缓冲
  this._buffer = lines.pop();
  for (var l = 0; l &lt; lines.length; l++) {
    var line = lines[l];
    try {
      var obj = JSON.parse(line);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // 推出解析后的对象到可读消费者
    this.push(obj);
  }
  cb();
};

JSONParseStream.prototype._flush = function(cb) {
  // 仅仅处理剩下的东西
  var rem = this._buffer.trim();
  if (rem) {
    try {
      var obj = JSON.parse(rem);
    } catch (er) {
      this.emit(&apos;error&apos;, er);
      return;
    }
    // 推出解析后的对象到可读消费者
    this.push(obj);
  }
  cb();
};</code></pre>
<p>The state objects contain other useful information for debugging the
state of streams in your programs.  It is safe to look at them, but
beyond setting option flags in the constructor, it is <strong>not</strong> safe to
modify them.

</p>
<p>状态对象包含了其它调试您的程序的流的状态时有用的信息。读取它们是可以的，但越过构造函数的选项来更改它们是<strong>不安全的</strong>。

</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://joyent.com" class="joyent-logo">Joyent</a>
        <ul class="clearfix">
            <li><a href="http://nodejs.org/">Node.js</a></li>
            <li><a href="http://nodejs.org/download/">Download</a></li>
            <li><a href="http://nodejs.org/about/">About</a></li>
            <li><a href="http://npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="http://nodejs.org/community/">Community</a></li>
            <li><a href="http://nodejs.org/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="http://jixiangac.com/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.10.18/LICENSE">license</a>.</p>
    </div>

  <script src="public/api_assets/sh_main.js"></script>
  <script src="public/api_assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <!--
  <script>
    window._gaq = [['_setAccount', 'UA-10874194-2'], ['_trackPageview']];
    (function(d, t) {
      var g = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      g.src = '//www.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g, s);
    }(document, 'script'));
  </script>
  -->
</body>
</html>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26599868-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>