<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>File System Node.js v0.10.18 文档 中文版</title>
  <link rel="stylesheet" href="public/api_assets/style.css">
  <link rel="stylesheet" href="public/api_assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/fs.html">
</head>
<body class="alt apidoc" id="api-section-fs">

    <div id="intro" class="interior">
        <a href="http://xudafeng.github.io/nodejs/" title="返回首页">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <li><a href="http://xudafeng.github.io/nodejs/" class="docs current">文档首页</a></li>
                <li><a href="http://nodejs.org/api/">英文版文档</a></li>
            </ul>
            <div style="margin-top:44px; font-size:12px;">
              <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh"><img alt="知识共享许可协议" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh">知识共享署名-非商业性使用 3.0 未本地化版本许可协议</a>进行许可。
            </div>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.10.18 手册 &amp; 文档</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">索引</a> |
                <a href="all.html">在单一页面中浏览</a> |
                <a href="http://jixiangac.com/doc/node/fs.json">JSON格式</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>目录</h2>
            <ul>
<li><a href="fs.html#fs_file_system">File System</a><ul>
<li><a href="fs.html#fs_fs_rename_oldpath_newpath_callback">fs.rename(oldPath, newPath, callback)</a></li>
<li><a href="fs.html#fs_fs_renamesync_oldpath_newpath">fs.renameSync(oldPath, newPath)</a></li>
<li><a href="fs.html#fs_fs_ftruncate_fd_len_callback">fs.ftruncate(fd, len, callback)</a></li>
<li><a href="fs.html#fs_fs_ftruncatesync_fd_len">fs.ftruncateSync(fd, len)</a></li>
<li><a href="fs.html#fs_fs_truncate_path_len_callback">fs.truncate(path, len, callback)</a></li>
<li><a href="fs.html#fs_fs_truncatesync_path_len">fs.truncateSync(path, len)</a></li>
<li><a href="fs.html#fs_fs_chownsync_path_uid_gid">fs.chownSync(path, uid, gid)</a></li>
<li><a href="fs.html#fs_fs_fchown_fd_uid_gid_callback">fs.fchown(fd, uid, gid, callback)</a></li>
<li><a href="fs.html#fs_fs_fchownsync_fd_uid_gid">fs.fchownSync(fd, uid, gid)</a></li>
<li><a href="fs.html#fs_fs_lchown_path_uid_gid_callback">fs.lchown(path, uid, gid, callback)</a></li>
<li><a href="fs.html#fs_fs_lchownsync_path_uid_gid">fs.lchownSync(path, uid, gid)</a></li>
<li><a href="fs.html#fs_fs_chmod_path_mode_callback">fs.chmod(path, mode, callback)</a></li>
<li><a href="fs.html#fs_fs_chmodsync_path_mode">fs.chmodSync(path, mode)</a></li>
<li><a href="fs.html#fs_fs_fchmod_fd_mode_callback">fs.fchmod(fd, mode, callback)</a></li>
<li><a href="fs.html#fs_fs_fchmodsync_fd_mode">fs.fchmodSync(fd, mode)</a></li>
<li><a href="fs.html#fs_fs_lchmod_path_mode_callback">fs.lchmod(path, mode, callback)</a></li>
<li><a href="fs.html#fs_fs_lchmodsync_path_mode">fs.lchmodSync(path, mode)</a></li>
<li><a href="fs.html#fs_fs_stat_path_callback">fs.stat(path, callback)</a></li>
<li><a href="fs.html#fs_fs_lstat_path_callback">fs.lstat(path, callback)</a></li>
<li><a href="fs.html#fs_fs_fstat_fd_callback">fs.fstat(fd, callback)</a></li>
<li><a href="fs.html#fs_fs_statsync_path">fs.statSync(path)</a></li>
<li><a href="fs.html#fs_fs_lstatsync_path">fs.lstatSync(path)</a></li>
<li><a href="fs.html#fs_fs_fstatsync_fd">fs.fstatSync(fd)</a></li>
<li><a href="fs.html#fs_fs_link_srcpath_dstpath_callback">fs.link(srcpath, dstpath, callback)</a></li>
<li><a href="fs.html#fs_fs_linksync_srcpath_dstpath">fs.linkSync(srcpath, dstpath)</a></li>
<li><a href="fs.html#fs_fs_symlink_srcpath_dstpath_type_callback">fs.symlink(srcpath, dstpath, [type], callback)</a></li>
<li><a href="fs.html#fs_fs_symlinksync_srcpath_dstpath_type">fs.symlinkSync(srcpath, dstpath, [type])</a></li>
<li><a href="fs.html#fs_fs_readlink_path_callback">fs.readlink(path, callback)</a></li>
<li><a href="fs.html#fs_fs_readlinksync_path">fs.readlinkSync(path)</a></li>
<li><a href="fs.html#fs_fs_realpath_path_cache_callback">fs.realpath(path, [cache], callback)</a></li>
<li><a href="fs.html#fs_fs_realpathsync_path_cache">fs.realpathSync(path, [cache])</a></li>
<li><a href="fs.html#fs_fs_unlink_path_callback">fs.unlink(path, callback)</a></li>
<li><a href="fs.html#fs_fs_unlinksync_path">fs.unlinkSync(path)</a></li>
<li><a href="fs.html#fs_fs_rmdir_path_callback">fs.rmdir(path, callback)</a></li>
<li><a href="fs.html#fs_fs_rmdirsync_path">fs.rmdirSync(path)</a></li>
<li><a href="fs.html#fs_fs_mkdir_path_mode_callback">fs.mkdir(path, [mode], callback)</a></li>
<li><a href="fs.html#fs_fs_mkdirsync_path_mode">fs.mkdirSync(path, [mode])</a></li>
<li><a href="fs.html#fs_fs_readdir_path_callback">fs.readdir(path, callback)</a></li>
<li><a href="fs.html#fs_fs_readdirsync_path">fs.readdirSync(path)</a></li>
<li><a href="fs.html#fs_fs_close_fd_callback">fs.close(fd, callback)</a></li>
<li><a href="fs.html#fs_fs_closesync_fd">fs.closeSync(fd)</a></li>
<li><a href="fs.html#fs_fs_open_path_flags_mode_callback">fs.open(path, flags, [mode], callback)</a></li>
<li><a href="fs.html#fs_fs_opensync_path_flags_mode">fs.openSync(path, flags, [mode])</a></li>
<li><a href="fs.html#fs_fs_utimes_path_atime_mtime_callback">fs.utimes(path, atime, mtime, callback)</a></li>
<li><a href="fs.html#fs_fs_utimessync_path_atime_mtime">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="fs.html#fs_fs_utimes_path_atime_mtime_callback_1">fs.utimes(path, atime, mtime, callback)</a></li>
<li><a href="fs.html#fs_fs_utimessync_path_atime_mtime_1">fs.utimesSync(path, atime, mtime)</a></li>
<li><a href="fs.html#fs_fs_futimes_fd_atime_mtime_callback">fs.futimes(fd, atime, mtime, callback)</a></li>
<li><a href="fs.html#fs_fs_futimessync_fd_atime_mtime">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="fs.html#fs_fs_futimes_fd_atime_mtime_callback_1">fs.futimes(fd, atime, mtime, callback)</a></li>
<li><a href="fs.html#fs_fs_futimessync_fd_atime_mtime_1">fs.futimesSync(fd, atime, mtime)</a></li>
<li><a href="fs.html#fs_fs_fsync_fd_callback">fs.fsync(fd, callback)</a></li>
<li><a href="fs.html#fs_fs_fsyncsync_fd">fs.fsyncSync(fd)</a></li>
<li><a href="fs.html#fs_fs_write_fd_buffer_offset_length_position_callback">fs.write(fd, buffer, offset, length[, position], callback)</a></li>
<li><a href="fs.html#fs_fs_write_fd_data_position_encoding_callback">fs.write(fd, data[, position[, encoding]], callback)</a></li>
<li><a href="fs.html#fs_fs_writesync_fd_buffer_offset_length_position">fs.writeSync(fd, buffer, offset, length[, position])</a></li>
<li><a href="fs.html#fs_fs_writesync_fd_data_position_encoding">fs.writeSync(fd, data[, position[, encoding]])</a></li>
<li><a href="fs.html#fs_fs_read_fd_buffer_offset_length_position_callback">fs.read(fd, buffer, offset, length, position, callback)</a></li>
<li><a href="fs.html#fs_fs_readsync_fd_buffer_offset_length_position">fs.readSync(fd, buffer, offset, length, position)</a></li>
<li><a href="fs.html#fs_fs_readfile_filename_options_callback">fs.readFile(filename, [options], callback)</a></li>
<li><a href="fs.html#fs_fs_readfilesync_filename_options">fs.readFileSync(filename, [options])</a></li>
<li><a href="fs.html#fs_fs_writefile_filename_data_options_callback">fs.writeFile(filename, data, [options], callback)</a></li>
<li><a href="fs.html#fs_fs_writefilesync_filename_data_options">fs.writeFileSync(filename, data, [options])</a></li>
<li><a href="fs.html#fs_fs_appendfile_filename_data_options_callback">fs.appendFile(filename, data, [options], callback)</a></li>
<li><a href="fs.html#fs_fs_appendfilesync_filename_data_options">fs.appendFileSync(filename, data, [options])</a></li>
<li><a href="fs.html#fs_fs_watchfile_filename_options_listener">fs.watchFile(filename, [options], listener)</a></li>
<li><a href="fs.html#fs_fs_unwatchfile_filename_listener">fs.unwatchFile(filename, [listener])</a></li>
<li><a href="fs.html#fs_fs_watch_filename_options_listener">fs.watch(filename, [options], [listener])</a><ul>
<li><a href="fs.html#fs">注意事项</a><ul>
<li><a href="fs.html#fs_1">可用性</a></li>
<li><a href="fs.html#fs_2">文件名参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="fs.html#fs_fs_exists_path_callback">fs.exists(path, callback)</a></li>
<li><a href="fs.html#fs_fs_existssync_path">fs.existsSync(path)</a></li>
<li><a href="fs.html#fs_class_fs_stats">Class: fs.Stats</a><ul>
<li><a href="fs.html#fs_stat_time_values">Stat Time Values</a></li>
</ul>
</li>
<li><a href="fs.html#fs_fs_createreadstream_path_options">fs.createReadStream(path, [options])</a></li>
<li><a href="fs.html#fs_class_fs_readstream">Class: fs.ReadStream</a><ul>
<li><a href="fs.html#fs_open">事件: &apos;open&apos;</a></li>
</ul>
</li>
<li><a href="fs.html#fs_fs_createwritestream_path_options">fs.createWriteStream(path, [options])</a></li>
<li><a href="fs.html#fs_class_fs_writestream">Class: fs.WriteStream</a><ul>
<li><a href="fs.html#fs_open_1">事件: &apos;open&apos;</a></li>
<li><a href="fs.html#fs_file_byteswritten">file.bytesWritten</a></li>
</ul>
</li>
<li><a href="fs.html#fs_class_fs_fswatcher">Class: fs.FSWatcher</a><ul>
<li><a href="fs.html#fs_watcher_close">watcher.close()</a></li>
<li><a href="fs.html#fs_change">事件: &apos;change&apos;</a></li>
<li><a href="fs.html#fs_error">事件: &apos;error&apos;</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>File System<span><a href="fs.html#fs_file_system" id="fs_file_system">#</a></span></h1>
<pre><code>稳定度: 3 - 稳定</code></pre>
<!--name=fs-->

<p>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <code>require(&apos;fs&apos;)</code>. All the methods have asynchronous and
synchronous forms.

</p>
<p>文件系统模块是一个简单包装的标准 POSIX 文件 I/O 操作方法集。您可以通过调用<code>require(&apos;fs&apos;)</code>来获取该模块。文件系统模块中的所有方法均有异步和同步版本。 

</p>
<p>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <code>null</code> or <code>undefined</code>.

</p>
<p>文件系统模块中的异步方法需要一个完成时的回调函数作为最后一个传入形参。
回调函数的构成由您调用的异步方法所决定，通常情况下回调函数的第一个形参为返回的错误信息。
如果异步操作执行正确并返回，该错误形参则为<code>null</code>或者<code>undefined</code>。

</p>
<p>When using the synchronous form any exceptions are immediately thrown.
You can use try/catch to handle exceptions or allow them to bubble up.

</p>
<p>如果您使用的是同步版本的操作方法，则一旦出现错误，会以通常的抛出错误的形式返回错误。
你可以用<code>try</code>和<code>catch</code>等语句来拦截错误并使程序继续进行。

</p>
<p>Here is an example of the asynchronous version:

</p>
<p>这里是一个异步版本的例子：

</p>
<pre><code>fs.unlink(&apos;/tmp/hello&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;successfully deleted /tmp/hello&apos;);
});</code></pre>
<p>Here is the synchronous version:

</p>
<p>这是同步版本的例子:

</p>
<pre><code>fs.unlinkSync(&apos;/tmp/hello&apos;)
console.log(&apos;successfully deleted /tmp/hello&apos;);</code></pre>
<p>With the asynchronous methods there is no guaranteed ordering. So the
following is prone to error:

</p>
<p>当使用异步版本时不能保证执行顺序,因此下面这个例子很容易出错:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;renamed complete&apos;);
});
fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
  if (err) throw err;
  console.log(&apos;stats: &apos; + JSON.stringify(stats));
});</code></pre>
<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.
The correct way to do this is to chain the callbacks.

</p>
<p><code>fs.stat</code>有可能在<code>fs.rename</code>前执行.要等到正确的执行顺序应该用下面的方法:

</p>
<pre><code>fs.rename(&apos;/tmp/hello&apos;, &apos;/tmp/world&apos;, function (err) {
  if (err) throw err;
  fs.stat(&apos;/tmp/world&apos;, function (err, stats) {
    if (err) throw err;
    console.log(&apos;stats: &apos; + JSON.stringify(stats));
  });
});</code></pre>
<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the
asynchronous versions of these calls. The synchronous versions will block
the entire process until they complete--halting all connections.

</p>
<p>在繁重的任务中,<em>强烈推荐</em>使用这些函数的异步版本.同步版本会阻塞进程,直到完成处理,也就是说会暂停所有的连接.

</p>
<p>Relative path to filename can be used, remember however that this path will be
relative to <code>process.cwd()</code>.

</p>
<p>可以使用文件名的相对路径, 但是记住这个路径是相对于<code>process.cwd()</code>的.

</p>
<p>Most fs functions let you omit the callback argument. If you do, a default
callback is used that rethrows errors. To get a trace to the original call
site, set the NODE_DEBUG environment variable:

</p>
<p>大部分的文件系统(fs)函数可以忽略回调函数(callback)这个参数.如果忽略它,将会由一个默认回调函数(callback)来重新抛出(rethrow)错误.要获得原调用点的堆栈跟踪(trace)信息,需要在环境变量里设置NODE_DEBUG.

</p>
<pre><code>$ env NODE_DEBUG=fs node script.js
fs.js:66
        throw err;
              ^
Error: EISDIR, read
    at rethrow (fs.js:61:21)
    at maybeCallback (fs.js:79:42)
    at Object.fs.readFile (fs.js:153:18)
    at bad (/path/to/script.js:2:17)
    at Object.&lt;anonymous&gt; (/path/to/script.js:5:1)
    &lt;etc.&gt;</code></pre>
<h2>fs.rename(oldPath, newPath, callback)<span><a href="fs.html#fs_fs_rename_oldpath_newpath_callback" id="fs_fs_rename_oldpath_newpath_callback">#</a></span></h2>
<p>Asynchronous rename(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的rename函数(2).完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.renameSync(oldPath, newPath)<span><a href="fs.html#fs_fs_renamesync_oldpath_newpath" id="fs_fs_renamesync_oldpath_newpath">#</a></span></h2>
<p>Synchronous rename(2).

</p>
<p>同步版本的rename(2).

</p>
<h2>fs.ftruncate(fd, len, callback)<span><a href="fs.html#fs_fs_ftruncate_fd_len_callback" id="fs_fs_ftruncate_fd_len_callback">#</a></span></h2>
<p>Asynchronous ftruncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<p>异步版本的ftruncate(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.ftruncateSync(fd, len)<span><a href="fs.html#fs_fs_ftruncatesync_fd_len" id="fs_fs_ftruncatesync_fd_len">#</a></span></h2>
<p>Synchronous ftruncate(2).

</p>
<p>同步版本的ftruncate(2).

</p>
<h2>fs.truncate(path, len, callback)<span><a href="fs.html#fs_fs_truncate_path_len_callback" id="fs_fs_truncate_path_len_callback">#</a></span></h2>
<p>Asynchronous truncate(2). No arguments other than a possible exception are
given to the completion callback.

</p>
<p>异步版本的truncate(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.truncateSync(path, len)<span><a href="fs.html#fs_fs_truncatesync_path_len" id="fs_fs_truncatesync_path_len">#</a></span></h2>
<p>Synchronous truncate(2).

</p>
<p>同步版本的truncate(2).

</p>
<p>异步版本的chown.完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<p>Asynchronous chown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的chown(2).完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.chownSync(path, uid, gid)<span><a href="fs.html#fs_fs_chownsync_path_uid_gid" id="fs_fs_chownsync_path_uid_gid">#</a></span></h2>
<p>Synchronous chown(2).

</p>
<p>同步版本的chown(2).

</p>
<h2>fs.fchown(fd, uid, gid, callback)<span><a href="fs.html#fs_fs_fchown_fd_uid_gid_callback" id="fs_fs_fchown_fd_uid_gid_callback">#</a></span></h2>
<p>Asynchronous fchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的fchown(2)。回调函数的参数除了出现错误时有一个错误对象外，没有其它参数。

</p>
<h2>fs.fchownSync(fd, uid, gid)<span><a href="fs.html#fs_fs_fchownsync_fd_uid_gid" id="fs_fs_fchownsync_fd_uid_gid">#</a></span></h2>
<p>Synchronous fchown(2).

</p>
<p>同步版本的fchown(2).

</p>
<h2>fs.lchown(path, uid, gid, callback)<span><a href="fs.html#fs_fs_lchown_path_uid_gid_callback" id="fs_fs_lchown_path_uid_gid_callback">#</a></span></h2>
<p>Asynchronous lchown(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的lchown(2)。完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.lchownSync(path, uid, gid)<span><a href="fs.html#fs_fs_lchownsync_path_uid_gid" id="fs_fs_lchownsync_path_uid_gid">#</a></span></h2>
<p>Synchronous lchown(2).

</p>
<p>同步版本的lchown(2).

</p>
<h2>fs.chmod(path, mode, callback)<span><a href="fs.html#fs_fs_chmod_path_mode_callback" id="fs_fs_chmod_path_mode_callback">#</a></span></h2>
<p>Asynchronous chmod(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 chmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.chmodSync(path, mode)<span><a href="fs.html#fs_fs_chmodsync_path_mode" id="fs_fs_chmodsync_path_mode">#</a></span></h2>
<p>Synchronous chmod(2).

</p>
<p>同步版的 chmod(2).

</p>
<h2>fs.fchmod(fd, mode, callback)<span><a href="fs.html#fs_fs_fchmod_fd_mode_callback" id="fs_fs_fchmod_fd_mode_callback">#</a></span></h2>
<p>Asynchronous fchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<p>异步版的 fchmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.fchmodSync(fd, mode)<span><a href="fs.html#fs_fs_fchmodsync_fd_mode" id="fs_fs_fchmodsync_fd_mode">#</a></span></h2>
<p>Synchronous fchmod(2).

</p>
<p>同步版的 fchmod(2).

</p>
<h2>fs.lchmod(path, mode, callback)<span><a href="fs.html#fs_fs_lchmod_path_mode_callback" id="fs_fs_lchmod_path_mode_callback">#</a></span></h2>
<p>Asynchronous lchmod(2). No arguments other than a possible exception
are given to the completion callback.

</p>
<p>异步版的 lchmod(2). 完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<p>Only available on Mac OS X.

</p>
<p>仅在 Mac OS X 系统下可用。

</p>
<h2>fs.lchmodSync(path, mode)<span><a href="fs.html#fs_fs_lchmodsync_path_mode" id="fs_fs_lchmodsync_path_mode">#</a></span></h2>
<p>Synchronous lchmod(2).

</p>
<p>同步版的 lchmod(2).

</p>
<h2>fs.stat(path, callback)<span><a href="fs.html#fs_fs_stat_path_callback" id="fs_fs_stat_path_callback">#</a></span></h2>
<p>Asynchronous stat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <a href="fs.html#fs_class_fs_stats">fs.Stats</a> object.  See the <a href="fs.html#fs_class_fs_stats">fs.Stats</a>
section below for more information.

</p>
<p>异步版的 stat(2). 回调函数（callback） 接收两个参数： <code>(err, stats)</code> ，其中
<code>stats</code> 是一个 <a href="fs.html#fs_class_fs_stats">fs.Stats</a> 对象。 详情请参考 <a href="fs.html#fs_class_fs_stats">fs.Stats</a>

</p>
<h2>fs.lstat(path, callback)<span><a href="fs.html#fs_fs_lstat_path_callback" id="fs_fs_lstat_path_callback">#</a></span></h2>
<p>Asynchronous lstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>lstat()</code> is identical to <code>stat()</code>, except that if
<code>path</code> is a symbolic link, then the link itself is stat-ed, not the file that it
refers to.

</p>
<p>异步版的 lstat(2). 回调函数（callback）接收两个参数： <code>(err, stats)</code> 其中
<code>stats</code> 是一个 <code>fs.Stats</code> 对象。 <code>lstat()</code> 与 <code>stat()</code> 相同，区别在于：
若 <code>path</code> 是一个符号链接时（symbolic link）,读取的是该符号链接本身，而不是它所
链接到的文件。

</p>
<h2>fs.fstat(fd, callback)<span><a href="fs.html#fs_fs_fstat_fd_callback" id="fs_fs_fstat_fd_callback">#</a></span></h2>
<p>Asynchronous fstat(2). The callback gets two arguments <code>(err, stats)</code> where
<code>stats</code> is a <code>fs.Stats</code> object. <code>fstat()</code> is identical to <code>stat()</code>, except that
the file to be stat-ed is specified by the file descriptor <code>fd</code>.

</p>
<p>异步版的 fstat(2). 回调函数（callback）接收两个参数： <code>(err, stats)</code> 其中
<code>stats</code> 是一个 <code>fs.Stats</code> 对象。 <code>fstat()</code> 与 <code>stat()</code> 相同，区别在于：
要读取的文件（译者注：即第一个参数）是一个文件描述符（file descriptor） <code>fd</code> 。

</p>
<h2>fs.statSync(path)<span><a href="fs.html#fs_fs_statsync_path" id="fs_fs_statsync_path">#</a></span></h2>
<p>Synchronous stat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 stat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.lstatSync(path)<span><a href="fs.html#fs_fs_lstatsync_path" id="fs_fs_lstatsync_path">#</a></span></h2>
<p>Synchronous lstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 lstat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.fstatSync(fd)<span><a href="fs.html#fs_fs_fstatsync_fd" id="fs_fs_fstatsync_fd">#</a></span></h2>
<p>Synchronous fstat(2). Returns an instance of <code>fs.Stats</code>.

</p>
<p>同步版的 fstat(2). 返回一个 <code>fs.Stats</code> 实例。

</p>
<h2>fs.link(srcpath, dstpath, callback)<span><a href="fs.html#fs_fs_link_srcpath_dstpath_callback" id="fs_fs_link_srcpath_dstpath_callback">#</a></span></h2>
<p>Asynchronous link(2). No arguments other than a possible exception are given to
the completion callback.

</p>
<p>异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。

</p>
<h2>fs.linkSync(srcpath, dstpath)<span><a href="fs.html#fs_fs_linksync_srcpath_dstpath" id="fs_fs_linksync_srcpath_dstpath">#</a></span></h2>
<p>Synchronous link(2).

</p>
<p>同步版的 link(2).

</p>
<h2>fs.symlink(srcpath, dstpath, [type], callback)<span><a href="fs.html#fs_fs_symlink_srcpath_dstpath_type_callback" id="fs_fs_symlink_srcpath_dstpath_type_callback">#</a></span></h2>
<p>Asynchronous symlink(2). No arguments other than a possible exception are given
to the completion callback.
<code>type</code> argument can be either <code>&apos;dir&apos;</code>, <code>&apos;file&apos;</code>, or <code>&apos;junction&apos;</code> (default is <code>&apos;file&apos;</code>).  It is only 
used on Windows (ignored on other platforms).
Note that Windows junction points require the destination path to be absolute.  When using
<code>&apos;junction&apos;</code>, the <code>destination</code> argument will automatically be normalized to absolute path.

</p>
<p>异步版的 symlink(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。
<code>type</code> 可以是 <code>&apos;dir&apos;</code>, <code>&apos;file&apos;</code>, 或者<code>&apos;junction&apos;</code> (默认是 <code>&apos;file&apos;</code>)，此参数仅用于
Windows 系统（其他系统平台会被忽略）。
注意： Windows 系统要求目标路径（译者注：即 <code>dstpath</code> 参数）必须是一个绝对路径，当使用
<code>&apos;junction&apos;</code> 时，<code>dstpath</code> 参数会自动转换为绝对路径。

</p>
<h2>fs.symlinkSync(srcpath, dstpath, [type])<span><a href="fs.html#fs_fs_symlinksync_srcpath_dstpath_type" id="fs_fs_symlinksync_srcpath_dstpath_type">#</a></span></h2>
<p>Synchronous symlink(2).

</p>
<p>同步版的 symlink(2).

</p>
<h2>fs.readlink(path, callback)<span><a href="fs.html#fs_fs_readlink_path_callback" id="fs_fs_readlink_path_callback">#</a></span></h2>
<p>Asynchronous readlink(2). The callback gets two arguments <code>(err,
linkString)</code>.

</p>
<p>异步版的 readlink(2). 回调函数（callback）接收两个参数： <code>(err,
linkString)</code>.

</p>
<h2>fs.readlinkSync(path)<span><a href="fs.html#fs_fs_readlinksync_path" id="fs_fs_readlinksync_path">#</a></span></h2>
<p>Synchronous readlink(2). Returns the symbolic link&apos;s string value.

</p>
<p>同步版的 readlink(2). 返回符号链接（symbolic link）的字符串值。

</p>
<h2>fs.realpath(path, [cache], callback)<span><a href="fs.html#fs_fs_realpath_path_cache_callback" id="fs_fs_realpath_path_cache_callback">#</a></span></h2>
<p>Asynchronous realpath(2). The <code>callback</code> gets two arguments <code>(err,
resolvedPath)</code>. May use <code>process.cwd</code> to resolve relative paths. <code>cache</code> is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional <code>fs.stat</code> calls for known real paths.

</p>
<p>异步版的 realpath(2). 回调函数（callback）接收两个参数： <code>(err,
resolvedPath)</code>. May use <code>process.cwd</code> to resolve relative paths. <code>cache</code> is an
object literal of mapped paths that can be used to force a specific path
resolution or avoid additional <code>fs.stat</code> calls for known real paths.

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>var cache = {&apos;/etc&apos;:&apos;/private/etc&apos;};
fs.realpath(&apos;/etc/passwd&apos;, cache, function (err, resolvedPath) {
  if (err) throw err;
  console.log(resolvedPath);
});</code></pre>
<h2>fs.realpathSync(path, [cache])<span><a href="fs.html#fs_fs_realpathsync_path_cache" id="fs_fs_realpathsync_path_cache">#</a></span></h2>
<p>Synchronous realpath(2). Returns the resolved path.

</p>
<p>realpath(2) 的同步版本。返回解析出的路径。

</p>
<h2>fs.unlink(path, callback)<span><a href="fs.html#fs_fs_unlink_path_callback" id="fs_fs_unlink_path_callback">#</a></span></h2>
<p>Asynchronous unlink(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 unlink(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息.

</p>
<h2>fs.unlinkSync(path)<span><a href="fs.html#fs_fs_unlinksync_path" id="fs_fs_unlinksync_path">#</a></span></h2>
<p>Synchronous unlink(2).

</p>
<p>同步版的 unlink(2).

</p>
<h2>fs.rmdir(path, callback)<span><a href="fs.html#fs_fs_rmdir_path_callback" id="fs_fs_rmdir_path_callback">#</a></span></h2>
<p>Asynchronous rmdir(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版的 rmdir(2). 异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。

</p>
<h2>fs.rmdirSync(path)<span><a href="fs.html#fs_fs_rmdirsync_path" id="fs_fs_rmdirsync_path">#</a></span></h2>
<p>Synchronous rmdir(2).

</p>
<p>同步版的 rmdir(2).

</p>
<h2>fs.mkdir(path, [mode], callback)<span><a href="fs.html#fs_fs_mkdir_path_mode_callback" id="fs_fs_mkdir_path_mode_callback">#</a></span></h2>
<p>Asynchronous mkdir(2). No arguments other than a possible exception are given
to the completion callback. <code>mode</code> defaults to <code>0777</code>.

</p>
<p>异步版的 mkdir(2)。 异步版的 link(2). 完成时的回调函数（callback）只接受一个参数：可能出现的异常信息。文件 <code>mode</code> 默认为 <code>0777</code>。

</p>
<h2>fs.mkdirSync(path, [mode])<span><a href="fs.html#fs_fs_mkdirsync_path_mode" id="fs_fs_mkdirsync_path_mode">#</a></span></h2>
<p>Synchronous mkdir(2).

</p>
<p>同步版的 mkdir(2)。

</p>
<h2>fs.readdir(path, callback)<span><a href="fs.html#fs_fs_readdir_path_callback" id="fs_fs_readdir_path_callback">#</a></span></h2>
<p>Asynchronous readdir(3).  Reads the contents of a directory.
The callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of
the names of the files in the directory excluding <code>&apos;.&apos;</code> and <code>&apos;..&apos;</code>.

</p>
<p>异步版的 readdir(3)。 读取 path 路径所在目录的内容。 回调函数 (callback) 接受两个参数 <code>(err, files)</code> 其中 <code>files</code> 是一个存储目录中所包含的文件名称的数组，数组中不包括 <code>&apos;.&apos;</code> 和 <code>&apos;..&apos;</code>。

</p>
<h2>fs.readdirSync(path)<span><a href="fs.html#fs_fs_readdirsync_path" id="fs_fs_readdirsync_path">#</a></span></h2>
<p>Synchronous readdir(3). Returns an array of filenames excluding <code>&apos;.&apos;</code> and
<code>&apos;..&apos;</code>.

</p>
<p>同步版的 readdir(3). 返回文件名数组，其中不包括 <code>&apos;.&apos;</code> 和 <code>&apos;..&apos;</code> 目录.

</p>
<h2>fs.close(fd, callback)<span><a href="fs.html#fs_fs_close_fd_callback" id="fs_fs_close_fd_callback">#</a></span></h2>
<p>Asynchronous close(2).  No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版 close(2).  完成时的回调函数(callback)只接受一个参数:可能出现的异常信息.

</p>
<h2>fs.closeSync(fd)<span><a href="fs.html#fs_fs_closesync_fd" id="fs_fs_closesync_fd">#</a></span></h2>
<p>Synchronous close(2).

</p>
<p>同步版的 close(2).

</p>
<h2>fs.open(path, flags, [mode], callback)<span><a href="fs.html#fs_fs_open_path_flags_mode_callback" id="fs_fs_open_path_flags_mode_callback">#</a></span></h2>
<p>Asynchronous file open. See open(2). <code>flags</code> can be:

</p>
<p>异步版的文件打开. 详见 open(2). <code>flags</code> 可以是:

</p>
<ul>
<li><p><code>&apos;r&apos;</code> - Open file for reading.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code>&apos;r&apos;</code>  - 以【只读】的方式打开文件. 当文件不存在时产生异常.</p>
</li>
<li><p><code>&apos;r+&apos;</code> - Open file for reading and writing.
An exception occurs if the file does not exist.</p>
</li>
<li><p><code>&apos;r+&apos;</code> - 以【读写】的方式打开文件. 当文件不存在时产生异常.</p>
</li>
<li><p><code>&apos;rs&apos;</code> - Open file for reading in synchronous mode. Instructs the operating
system to bypass the local file system cache.</p>
</li>
<li><p><code>&apos;rs&apos;</code> - 同步模式下，以【只读】的方式打开文件. 指令绕过操作系统的本地文件系统缓存.</p>
<p>This is primarily useful for opening files on NFS mounts as it allows you to
skip the potentially stale local cache. It has a very real impact on I/O
performance so don&apos;t use this flag unless you need it.</p>
</li>
</ul>
<p>该功能主要用于打开 NFS 挂载的文件, 因为它可以让你跳过默认使用的过时本地缓存. 但这实际上非常影响 I/O 操作的性能, 因此除非你确实有这样的需求, 否则请不要使用该标志.

</p>
<p>  Note that this doesn&apos;t turn <code>fs.open()</code> into a synchronous blocking call.
  If that&apos;s what you want then you should be using <code>fs.openSync()</code>

</p>
<p> 注意: 这并不意味着 <code>fs.open()</code> 变成了一个同步阻塞的请求. 如果你想要一个同步阻塞的请求你应该使用 <code>fs.openSync()</code>.

</p>
<ul>
<li><p><code>&apos;rs+&apos;</code> - Open file for reading and writing, telling the OS to open it
synchronously. See notes for <code>&apos;rs&apos;</code> about using this with caution.</p>
</li>
<li><p><code>&apos;rs+&apos;</code> - 同步模式下, 以【读写】的方式打开文件. 请谨慎使用该方式, 详细请查看 <code>&apos;rs&apos;</code> 的注释.</p>
</li>
<li><p><code>&apos;w&apos;</code> - Open file for writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code>&apos;w&apos;</code> - 以【只写】的形式打开文件. 文件会被创建 (如果文件不存在) 或者覆盖 (如果存在).</p>
</li>
<li><p><code>&apos;wx&apos;</code> - Like <code>&apos;w&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;wx&apos;</code> - 类似 <code>&apos;w&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;w+&apos;</code> - Open file for reading and writing.
The file is created (if it does not exist) or truncated (if it exists).</p>
</li>
<li><p><code>&apos;w+&apos;</code> - 以【读写】的方式打开文件. 文件会被创建 (如果文件不存在) 或者覆盖 (如果存在).</p>
</li>
<li><p><code>&apos;wx+&apos;</code> - Like <code>&apos;w+&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;wx+&apos;</code> - 类似 <code>&apos;w+&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;a&apos;</code> - Open file for appending.
The file is created if it does not exist.</p>
</li>
<li><p><code>&apos;a&apos;</code> - 以【附加】的形式打开文件，即新写入的数据会附加在原来的文件内容之后. 如果文件不存在则会默认创建.</p>
</li>
<li><p><code>&apos;ax&apos;</code> - Like <code>&apos;a&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;ax&apos;</code> - 类似 <code>&apos;a&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
<li><p><code>&apos;a+&apos;</code> - Open file for reading and appending.
The file is created if it does not exist.</p>
</li>
<li><p><code>&apos;a+&apos;</code> - 以【读取】和【附加】的形式打开文件. 如果文件不存在则会默认创建.</p>
</li>
<li><p><code>&apos;ax+&apos;</code> - Like <code>&apos;a+&apos;</code> but fails if <code>path</code> exists.</p>
</li>
<li><p><code>&apos;ax+&apos;</code> - 类似 <code>&apos;a+&apos;</code> 区别是如果文件存在则操作会失败.</p>
</li>
</ul>
<p><code>mode</code> sets the file mode (permission and sticky bits), but only if the file was
created. It defaults to <code>0666</code>, readable and writeable.

</p>
<p>参数 <code>mode</code> 用于设置文件模式 (permission and sticky bits), 不过前提是这个文件是已存在的. 默认情况下是 <code>0666</code>, 有可读和可写权限.

</p>
<p>The callback gets two arguments <code>(err, fd)</code>.

</p>
<p>该 callback 接收两个参数 <code>(err, fd)</code>.

</p>
<p>The exclusive flag <code>&apos;x&apos;</code> (<code>O_EXCL</code> flag in open(2)) ensures that <code>path</code> is newly
created. On POSIX systems, <code>path</code> is considered to exist even if it is a symlink
to a non-existent file. The exclusive flag may or may not work with network file
systems.

</p>
<p>排除 (exclusive) 标识 <code>&apos;x&apos;</code> （对应 open(2) 的 <code>O_EXCL</code> 标识） 保证 <code>path</code> 是一个新建的文件。
POSIX 操作系统上，即使 <code>path</code> 是一个指向不存在位置的符号链接，也会被认定为文件存在。
排除标识在网络文件系统不能确定是否有效。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.openSync(path, flags, [mode])<span><a href="fs.html#fs_fs_opensync_path_flags_mode" id="fs_fs_opensync_path_flags_mode">#</a></span></h2>
<p>Synchronous version of <code>fs.open()</code>.

</p>
<p><code>fs.open()</code> 的同步版.

</p>
<h2>fs.utimes(path, atime, mtime, callback)<span><a href="fs.html#fs_fs_utimes_path_atime_mtime_callback" id="fs_fs_utimes_path_atime_mtime_callback">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a href="fs.html#fs_fs_utimessync_path_atime_mtime" id="fs_fs_utimessync_path_atime_mtime">#</a></span></h2>
<h2>fs.utimes(path, atime, mtime, callback)<span><a href="fs.html#fs_fs_utimes_path_atime_mtime_callback_1" id="fs_fs_utimes_path_atime_mtime_callback_1">#</a></span></h2>
<h2>fs.utimesSync(path, atime, mtime)<span><a href="fs.html#fs_fs_utimessync_path_atime_mtime_1" id="fs_fs_utimessync_path_atime_mtime_1">#</a></span></h2>
<p>Change file timestamps of the file referenced by the supplied path.

</p>
<p>更改 path 所指向的文件的时间戳。

</p>
<h2>fs.futimes(fd, atime, mtime, callback)<span><a href="fs.html#fs_fs_futimes_fd_atime_mtime_callback" id="fs_fs_futimes_fd_atime_mtime_callback">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a href="fs.html#fs_fs_futimessync_fd_atime_mtime" id="fs_fs_futimessync_fd_atime_mtime">#</a></span></h2>
<h2>fs.futimes(fd, atime, mtime, callback)<span><a href="fs.html#fs_fs_futimes_fd_atime_mtime_callback_1" id="fs_fs_futimes_fd_atime_mtime_callback_1">#</a></span></h2>
<h2>fs.futimesSync(fd, atime, mtime)<span><a href="fs.html#fs_fs_futimessync_fd_atime_mtime_1" id="fs_fs_futimessync_fd_atime_mtime_1">#</a></span></h2>
<p>Change the file timestamps of a file referenced by the supplied file
descriptor.

</p>
<p>更改文件描述符 (file discriptor) 所指向的文件的时间戳。

</p>
<h2>fs.fsync(fd, callback)<span><a href="fs.html#fs_fs_fsync_fd_callback" id="fs_fs_fsync_fd_callback">#</a></span></h2>
<p>Asynchronous fsync(2). No arguments other than a possible exception are given
to the completion callback.

</p>
<p>异步版本的 fsync(2)。回调函数仅含有一个异常 (exception) 参数。

</p>
<h2>fs.fsyncSync(fd)<span><a href="fs.html#fs_fs_fsyncsync_fd" id="fs_fs_fsyncsync_fd">#</a></span></h2>
<p>Synchronous fsync(2).

</p>
<p>fsync(2) 的同步版本。

</p>
<h2>fs.write(fd, buffer, offset, length[, position], callback)<span><a href="fs.html#fs_fs_write_fd_buffer_offset_length_position_callback" id="fs_fs_write_fd_buffer_offset_length_position_callback">#</a></span></h2>
<p>Write <code>buffer</code> to the file specified by <code>fd</code>.

</p>
<p>通过文件标识<code>fd</code>，向指定的文件中写入<code>buffer</code>。

</p>
<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.

</p>
<p><code>offset</code> 和<code>length</code> 可以确定从哪个位置开始写入buffer。

</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &apos;number&apos;</code>, the data will be written
at the current position. See pwrite(2).

</p>
<p><code>position</code> 是参考当前文档光标的位置，然后从该处写入数据。如果<code>typeof position !== &apos;number&apos;</code>，那么数据会从当前文档位置写入，请看pwrite(2)。

</p>
<p>The callback will be given three arguments <code>(err, written, buffer)</code> where
<code>written</code> specifies how many <em>bytes</em> were written from <code>buffer</code>.

</p>
<p>回调中会给出三个参数 <code>(err, written, buffer)</code>，<code>written</code> 说明从<code>buffer</code>写入的字节数。

</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.

</p>
<p>注意，<code>fs.write</code>多次地在同一个文件中使用而没有等待回调是不安全的。在这种情况下，强烈推荐使用<code>fs.createWriteStream</code>。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.write(fd, data[, position[, encoding]], callback)<span><a href="fs.html#fs_fs_write_fd_data_position_encoding_callback" id="fs_fs_write_fd_data_position_encoding_callback">#</a></span></h2>
<p>Write <code>data</code> to the file specified by <code>fd</code>.  If <code>data</code> is not a Buffer instance
then the value will be coerced to a string.

</p>
<p>把<code>data</code>写入到文档中通过指定的<code>fd</code>,如果<code>data</code>不是buffer对象的实例则会把值强制转化成一个字符串。

</p>
<p><code>position</code> refers to the offset from the beginning of the file where this data
should be written. If <code>typeof position !== &apos;number&apos;</code> the data will be written at
the current position. See pwrite(2).

</p>
<p><code>position</code> 是参考当前文档光标的位置，然后从该处写入数据。如果<code>typeof position !== &apos;number&apos;</code>，那么数据会从当前文档位置写入，请看pwrite(2)。

</p>
<p><code>encoding</code> is the expected string encoding.

</p>
<p><code>encoding</code> 是预期得到一个字符串编码

</p>
<p>The callback will receive the arguments <code>(err, written, string)</code> where <code>written</code>
specifies how many <em>bytes</em> the passed string required to be written. Note that
bytes written is not the same as string characters. See
<a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">Buffer.byteLength</a>.

</p>
<p>回调会得到这些参数 <code>(err, written, string)</code>，<code>written</code>表明传入的<code>string</code>需要写入的字符串长度。注意字节的写入跟字符串写入是不一样的。请看<a href="buffer.html#buffer_class_method_buffer_bytelength_string_encoding">Buffer.byteLength</a>.

</p>
<p>Unlike when writing <code>buffer</code>, the entire string must be written. No substring
may be specified. This is because the byte offset of the resulting data may not
be the same as the string offset.

</p>
<p>与写入<code>buffer</code>不同，必须写入完整的字符串，截取字符串不是符合规定的。这是因为返回的字节的位移跟字符串的位移是不一样的。

</p>
<p>Note that it is unsafe to use <code>fs.write</code> multiple times on the same file
without waiting for the callback. For this scenario,
<code>fs.createWriteStream</code> is strongly recommended.

</p>
<p>注意，<code>fs.write</code>多次地在同一个文件中使用而没有等待回调是不安全的。在这种情况下，强烈推荐使用<code>fs.createWriteStream</code>。

</p>
<p>On Linux, positional writes don&apos;t work when the file is opened in append mode.
The kernel ignores the position argument and always appends the data to
the end of the file.

</p>
<p>在 Linux 上，无法对以追加 (append) 模式打开的文件进行指定位置的写入操作。
内核会忽略位置参数并且总是将数据追加到文件尾部。

</p>
<h2>fs.writeSync(fd, buffer, offset, length[, position])<span><a href="fs.html#fs_fs_writesync_fd_buffer_offset_length_position" id="fs_fs_writesync_fd_buffer_offset_length_position">#</a></span></h2>
<h2>fs.writeSync(fd, data[, position[, encoding]])<span><a href="fs.html#fs_fs_writesync_fd_data_position_encoding" id="fs_fs_writesync_fd_data_position_encoding">#</a></span></h2>
<p>Synchronous versions of <code>fs.write()</code>. Returns the number of bytes written.

</p>
<p>同步版本的<code>fs.write()</code>。返回写入的字节数。

</p>
<h2>fs.read(fd, buffer, offset, length, position, callback)<span><a href="fs.html#fs_fs_read_fd_buffer_offset_length_position_callback" id="fs_fs_read_fd_buffer_offset_length_position_callback">#</a></span></h2>
<p>Read data from the file specified by <code>fd</code>.

</p>
<p>从指定的文档标识符<code>fd</code>读取文件数据。

</p>
<p><code>buffer</code> is the buffer that the data will be written to.

</p>
<p><code>buffer</code> 是缓冲区，数据将会写入这里。

</p>
<p><code>offset</code> is the offset in the buffer to start writing at.

</p>
<p><code>offset</code> 是开始向缓冲区 <code>buffer</code> 写入的偏移量。

</p>
<p><code>length</code> is an integer specifying the number of bytes to read.

</p>
<p><code>length</code> 是一个整形值，指定了读取的字节数。

</p>
<p><code>position</code> is an integer specifying where to begin reading from in the file.
If <code>position</code> is <code>null</code>, data will be read from the current file position.

</p>
<p><code>position</code> 是一个整形值，指定了从哪里开始读取文件，如果<code>position</code>为<code>null</code>，将会从文件当前的位置读取数据。

</p>
<p>The callback is given the three arguments, <code>(err, bytesRead, buffer)</code>.

</p>
<p>回调函数给定了三个参数， <code>(err, bytesRead, buffer)</code>， 分别为错误，读取的字节和缓冲区。

</p>
<h2>fs.readSync(fd, buffer, offset, length, position)<span><a href="fs.html#fs_fs_readsync_fd_buffer_offset_length_position" id="fs_fs_readsync_fd_buffer_offset_length_position">#</a></span></h2>
<p>Synchronous version of <code>fs.read</code>. Returns the number of <code>bytesRead</code>.

</p>
<p> <code>fs.read</code> 函数的同步版本。 返回<code>bytesRead</code>的个数。

</p>
<h2>fs.readFile(filename, [options], callback)<span><a href="fs.html#fs_fs_readfile_filename_options_callback" id="fs_fs_readfile_filename_options_callback">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>null</code></li>
<li><code>flag</code> <span>String</span> default = <code>&apos;r&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>null</code></li>
<li><code>flag</code> <span>String</span> default = <code>&apos;r&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously reads the entire contents of a file. Example:

</p>
<p>异步读取一个文件的全部内容。举例：

</p>
<pre><code>fs.readFile(&apos;/etc/passwd&apos;, function (err, data) {
  if (err) throw err;
  console.log(data);
});</code></pre>
<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the
contents of the file.

</p>
<p>回调函数传递了两个参数 <code>(err, data)</code>,  <code>data</code> 就是文件的内容。

</p>
<p>If no encoding is specified, then the raw buffer is returned.

</p>
<p>如果未指定编码方式，原生buffer就会被返回。

</p>
<h2>fs.readFileSync(filename, [options])<span><a href="fs.html#fs_fs_readfilesync_filename_options" id="fs_fs_readfilesync_filename_options">#</a></span></h2>
<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.

</p>
<p> <code>fs.readFile</code>的同步版本。 返回文件名为 <code>filename</code> 的文件内容。

</p>
<p>If the <code>encoding</code> option is specified then this function returns a
string. Otherwise it returns a buffer.

</p>
<p>如果 <code>encoding</code> 选项被指定， 那么这个函数返回一个字符串。如果未指定，则返回一个原生buffer。

</p>
<h2>fs.writeFile(filename, data, [options], callback)<span><a href="fs.html#fs_fs_writefile_filename_data_options_callback" id="fs_fs_writefile_filename_data_options_callback">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;w&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;w&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously writes data to a file, replacing the file if it already exists.
<code>data</code> can be a string or a buffer.

</p>
<p>异步的将数据写入一个文件, 如果文件原先存在，会被替换。
<code>data</code> 可以是一个string，也可以是一个原生buffer。

</p>
<p>The <code>encoding</code> option is ignored if <code>data</code> is a buffer. It defaults
to <code>&apos;utf8&apos;</code>.

</p>
<p><code>encoding</code> 选项会被忽视如果 <code>data</code> 不是string而是原生buffer。<code>encoding</code>缺省为 <code>&apos;utf8&apos;</code>。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>fs.writeFile(&apos;message.txt&apos;, &apos;Hello Node&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;It\&apos;s saved!&apos;); //文件被保存
});</code></pre>
<h2>fs.writeFileSync(filename, data, [options])<span><a href="fs.html#fs_fs_writefilesync_filename_data_options" id="fs_fs_writefilesync_filename_data_options">#</a></span></h2>
<p>The synchronous version of <code>fs.writeFile</code>.

</p>
<p><code>fs.writeFile</code>的同步版本。

</p>
<h2>fs.appendFile(filename, data, [options], callback)<span><a href="fs.html#fs_fs_appendfile_filename_data_options_callback" id="fs_fs_appendfile_filename_data_options_callback">#</a></span></h2>
<div><ul>
<li><code>filename</code> <span>String</span></li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;a&apos;</code></li>
</ul>
</li>
<li><p><code>callback</code> <span>Function</span></p>
</li>
<li><p><code>filename</code> <span>String</span></p>
</li>
<li><code>data</code> <span>String | Buffer</span></li>
<li><code>options</code> <span>Object</span><ul>
<li><code>encoding</code> <span>String | Null</span> default = <code>&apos;utf8&apos;</code></li>
<li><code>mode</code> <span>Number</span> default = <code>438</code> (aka <code>0666</code> in Octal)</li>
<li><code>flag</code> <span>String</span> default = <code>&apos;a&apos;</code></li>
</ul>
</li>
<li><code>callback</code> <span>Function</span></li>
</div></ul>
<p>Asynchronously append data to a file, creating the file if it not yet exists.
<code>data</code> can be a string or a buffer.

</p>
<p>异步的将数据添加到一个文件的尾部，如果文件不存在，会创建一个新的文件。
<code>data</code> 可以是一个string，也可以是原生buffer。

</p>
<p>Example:

</p>
<p>示例：

</p>
<pre><code>fs.appendFile(&apos;message.txt&apos;, &apos;data to append&apos;, function (err) {
  if (err) throw err;
  console.log(&apos;The &quot;data to append&quot; was appended to file!&apos;); //数据被添加到文件的尾部
});</code></pre>
<h2>fs.appendFileSync(filename, data, [options])<span><a href="fs.html#fs_fs_appendfilesync_filename_data_options" id="fs_fs_appendfilesync_filename_data_options">#</a></span></h2>
<p>The synchronous version of <code>fs.appendFile</code>.

</p>
<p><code>fs.appendFile</code>的同步版本。

</p>
<h2>fs.watchFile(filename, [options], listener)<span><a href="fs.html#fs_fs_watchfile_filename_options_listener" id="fs_fs_watchfile_filename_options_listener">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定.   尽可能的话推荐使用 fs.watch 来代替。</code></pre>
<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each
time the file is accessed.

</p>
<p>监视<code>filename</code>指定的文件的改变. 回调函数 <code>listener</code> 会在文件每一次被访问时被调用。

</p>
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing two members a boolean, <code>persistent</code>, and <code>interval</code>. <code>persistent</code>
indicates whether the process should continue to run as long as files are
being watched. <code>interval</code> indicates how often the target should be polled,
in milliseconds. The default is <code>{ persistent: true, interval: 5007 }</code>.

</p>
<p>第二个参数是可选的。 如果提供此参数，<code>options</code> 应该是包含两个成员<code>persistent</code>和<code>interval</code>的对象，其中<code>persistent</code>值为boolean类型。<code>persistent</code>指定进程是否应该在文件被监视（watch）时继续运行，<code>interval</code>指定了目标文件被查询的间隔，以毫秒为单位。缺省值为<code>{ persistent: true, interval: 5007 }</code>。

</p>
<p>The <code>listener</code> gets two arguments the current stat object and the previous
stat object:

</p>
<p><code>listener</code> 有两个参数，第一个为文件现在的状态，第二个为文件的前一个状态。

</p>
<pre><code>fs.watchFile(&apos;message.text&apos;, function (curr, prev) {
  console.log(&apos;the current mtime is: &apos; + curr.mtime);
  console.log(&apos;the previous mtime was: &apos; + prev.mtime);
});</code></pre>
<p>These stat objects are instances of <code>fs.Stat</code>.

</p>
<p><code>listener</code>中的文件状态对象类型为<code>fs.Stat</code>。

</p>
<p>If you want to be notified when the file was modified, not just accessed
you need to compare <code>curr.mtime</code> and <code>prev.mtime</code>.

</p>
<p>如果你只想在文件被修改时被告知，而不是仅仅在被访问时就告知，你应当在<code>listener</code>回调函数中比较下两个状态对象的<code>mtime</code>属性。即<code>curr.mtime</code> 和 <code>prev.mtime</code>.

</p>
<h2>fs.unwatchFile(filename, [listener])<span><a href="fs.html#fs_fs_unwatchfile_filename_listener" id="fs_fs_unwatchfile_filename_listener">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定.   尽可能的话推荐使用 fs.watch 来代替。</code></pre>
<p>Stop watching for changes on <code>filename</code>. If <code>listener</code> is specified, only that
particular listener is removed. Otherwise, <em>all</em> listeners are removed and you
have effectively stopped watching <code>filename</code>.

</p>
<p>停止监视文件名为 <code>filename</code>的文件. 如果 <code>listener</code> 参数被指定, 会移除在<code>fs.watchFile</code>函数中指定的那一个listener回调函数。 否则, <em>所有的</em> 回调函数都会被移除，你将彻底停止监视<code>filename</code>文件。

</p>
<p>Calling <code>fs.unwatchFile()</code> with a filename that is not being watched is a
no-op, not an error.

</p>
<p>调用 <code>fs.unwatchFile()</code> 时，传递的文件名为未被监视的文件时，不会发生错误，而会发生一个no-op。

</p>
<h2>fs.watch(filename, [options], [listener])<span><a href="fs.html#fs_fs_watch_filename_options_listener" id="fs_fs_watch_filename_options_listener">#</a></span></h2>
<pre><code>稳定性: 2 - 不稳定的</code></pre>
<p>Watch for changes on <code>filename</code>, where <code>filename</code> is either a file or a
directory.  The returned object is a <a href="fs.html#fs_class_fs_fswatcher">fs.FSWatcher</a>.

</p>
<p>观察指定路径的改变，<code>filename</code> 路径可以是文件或者目录。改函数返回的对象是 <a href="fs.html#fs_class_fs_fswatcher">fs.FSWatcher</a>。

</p>
<p>The second argument is optional. The <code>options</code> if provided should be an object
containing a boolean member <code>persistent</code>, which indicates whether the process
should continue to run as long as files are being watched. The default is
<code>{ persistent: true }</code>.

</p>
<p>第二个参数是可选的. 如果 <code>options</code> 选项被提供那么它应当是一个只包含成员<code>persistent</code>得对象，
<code>persistent</code>为boolean类型。<code>persistent</code>指定了进程是否“只要文件被监视就继续执行”缺省值为
<code>{ persistent: true }</code>.

</p>
<p>The listener callback gets two arguments <code>(event, filename)</code>.  <code>event</code> is either
&apos;rename&apos; or &apos;change&apos;, and <code>filename</code> is the name of the file which triggered
the event.

</p>
<p>监听器的回调函数得到两个参数 <code>(event, filename)</code>。其中 <code>event</code> 是 &apos;rename&apos;（重命名）或者 &apos;change&apos;（改变），而 <code>filename</code> 则是触发事件的文件名。

</p>
<h3>注意事项<span><a href="fs.html#fs" id="fs">#</a></span></h3>
<!--type=misc-->

<p>The <code>fs.watch</code> API is not 100% consistent across platforms, and is
unavailable in some situations.

</p>
<p><code>fs.watch</code> 不是完全跨平台的，且在某些情况下不可用。

</p>
<h4>可用性<span><a href="fs.html#fs_1" id="fs_1">#</a></span></h4>
<!--type=misc-->

<p>This feature depends on the underlying operating system providing a way
to be notified of filesystem changes.

</p>
<p>此功能依赖于操作系统底层提供的方法来监视文件系统的变化。

</p>
<ul>
<li>On Linux systems, this uses <code>inotify</code>.</li>
<li>On BSD systems (including OS X), this uses <code>kqueue</code>.</li>
<li>On SunOS systems (including Solaris and SmartOS), this uses <code>event ports</code>.</li>
<li><p>On Windows systems, this feature depends on <code>ReadDirectoryChangesW</code>.</p>
</li>
<li><p>在 Linux 操作系统上，使用 <code>inotify</code>。</p>
</li>
<li>在 BSD 操作系统上 (包括 OS X)，使用 <code>kqueue</code>。</li>
<li>在 SunOS 操作系统上 (包括 Solaris 和 SmartOS)，使用 <code>event ports</code>。</li>
<li>在 Windows 操作系统上，该特性依赖于 <code>ReadDirectoryChangesW</code>。</li>
</ul>
<p>If the underlying functionality is not available for some reason, then
<code>fs.watch</code> will not be able to function.  For example, watching files or
directories on network file systems (NFS, SMB, etc.) often doesn&apos;t work
reliably or at all.

</p>
<p>如果系统底层函数出于某些原因不可用，那么 <code>fs.watch</code> 也就无法工作。例如，监视网络文件系统(如 NFS, SMB 等)的文件或者目录，就时常不能稳定的工作，有时甚至完全不起作用。

</p>
<p>You can still use <code>fs.watchFile</code>, which uses stat polling, but it is slower and
less reliable.

</p>
<p>你仍然可以调用使用了文件状态调查的 <code>fs.watchFile</code>，但是会比较慢而且比较不可靠。

</p>
<h4>文件名参数<span><a href="fs.html#fs_2" id="fs_2">#</a></span></h4>
<!--type=misc-->

<p>Providing <code>filename</code> argument in the callback is not supported
on every platform (currently it&apos;s only supported on Linux and Windows).  Even
on supported platforms <code>filename</code> is not always guaranteed to be provided.
Therefore, don&apos;t assume that <code>filename</code> argument is always provided in the
callback, and have some fallback logic if it is null.

</p>
<p>在回调函数中提供的 <code>filename</code> 参数不是在每一个操作系统中都被支持（当下仅在Linux和Windows上支持）。
即便是在支持的系统中，<code>filename</code>也不能保证在每一次回调都被提供。因此，不要假设<code>filename</code>参数总会会在
回调函数中提供，在回调函数中添加检测<code>filename</code>是否为null的if判断语句。

</p>
<pre><code>fs.watch(&apos;somedir&apos;, function (event, filename) {
  console.log(&apos;event is: &apos; + event);
  if (filename) {
    console.log(&apos;filename provided: &apos; + filename);
  } else {
    console.log(&apos;filename not provided&apos;);
  }
});</code></pre>
<h2>fs.exists(path, callback)<span><a href="fs.html#fs_fs_exists_path_callback" id="fs_fs_exists_path_callback">#</a></span></h2>
<p>Test whether or not the given path exists by checking with the file system.
Then call the <code>callback</code> argument with either true or false.  Example:

</p>
<p>检查指定路径的文件或者目录是否存在。接着通过 <code>callback</code> 传入的参数指明存在 (true) 或者不存在 (false)。示例:

</p>
<pre><code>fs.exists(&apos;/etc/passwd&apos;, function (exists) {
  util.debug(exists ? &quot;存在&quot; : &quot;不存在!&quot;);
});</code></pre>
<h2>fs.existsSync(path)<span><a href="fs.html#fs_fs_existssync_path" id="fs_fs_existssync_path">#</a></span></h2>
<p>Synchronous version of <code>fs.exists</code>.

</p>
<p><code>fs.exists</code> 函数的同步版。

</p>
<h2>Class: fs.Stats<span><a href="fs.html#fs_class_fs_stats" id="fs_class_fs_stats">#</a></span></h2>
<p>Objects returned from <code>fs.stat()</code>, <code>fs.lstat()</code> and <code>fs.fstat()</code> and their
synchronous counterparts are of this type.

</p>
<p><code>fs.stat()</code>, <code>fs.lstat()</code> 和 <code>fs.fstat()</code> 以及他们对应的同步版本返回的对象。

</p>
<ul>
<li><code>stats.isFile()</code></li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li>
<li><code>stats.isFIFO()</code></li>
<li><p><code>stats.isSocket()</code></p>
</li>
<li><p><code>stats.isFile()</code></p>
</li>
<li><code>stats.isDirectory()</code></li>
<li><code>stats.isBlockDevice()</code></li>
<li><code>stats.isCharacterDevice()</code></li>
<li><code>stats.isSymbolicLink()</code> (仅在与 <code>fs.lstat()</code>一起使用时合法)</li>
<li><code>stats.isFIFO()</code></li>
<li><code>stats.isSocket()</code></li>
</ul>
<p>For a regular file <code>util.inspect(stats)</code> would return a string very
similar to this:

</p>
<p>对于一个普通文件使用 <code>util.inspect(stats)</code> 将会返回一个类似如下输出的字符串：

</p>
<pre><code>{ dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }</code></pre>
<p>Please note that <code>atime</code>, <code>mtime</code>, <code>birthtime</code>, and <code>ctime</code> are
instances of <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> object and to compare the values of
these objects you should use appropriate methods. For most general
uses <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> will return the number of
milliseconds elapsed since <em>1 January 1970 00:00:00 UTC</em> and this
integer should be sufficient for any comparison, however there
additional methods which can be used for displaying fuzzy information.
More details can be found in the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a>
page.

</p>
<p>请注意 <code>atime</code>, <code>mtime</code>, <code>birthtime</code>, and <code>ctime</code> 是
 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">Date</a> 对象的实例。而且在比较这些对象的值时你应当使用合适的方法。
大部分情况下，使用 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date/getTime">getTime()</a> 将会返回自 <em>1 January 1970 00:00:00 UTC</em> 以来逝去的毫秒数，
而且这个整形值应该能满足任何比较的使用条件。但是仍然还有一些额外的方法可以用来显示一些模糊的信息。更多细节请查看
 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Date">MDN JavaScript Reference</a> 页面。

</p>
<h3>Stat Time Values<span><a href="fs.html#fs_stat_time_values" id="fs_stat_time_values">#</a></span></h3>
<p>The times in the stat object have the following semantics:

</p>
<p>在状态对象（stat object）中的时间有以下语义：

</p>
<ul>
<li><code>atime</code> &quot;Access Time&quot; - Time when file data last accessed.  Changed
by the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>read(2)</code> system calls.</li>
<li><code>mtime</code> &quot;Modified Time&quot; - Time when file data last modified.
Changed by the <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>write(2)</code> system calls.</li>
<li><code>ctime</code> &quot;Change Time&quot; - Time when file status was last changed
(inode data modification).  Changed by the <code>chmod(2)</code>, <code>chown(2)</code>,
<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>,
<code>read(2)</code>, and <code>write(2)</code> system calls.</li>
<li><p><code>birthtime</code> &quot;Birth Time&quot; -  Time of file creation. Set once when the
file is created.  On filesystems where birthtime is not available,
this field may instead hold either the <code>ctime</code> or
<code>1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code>0</code>).  On Darwin and
other FreeBSD variants, also set if the <code>atime</code> is explicitly set to
an earlier value than the current <code>birthtime</code> using the <code>utimes(2)</code>
system call.</p>
</li>
<li><p><code>atime</code> &quot;Access Time&quot; - 文件数据上次被访问的时间.<br>会被 <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>read(2)</code> 等系统调用改变。</p>
</li>
<li><code>mtime</code> &quot;Modified Time&quot; - 文件上次被修改的时间。
会被 <code>mknod(2)</code>, <code>utimes(2)</code>, and <code>write(2)</code> 等系统调用改变。</li>
<li><code>ctime</code> &quot;Change Time&quot; - 文件状态上次改变的时间。
(inode data modification).  会被 <code>chmod(2)</code>, <code>chown(2)</code>,
<code>link(2)</code>, <code>mknod(2)</code>, <code>rename(2)</code>, <code>unlink(2)</code>, <code>utimes(2)</code>,
<code>read(2)</code>, and <code>write(2)</code> 等系统调用改变。</li>
<li><code>birthtime</code> &quot;Birth Time&quot; -  文件被创建的时间。 会在文件被创建时生成。
在一些不提供文件<code>birthtime</code>的文件系统中,
这个字段会被 <code>ctime</code> 或
<code>1970-01-01T00:00Z</code> (ie, unix epoch timestamp <code>0</code>)来填充。  在 Darwin 和其他
 FreeBSD 系统变体中, 也将 <code>atime</code> 显式地设置成比它现在的 <code>birthtime</code> 更早的一个时间值，这个过程使用了<code>utimes(2)</code>系统调用。</li>
</ul>
<p>Prior to Node v0.12, the <code>ctime</code> held the <code>birthtime</code> on Windows
systems.  Note that as of v0.12, <code>ctime</code> is not &quot;creation time&quot;, and
on Unix systems, it never was.

</p>
<p>在Node v0.12版本之前, <code>ctime</code> 持有Windows系统的 <code>birthtime</code> 值. 注意在v.0.12版本中, <code>ctime</code> 不再是&quot;creation time&quot;, 而且在Unix系统中，他从来都不是。

</p>
<h2>fs.createReadStream(path, [options])<span><a href="fs.html#fs_fs_createreadstream_path_options" id="fs_fs_createreadstream_path_options">#</a></span></h2>
<p>Returns a new ReadStream object (See <code>Readable Stream</code>).

</p>
<p>返回一个新的 ReadStream 对象 (详见 <code>Readable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ flags: &apos;r&apos;,
  encoding: null,
  fd: null,
  mode: 0666,
  autoClose: true
}</code></pre>
<p><code>options</code> can include <code>start</code> and <code>end</code> values to read a range of bytes from
the file instead of the entire file.  Both <code>start</code> and <code>end</code> are inclusive and
start at 0. The <code>encoding</code> can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code>, or <code>&apos;base64&apos;</code>.

</p>
<p><code>options</code> 可以提供 <code>start</code> 和 <code>end</code> 值用于读取文件内的特定范围而非整个文件。
<code>start</code> 和 <code>end</code> 都是包含在范围内的（inclusive, 可理解为闭区间）并且以 0 开始。
<code>encoding</code> 可选为 <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> 或者 <code>&apos;base64&apos;</code>。

</p>
<p>If <code>autoClose</code> is false, then the file descriptor won&apos;t be closed, even if
there&apos;s an error.  It is your responsibility to close it and make sure
there&apos;s no file descriptor leak.  If <code>autoClose</code> is set to true (default
behavior), on <code>error</code> or <code>end</code> the file descriptor will be closed
automatically.

</p>
<p>如果 <code>autoClose</code> 为 false 则即使在发生错误时也不会关闭文件描述符 (file descriptor)。
此时你需要负责关闭文件，避免文件描述符泄露 (leak)。
如果 <code>autoClose</code> 为 true （缺省值），
当发生 <code>error</code> 或者 <code>end</code> 事件时，文件描述符会被自动释放。

</p>
<p>An example to read the last 10 bytes of a file which is 100 bytes long:

</p>
<p>一个从100字节的文件中读取最后10字节的例子：

</p>
<pre><code>fs.createReadStream(&apos;sample.txt&apos;, {start: 90, end: 99});</code></pre>
<h2>Class: fs.ReadStream<span><a href="fs.html#fs_class_fs_readstream" id="fs_class_fs_readstream">#</a></span></h2>
<p><code>ReadStream</code> is a <a href="stream.html#stream_class_stream_readable">Readable Stream</a>.

</p>
<p><code>ReadStream</code> 是一个可读的流<a href="stream.html#stream_class_stream_readable">(Readable Stream)</a>.

</p>
<h3>事件: &apos;open&apos;<span><a href="fs.html#fs_open" id="fs_open">#</a></span></h3>
<div><ul>
<li><p><code>fd</code> <span>Integer</span> file descriptor used by the ReadStream.</p>
</li>
<li><p><code>fd</code> <span>整形</span> ReadStream 所使用的文件描述符。</p>
</li>
</div></ul>
<p>Emitted when the ReadStream&apos;s file is opened.

</p>
<p>当文件的 ReadStream 被创建时触发。

</p>
<h2>fs.createWriteStream(path, [options])<span><a href="fs.html#fs_fs_createwritestream_path_options" id="fs_fs_createwritestream_path_options">#</a></span></h2>
<p>Returns a new WriteStream object (See <code>Writable Stream</code>).

</p>
<p>返回一个新的 WriteStream 对象 (详见 <code>Writable Stream</code>).

</p>
<p><code>options</code> is an object with the following defaults:

</p>
<p><code>options</code> 是一个包含下列缺省值的对象：

</p>
<pre><code>{ flags: &apos;w&apos;,
  encoding: null,
  mode: 0666 }</code></pre>
<p><code>options</code> may also include a <code>start</code> option to allow writing data at
some position past the beginning of the file.  Modifying a file rather
than replacing it may require a <code>flags</code> mode of <code>r+</code> rather than the
default mode <code>w</code>.

</p>
<p><code>options</code> 也可以包含一个 <code>start</code> 选项用于指定在文件中开始写入数据的位置。
修改而不替换文件需要 <code>flags</code> 的模式指定为 <code>r+</code> 而不是默值的 <code>w</code>.

</p>
<h2>Class: fs.WriteStream<span><a href="fs.html#fs_class_fs_writestream" id="fs_class_fs_writestream">#</a></span></h2>
<p><code>WriteStream</code> is a <a href="stream.html#stream_class_stream_writable">Writable Stream</a>.

</p>
<p><code>WriteStream</code> 是一个可写的流<a href="stream.html#stream_class_stream_writable">(Writable Stream)</a>.

</p>
<h3>事件: &apos;open&apos;<span><a href="fs.html#fs_open_1" id="fs_open_1">#</a></span></h3>
<div><ul>
<li><p><code>fd</code> <span>Integer</span> file descriptor used by the WriteStream.</p>
</li>
<li><p><code>fd</code> <span>整形</span> WriteStream 所使用的文件描述符。</p>
</li>
</div></ul>
<p>Emitted when the WriteStream&apos;s file is opened.

</p>
<p>当 WriteStream 创建时触发。

</p>
<h3>file.bytesWritten<span><a href="fs.html#fs_file_byteswritten" id="fs_file_byteswritten">#</a></span></h3>
<p>The number of bytes written so far. Does not include data that is still queued
for writing.

</p>
<p>已写的字节数。不包含仍在队列中准备写入的数据。

</p>
<h2>Class: fs.FSWatcher<span><a href="fs.html#fs_class_fs_fswatcher" id="fs_class_fs_fswatcher">#</a></span></h2>
<p>Objects returned from <code>fs.watch()</code> are of this type.

</p>
<p><code>fs.watch()</code> 返回的对象类型。

</p>
<h3>watcher.close()<span><a href="fs.html#fs_watcher_close" id="fs_watcher_close">#</a></span></h3>
<p>Stop watching for changes on the given <code>fs.FSWatcher</code>.

</p>
<p>停止观察 <code>fs.FSWatcher</code> 对象中的更改。

</p>
<h3>事件: &apos;change&apos;<span><a href="fs.html#fs_change" id="fs_change">#</a></span></h3>
<div><ul>
<li><code>event</code> <span>String</span> The type of fs change</li>
<li><p><code>filename</code> <span>String</span> The filename that changed (if relevant/available)</p>
</li>
<li><p><code>event</code> <span>字符串</span> fs 改变的类型</p>
</li>
<li><code>filename</code> <span>字符串</span> 改变的文件名 (if relevant/available)</li>
</div></ul>
<p>Emitted when something changes in a watched directory or file.
See more details in <a href="fs.html#fs_fs_watch_filename_options_listener">fs.watch</a>.

</p>
<p>当正在观察的目录或文件发生变动时触发。更多细节，详见 <a href="fs.html#fs_fs_watch_filename_options_listener">fs.watch</a>。

</p>
<h3>事件: &apos;error&apos;<span><a href="fs.html#fs_error" id="fs_error">#</a></span></h3>
<div><ul>
<li><p><code>error</code> <span>Error object</span></p>
</li>
<li><p><code>error</code> <span>Error 对象</span></p>
</li>
</div></ul>
<p>Emitted when an error occurs.


</p>
<p>当产生错误时触发</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://joyent.com" class="joyent-logo">Joyent</a>
        <ul class="clearfix">
            <li><a href="http://nodejs.org/">Node.js</a></li>
            <li><a href="http://nodejs.org/download/">Download</a></li>
            <li><a href="http://nodejs.org/about/">About</a></li>
            <li><a href="http://npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="http://nodejs.org/community/">Community</a></li>
            <li><a href="http://nodejs.org/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="http://jixiangac.com/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.10.18/LICENSE">license</a>.</p>
    </div>

  <script src="public/api_assets/sh_main.js"></script>
  <script src="public/api_assets/sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <!--
  <script>
    window._gaq = [['_setAccount', 'UA-10874194-2'], ['_trackPageview']];
    (function(d, t) {
      var g = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      g.src = '//www.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g, s);
    }(document, 'script'));
  </script>
  -->
</body>
</html>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26599868-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>