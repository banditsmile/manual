{
  "source": "crypto.markdown",
  "modules": [
    {
      "textRaw": "加密（Crypto）",
      "name": "加密（crypto）",
      "desc": "<pre><code>稳定度: 2 - 不稳定；正在讨论未来版本的API变动。会尽量减少重大变动的发生。详见下文。</code></pre>\n<p>Use <code>require(&apos;crypto&apos;)</code> to access this module.\n\n</p>\n<p>使用 <code>require(&apos;crypto&apos;)</code> 来调用该模块。\n\n</p>\n<p>The crypto module offers a way of encapsulating secure credentials to be\nused as part of a secure HTTPS net or http connection.\n\n</p>\n<p>crypto模块提供在HTTPS或HTTP连接中封装安全凭证的方法.\n\n</p>\n<p>It also offers a set of wrappers for OpenSSL&apos;s hash, hmac, cipher,\ndecipher, sign and verify methods.\n\n</p>\n<p>它提供OpenSSL中的一系列哈希方法，包括hmac、cipher、decipher、签名和验证等方法的封装。\n\n</p>\n",
      "methods": [
        {
          "textRaw": "crypto.getCiphers()",
          "type": "method",
          "name": "getCiphers",
          "desc": "<p>Returns an array with the names of the supported ciphers.\n\n</p>\n<p>返回一个数组，包含支持的加密算法的名字。\n\n</p>\n<p>Example:\n\n</p>\n<p>示例：\n\n</p>\n<pre><code>var ciphers = crypto.getCiphers();\nconsole.log(ciphers); // [&apos;AES-128-CBC&apos;, &apos;AES-128-CBC-HMAC-SHA1&apos;, ...]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "crypto.getHashes()",
          "type": "method",
          "name": "getHashes",
          "desc": "<p>Returns an array with the names of the supported hash algorithms.\n\n</p>\n<p>返回一个包含所支持的哈希算法的数组。\n\n</p>\n<p>Example:\n\n</p>\n<p>示例：\n\n</p>\n<pre><code>var hashes = crypto.getHashes();\nconsole.log(hashes); // [&apos;sha&apos;, &apos;sha1&apos;, &apos;sha1WithRSAEncryption&apos;, ...]</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "crypto.createCredentials(details)",
          "type": "method",
          "name": "createCredentials",
          "desc": "<p>Creates a credentials object, with the optional details being a\ndictionary with keys:\n\n</p>\n<p>创建一个加密凭证对象，接受一个可选的参数对象：\n\n</p>\n<ul>\n<li><code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private\nkey, certificate and CA certificates</li>\n<li><code>key</code> : A string holding the PEM encoded private key</li>\n<li><code>passphrase</code> : A string of passphrase for the private key or pfx</li>\n<li><code>cert</code> : A string holding the PEM encoded certificate</li>\n<li><code>ca</code> : Either a string or list of strings of PEM encoded CA\ncertificates to trust.</li>\n<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs\n(Certificate Revocation List)</li>\n<li><p><code>ciphers</code>: A string describing the ciphers to use or exclude.\nConsult\n<a href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>\nfor details on the format.</p>\n</li>\n<li><p><code>pfx</code> : 一个字符串或者buffer对象，代表经PFX或者PKCS12编码产生的私钥、证书以及CA证书</p>\n</li>\n<li><code>key</code> : 一个字符串，代表经PEM编码产生的私钥</li>\n<li><code>passphrase</code> : 私钥或者pfx的密码</li>\n<li><code>cert</code> : 一个字符串，代表经PEM编码产生的证书</li>\n<li><code>ca</code> : 一个字符串或者字符串数组，表示可信任的经PEM编码产生的CA证书列表</li>\n<li><code>crl</code> : 一个字符串或者字符串数组，表示经PEM编码产生的CRL（证书吊销列表 Certificate Revocation List）</li>\n<li><code>ciphers</code>: 一个字符串，表示需要使用或者排除的加密算法\n可以在\n<a href=\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>\n查看更多关于加密算法格式的资料。</li>\n</ul>\n<p>If no &apos;ca&apos; details are given, then node.js will use the default\npublicly trusted list of CAs as given in\n</p>\n<p><a href=\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.\n\n</p>\n<p>如果没有指定<code>ca</code>，node.js会使用<a href=\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>提供的公共可信任的CA列表。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "details"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHash(algorithm)",
          "type": "method",
          "name": "createHash",
          "desc": "<p>Creates and returns a hash object, a cryptographic hash with the given\nalgorithm which can be used to generate hash digests.\n\n</p>\n<p>创建并返回一个哈希对象，一个使用所给算法的用于生成摘要的加密哈希。\n\n</p>\n<p><code>algorithm</code> is dependent on the available algorithms supported by the\nversion of OpenSSL on the platform. Examples are <code>&apos;sha1&apos;</code>, <code>&apos;md5&apos;</code>,\n<code>&apos;sha256&apos;</code>, <code>&apos;sha512&apos;</code>, etc.  On recent releases, <code>openssl\nlist-message-digest-algorithms</code> will display the available digest\nalgorithms.\n\n</p>\n<p><code>algorithm</code> 取决与平台上所安装的 OpenSSL 版本所支持的算法。比如 <code>&apos;sha1&apos;</code>、<code>&apos;md5&apos;</code>、<code>&apos;sha256&apos;</code>、<code>&apos;sha512&apos;</code> 等等。在最近的发行版本中，<code>openssl list-message-digest-algorithms</code> 会显示可用的摘要算法。\n\n</p>\n<p>Example: this program that takes the sha1 sum of a file\n\n</p>\n<p>例子：这段程序会计算出一个文件的 sha1 摘要值。\n\n</p>\n<pre><code>s.on(&apos;end&apos;, function() {\n  var d = shasum.digest(&apos;hex&apos;);\n  console.log(d + &apos;  &apos; + filename);\n});</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createHmac(algorithm, key)",
          "type": "method",
          "name": "createHmac",
          "desc": "<p>Creates and returns a hmac object, a cryptographic hmac with the given\nalgorithm and key.\n\n</p>\n<p>创建并返回一个hmac对象，也就是通过给定的加密算法和密钥生成的加密图谱（cryptographic）。\n\n</p>\n<p>It is a <a href=\"stream.html\">stream</a> that is both readable and writable.  The\nwritten data is used to compute the hmac.  Once the writable side of\nthe stream is ended, use the <code>read()</code> method to get the computed\ndigest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.\n\n</p>\n<p>它是一个既可读又可写的流（<a href=\"stream.html\">stream</a>）。写入的数据会被用于计算hmac。写入终止后，可以使用<code>read()</code>方法获取计算后的摘要值。之前版本的<code>update</code>和<code>digest</code>方法仍然支持。\n\n</p>\n<p><code>algorithm</code> is dependent on the available algorithms supported by\nOpenSSL - see createHash above.  <code>key</code> is the hmac key to be used.\n\n</p>\n<p><code>algorithm</code>在OpenSSL支持的算法列表中被抛弃了——见上方createHash部分。<code>key</code>是hmac算法用到的密钥。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipher(algorithm, password)",
          "type": "method",
          "name": "createCipher",
          "desc": "<p>Creates and returns a cipher object, with the given algorithm and\npassword.\n\n</p>\n<p>用给定的算法和密码，创建并返回一个cipher加密算法的对象。（译者：cipher 就是加密算法的意思， ssl 的 cipher 主要是对称加密算法和不对称加密算法的组合。）\n\n</p>\n<p><code>algorithm</code> is dependent on OpenSSL, examples are <code>&apos;aes192&apos;</code>, etc.  On\nrecent releases, <code>openssl list-cipher-algorithms</code> will display the\navailable cipher algorithms.  <code>password</code> is used to derive key and IV,\nwhich must be a <code>&apos;binary&apos;</code> encoded string or a <a href=\"buffer.html\">buffer</a>.\n\n</p>\n<p><code>algorithm</code>算法是依赖OpenSSL库的, 例如: <code>&apos;aes192&apos;</code>算法等。在最近发布的版本， 执行命令 <code>openssl list-cipher-algorithms</code> 就会显示出所有可用的加密算法，<code>password</code>是用来派生key和IV的，它必须是一个 <code>&apos;binary&apos;</code> 2进制格式的字符串或者是一个<a href=\"buffer.html\">buffer</a>。（译者：key表示密钥，IV表示向量在加密过程和解密过程都要使用）\n\n</p>\n<p>It is a <a href=\"stream.html\">stream</a> that is both readable and writable.  The\nwritten data is used to compute the hash.  Once the writable side of\nthe stream is ended, use the <code>read()</code> method to get the computed hash\ndigest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.\n\n</p>\n<p>它是一个既可读又可写的<a href=\"stream.html\">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createCipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createCipheriv",
          "desc": "<p>Creates and returns a cipher object, with the given algorithm, key and\niv.\n\n</p>\n<p>用给定的算法、密码和向量，创建并返回一个cipher加密算法的对象。\n\n</p>\n<p><code>algorithm</code> is the same as the argument to <code>createCipher()</code>.  <code>key</code> is\nthe raw key used by the algorithm.  <code>iv</code> is an <a href=\"http://en.wikipedia.org/wiki/Initialization_vector\">initialization\nvector</a>.\n\n</p>\n<p><code>algorithm</code>算法和<code>createCipher()</code> 方法的参数相同.  <code>key</code>密钥是一个被算法使用的原始密钥，<code>iv</code>是一个<a href=\"http://en.wikipedia.org/wiki/Initialization_vector\">初始化向量</a>。\n\n</p>\n<p><code>key</code> and <code>iv</code> must be <code>&apos;binary&apos;</code> encoded strings or\n<a href=\"buffer.html\">buffers</a>.\n\n</p>\n<p><code>key</code>密钥和<code>iv</code>向量必须是<code>&apos;binary&apos;</code>2进制格式的字符串或<a href=\"buffer.html\">buffers</a>.\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipher(algorithm, password)",
          "type": "method",
          "name": "createDecipher",
          "desc": "<p>Creates and returns a decipher object, with the given algorithm and\nkey.  This is the mirror of the [createCipher()][] above.\n\n</p>\n<p>根据给定的算法和密钥，创建并返回一个解密器对象。这是上述[createCipher()][]的一个镜像。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "password"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDecipheriv(algorithm, key, iv)",
          "type": "method",
          "name": "createDecipheriv",
          "desc": "<p>Creates and returns a decipher object, with the given algorithm, key\nand iv.  This is the mirror of the [createCipheriv()][] above.\n\n</p>\n<p>Creates and returns a decipher object, with the given algorithm, key\nand iv.  This is the mirror of the [createCipheriv()][] above.\n根据给定的算法，密钥和初始化向量，创建并返回一个解密器对象。这是上述[createCipheriv()][]的一个镜像。\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                },
                {
                  "name": "key"
                },
                {
                  "name": "iv"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createSign(algorithm)",
          "type": "method",
          "name": "createSign",
          "desc": "<p>Creates and returns a signing object, with the given algorithm.  On\nrecent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will\ndisplay the available signing algorithms. Examples are <code>&apos;RSA-SHA256&apos;</code>.\n\n</p>\n<p>根据给定的算法，创建并返回一个signing对象。在最近的OpenSSL发布版本中，<code>openssl list-public-key-algorithms</code>会列出可用的签名算法，例如<code>&apos;RSA-SHA256&apos;</code>。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createVerify(algorithm)",
          "type": "method",
          "name": "createVerify",
          "desc": "<p>Creates and returns a verification object, with the given algorithm.\nThis is the mirror of the signing object above.\n\n</p>\n<p>根据指明的算法，创建并返回一个验证器对象。这是上述签名器对象的镜像。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "algorithm"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime_length)",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<p>Creates a Diffie-Hellman key exchange object and generates a prime of\nthe given bit length. The generator used is <code>2</code>.\n\n</p>\n<p>创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象，并根据给定的位长度生成一个质数。所用的生成器是<code>s</code>。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime_length"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.createDiffieHellman(prime, [encoding])",
          "type": "method",
          "name": "createDiffieHellman",
          "desc": "<p>Creates a Diffie-Hellman key exchange object using the supplied prime.\nThe generator used is <code>2</code>. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or\n<code>&apos;base64&apos;</code>.  If no encoding is specified, then a buffer is expected.\n\n</p>\n<p>根据给定的质数创建一个迪菲－赫尔曼密钥交换(Diffie-Hellman key exchange)对象。\n所用的生成器是<code>2</code>。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或\n<code>&apos;base64&apos;</code>。如果没有指明编码方式，则默认是一个buffer对象。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "prime"
                },
                {
                  "name": "encoding",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.getDiffieHellman(group_name)",
          "type": "method",
          "name": "getDiffieHellman",
          "desc": "<p>Creates a predefined Diffie-Hellman key exchange object.  The\nsupported groups are: <code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code> (defined in [RFC\n2412][]) and <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>,\n<code>&apos;modp18&apos;</code> (defined in [RFC 3526][]).  The returned object mimics the\ninterface of objects created by [crypto.createDiffieHellman()][]\nabove, but will not allow to change the keys (with\n[diffieHellman.setPublicKey()][] for example).  The advantage of using\nthis routine is that the parties don&apos;t have to generate nor exchange\ngroup modulus beforehand, saving both processor and communication\ntime.\n\n</p>\n<p>创建一个预定义的迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)对象。支持以下的D-H组：<code>&apos;modp1&apos;</code>, <code>&apos;modp2&apos;</code>, <code>&apos;modp5&apos;</code> (在[RFC\n2412][]中定义) 和 <code>&apos;modp14&apos;</code>, <code>&apos;modp15&apos;</code>, <code>&apos;modp16&apos;</code>, <code>&apos;modp17&apos;</code>,\n<code>&apos;modp18&apos;</code> (在 [RFC 3526][]中定义)。返回的对象模仿了上述 [crypto.createDiffieHellman()][]方法所创建的对象的接口，但不会晕允许密钥交换\n(例如像\n[diffieHellman.setPublicKey()][]那样)。执行这套流程的好处是双方不需要事先生成或交换组余数，节省了处理和通信时间。\n\n</p>\n<p>Example (obtaining a shared secret):\n\n</p>\n<p>例子 (获取一个共享秘密):\n\n</p>\n<pre><code>/* alice_secret和 bob_secret应该是一样的 */\nconsole.log(alice_secret == bob_secret);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "group_name"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2(password, salt, iterations, keylen, callback)",
          "type": "method",
          "name": "pbkdf2",
          "desc": "<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive\na key of given length from the given password, salt and iterations.\nThe callback gets two arguments <code>(err, derivedKey)</code>.\n\n</p>\n<p>异步PBKDF2提供了一个伪随机函数 HMAC-SHA1，根据给定密码的长度，salt和iterations来得出一个密钥。回调函数得到两个参数 <code>(err, derivedKey)</code>。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                },
                {
                  "name": "callback"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pbkdf2Sync(password, salt, iterations, keylen)",
          "type": "method",
          "name": "pbkdf2Sync",
          "desc": "<p>Synchronous PBKDF2 function.  Returns derivedKey or throws error.\n\n</p>\n<p>同步 PBKDF2 函数。返回derivedKey或抛出一个错误。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "password"
                },
                {
                  "name": "salt"
                },
                {
                  "name": "iterations"
                },
                {
                  "name": "keylen"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.randomBytes(size, [callback])",
          "type": "method",
          "name": "randomBytes",
          "desc": "<p>Generates cryptographically strong pseudo-random data. Usage:\n\n</p>\n<p>生成密码学强度的伪随机数据。用法：\n\n</p>\n<pre><code>// 同步\ntry {\n  var buf = crypto.randomBytes(256);\n  console.log(&apos;有 %d 字节的随机数据： %s&apos;, buf.length, buf);\n} catch (ex) {\n  // handle error\n}</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "crypto.pseudoRandomBytes(size, [callback])",
          "type": "method",
          "name": "pseudoRandomBytes",
          "desc": "<p>Generates <em>non</em>-cryptographically strong pseudo-random data. The data\nreturned will be unique if it is sufficiently long, but is not\nnecessarily unpredictable. For this reason, the output of this\nfunction should never be used where unpredictability is important,\nsuch as in the generation of encryption keys.\n\n</p>\n<p>生成<em>非</em>密码学强度的伪随机数据。如果数据足够长的话会返回一个唯一的数据，但这个返回值不一定是不可预料的。基于这个原因，当不可预料性很重要时，这个函数的返回值永远都不应该被使用，例如在生成加密的密钥时。\n\n</p>\n<p>Usage is otherwise identical to <code>crypto.randomBytes</code>.\n\n</p>\n<p>用法与 <code>crypto.randomBytes</code>一模一样。\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "size"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        }
      ],
      "modules": [
        {
          "textRaw": "类: Hash",
          "name": "类:_hash",
          "desc": "<p>The class for creating hash digests of data.\n\n</p>\n<p>创建数据哈希摘要的类。\n\n</p>\n<p>It is a <a href=\"stream.html\">stream</a> that is both readable and writable.  The\nwritten data is used to compute the hash.  Once the writable side of\nthe stream is ended, use the <code>read()</code> method to get the computed hash\ndigest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.\n\n</p>\n<p>它是一个既可读又可写的<a href=\"stream.html\">流</a>。所写入的数据会被用作计算哈希。当流的可写端终止后，使用 <code>read()</code> 方法来获取计算得的哈希摘要。同时也支持旧有的 <code>update</code> 和 <code>digest</code> 方法。\n\n</p>\n<p>Returned by <code>crypto.createHash</code>.\n\n</p>\n<p>通过 <code>crypto.createHash</code> 返回。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hash.update(data, [input_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the hash content with the given <code>data</code>, the encoding of which\nis given in <code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or\n<code>&apos;binary&apos;</code>.  If no encoding is provided, then a buffer is expected.\n\n</p>\n<p>通过提供的数据更新哈希对象，可以通过<code>input_encoding</code>指定编码为<code>&apos;utf8&apos;</code>、<code>&apos;ascii&apos;</code>或者\n<code>&apos;binary&apos;</code>。如果没有指定编码，将作为二进制数据（buffer）处理。\n\n</p>\n<p>This can be called many times with new data as it is streamed.\n\n</p>\n<p>因为它是流式数据，所以可以使用不同的数据调用很多次。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hash.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<p>Calculates the digest of all of the passed data to be hashed.  The\n<code>encoding</code> can be <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> or <code>&apos;base64&apos;</code>.  If no encoding\nis provided, then a buffer is returned.\n\n</p>\n<p>计算传入的所有数据的摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。\n\n</p>\n<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method has been\ncalled.\n\n</p>\n<p>注意：<code>hash</code> 对象在 <code>digest()</code> 方法被调用后将不可用。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ],
          "type": "module",
          "displayName": "类: Hash"
        },
        {
          "textRaw": "Recent API Changes",
          "name": "recent_api_changes",
          "desc": "<p>The Crypto module was added to Node before there was the concept of a\nunified Stream API, and before there were Buffer objects for handling\nbinary data.\n\n</p>\n<p>早在统一的流API概念出现，以及引入Buffer对象来处理二进制数据之前，Crypto模块就被添加到Node。\n\n</p>\n<p>As such, the streaming classes don&apos;t have the typical methods found on\nother Node classes, and many methods accepted and returned\nBinary-encoded strings by default rather than Buffers.  This was\nchanged to use Buffers by default instead.\n\n</p>\n<p>因为这样，与流有关的类中并没有其它Node类的典型函数，而且很多函数接受和返回默认的二进制编码的字符串，而不是Buffer对象。在最近的修改中，这些函数都被改成默认使用Buffer对象。\n\n</p>\n<p>This is a breaking change for some use cases, but not all.\n\n</p>\n<p>这对于某些(但不是全部)使用场景来讲是重大的改变。\n\n</p>\n<p>For example, if you currently use the default arguments to the Sign\nclass, and then pass the results to the Verify class, without ever\ninspecting the data, then it will continue to work as before.  Where\nyou once got a binary string and then presented the binary string to\nthe Verify object, you&apos;ll now get a Buffer, and present the Buffer to\nthe Verify object.\n\n</p>\n<p>例如，如果你现在使用Sign类的默认参数，然后在没有检查数据的情况下，将结果传递给Verify类，那么程序会照常工作。在以前，你会拿到一个二进制字符串，然后它传递给Verify对象；而现在，你会得到一个Buffer对象，然后把它传递给Verify对象。\n\n</p>\n<p>However, if you were doing things with the string data that will not\nwork properly on Buffers (such as, concatenating them, storing in\ndatabases, etc.), or you are passing binary strings to the crypto\nfunctions without an encoding argument, then you will need to start\nproviding encoding arguments to specify which encoding you&apos;d like to\nuse.  To switch to the previous style of using binary strings by\ndefault, set the <code>crypto.DEFAULT_ENCODING</code> field to &apos;binary&apos;.  Note\nthat new programs will probably expect buffers, so only use this as a\ntemporary measure.\n\n</p>\n<p>但是，如果你以前是使用那些在Buffer对象上不能正常工作的字符串数据，或者以默认编码方式将二进制数据传递给加密函数的话，那你就要开始提供编码方式参数来指明你想使用的编码方式了。如果想准换回旧的风格默认使用二进制字符串，那么你需要把<code>crypto.DEFAULT_ENCODING</code>字段设为&apos;binary&apos;。但请注意，因为新的程序很可能会期望buffer对象，所以仅将此当做临时手段。\n\n</p>\n",
          "type": "module",
          "displayName": "Recent API Changes"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: Hmac",
          "type": "class",
          "name": "Hmac",
          "desc": "<p>Class for creating cryptographic hmac content.\n\n</p>\n<p>用于创建hmac加密图谱（cryptographic）的类。\n\n</p>\n<p>Returned by <code>crypto.createHmac</code>.\n\n</p>\n<p>由<code>crypto.createHmac</code>返回。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "hmac.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<p>Update the hmac content with the given <code>data</code>.  This can be called\nmany times with new data as it is streamed.\n\n</p>\n<p>通过提供的数据更新hmac对象。因为它是流式数据，所以可以使用新数据调用很多次。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "hmac.digest([encoding])",
              "type": "method",
              "name": "digest",
              "desc": "<p>Calculates the digest of all of the passed data to the hmac.  The\n<code>encoding</code> can be <code>&apos;hex&apos;</code>, <code>&apos;binary&apos;</code> or <code>&apos;base64&apos;</code>.  If no encoding\nis provided, then a buffer is returned.\n\n</p>\n<p>计算传入的所有数据的hmac摘要值。<code>encoding</code>可以是<code>&apos;hex&apos;</code>、<code>&apos;binary&apos;</code>或者<code>&apos;base64&apos;</code>，如果没有指定，会返回一个buffer对象。\n\n</p>\n<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method has been\ncalled.\n\n</p>\n<p>注意： <code>hmac</code>对象在调用<code>digest()</code>之后就不再可用了。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Cipher",
          "type": "class",
          "name": "Cipher",
          "desc": "<p>Class for encrypting data.\n\n</p>\n<p>这个类是用来加密数据的。\n\n</p>\n<p>Returned by <code>crypto.createCipher</code> and <code>crypto.createCipheriv</code>.\n\n</p>\n<p>这个类由 <code>crypto.createCipher</code> 和 <code>crypto.createCipheriv</code> 返回。\n\n</p>\n<p>Cipher objects are <a href=\"stream.html\">streams</a> that are both readable and\nwritable.  The written plain text data is used to produce the\nencrypted data on the readable side.  The legacy <code>update</code> and <code>final</code>\nmethods are also supported.\n\n</p>\n<p>Cipher加密对象是 <a href=\"stream.html\">streams</a>，他是具有 readable 可读和 writable 可写的。写入的纯文本数据是用来在可读流一侧加密数据的。\n以前版本的<code>update</code> 和<code>final</code>方法也还是支持的。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "cipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the cipher with <code>data</code>, the encoding of which is given in\n<code>input_encoding</code> and can be <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code>.  If no\nencoding is provided, then a buffer is expected.\n\n</p>\n<p>用<code>data</code>参数更新cipher加密对象, 它的编码<code>input_encoding</code>必须是下列给定编码的 <code>&apos;utf8&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;binary&apos;</code> 中一种。如果没有编码参数，那么打他参数必须是一个buffer。\n\n</p>\n<p>The <code>output_encoding</code> specifies the output format of the enciphered\ndata, and can be <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is\nprovided, then a buffer is returned.\n\n</p>\n<p>参数 <code>output_encoding</code>输出编码指定了加密数据的输出格式，可以是<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或者<code>&apos;hex&apos;</code>，如果没有提供这个参数，buffer将会返回。\n\n</p>\n<p>Returns the enciphered contents, and can be called many times with new\ndata as it is streamed.\n\n</p>\n<p>返回加密内容，并且Returns the enciphered contents, 用新数据作为流的话，它可以被调用多次。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<p>Returns any remaining enciphered contents, with <code>output_encoding</code>\nbeing one of: <code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is\nprovided, then a buffer is returned.\n\n</p>\n<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>中的任意一个。 如果没有提供编码格式，则返回一个buffer对象。\n\n</p>\n<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method has been\ncalled.\n\n</p>\n<p>注: 调用<code>final()</code>函数后<code>cipher</code> 对象不能被使用。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "cipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<p>You can disable automatic padding of the input data to block size. If\n<code>auto_padding</code> is false, the length of the entire input data must be a\nmultiple of the cipher&apos;s block size or <code>final</code> will fail.  Useful for\nnon-standard padding, e.g. using <code>0x0</code> instead of PKCS padding. You\nmust call this before <code>cipher.final</code>.\n\n</p>\n<p>对于将输入数据自动填充到块大小的功能，你可以将其禁用。如果<code>auto_padding</code>是false， 那么整个输入数据的长度必须是加密器的块大小的整倍数，否则<code>final</code>会失败。这对非标准的填充很有用，例如使用<code>0x0</code>而不是PKCS的填充。这个函数必须在<code>cipher.final</code>之前调用。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Decipher",
          "type": "class",
          "name": "Decipher",
          "desc": "<p>Class for decrypting data.\n\n</p>\n<p>解密数据的类。\n\n</p>\n<p>Returned by <code>crypto.createDecipher</code> and <code>crypto.createDecipheriv</code>.\n\n</p>\n<p>由<code>crypto.createDecipher</code>和<code>crypto.createDecipheriv</code>返回。\n\n</p>\n<p>Decipher objects are <a href=\"stream.html\">streams</a> that are both readable and\nwritable.  The written enciphered data is used to produce the\nplain-text data on the the readable side.  The legacy <code>update</code> and\n<code>final</code> methods are also supported.\n\n</p>\n<p>解密器对象是可读写的<a href=\"stream.html\">流</a>对象。用被写入的加密数据生成可读的平文数据。解码器对象也支持The legacy <code>update</code>和\n<code>final</code>函数。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "decipher.update(data, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the decipher with <code>data</code>, which is encoded in <code>&apos;binary&apos;</code>,\n<code>&apos;base64&apos;</code> or <code>&apos;hex&apos;</code>.  If no encoding is provided, then a buffer is\nexpected.\n\n</p>\n<p>用<code>data</code>来更新解密器，其中<code>data</code>以<code>&apos;binary&apos;</code>,\n<code>&apos;base64&apos;</code> 或 <code>&apos;hex&apos;</code>进行编码。如果没有指明编码方式，则默认<code>data</code>是一个buffer对象。\n\n</p>\n<p>The <code>output_decoding</code> specifies in what format to return the\ndeciphered plaintext: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>.  If no\nencoding is provided, then a buffer is returned.\n\n</p>\n<p><code>output_decoding</code>指明了用以下哪种编码方式返回解密后的平文：<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.final([output_encoding])",
              "type": "method",
              "name": "final",
              "desc": "<p>Returns any remaining plaintext which is deciphered, with\n<code>output_encoding</code> being one of: <code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> or <code>&apos;utf8&apos;</code>.  If\nno encoding is provided, then a buffer is returned.\n\n</p>\n<p>返回剩余的加密内容，<code>output_encoding</code>为<code>&apos;binary&apos;</code>, <code>&apos;ascii&apos;</code> 或 <code>&apos;utf8&apos;</code>中的任意一个。如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method has been\ncalled.\n\n</p>\n<p>注: 调用<code>final()</code>函数后不能使用<code>decipher</code> 对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "decipher.setAutoPadding(auto_padding=true)",
              "type": "method",
              "name": "setAutoPadding",
              "desc": "<p>You can disable auto padding if the data has been encrypted without\nstandard block padding to prevent <code>decipher.final</code> from checking and\nremoving it. Can only work if the input data&apos;s length is a multiple of\nthe ciphers block size. You must call this before streaming data to\n<code>decipher.update</code>.\n\n</p>\n<p>如果数据以非标准的块填充方式被加密，那么你可以禁用自动填充来防止<code>decipher.final</code>对数据进行检查和移除。这只有在输入数据的长度是加密器块大小的整倍数时才有效。这个函数必须在将数据流传递给<code>decipher.update</code>之前调用。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "auto_padding",
                      "default": "true"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Sign",
          "type": "class",
          "name": "Sign",
          "desc": "<p>Class for generating signatures.\n\n</p>\n<p>生成数字签名的类\n\n</p>\n<p>Returned by <code>crypto.createSign</code>.\n\n</p>\n<p>由<code>crypto.createSign</code>返回。\n\n</p>\n<p>Sign objects are writable <a href=\"stream.html\">streams</a>.  The written data is\nused to generate the signature.  Once all of the data has been\nwritten, the <code>sign</code> method will return the signature.  The legacy\n<code>update</code> method is also supported.\n\n</p>\n<p>Sign对象是可写的<a href=\"stream.html\">流</a>对象。被写入的数据用来生成数字签名。当所有的数据都被写入后，<code>sign</code> 函数会返回数字签名。Sign对象也支持The legacy\n<code>update</code>函数。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "sign.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the sign object with data.  This can be called many times\nwith new data as it is streamed.\n\n</p>\n<p>用<code>data</code>来更新sign对象。 This can be called many times\nwith new data as it is streamed.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "sign.sign(private_key, [output_format])",
              "type": "method",
              "name": "sign",
              "desc": "<p>Calculates the signature on all the updated data passed through the\nsign.  <code>private_key</code> is a string containing the PEM encoded private\nkey for signing.\n\n</p>\n<p>根据所有传送给sign的更新数据来计算电子签名。<code>private_key</code>是一个包含了签名私钥的字符串，而该私钥是用PEM编码的。\n\n</p>\n<p>Returns the signature in <code>output_format</code> which can be <code>&apos;binary&apos;</code>,\n<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is\nreturned.\n\n</p>\n<p>返回一个数字签名，该签名的格式可以是<code>&apos;binary&apos;</code>,\n<code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>. 如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n<p>Note: <code>sign</code> object can not be used after <code>sign()</code> method has been\ncalled.\n\n</p>\n<p>注：调用<code>sign()</code>后不能使用<code>sign</code>对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "output_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: Verify",
          "type": "class",
          "name": "Verify",
          "desc": "<p>Class for verifying signatures.\n\n</p>\n<p>用来验证数字签名的类。\n\n</p>\n<p>Returned by <code>crypto.createVerify</code>.\n\n</p>\n<p>由 <code>crypto.createVerify</code>返回。\n\n</p>\n<p>Verify objects are writable <a href=\"stream.html\">streams</a>.  The written data\nis used to validate against the supplied signature.  Once all of the\ndata has been written, the <code>verify</code> method will return true if the\nsupplied signature is valid.  The legacy <code>update</code> method is also\nsupported.\n\n</p>\n<p>验证器对象是可写的<a href=\"stream.html\">流</a>对象.  被写入的数据会被用来验证提供的数字签名。在所有的数据被写入后，如果提供的数字签名有效，<code>verify</code>函数会返回真。验证器对象也支持 The legacy <code>update</code>函数。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "verifier.update(data)",
              "type": "method",
              "name": "update",
              "desc": "<p>Updates the verifier object with data.  This can be called many times\nwith new data as it is streamed.\n\n</p>\n<p>用数据更新验证器对象。This can be called many times\nwith new data as it is streamed.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "data"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "verifier.verify(object, signature, [signature_format])",
              "type": "method",
              "name": "verify",
              "desc": "<p>Verifies the signed data by using the <code>object</code> and <code>signature</code>.\n<code>object</code> is  a string containing a PEM encoded object, which can be\none of RSA public key, DSA public key, or X.509 certificate.\n<code>signature</code> is the previously calculated signature for the data, in\nthe <code>signature_format</code> which can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>.\nIf no encoding is specified, then a buffer is expected.\n\n</p>\n<p>用<code>object</code>和<code>signature</code>来验证被签名的数据。\n<code>object</code>是一个字符串，这个字符串包含了一个被PEM编码的对象，这个对象可以是RSA公钥，DSA公钥或者X.509 证书。\n<code>signature</code>是之前计算出来的数字签名，其中的 <code>signature_format</code>可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>.\n如果没有指明编码方式，那么默认是一个buffer对象。\n\n</p>\n<p>Returns true or false depending on the validity of the signature for\nthe data and public key.\n\n</p>\n<p>根据数字签名对于数据和公钥的有效性，返回true或false。\n\n</p>\n<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method has been\ncalled.\n\n</p>\n<p>注: 调用<code>verify()</code>函数后不能使用<code>verifier</code>对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "object"
                    },
                    {
                      "name": "signature"
                    },
                    {
                      "name": "signature_format",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "textRaw": "Class: DiffieHellman",
          "type": "class",
          "name": "DiffieHellman",
          "desc": "<p>The class for creating Diffie-Hellman key exchanges.\n\n</p>\n<p>创建迪菲－赫尔曼密钥交换(Diffie-Hellman key exchanges)的类。\n\n</p>\n<p>Returned by <code>crypto.createDiffieHellman</code>.\n\n</p>\n<p>由<code>crypto.createDiffieHellman</code>返回。\n\n</p>\n",
          "methods": [
            {
              "textRaw": "diffieHellman.generateKeys([encoding])",
              "type": "method",
              "name": "generateKeys",
              "desc": "<p>Generates private and public Diffie-Hellman key values, and returns\nthe public key in the specified encoding. This key should be\ntransferred to the other party. Encoding can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>,\nor <code>&apos;base64&apos;</code>.  If no encoding is provided, then a buffer is returned.\n\n</p>\n<p>生成迪菲－赫尔曼(Diffie-Hellman)算法的公钥和私钥，并根据指明的编码方式返回公钥。这个公钥可以转交给第三方。编码方式可以是 <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>.  如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])",
              "type": "method",
              "name": "computeSecret",
              "desc": "<p>Computes the shared secret using <code>other_public_key</code> as the other\nparty&apos;s public key and returns the computed shared secret. Supplied\nkey is interpreted using specified <code>input_encoding</code>, and secret is\nencoded using specified <code>output_encoding</code>. Encodings can be\n<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If the input encoding is not\nprovided, then a buffer is expected.\n\n</p>\n<p>以<code>other_public_key</code>作为第三方公钥来计算共享秘密，并返回这个共享秘密。参数中的密钥会以<code>input_encoding</code>编码方式来解读，而共享密钥则会用<code>output_encoding</code>进行编码。编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>或 <code>&apos;base64&apos;</code>。如果没有提供输入的编码方式，则默认为一个buffer对象。\n\n</p>\n<p>If no output encoding is given, then a buffer is returned.\n\n</p>\n<p>如果没有指明输出的编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "other_public_key"
                    },
                    {
                      "name": "input_encoding",
                      "optional": true
                    },
                    {
                      "name": "output_encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrime([encoding])",
              "type": "method",
              "name": "getPrime",
              "desc": "<p>Returns the Diffie-Hellman prime in the specified encoding, which can\nbe <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,\nthen a buffer is returned.\n\n</p>\n<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getGenerator([encoding])",
              "type": "method",
              "name": "getGenerator",
              "desc": "<p>Returns the Diffie-Hellman prime in the specified encoding, which can\nbe <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,\nthen a buffer is returned.\n\n</p>\n<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)质数，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPublicKey([encoding])",
              "type": "method",
              "name": "getPublicKey",
              "desc": "<p>Returns the Diffie-Hellman public key in the specified encoding, which\ncan be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is provided,\nthen a buffer is returned.\n\n</p>\n<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)公钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。 如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.getPrivateKey([encoding])",
              "type": "method",
              "name": "getPrivateKey",
              "desc": "<p>Returns the Diffie-Hellman private key in the specified encoding,\nwhich can be <code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code>, or <code>&apos;base64&apos;</code>. If no encoding is\nprovided, then a buffer is returned.\n\n</p>\n<p>根据指明的编码格式返回迪菲－赫尔曼(Diffie-Hellman)私钥，其中编码方式可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPublicKey(public_key, [encoding])",
              "type": "method",
              "name": "setPublicKey",
              "desc": "<p>Sets the Diffie-Hellman public key. Key encoding can be <code>&apos;binary&apos;</code>,\n<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is\nexpected.\n\n</p>\n<p>设置迪菲－赫尔曼(Diffie-Hellman)公钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "public_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "diffieHellman.setPrivateKey(private_key, [encoding])",
              "type": "method",
              "name": "setPrivateKey",
              "desc": "<p>Sets the Diffie-Hellman private key. Key encoding can be <code>&apos;binary&apos;</code>,\n<code>&apos;hex&apos;</code> or <code>&apos;base64&apos;</code>. If no encoding is provided, then a buffer is\nexpected.\n\n</p>\n<p>设置迪菲－赫尔曼(Diffie-Hellman)私钥，编码方式可以是可以是<code>&apos;binary&apos;</code>, <code>&apos;hex&apos;</code> 或 <code>&apos;base64&apos;</code>。如果没有指明编码方式，则返回一个buffer对象。\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "private_key"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "properties": [
        {
          "textRaw": "crypto.DEFAULT_ENCODING",
          "name": "DEFAULT_ENCODING",
          "desc": "<p>The default encoding to use for functions that can take either strings\nor buffers.  The default value is <code>&apos;buffer&apos;</code>, which makes it default\nto using Buffer objects.  This is here to make the crypto module more\neasily compatible with legacy programs that expected <code>&apos;binary&apos;</code> to be\nthe default encoding.\n\n</p>\n<p>对于可以接受字符串或buffer对象的函数的默认编码方式。默认值是<code>&apos;buffer&apos;</code>，所以默认使用Buffer对象。这是为了让crypto模块与默认<code>&apos;binary&apos;</code>为编码方式的遗留程序更容易兼容。\n\n</p>\n<p>Note that new programs will probably expect buffers, so only use this\nas a temporary measure.\n\n</p>\n<p>要注意，新的程序会期待buffer对象，所以使用这个时请只作为暂时的手段。\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "加密（Crypto）"
    }
  ]
}