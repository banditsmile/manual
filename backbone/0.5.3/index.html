
<!DOCTYPE HTML>
<!-- host at www.csser.com -->
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <title>Backbone.js API中文文档 - CSSer</title>
  <style>
    body {
      font-size: 14px;
      line-height: 22px;
      font-family: Helvetica Neue, Helvetica, Arial;
      background: #f4f4f4 url(http://documentcloud.github.com/backbone/docs/images/background.png);
    }
    .interface {
      font-family: "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, sans-serif !important;
    }
    div#sidebar {
      background: #fff;
      position: fixed;
      top: 0; left: 0; bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #ddd;
      box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 20px #ccc; -moz-box-shadow: 0 0 20px #ccc;
    }
      a.toc_title, a.toc_title:visited {
        display: block;
        color: black;
        font-weight: bold;
        margin-top: 15px;
      }
        a.toc_title:hover {
          text-decoration: underline;
        }
        #sidebar .version {
          font-size: 10px;
          font-weight: normal;
        }
      ul.toc_section {
        font-size: 11px;
        line-height: 14px;
        margin: 5px 0 0 0;
        padding-left: 0px;
        list-style-type: none;
        font-family: Lucida Grande;
      }
        .toc_section li {
          cursor: pointer;
          margin: 0 0 3px 0;
        }
          .toc_section li a {
            text-decoration: none;
            color: black;
          }
            .toc_section li a:hover {
              text-decoration: underline;
            }
    div.container {
      position: relative;
      width: 750px;
      margin: 40px 0 50px 260px;
    }
    div.run {
      position: absolute;
      right: 15px;
      width: 26px; height: 18px;
      background: url('http://documentcloud.github.com/backbone/docs/images/arrows.png') no-repeat -26px 0;
    }
      div.run:active {
        background-position: -51px 0;
      }
    p, div.container ul {
      margin: 20px 0;
    }
      p.warning {
        font-size: 12px;
        line-height: 18px;
        font-style: italic;
      }
      div.container ul {
        list-style: circle;
        font-size: 12px;
        padding-left: 15px;
      }
    a, a:visited {
      color: #444;
    }
    a:active, a:hover {
      color: #000;
    }
    a img {
      border: 0;
    }
    h1, h2, h3, h4, h5, h6 {
      padding-top: 20px;
    }
      h2 {
        font-size: 20px;
      }
    b.header {
      font-size: 16px;
      line-height: 30px;
    }
    span.alias {
      font-size: 14px;
      font-style: italic;
      margin-left: 20px;
    }
    table {
      margin: 15px 0 0; padding: 0;
    }
      tr, td {
        margin: 0; padding: 0;
      }
        td {
          padding: 0px 15px 5px 0;
        }
    code, pre, tt {
      font-family: Monaco, Consolas, "Lucida Console", monospace;
      font-size: 12px;
      line-height: 18px;
      font-style: normal;
    }
      tt {
        padding: 0px 3px;
        background: #fff;
        border: 1px solid #ddd;
        zoom: 1;
      }
      code {
        margin-left: 20px;
      }
      pre {
        font-size: 12px;
        padding: 2px 0 2px 15px;
        border: 4px solid #bbb; border-top: 0; border-bottom: 0;
        margin: 0px 0 30px;
      }
      img.example_image {
        margin: 0px auto;
      }
  </style>
</head>
<body>

  <div id="sidebar" class="interface">

    <a class="toc_title" href="index.html#">
      Backbone.js <span class="version">(0.5.3)</span>
    </a>

    <a class="toc_title" href="index.html#Introduction">
      简介
    </a>

    <a class="toc_title" href="index.html#Events">
      事件
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#Events-bind">bind</a></li>
      <li>– <a href="index.html#Events-unbind">unbind</a></li>
      <li>– <a href="index.html#Events-trigger">trigger</a></li>
    </ul>

    <a class="toc_title" href="index.html#Model">
      模型
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#Model-extend">extend</a></li>
      <li>– <a href="index.html#Model-constructor">constructor / initialize</a></li>
      <li>– <a href="index.html#Model-get">get</a></li>
      <li>– <a href="index.html#Model-set">set</a></li>
      <li>– <a href="index.html#Model-escape">escape</a></li>
      <li>– <a href="index.html#Model-has">has</a></li>
      <li>– <a href="index.html#Model-unset">unset</a></li>
      <li>– <a href="index.html#Model-clear">clear</a></li>
      <li>– <a href="index.html#Model-id">id</a></li>
      <li>– <a href="index.html#Model-cid">cid</a></li>
      <li>– <a href="index.html#Model-attributes">attributes</a></li>
      <li>– <a href="index.html#Model-defaults">defaults</a></li>
      <li>- <a href="index.html#Model-toJSON">toJSON</a></li>
      <li>– <a href="index.html#Model-fetch">fetch</a></li>
      <li>– <a href="index.html#Model-save">save</a></li>
      <li>– <a href="index.html#Model-destroy">destroy</a></li>
      <li>– <a href="index.html#Model-validate">validate</a></li>
      <li>– <a href="index.html#Model-url">url</a></li>
      <li>– <a href="index.html#Model-urlRoot">urlRoot</a></li>
      <li>– <a href="index.html#Model-parse">parse</a></li>
      <li>– <a href="index.html#Model-clone">clone</a></li>
      <li>– <a href="index.html#Model-isNew">isNew</a></li>
      <li>– <a href="index.html#Model-change">change</a></li>
      <li>– <a href="index.html#Model-hasChanged">hasChanged</a></li>
      <li>– <a href="index.html#Model-changedAttributes">changedAttributes</a></li>
      <li>– <a href="index.html#Model-previous">previous</a></li>
      <li>– <a href="index.html#Model-previousAttributes">previousAttributes</a></li>
    </ul>

    <a class="toc_title" href="index.html#Collection">
      集合
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#Collection-extend">extend</a></li>
      <li>– <a href="index.html#Collection-model">model</a></li>
      <li>– <a href="index.html#Collection-constructor">constructor / initialize</a></li>
      <li>– <a href="index.html#Collection-models">models</a></li>
      <li>– <a href="index.html#Collection-toJSON">toJSON</a></li>
      <li>– <a href="index.html#Collection-Underscore-Methods"><b>Underscore 方法 (26)</b></a></li>
      <li>– <a href="index.html#Collection-add">add</a></li>
      <li>– <a href="index.html#Collection-remove">remove</a></li>
      <li>– <a href="index.html#Collection-get">get</a></li>
      <li>– <a href="index.html#Collection-getByCid">getByCid</a></li>
      <li>– <a href="index.html#Collection-at">at</a></li>
      <li>– <a href="index.html#Collection-length">length</a></li>
      <li>– <a href="index.html#Collection-comparator">comparator</a></li>
      <li>– <a href="index.html#Collection-sort">sort</a></li>
      <li>– <a href="index.html#Collection-pluck">pluck</a></li>
      <li>– <a href="index.html#Collection-url">url</a></li>
      <li>– <a href="index.html#Collection-parse">parse</a></li>
      <li>– <a href="index.html#Collection-fetch">fetch</a></li>
      <li>– <a href="index.html#Collection-reset">reset</a></li>
      <li>– <a href="index.html#Collection-create">create</a></li>
    </ul>

    <a class="toc_title" href="index.html#Router">
      路由
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#Router-extend">extend</a></li>
      <li>– <a href="index.html#Router-routes">routes</a></li>
      <li>– <a href="index.html#Router-constructor">constructor / initialize</a></li>
      <li>– <a href="index.html#Router-route">route</a></li>
      <li>– <a href="index.html#Router-navigate">navigate</a></li>
    </ul>

    <a class="toc_title" href="index.html#History">
      历史
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#History-start">start</a></li>
    </ul>

    <a class="toc_title" href="index.html#Sync">
      同步
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#Sync">Backbone.sync</a></li>
      <li>– <a href="index.html#Sync-emulateHTTP">Backbone.emulateHTTP</a></li>
      <li>– <a href="index.html#Sync-emulateJSON">Backbone.emulateJSON</a></li>
    </ul>

    <a class="toc_title" href="index.html#View">
      视图
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#View-extend">extend</a></li>
      <li>– <a href="index.html#View-constructor">constructor / initialize</a></li>
      <li>– <a href="index.html#View-el">el</a></li>
      <li>– <a href="index.html#View-dollar">$ (jQuery 或 Zepto)</a></li>
      <li>– <a href="index.html#View-render">render</a></li>
      <li>– <a href="index.html#View-remove">remove</a></li>
      <li>– <a href="index.html#View-make">make</a></li>
      <li>– <a href="index.html#View-delegateEvents">delegateEvents</a></li>
    </ul>

    <a class="toc_title" href="index.html#Utility">
      工具
    </a>
    <ul class="toc_section">
      <li>– <a href="index.html#Utility-noConflict">noConflict</a></li>
    </ul>

    <!-- <a class="toc_title" href="#faq">常见问题</a>
       - <ul class="toc_section">
       -   <li>– <a href="#FAQ-events">事件分类</a></li>
       -   <li>– <a href="#FAQ-tim-toady">通过不止一种方式来实现</a></li>
       -   <li>– <a href="#FAQ-nested">嵌套模型和集合</a></li>
       -   <li>– <a href="#FAQ-bootstrap">加载启动模型</a></li>
       -   <li>– <a href="#FAQ-mvc">复杂MVC</a></li>
       -   <li>– <a href="#FAQ-this">绑定"this"</a></li>
       - </ul> -->


  </div>

  <div class="container">

	<h1> Backbone.js API中文文档 </h1>

	<ul>
		<li>翻译：一回 </li>
		<li>日期：2011-8-16 </li>
		<li>反馈：xianlihua$gmail.com [$ -> @] </li>
		<li>特别鸣谢：<a href="http://www.csser.com" target="_blank" title="关注web前后端应用开发">CSSer</a> </li>
	</ul>

	<p>本手册可自由转载，但须注明译者及来源，尊重他人劳动，共建和谐的学习与研究氛围，从你我做起。 </p>

	<p>
	  <img src="http://documentcloud.github.com/backbone/docs/images/backbone.png" alt="Backbone.js" />
	</p>

	<p>简单术语翻译对照：散列表（hash） 模型（model） 视图（view） 集合（collection） 回调函数（callback） 绑定（bind）</p>

    <p>
      <a href="http://github.com/documentcloud/backbone/" target="_blank">Backbone</a>
	  为复杂Javascript应用程序提供<b>模型</b>(models)、<b>集合</b>(collections)、<b>视图</b>(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API；
	  视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。
    </p>

    <p>
      Backbone项目 <a href="http://github.com/documentcloud/backbone/" target="_blank">托管在Github</a>
    </p>

    <p>
      <i>
        Backbone是 <a href="http://documentcloud.org/" target="_blank">DocumentCloud</a> 的一个开源组件.
      </i>
    </p>

    <h2 id="downloads"> 下载和依赖 </h2>

    <p>
	  <a href="http://www.csser.com" target="_blank">一回</a> 翻译的为 0.5.3 版本，下载请前往 <a href="http://documentcloud.github.com/backbone/" target="_blank">Backbone官网</a> 。
	</p>
	<p>
	  Backbone.js 唯一重度依赖
      <a href="http://documentcloud.github.com/underscore/" target="_blank">Underscore.js</a>.
	  对于 RESTful , history 的支持依赖于 <a href="index.html#Router">Backbone.Router</a> ,
	  DOM 处理依赖于 <a href="index.html#View">Backbone.View</a> ,
      <a href="https://github.com/douglascrockford/JSON-js" target="_blank">json2.js</a>, 和
      <a href="http://jquery.com" target="_blank">jQuery</a> <small>( > 1.4.2)</small> 或
      <a href="http://zeptojs.com/" target="_blank">Zepto</a> 之一.
    </p>

    <h2 id="Introduction">简介</h2>

    <p>
	  当我们开发含有大量Javascript的web应用程序时，首先你需要做的事情之一便是停止向DOM对象附加数据。
	  通过复杂多变的jQuery选择符和回调函数创建Javascript应用程序，包括在HTML UI，Javascript逻辑和数据之间保持同步，都不复杂。
	  但对富客户端应用来说，良好的架构通常是有很多益处的。
    </p>

    <p>
	  Backbone将数据呈现为
      <a href="index.html#Model">模型</a>, 你可以创建模型、对模型进行验证和销毁，甚至将它保存到服务器。
	  当UI的变化引起模型属性改变时，模型会触发<i>"change"</i>事件；
	  所有显示模型数据的 <a href="index.html#View">视图</a> 会接收到该事件的通知，继而视图重新渲染。
	  你无需查找DOM来搜索指定<i>id</i>的元素去手动更新HTML。
      &mdash; 当模型改变了，视图便会自动变化。
    </p>


    <h2 id="Events">Backbone.Events</h2>

    <p>
	  <b>Events</b> 是一个可以被mix到任意对象的模块，它拥有让对象绑定和触发自定义事件的能力。
	  事件在被绑定之前是不需要事先声明的，还可以携带参数。我们通过一个例子来看：
    </p>

<pre class="runnable">
var object = {};

_.extend(object, Backbone.Events);

object.bind("alert", function(msg) {
  alert("Triggered " + msg);
});

object.trigger("alert", "www.csser.com");
</pre>

    <p id="Events-bind">
      <b class="header">bind</b><code>object.bind(event, callback, [context])</code>
      <br />
      绑定 <b>callback</b> 函数到 object 对象。
	  当<b>事件</b>触发时执行回调函数 callback 。如果一个页面中有大量不同的事件，按照惯例使用冒号指定命名空间：
       <tt>"poll:start"</tt>, 或 <tt>"change:selection"</tt>
    </p>

    <p>
	  当 callback 执行时提供第三个可选参数，可以为 <tt>this</tt> 指定上下文： <tt>model.bind('change', this.render, this)</tt>
    </p>

    <p>
	  绑定到特殊事件 <tt>"all"</tt> 的回调函数会在任意事件发生时被触发，其第一个参数为事件的名称。
	  例如，将一个对象的所有事件代理到另一对象：
    </p>

<pre>
proxy.bind("all", function(eventName) {
  object.trigger(eventName);
});
</pre>

    <p id="Events-unbind">
      <b class="header">unbind</b><code>object.unbind([event], [callback])</code>
      <br />
	  从 object 对象移除先前绑定的 <b>callback</b> 函数。如果不指定第二个参数，所有 <b>event</b> 事件绑定的回调函数都被移除。
	  如果第一个参数也不指定，对象所绑定的<i>所有</i>回调函数都将被移除。
    </p>

<pre>
object.unbind("change", onChange);  // 只移除onChange回调函数

object.unbind("change");            // 移除所有 "change" 回调函数

object.unbind();                    // 移除对象的所有回调函数
</pre>

    <p id="Events-trigger">
      <b class="header">trigger</b><code>object.trigger(event, [*args])</code>
      <br />
	  触发 <b>event</b> 事件的回调函数。后续传入 <b>trigger</b> 的参数会被依次传入事件回调函数。
    </p>

    <h2 id="Model">Backbone.Model</h2>

    <p>
	  <b>模型</b> 是所有 Javascript 应用程序的核心，包括交互数据及相关的大量逻辑：
	  转换、验证、计算属性和访问控制。你可以用特定的方法扩展 <b>Backbone.Model</b> ，
	  <b>模型</b> 也提供了一组基本的管理变化的功能。
    </p>

    <p>
	  下面的示例演示了如何定义一个模型，包括自定义方法、设置属性、以及触发该属性变化的事件。
    </p>

<pre class="runnable">
var Sidebar = Backbone.Model.extend({
  promptColor: function() {
    var cssColor = prompt("请输入一个CSS颜色值：");
    this.set({color: cssColor});
  }
});

window.sidebar = new Sidebar;

sidebar.bind('change:color', function(model, color) {
  $('#sidebar').css({background: color});
});

sidebar.set({color: 'white'});

sidebar.promptColor();
</pre>

    <p id="Model-extend">
      <b class="header">extend</b><code>Backbone.Model.extend(properties, [classProperties])</code>
      <br />
	  要创建自己的 <b>模型</b> 类，你可以扩展 <b>Backbone.Model</b> 并提供实例 <b>属性</b> ，
	  以及可选的可以直接注册到构造函数的 <b>类属性</b> (classProperties)。
    </p>

    <p>
	  <b>extend</b> 可以正确的设置原型链，因此通过 <b>extend</b> 创建的子类 (subclasses) 也可以被深度扩展。
    </p>

<pre>
var Note = Backbone.Model.extend({

  initialize: function() { ... },

  author: function() { ... },

  coordinates: function() { ... },

  allowedToEdit: function(account) {
    return true;
  }

});

var PrivateNote = Note.extend({

  allowedToEdit: function(account) {
    return account.owns(this);
  }

});
</pre>

    <p class="warning">
		<tt>父类</tt> 的简述：Javascript没有提供一种直接调用父类的方式，
		如果你要重载原型链中上层定义的同名函数，如 <tt>set</tt>，或 <tt>save</tt> ，
		并且你想调用父对象的实现，这时需要明确的调用它，类似这样：
    </p>

<pre>
var CSSercom = Backbone.Model.extend({
  set: function(attributes, options) {
    Backbone.Model.prototype.set.call(this, attributes, options);
    ...
  }
});
</pre>

    <p id="Model-constructor">
      <b class="header">constructor / initialize</b><code>new Model([attributes])</code>
      <br />
	  当创建模型实例时，可以传入 <b>属性</b> 初始值，这些值会被 <a href="index.html#Model-set">set</a> 到模型。
	  如果定义了 <b>initialize</b> 函数，该函数会在模型创建后执行。
    </p>

<pre>
new Site({
  title: "CSSer, 关注web前后端技术",
  author: "一回"
});
</pre>

    <p id="Model-get">
      <b class="header">get</b><code>model.get(attribute)</code>
      <br />
	  从模型获取当前属性值，比如：<tt>csser.get("title")</tt>
    </p>

    <p id="Model-set">
      <b class="header">set</b><code>model.set(attributes, [options])</code>
      <br />
	  向模型设置一个或多个散列属性。
	  如果任何一个属性改变了模型的状态，在不传入 <tt>{silent: true}</tt> 选项参数的情况下，会触发 <tt>"change"</tt> 事件。
	  可以绑定事件到某个属性，例如：<tt>change:title</tt>，及 <tt>change:content</tt>。
    </p>

<pre>
csser.set({title: "CSSer", content: "http://www.csser.com"});
</pre>

    <p>
	  如果模型拥有 <a href="index.html#Model-validate">validate</a> 方法，
	  那么属性验证会在 set 之前执行，如果验证失败，模型不会发生变化，这时 <b>set</b> 会返回 <tt>false</tt>。
	  也可以在选项中传入 <tt>error</tt> 回调函数，此时验证失败时会执行它而不触发 <tt>"error"</tt> 事件。
    </p>

    <p id="Model-escape">
      <b class="header">escape</b><code>model.escape(attribute)</code>
      <br />
	  与 <a href="index.html#Model-get">get</a> 类似, 但返回模型属性值的 HTML 转义后的版本。
	  如果将数据从模型插入 HTML，使用 <b>escape</b> 取数据可以避免
      <a href="http://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank">XSS</a> 攻击.
    </p>

<pre class="runnable">
var hacker = new Backbone.Model({
  name: "&lt;script&gt;alert('xss')&lt;/script&gt;"
});

alert(hacker.escape('name'));

</pre>

    <p id="Model-has">
      <b class="header">has</b><code>model.has(attribute)</code>
      <br />
	  属性值为非 null 或非 undefined 时返回 <tt>true</tt>
    </p>

<pre>
if (note.has("title")) {
  ...
}
</pre>

    <p id="Model-unset">
      <b class="header">unset</b><code>model.unset(attribute, [options])</code>
      <br />
	  从内部属性散列表中删除指定属性。
	  如果未设置 <tt>silent</tt> 选项，会触发 <tt>"change"</tt> 事件。
    </p>

    <p id="Model-clear">
      <b class="header">clear</b><code>model.clear([options])</code>
      <br />
	  从模型中删除所有属性。
	  如果未设置 <tt>silent</tt> 选项，会触发 <tt>"change"</tt> 事件。
    </p>

    <p id="Model-id">
      <b class="header">id</b><code>model.id</code>
      <br />
	  模型的特殊属性， <b>id</b> 可以是任意字符串（整型 id 或 UUID）。
	  在属性中设置的 <b>id</b> 会被直接拷贝到模型属性上。
	  我们可以从集合（collections）中通过 id 获取模型，另外 id 通常用于生成模型的 URLs。
    </p>

    <p id="Model-cid">
      <b class="header">cid</b><code>model.cid</code>
      <br />
	  模型的特殊属性，<b>cid</b> 或客户 id 是当所有模型创建时自动产生的唯一标识符。
	  客户 ids 在模型尚未保存到服务器之前便存在，此时模型可能仍不具有最终的 <b>id</b>，
	  客户 ids 的形式为：<tt>c1, c2, c3 ...</tt>
    </p>

    <p id="Model-attributes">
      <b class="header">attributes</b><code>model.attributes</code>
      <br />
	  <b>attributes</b> 属性是包含模型状态的内部散列表。
	  建议采用 <a href="index.html#Model-set">set</a> 更新属性而不要直接修改。
	  如要获取模型属性的副本，
      用 <a href="index.html#Model-toJSON">toJSON</a> 取而代之。
    </p>

    <p id="Model-defaults">
      <b class="header">defaults</b><code>model.defaults or model.defaults()</code>
      <br />
	  <b>defaults</b> 散列（或函数）用于为模型指定默认属性。
	  创建模型实例时，任何未指定的属性会被设置为其默认值。
    </p>

<pre class="runnable">
var Meal = Backbone.Model.extend({
  defaults: {
    "appetizer":  "caesar salad",
    "entree":     "ravioli",
    "dessert":    "cheesecake"
  }
});

alert("Dessert will be " + (new Meal).get('dessert'));
</pre>

    <p class="warning">
	  需要提醒的是，在 Javascript 中，对象是按引用传值的，因此包含对象作为默认值，它会被所有实例共享。
    </p>

    <p id="Model-toJSON">
      <b class="header">toJSON</b><code>model.toJSON()</code>
      <br />
	  返回模型 <a href="index.html#Model-attributes">attributes</a> 副本的 JSON 字符串化形式。
	  它可用于模型的持久化、序列化，或者传递到视图前的扩充。
	  该方法的名称有点混乱，因为它事实上并不返回 JSON 字符串，但
      <a href="https://developer.mozilla.org/en/JSON#toJSON()_method" target="_blank">JavaScript API for <b>JSON.stringify</b> </a>可以实现。
    </>

<pre class="runnable">
var artist = new Backbone.Model({
  firstName: "立华",
  lastName: "咸"
});

artist.set({birthday: "December 13, 1979"});

alert(JSON.stringify(artist));
</pre>

    <p id="Model-fetch">
      <b class="header">fetch</b><code>model.fetch([options])</code>
      <br />
	  从服务器重置模型状态。这对模型尚未填充数据，或者服务器端已有最新状态的情况很有用处。
	  如果服务器端状态与当前属性不同，则触发 <tt>"change"</tt> 事件。
	  选项的散列表参数接受 <tt>success</tt> 和 <tt>error</tt> 回调函数，
	  回调函数中可以传入 <tt>(model,response)</tt> 作为参数。
    </p>

<pre>
// 每隔 10 秒从服务器拉取数据以保持频道模型是最新的
setInterval(function() {
  channel.fetch();
}, 10000);
</pre>

    <p id="Model-save">
      <b class="header">save</b><code>model.save([attributes], [options])</code>
      <br />
	  通过委托 <a href="index.html#Sync">Backbone.sync</a> 保存模型到数据库（或可替代的持久层）。
	  <b>attributes</b> 散列表
      (在 <a href="index.html#Model-set">set</a>) 应当包含想要改变的属性，不涉及的键不会被修改。
      如果模型含有 <a href="index.html#Model-validate">validate</a> 方法，并且验证失败，模型不会保存。
	  如果模型
      <a href="index.html#Model-isNew">isNew</a>, 保存将采用 <tt>"create"</tt>
      (HTTP <tt>POST</tt>) 方法, 如果模型已经在服务器存在，保存将采用
      <tt>"update"</tt> (HTTP <tt>PUT</tt>) 方法.
    </p>

    <p>
	  在下面的示例，注意我们是如何在模型初次保存时接收到 <tt>"create"</tt> 请求，第二次接收到 <tt>"update"</tt>
	  请求的。
    </p>

<pre class="runnable">
Backbone.sync = function(method, model) {
  alert(method + ": " + JSON.stringify(model));
  model.id = 1;
};

var book = new Backbone.Model({
  title: "The Rough Riders",
  author: "Theodore Roosevelt"
});

book.save();

book.save({author: "Teddy"});
</pre>

    <p>
      <b>save</b> 支持在选项散列表中传入 <tt>success</tt> 和 <tt>error</tt> 回调函数，
      回调函数支持传入 <tt>(model, response)</tt> 作为参数。
	  如果模型拥有 <tt>validate</tt> 方法并且验证失败，<tt>error</tt> 回调函数会执行。
	  如果服务端验证失败，返回非 <tt>200</tt> 的 HTTP 响应码，将产生文本或 JSON 的错误内容。
    </p>

<pre>
book.save({author: "F.D.R."}, {error: function(){ ... }});
</pre>

    <p id="Model-destroy">
      <b class="header">destroy</b><code>model.destroy([options])</code>
      <br />
	  通过委托 HTTP <tt>DELETE</tt> 请求到
      <a href="index.html#Sync">Backbone.sync</a> 销毁服务器上的模型. 接受
      <tt>success</tt> 和 <tt>error</tt> 回调函数作为选项散列表参数。
	  将在模型上触发 <tt>"destroy"</tt> 事件，该事件可以通过任意包含它的集合向上冒泡。
    </p>

<pre>
book.destroy({success: function(model, response) {
  ...
}});
</pre>

    <p id="Model-validate">
      <b class="header">validate</b><code>model.validate(attributes)</code>
      <br />
	  该方法是未定义的，如果有在Javascript执行的需要，建议用自定义的验证逻辑重载它。
	  <b>validate</b> 会在 <tt>set</tt> 和 <tt>save</tt> 之前调用，并传入待更新的属性。
	  如果模型和属性通过验证，不返回任何值；
	  如果属性不合法，返回一个可选择的错误。该错误可以是简单的用于显示的字符串错误信息，
	  或者是一个可以描述错误详细的 error 对象。
	  如果 <b>validate</b> 返回错误，<tt>set</tt> 和 <tt>save</tt> 将不会执行。
	  失败的验证会触发一个 <tt>"error"</tt>事件。
    </p>

<pre class="runnable">
var Chapter = Backbone.Model.extend({
  validate: function(attrs) {
    if (attrs.end < attrs.start) {
      return "can't end before it starts";
    }
  }
});

var one = new Chapter({
  title : "Chapter One: The Beginning"
});

one.bind("error", function(model, error) {
  alert(model.get("title") + " " + error);
});

one.set({
  start: 15,
  end:   10
});
</pre>

    <p>
	  <tt>"error"</tt> 事件对模型和集合级别提供粗粒度的错误信息很有帮助，
	  但如果想设计更好的处理错误的特定视图，可以直接传入 <tt>error</tt> 回调函数重载事件。
    </p>

<pre>
account.set({access: "unlimited"}, {
  error: function(model, error) {
    alert(error);
  }
});
</pre>

    <p id="Model-url">
      <b class="header">url</b><code>model.url()</code>
      <br />
	  返回模型资源在服务器上位置的相对 URL 。
	  如果模型放在其它地方，可通过合理的逻辑重载该方法。
	  生成 URLs 的形式为：<tt>"/[collection.url]/[id]"</tt>，
	  如果模型不是集合的一部分，则 URLs 形式为：<tt>"/[urlRoot]/id"</tt>。
    </p>

    <p>
      由于是委托到 <a href="index.html#Collection-url">Collection#url</a> 来生成 URL，
	  所以首先需要确认它是否定义过，或者所有模型共享一个通用根 URL 时，是否存在 <a href="index.html#Model-urlRoot">urlRoot</a> 属性。
	  例如，一个 id 为 <tt>101</tt> 的模型，存储在
	  <tt>url</tt> 为 <tt>"/documents/7/notes"</tt> 的 <a href="index.html#Collection">Backbone.Collection</a> 中，
	  那么该模型的 URL 为：<tt>"/documents/7/notes/101"</tt>
    </p>

    <p id="Model-urlRoot">
      <b class="header">urlRoot</b><code>model.urlRoot</code>
      <br />
	  如果使用的集合外部的模型，通过指定 <tt>urlRoot</tt> 来设置生成基于模型 id 的 URLs 的默认 <a href="index.html#Model-url">url</a> 函数。
	  <tt>"/[urlRoot]/id"</tt>
    </p>

<pre class="runnable">
var Book = Backbone.Model.extend({urlRoot : '/books'});

var solaris = new Book({id: "1083-lem-solaris"});

alert(solaris.url());
</pre>

    <p id="Model-parse">
      <b class="header">parse</b><code>model.parse(response)</code>
      <br />
	  <b>parse</b> 会在通过 <a href="index.html#Model-fetch">fetch</a> 从服务器返回模型数据，以及 <a href="index.html#Model-save">save</a> 时执行。
	  传入本函数的为原始 <tt>response</tt> 对象，并且应当返回可以 <a href="index.html#Model-set">set</a> 到模型的属性散列表。
	  默认实现是自动进行的，仅简单传入 JSON 响应。
	  如果需要使用已存在的 API，或者更好的命名空间响应，可以重载它。
    </p>

    <p>
	  如果使用的 Rails 后端，需要注意 Rails's 默认的 <tt>to_json</tt> 实现已经包含了命名空间之下的模型属性。
	  对于无缝的后端集成环境禁用这种行为：
    </p>

<pre>
ActiveRecord::Base.include_root_in_json = false
</pre>

    <p id="Model-clone">
      <b class="header">clone</b><code>model.clone()</code>
      <br />
	  返回与模型属性一致的新的实例。
    </p>

    <p id="Model-isNew">
      <b class="header">isNew</b><code>model.isNew()</code>
      <br />
	  模型是否已经保存到服务器。
	  如果模型尚无 <tt>id</tt>，则被视为新的。
    </p>

    <p id="Model-change">
      <b class="header">change</b><code>model.change()</code>
      <br />
	  手动触发 <tt>"change"</tt> 事件。
	  如果已经在 <a href="index.html#Model-set">set</a> 函数传入选项参数 <tt>{silent: true}</tt> ，
	  当所有操作结束时，可以手动调用 <tt>model.change()</tt> 。
    </p>

    <p id="Model-hasChanged">
      <b class="header">hasChanged</b><code>model.hasChanged([attribute])</code>
      <br />
	  标识模型从上次 <tt>"change"</tt> 事件发生后是否改变过。
	  如果传入 <b>attribute</b> ，当指定属性改变后返回 <tt>true</tt>。
    </p>

    <p class="warning">
	  注意，本方法以及接下来 change 相关的方法，仅对 <tt>"change"</tt> 事件发生有效。
    </p>

<pre>
book.bind("change", function() {
  if (book.hasChanged("title")) {
    ...
  }
});
</pre>

    <p id="Model-changedAttributes">
      <b class="header">changedAttributes</b><code>model.changedAttributes([attributes])</code>
      <br />
	  仅获取模型属性已改变的散列表。
	  或者也可以传入外来的 <b>attributes</b> 散列，返回该散列与模型不同的属性。
	  一般用于指出视图的哪个部分已被更新，或者确定哪些需要与服务器进行同步。
    </p>

    <p id="Model-previous">
      <b class="header">previous</b><code>model.previous(attribute)</code>
      <br />
	  在 <tt>"change"</tt> 事件发生的过程中，本方法可被用于获取已改变属性的旧值。
    </p>

<pre class="runnable">
var bill = new Backbone.Model({
  name: "二回"
});

bill.bind("change:name", function(model, name) {
  alert("名字已从 " + bill.previous("name") + " 改为 " + name);
});

bill.set({name : "一回"});
</pre>

    <p id="Model-previousAttributes">
      <b class="header">previousAttributes</b><code>model.previousAttributes()</code>
      <br />
	  返回模型的上一个属性散列的副本。一般用于获取模型的不同版本之间的区别，或者当发生错误时回滚模型状态。
    </p>

    <h2 id="Collection">Backbone.Collection</h2>

	<p>集合是模型的有序组合，我们可以在集合上绑定 <tt>"change"</tt> 事件，从而当集合中的模型发生变化时获得通知，集合也可以监听 <tt>"add"</tt> 和 <tt>“remove"</tt> 事件， 从服务器更新，并能使用 <a href="index.html#Collection-Underscore-Methods">Underscore.js  提供的方法</a> </p>

	<p>集合中的模型触发的任何事件都可以在集合身上直接触发，所以我们可以监听集合中模型的变化：<tt>Documents.bind("change:selected", ...)</tt></p>

    <p id="Collection-extend">
      <b class="header">extend</b><code>Backbone.Collection.extend(properties, [classProperties])</code>
      <br />
	  通过扩展 <b>Backbone.Collection</b> 创建一个 <b>Collection</b> 类。实例属性参数 <b>properties</b> 以及 类属性参数 <b>classProperties</b> 会被直接注册到集合的构造函数。
    </p>

    <p id="Collection-model">
      <b class="header">model</b><code>collection.model</code>
      <br />
	  指定集合的模型类。可以传入原始属性对象（和数组）来 <a href="index.html#Collection-add">add</a>，<a href="index.html#Collection-create">create</a>，以及
	  <a href="index.html#Collection-reset">reset</a>，传入的属性会被自动转换为适合的模型类型。
    </p>

<pre>
var Library = Backbone.Collection.extend({
  model: Book
});
</pre>

    <p id="Collection-constructor">
      <b class="header">constructor / initialize</b><code>new Collection([models], [options])</code>
      <br />
	  当创建集合时，你可以选择传入初始的 <b>模型</b> 数组。集合的 <a href="index.html#Collection-comparator">comparator</a> 函数也可以作为选项传入。
	  如果定义了 <b>initialize</b> 函数，会在集合创建时被调用。
    </p>

<pre>
var tabs = new TabSet([tab1, tab2, tab3]);
</pre>

    <p id="Collection-models">
      <b class="header">models</b><code>collection.models</code>
      <br />
	  访问集合中模型的原始值。通常我们使用 <tt>get</tt>，<tt>at</tt>，或 <b>Underscore方法</b> 访问模型对象，但偶尔也需要直接访问。
    </p>

    <p id="Collection-toJSON">
      <b class="header">toJSON</b><code>collection.toJSON()</code>
      <br />
	  返回集合中包含的每个模型对象的数组。可用于集合的序列化和持久化。本方法名称容易引起混淆，因为它与
      <a href="https://developer.mozilla.org/en/JSON#toJSON()_method" target="_blank">JavaScript's JSON API</a> 命名相同.
    </p>

<pre class="runnable">
var collection = new Backbone.Collection([
  {name: "Tim", age: 5},
  {name: "Ida", age: 26},
  {name: "Rob", age: 55}
]);

alert(JSON.stringify(collection));
</pre>

    <p id="Collection-Underscore-Methods">
      <b class="header">Underscore 方法 (26)</b>
      <br />
	  Backbone 代理了 <b>Underscore.js</b> 从而为 <b>Backbone.Collection</b> 提供了26个迭代函数。这里没有列出这些函数的使用方法，你可以点击链接前往查看：
    </p>

    <ul>
      <li><a href="http://documentcloud.github.com/underscore/#each" target="_blank">forEach (each)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#map" target="_blank">map</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#reduce" target="_blank">reduce (foldl, inject)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#reduceRight" target="_blank">reduceRight (foldr)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#detect" target="_blank">find (detect)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#select" target="_blank">filter (select)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#reject" target="_blank">reject</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#all" target="_blank">every (all)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#any" target="_blank">some (any)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#include" target="_blank">include</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#invoke" target="_blank">invoke</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#max" target="_blank">max</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#min" target="_blank">min</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#sortBy" target="_blank">sortBy</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#groupBy" target="_blank">groupBy</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#sortedIndex" target="_blank">sortedIndex</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#toArray" target="_blank">toArray</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#size" target="_blank">size</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#first" target="_blank">first</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#rest" target="_blank">rest</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#last" target="_blank">last</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#without" target="_blank">without</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#indexOf" target="_blank">indexOf</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#lastIndexOf" target="_blank">lastIndexOf</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#isEmpty" target="_blank">isEmpty</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#chain" target="_blank">chain</a></li>
    </ul>

<pre>
Books.each(function(book) {
  book.publish();
});

var titles = Books.map(function(book) {
  return book.get("title");
});

var publishedBooks = Books.filter(function(book) {
  return book.get("published") === true;
});

var alphabetical = Books.sortBy(function(book) {
  return book.author.get("name").toLowerCase();
});
</pre>

    <p id="Collection-add">
      <b class="header">add</b><code>collection.add(models, [options])</code>
      <br />
	  向集合中增加模型（或模型数组）。默认会触发 <tt>"add"</tt> 事件，可以传入 <tt>{silent : true}</tt> 关闭。
	  如果定义了 <a href="index.html#Collection-model">模型</a> 属性，也可以传入原始的属性对象让其看起来像一个模型实例。
	  传入 <tt>{at: index}</tt> 可以将模型插入集合中特定的位置。
    </p>

<pre class="runnable">
var ships = new Backbone.Collection;

ships.bind("add", function(ship) {
  alert("Ahoy " + ship.get("name") + "!");
});

ships.add([
  {name: "Flying Dutchman"},
  {name: "Black Pearl"}
]);
</pre>

    <p id="Collection-remove">
      <b class="header">remove</b><code>collection.remove(models, [options])</code>
      <br />
	  从集合中删除模型（或模型数组）。会触发 <tt>"remove"</tt> 事件，同样可以使用 <tt>silent</tt> 关闭。
    </p>

    <p id="Collection-get">
      <b class="header">get</b><code>collection.get(id)</code>
      <br />
	  返回集合中 id 为 <b>id</b> 的模型。
    </p>

<pre>
var book = Library.get(110);
</pre>

    <p id="Collection-getByCid">
      <b class="header">getByCid</b><code>collection.getByCid(cid)</code>
      <br />
	  通过指定客户id返回集合中的模型。客户id是指模型创建时自动生成的 <tt>.cid</tt> 属性。在模型尚未保存到服务器时其还没有id值，所以通过cid获取模型很有用处。
    </p>

    <p id="Collection-at">
      <b class="header">at</b><code>collection.at(index)</code>
      <br />
	  返回集合中指定索引的模型对象。不论你是否对模型进行了重新排序， <b>at</b> 始终返回其在集合中插入时的索引值。
    </p>

    <p id="Collection-length">
      <b class="header">length</b><code>collection.length</code>
      <br />
	  与数组类似，集合拥有 <tt>length</tt> 属性，返回该集合拥有的模型数量。
    </p>

    <p id="Collection-comparator">
      <b class="header">comparator</b><code>collection.comparator</code>
      <br />
	  默认情况下，集合没有声明 <b>comparator</b> 函数。如果定义了该函数，集合中的模型会按照指定的算法进行排序。
	  换言之，模型被增加的同时会插入适合的位置。Comparator接收模型作为参数，返回数值或字符串作为相对其它模型的排序依据。
    </p>

    <p>
	  注意即使下面例子中的章节是后加入集合中的，但它们都会遵循正确的排序：
    </p>

<pre class="runnable">
var Chapter  = Backbone.Model;
var chapters = new Backbone.Collection;

chapters.comparator = function(chapter) {
  return chapter.get("page");
};

chapters.add(new Chapter({page: 9, title: "The End"}));
chapters.add(new Chapter({page: 5, title: "The www.csser.com"}));
chapters.add(new Chapter({page: 1, title: "The Beginning"}));

alert(chapters.pluck('title'));
</pre>

    <p class="warning">
	  说明：comparator 函数与 Javascript 的 "sort" 并不相同，后者必须返回 <tt>0</tt>, <tt>1</tt>, 或 <tt>-1</tt>, 前者则更像 <tt>sortBy</tt> &mdash; 一个更友好的API。
    </p>

    <p id="Collection-sort">
      <b class="header">sort</b><code>collection.sort([options])</code>
      <br />
	  强制对集合进行重排序。一般情况下不需要调用本函数，因为 <a href="index.html#Collection-comparator">comparator</a> 函数会实时排序。
	  如果不指定 <tt>{silent: true}</tt> ，调用 <b>sort</b> 会触发集合的 <tt>"reset"</tt> 事件。
    </p>

    <p id="Collection-pluck">
      <b class="header">pluck</b><code>collection.pluck(attribute)</code>
      <br />
	  从集合中的每个模型拉取 <tt>attribute</tt>。等价于调用 <tt>map</tt>，并从迭代器中返回单个属性。
    </p>

<pre class="runnable">
var stooges = new Backbone.Collection([
	new Backbone.Model({name: "Curly"}),
	new Backbone.Model({name: "Larry"}),
	new Backbone.Model({name: "Moe"})
]);

var names = stooges.pluck("name");

alert(JSON.stringify(names));
</pre>

    <p id="Collection-url">
      <b class="header">url</b><code>collection.url or collection.url()</code>
      <br />
	  设置 <b>url</b> 属性（或函数）以指定集合对应的服务器位置。集合内的模型使用 <b>url</b> 构造自身的 URLs。
    </p>

<pre>
var Notes = Backbone.Collection.extend({
  url: '/notes'
});

// 或者，更复杂一些的方式：

var Notes = Backbone.Collection.extend({
  url: function() {
    return this.document.url() + '/notes';
  }
});
</pre>

    <p id="Collection-parse">
      <b class="header">parse</b><code>collection.parse(response)</code>
      <br />
	  每一次调用 <a href="index.html#Collectionfetch">fetch</a> 从服务器拉取集合的模型数据时，<b>parse</b>都会被调用。
	  本函数接收原始 <tt>response</tt> 对象，返回可以 <a href="index.html#Collection-add">add</a> 到集合的模型属性数组。
	  默认实现是无需操作的，只需简单传入服务端返回的JSON对象。
	  如果需要处理遗留API，或者在返回数据定义自己的命名空间，可以重写本函数。
    </p>

<pre>
var Tweets = Backbone.Collection.extend({
	// Twitter 搜索 API 在 "result" 键下返回 tweets
	parse: function(response) {
		return response.results;
	}
});
</pre>

    <p id="Collection-fetch">
      <b class="header">fetch</b><code>collection.fetch([options])</code>
      <br />
	  从服务器拉取集合的默认模型，成功接收数据后会重置（reset）集合。
	  <b>options</b> 支持 <tt>success</tt> 和 <tt>error</tt> 回调函数，回调函数接收 <tt>(collection, response)</tt> 作为参数。
	  可以委托 <a href="index.html#Sync">Backbone.sync</a> 在随后处理个性化需求。
	  处理 <b>fetch</b> 请求的服务器应当返回模型的 <tt>JSON</tt> 数组。
    </p>

<pre class="runnable">
Backbone.sync = function(method, model) {
  alert(method + ": " + model.url);
};

var Accounts = new Backbone.Collection;
Accounts.url = '/accounts';

Accounts.fetch();
</pre>

    <p>
	  如果希望向当前集合追加模型数据而不是替换，传入 <tt>{add: true}</tt> 作为 <b>fetch</b> 的参数。
    </p>

    <p>
	  <b>fetch</b> 的参数可以支持直接传入 <b>jQuery.ajax</b> 作为参数，所以拉取指定页码的集合数据可以这样写：。
      <tt>Documents.fetch({data: {page: 3}})</tt>
    </p>

    <p>
	  不建议在页面加载完毕时利用 <b>fetch</b> 拉取并填充集合数据 &mdash; 所有页面初始数据应当在 <a href="index.html#FAQ-bootstrap">bootstrapped</a> 时已经就绪。
	  <b>fetch</b> 适用于惰性加载不需立刻展现的模型数据。
    </p>

    <p id="Collection-reset">
      <b class="header">reset</b><code>collection.reset(models, [options])</code>
      <br />
	  每次一个的向集合做增删操作已经很好了，但有时会有很多的模型变化以至于需要对集合做大批量的更新操作。
	  利用 <b>reset</b> 可将集合替换为新的模型（或键值对象），结束后触发 <tt>"reset"</tt> 事件。
	  传入 <tt>{silent: true}</tt> 忽略 <tt>"reset"</tt> 事件的触发。
	  不传入任何参数将清空整个集合。
    </p>

    <p>
	  这里有一个在页面加载完毕后 <b>reset</b> 初始启动集合的例子：
    </p>

<pre>
&lt;script&gt;
	Accounts.reset(&lt;%= @csser.to_json %&gt;);
&lt;/script&gt;
</pre>


    <p id="Collection-create">
      <b class="header">create</b><code>collection.create(attributes, [options])</code>
      <br />
	  在集合中创建一个模型。
	  等价于用键值对象实例一个模型，然后将模型保存到服务器，保存成功后将模型增加到集合中。
	  如果验证失败会阻止模型创建，返回 <tt>false</tt>，否则返回该模型。
	  为了能正常运行，需要在集合中设置 <a href="index.html#Collection-model">model</a> 属性。
	  <b>create</b> 方法接收键值对象或者已经存在尚未保存的模型对象作为参数。
    </p>

<pre>
var Library = Backbone.Collection.extend({
	model: Book
});

var NYPL = new Library;

var othello = NYPL.create({
	title: "Backbone.js API 中文手册",
	author: "一回（www.csser.com）"
});
</pre>

    <h2 id="Router">Backbone.Router</h2>

    <p>
	   web应用程序通常需要为应用的重要位置提供可链接，可收藏，可分享的 URLs。
	   直到最近， 猫点（hash）片段（<tt>#page</tt>）可以被用来提供这种链接，
	   同时随着 History API 的到来，猫点已经可以用于处理标准 URLs （<tt>/page</tt>）。
	   <b>Backbone.Router</b> 为客户端路由提供了许多方法，并能连接到指定的动作（actions）和事件（events）。
	   对于不支持 History API 的旧浏览器，路由提供了优雅的回调函数并可以透明的进行 URL 片段的转换。
    </p>

    <p>
	  页面加载期间，当应用已经创建了所有的路由，需要调用 <tt>Backbone.history.start()</tt>，或 <tt>Backbone.history.start({pushState : true})</tt> 来确保驱动初始化 URL 的路由。
    </p>

    <p id="Router-extend">
      <b class="header">extend</b><code>Backbone.Router.extend(properties, [classProperties])</code>
      <br />
	  创建一个自定义的路由类。
	  可以通过 <a href="index.html#Router-routes">routes</a> 定义路由动作键值对，当匹配了 URL 片段便执行定义的动作。
    </p>

<pre>
var Workspace = Backbone.Router.extend({

  routes: {
    "help":                 "help",    // #help
    "search/:query":        "search",  // #search/kiwis
    "search/:query/p:page": "search"   // #search/kiwis/p7
  },

  help: function() {
    ...
  },

  search: function(query, page) {
    ...
  }

});
</pre>

    <p id="Router-routes">
      <b class="header">routes</b><code>router.routes</code>
      <br />
	  routes 将带参数的 URLs 映射到路由实例的方法上，这与 <a href="index.html#View">视图</a> 的 <a href="index.html#View-delegateEvents">事件键值对</a> 非常类似。
	  路由可以包含参数，<tt>:param</tt>，它在斜线之间匹配 URL 组件。
	  路由也支持通配符，<tt>*splat</tt>，可以匹配多个 URL 组件。
    </p>

    <p>
	  举个例子，路由 <tt>"search/:query/p:page"</tt> 能匹配 <tt>#search/obama/p2</tt> , 这里传入了 <tt>"obama"</tt> 和 <tt>"2"</tt> 到路由对应的动作中去了。
	  <tt>"file/*path</tt> 路由可以匹配 <tt>#file/nested/folder/file.txt</tt>，这时传入动作的参数为 <tt>"nested/folder/file.txt"</tt>。
    </p>

    <p>
	  当访问者点击浏览器后退按钮，或者输入 URL ，如果匹配一个路由，此时会触发一个基于动作名称的 <a href="index.html#Events">事件</a>，
	  其它对象可以监听这个路由并接收到通知。
	  下面的示例中，用户访问 <tt>#help/uploading</tt> 将从路由中触发 <tt>route:help</tt> 事件。
    </p>

<pre>
routes: {
  "help/:page":         "help",
  "download/*path":     "download",
  "folder/:name":       "openFolder",
  "folder/:name-:mode": "openFolder"
}
</pre>

<pre>
router.bind("route:help", function(page) {
  ...
});
</pre>

    <p id="Router-constructor">
      <b class="header">constructor / initialize</b><code>new Router([options])</code>
      <br />
	  实例化一个路由对象，你可以直接传入 <a href="index.html#Router-routes">routes</a> 键值对象作为参数。
	  如果定义该参数， 它们将被传入 <tt>initialize</tt> 构造函数中初始化。
    </p>

    <p id="Router-route">
      <b class="header">route</b><code>router.route(route, name, callback)</code>
      <br />
	  为路由对象手动创建路由，<tt>route</tt> 参数可以是 <a href="index.html#Router-routes">路由字符串</a> 或 正则表达式。
	  每个捕捉到的被传入的路由或正则表达式，都将作为参数传入回调函数（callback）。
	  一旦路由匹配，<tt>name</tt> 参数会触发 <tt>"route:name"</tt> 事件。
    </p>

<pre>
initialize: function(options) {

  // 匹配 #page/10, 传入回调函数 "10"
  this.route("page/:number", "page", function(number){ ... });

  // 匹配 /csser.com/b/c/open, 传入回调函数 "csser.com/b/c"
  this.route(/^(.*?)\/open$/, "open", function(id){ ... });

}
</pre>

    <p id="Router-navigate">
      <b class="header">navigate</b><code>router.navigate(fragment, [triggerRoute])</code>
      <br />
	  手动到达应用程序中的某个位置。
	  传入 <b>triggerRoute</b> 以执行路由动作函数。
    </p>

<pre>
openPage: function(pageNumber) {
  this.document.pages.at(pageNumber).open();
  this.navigate("page/" + pageNumber);
}

# 或者 ...

app.navigate("help/troubleshooting", true);
</pre>

    <h2 id="History">Backbone.history</h2>

    <p>
	  <b>History</b> 作为全局路由服务用于处理 <tt>hashchange</tt> 事件或 <tt>pushState</tt>，匹配适合的路由，并触发回调函数。
	  我们不需要自己去做这些事情 &mdash; 如果使用带有键值对的 <a href="index.html#Router">路由</a>，<tt>Backbone.history</tt> 会被自动创建。
    </p>

    <p>
	  Backbone 会自动判断浏览器对 <b>pushState</b> 的支持，以做内部的选择。
	  不支持 <tt>pushState</tt> 的浏览器将会继续使用基于猫点的 URL 片段，
	  如果兼容 <tt>pushState</tt> 的浏览器访问了某个 URL 猫点，将会被透明的转换为真实的 URL。
	  注意使用真实的 URLs 需要 web 服务器支持直接渲染那些页面，因此后端程序也需要做修改。
	  例如，如果有这样一个路由 <tt>/document/100</tt>，如果浏览器直接访问它， web 服务器必须能够处理该页面。
	  趋于对搜索引擎爬虫的兼容，让服务器完全为该页面生成静态 HTML 是非常好的做法 ...
	  但是如果要做的是一个 web 应用，只需要利用 Javascript 和 Backbone 视图将服务器返回的 REST 数据渲染就很好了。
    </p>

    <p id="History-start">
      <b class="header">start</b><code>Backbone.history.start([options])</code>
      <br />
	  当所有的 <a href="index.html#Router">路由</a> 创建并设置完毕，调用 <tt>Backbone.history.start()</tt> 开始监控 <tt>hashchange</tt> 事件并分配路由。
    </p>

    <p>
	  需要指出的是，如果想在应用中使用 HTML5 支持的 <tt>pushState</tt>，只需要这样做：<tt>Backbone.history.start({pushState : true})</tt> 。
    </p>

    <p>
	  如果应用不是基于域名的根路径 <tt>/</tt>，需要告诉 History 基于什么路径：
      <tt>Backbone.history.start({pushState: true, root: "/public/search/"})</tt>
    </p>

    <p>
	  当执行后，如果某个路由成功匹配当前 URL，<tt>Backbone.history.start()</tt> 返回 <tt>true</tt>。
	  如果没有定义的路由匹配当前 URL，返回 <tt>false</tt>。
    </p>

    <p>
	  如果服务器已经渲染了整个页面，但又不希望开始 History 时触发初始路由，传入 <tt>silent : true</tt> 即可。
    </p>

<pre>
$(function(){
  new WorkspaceRouter();
  new HelpPaneRouter();
  Backbone.history.start({pushState: true});
});
</pre>

    <h2 id="Sync">Backbone.sync</h2>

    <p>
	  <b>Backbone.sync</b> 是 Backbone 每次向服务器读取或保存模型时都要调用执行的函数。
	  默认情况下，它使用 <tt>(jQuery/Zepto).ajax</tt> 方法发送 RESTful json 请求。
	  如果想采用不同的持久化方案，比如 WebSockets, XML, 或 Local Storage，我们可以重载该函数。
    </p>

    <p>
	  <b>Backbone.sync</b> 的语法为 <tt>sync(method, model, [options])</tt>。
    </p>

    <ul>
      <li><b>method</b> – CRUD 方法 (<tt>"create"</tt>, <tt>"read"</tt>, <tt>"update"</tt>, 或 <tt>"delete"</tt>)</li>
      <li><b>model</b> – 要被保存的模型（或要被读取的集合）</li>
      <li><b>options</b> – 成功和失败的回调函数，以及所有 jQuery 请求支持的选项</li>
    </ul>

    <p>
	  默认情况下，当 <b>Backbone.sync</b> 发送请求以保存模型时，其属性会被序列化为 JSON，并以 <tt>application/json</tt> 的内容类型发送。
	  当接收到来自服务器的 JSON 响应后，对经过服务器改变的模型进行拆解，然后在客户端更新。
	  当 <tt>"read"</tt> 请求从服务器端响应一个集合（<a href="index.html#Collection#fetch">Collection#fetch</a>）时，便拆解模型属性对象的数组。
    </p>

    <p>
	  默认 <b>sync</b> 映射 REST 风格的 CRUD 类似下面这样：
    </p>

    <ul>
      <li><b>create &rarr; POST &nbsp; </b><tt>/collection</tt></li>
      <li><b>read &rarr; GET &nbsp; </b><tt>/collection[/id]</tt></li>
      <li><b>update &rarr; PUT &nbsp; </b><tt>/collection/id</tt></li>
      <li><b>delete &rarr; DELETE &nbsp; </b><tt>/collection/id</tt></li>
    </ul>


    <p id="Sync-emulateHTTP">
      <b class="header">emulateHTTP</b><code>Backbone.emulateHTTP = true</code>
      <br />
	  老的浏览器不支持 Backbone 默认的 REST/HTTP，此时可以开启 <tt>Backbone.emulateHTTP</tt> 。
	  设置该选项将通过 <tt>POST</tt> 方法伪造 <tt>PUT</tt> 和 <tt>DELETE</tt> 请求，此时该请求会向服务器传入名为 <tt>_method</tt> 的参数。
	  设置该选项同时也会向服务器发送 <tt>X-HTTP-Method-Override</tt> 头。
    </p>

<pre>
Backbone.emulateHTTP = true;

model.save();  // POST 到 "/collection/id", 附带 "_method=PUT" + header.
</pre>

    <p id="Sync-emulateJSON">
      <b class="header">emulateJSON</b><code>Backbone.emulateJSON = true</code>
      <br />
	  同样老的浏览器也不支持发送 <tt>application/json</tt> 编码的请求，
	  设置 <tt>Backbone.emulateJSON = true;</tt> 后 JSON 模型会被序列化为 <tt>model</tt> 参数，
	  请求会按照 <tt>application/x-www-form-urlencoded</tt> 的内容类型发送，就像提交表单一样。
    </p>

    <h2 id="View">Backbone.View</h2>

    <p>
	  Backbone 视图的使用相当方便 &mdash; 它不会影响任何的 HTML 或 CSS 代码，并且可以与任意 Javascript 模板引擎兼容。
	  基本的做法就是，将界面组织到逻辑视图，之后是模型，当模型数据发生改变，视图立刻自动更新，这一切都不需要重绘页面。
	  我们再也不必钻进 JSON 对象中，查找 DOM 元素，手动更新 HTML 了，通过绑定视图的 <tt>render</tt> 函数到模型的 <tt>"change"</tt> 事件 &mdash; 模型数据会即时的显示在 UI 中。
    </p>

    <p id="View-extend">
      <b class="header">extend</b><code>Backbone.View.extend(properties, [classProperties])</code>
      <br />
	  创建自定义的视图类。
	  通常我们需要重载 <a href="index.html#View-render">render</a> 函数，声明 <a href="index.html#View-delegateEvents">事件</a>，
	  以及通过 <tt>tagName</tt>，<tt>className</tt>，或 <tt>id</tt> 为视图指定根元素。
    </p>

<pre>
var DocumentRow = Backbone.View.extend({

  tagName: "li",

  className: "document-row",

  events: {
    "click .icon":          "open",
    "click .button.edit":   "openEditDialog",
    "click .button.delete": "destroy"
  },

  render: function() {
    ...
  }

});
</pre>

    <p id="View-constructor">
      <b class="header">constructor / initialize</b><code>new View([options])</code>
      <br />
	  每次实例化一个视图时，传入的选项参数会被注册到 <tt>this.options</tt> 中以备后用。
	  这里有多个特殊的选项，如果传入，则直接注册到视图中去：
      <tt>model</tt>, <tt>collection</tt>,
      <tt>el</tt>, <tt>id</tt>, <tt>className</tt>, 以及 <tt>tagName</tt>.
	  如果视图定义了 <b>initialize</b> 函数，当视图实例化时该函数便立刻执行。
	  如果希望创建一个指向 DOM 中已存在的元素的视图，传入该元素作为选项：
      <tt>new View({el: existingElement})</tt>
    </p>

<pre>
var doc = Documents.first();

new DocumentRow({
  model: doc,
  id: "document-row-" + doc.id
});
</pre>

    <p id="View-el">
      <b class="header">el</b><code>view.el</code>
      <br />
	  所有的视图都拥有一个 DOM 元素（<b>el</b> 属性），即使该元素仍未插入页面中去。
	  视图可以在任何时候渲染，然后一次性插入 DOM 中去，这样能尽量减少 reflows 和 repaints 从而获得高性能的 UI 渲染。
	  <tt>this.el</tt> 可以从视图的 <tt>tagName</tt>，<tt>className</tt>，以及 <tt>id</tt> 属性创建，如果都未指定，<b>el</b> 会是一个空 <tt>div</tt>。
    </p>

    <p>
	  如果希望将 <b>el</b> 赋给页面 DOM 中已经存在的元素，直接设置其值为真实的 DOM 元素或 CSS 选择符字符串。
    </p>

<pre class="runnable">
var ItemView = Backbone.View.extend({
  tagName: 'li'
});

var BodyView = Backbone.View.extend({
  el: 'body'
});

var item = new ItemView();
var body = new BodyView();

alert(item.el + ' ' + body.el);
</pre>

    <p id="View-dollar">
      <b class="header">$ (jQuery 或 Zepto)</b><code>view.$(selector)</code>
      <br />
	  如果页面中引入了 jQuery 或 Zepto ，每个视图都将拥有 <b>$</b> 函数，可以在视图元素查询作用域内运行。
	  如果使用该作用域内的 jQuery 函数，就不需要从列表中指定的元素获取模型的 ids 这种查询了，我们可以更多的依赖 HTML class 属性。
	  它等价于运行：<tt>$(selector, this.el)</tt>。
    </p>

<pre>
ui.Chapter = Backbone.View.extend({
  serialize : function() {
    return {
      title: this.$(".title").text(),
      start: this.$(".start-page").text(),
      end:   this.$(".end-page").text()
    };
  }
});
</pre>

    <p id="View-render">
      <b class="header">render</b><code>view.render()</code>
      <br />
	  <b>render</b> 默认实现是没有操作的。
	  重载本函数可以实现从模型数据渲染视图模板，并可用新的 HTML 更新 <tt>this.el</tt>。
	  推荐的做法是在 <b>render</b> 函数的末尾 <tt>return this</tt> 以开启链式调用。
    </p>

<pre>
var Bookmark = Backbone.View.extend({
  render: function() {
    $(this.el).html(this.template(this.model.toJSON()));
    return this;
  }
});
</pre>

    <p>
	  Backbone 并不知道开发者使用何种模板引擎。
	  <b>render</b> 函数中可以采用拼字符串，或者利用 <tt>document.createElement</tt> 创建 DOM 树等等。
	  但还是建议选择一个好的 Javascript 模板引擎。
      <a href="http://github.com/janl/mustache.js" target="_blank">Mustache.js</a>,
      <a href="http://github.com/creationix/haml-js" target="_blank">Haml-js</a>, 以及
      <a href="http://github.com/sstephenson/eco" target="_blank">Eco</a> 都是很好的选择。
      因为 <a href="http://documentcloud.github.com/underscore/" target="_blank">Underscore.js</a> 已经引入页面了，
      所以为了防止 XSS 攻击带给数据的安全威胁，<a href="http://documentcloud.github.com/underscore/#template" target="_blank">_.template</a> 可以使用并是一个很好的选择。
    </p>

    <p>
	  无论基于什么考虑，都永远不要在 Javascript 中拼接 HTML 字符串。
    </p>

    <p id="View-remove">
      <b class="header">remove</b><code>view.remove()</code>
      <br />
	  从 DOM 中移除视图。它等价与下面的语句：
      <tt>$(view.el).remove();</tt>
    </p>

    <p id="View-make">
      <b class="header">make</b><code>view.make(tagName, [attributes], [content])</code>
      <br />
	  借助给定的元素类型（<b>tagName</b>），以及可选的 attributes 和 HTML 内容创建 DOM 元素。
	  通常用于内部创建初始的 <tt>view.el</tt>。
    </p>

<pre class="runnable">
var view = new Backbone.View;

var el = view.make("b", {className: "bold"}, "Bold! ");

$("#make-demo").append(el);
</pre>

<div id="make-demo"></div>

    <p id="View-delegateEvents">
      <b class="header">delegateEvents</b><code>delegateEvents([events])</code>
      <br />
	  采用 jQuery 的<tt>delegate</tt> 函数来为视图内的 DOM 事件提供回调函数声明。
	  如果未传入 <b>events</b> 对象，使用 <tt>this.events</tt> 作为事件源。
	  事件对象的书写格式为 <tt>{"event selector" : "callback"}</tt>。
	  省略 <tt>selector</tt> 则事件被绑定到视图的根元素（<tt>this.el</tt>）。
	  默认情况下，<tt>delegateEvents</tt> 会在视图的构造函数内被调用，因此如果有 <tt>events</tt> 对象，所有的 DOM 事件已经被连接，
	  并且我们永远不需要去手动调用本函数。
    </p>

    <p>
	  <tt>events</tt> 属性也可以被定义成返回 <b>events</b> 对象的函数，这样让我们定义事件，以及实现事件的继承变得更加方便。
    </p>

    <p>
	  视图 <a href="index.html#View-render">渲染</a> 期间使用 <b>delegateEvents</b> 相比用 jQuery 向子元素绑定事件有更多优点。
	  所有注册的函数在传递给 jQuery 之前已被绑定到视图上，因此当回调函数执行时，<tt>this</tt> 仍将指向视图对象。
	  当 <b>delegateEvents</b> 再次运行，此时或许需要一个不同的 <tt>events</tt> 对象，所以所有回调函数将被移除，然后重新委托 &mdash; 
	  这对模型不同行为也不同的视图挺有用处。
    </p>

    <p>
	  搜索结果页面显示文档的视图看起来类似这样：
    </p>

<pre>
var DocumentView = Backbone.View.extend({

  events: {
    "dblclick"                : "open",
    "click .icon.doc"         : "select",
    "contextmenu .icon.doc"   : "showMenu",
    "click .show_notes"       : "toggleNotes",
    "click .title .lock"      : "editAccessLevel",
    "mouseover .title .date"  : "showTooltip"
  },

  render: function() {
    $(this.el).html(this.template(this.model.toJSON()));
    return this;
  },

  open: function() {
    window.open(this.model.get("viewer_url"));
  },

  select: function() {
    this.model.set({selected: true});
  },

  ...

});
</pre>

    <h2 id="Utility">Utility Functions</h2>

    <p>

    </p>

    <p id="Utility-noConflict">
      <b class="header">noConflict</b><code>var backbone = Backbone.noConflict();</code>
      <br />
	  返回 <tt>Backbone</tt> 对象的原始值。通常用于在第三方网站上引入了多个 Backbone 文件，避免冲突。
    </p>

<pre>
var localBackbone = Backbone.noConflict();
var model = localBackbone.Model.extend(...);
</pre>


<!--     <h2 id="faq">常见问题</h2>
   - 
   -     <p id="FAQ-events">
   -       <b class="header">事件分类</b>
   -       <br />
   -       Here's a list of all of the built-in events that Backbone.js can fire.
   -       You're also free to trigger your own events on Models and Views as you
   -       see fit.
   -     </p>
   - 
   -     <ul>
   -       <li><b>"add"</b> (model, collection) &mdash; when a model is added to a collection. </li>
   -       <li><b>"remove"</b> (model, collection) &mdash; when a model is removed from a collection. </li>
   -       <li><b>"reset"</b> (collection) &mdash; when the collection's entire contents have been replaced. </li>
   -       <li><b>"change"</b> (model, collection) &mdash; when a model's attributes have changed. </li>
   -       <li><b>"change:[attribute]"</b> (model, collection) &mdash; when a specific attribute has been updated. </li>
   -       <li><b>"destroy"</b> (model, collection) &mdash; when a model is <a href="#Model-destroy">destroyed</a>. </li>
   -       <li><b>"error"</b> (model, collection) &mdash; when a model's validation fails, or a <a href="#Model-save">save</a> call fails on the server. </li>
   -       <li><b>"route:[name]"</b> (router) &mdash; when one of a router's routes has matched. </li>
   -       <li><b>"all"</b> &mdash; this special event fires for <i>any</i> triggered event, passing the event name as the first argument. </li>
   -     </ul>
   - 
   -     <p id="FAQ-tim-toady">
   -       <b class="header">通过不止一种方式来实现</b>
   -       <br />
   -       It's common for folks just getting started to treat the examples listed
   -       on this page as some sort of gospel truth. In fact, Backbone.js is intended
   -       to be fairly agnostic about many common patterns in client-side code.
   -       For example...
   -     </p>
   - 
   -     <p>
   -       <b>References between Models and Views</b> can be handled several ways.
   -       Some people like to have direct pointers, where views correspond 1:1 with
   -       models (<tt>model.view</tt> and <tt>view.model</tt>). Others prefer to have intermediate
   -       "controller" objects that orchestrate the creation and organization of
   -       views into a hierarchy. Others still prefer the evented approach, and always
   -       fire events instead of calling methods directly. All of these styles work well.
   -     </p>
   - 
   -     <p>
   -       <b>Batch operations</b> on Models are common, but often best handled differently
   -       depending on your server-side setup. Some folks don't mind making individual
   -       Ajax requests. Others create explicit resources for RESTful batch operations:
   -       <tt>/notes/batch/destroy?ids=1,2,3,4</tt>. Others tunnel REST over JSON, with the
   -       creation of "changeset" requests:
   -     </p>
   - 
   - <pre>
   -   {
   -     "create":  [array of models to create]
   -     "update":  [array of models to update]
   -     "destroy": [array of model ids to destroy]
   -   }
   - </pre>
   - 
   -     <p>
   -       <b>Feel free to define your own events.</b> <a href="#Events">Backbone.Events</a>
   -       is designed so that you can mix it in to any JavaScript object or prototype.
   -       Since you can use any string as an event, it's often handy to bind
   -       and trigger your own custom events: <tt>model.bind("selected:true")</tt> or
   -       <tt>model.bind("editing")</tt>
   -     </p>
   - 
   -     <p>
   -       <b>Render the UI</b> as you see fit. Backbone is agnostic as to whether you
   -       use <a href="http://documentcloud.github.com/underscore/#template">Underscore templates</a>,
   -       <a href="https://github.com/janl/mustache.js">Mustache.js</a>, direct DOM
   -       manipulation, server-side rendered snippets of HTML, or
   -       <a href="http://jqueryui.com/">jQuery UI</a> in your <tt>render</tt> function.
   -       Sometimes you'll create a view for each model ... sometimes you'll have a
   -       view that renders thousands of models at once, in a tight loop. Both can be
   -       appropriate in the same app, depending on the quantity of data involved,
   -       and the complexity of the UI.
   -     </p>
   - 
   -     <p id="FAQ-nested">
   -       <b class="header">嵌套模型和集合</b>
   -       <br />
   -       It's common to nest collections inside of models with Backbone. For example,
   -       consider a <tt>Mailbox</tt> model that contains many <tt>Message</tt> models.
   -       One nice pattern for handling this is have a <tt>this.messages</tt> collection
   -       for each mailbox, enabling the lazy-loading of messages, when the mailbox
   -       is first opened ... perhaps with <tt>MessageList</tt> views listening for
   -       <tt>"add"</tt> and <tt>"remove"</tt> events.
   -     </p>
   - 
   - <pre>
   - var Mailbox = Backbone.Model.extend({
   - 
   -   initialize: function() {
   -     this.messages = new Messages;
   -     this.messages.url = '/mailbox/' + this.id + '/messages';
   -     this.messages.bind("reset", this.updateCounts);
   -   },
   - 
   -   ...
   - 
   - });
   - 
   - var Inbox = new Mailbox;
   - 
   - // And then, when the Inbox is opened:
   - 
   - Inbox.messages.fetch();
   - </pre>
   - 
   -     <p>
   -       If you're looking for something more opinionated, there are a number of
   -       Backbone plugins that add sophisticated associations among models,
   -       <a href="https://github.com/documentcloud/backbone/wiki/Extensions%2C-Plugins%2C-Resources">available on the wiki</a>.
   -     </p>
   - 
   -     <p id="FAQ-bootstrap">
   -       <b class="header">加载启动模型</b>
   -       <br />
   -       When your app first loads, it's common to have a set of initial models that
   -       you know you're going to need, in order to render the page. Instead of
   -       firing an extra AJAX request to <a href="#Collection-fetch">fetch</a> them,
   -       a nicer pattern is to have their data already bootstrapped into the page.
   -       You can then use <a href="#Collection-reset">reset</a> to populate your
   -       collections with the initial data. At DocumentCloud, in the
   -       <a href="http://en.wikipedia.org/wiki/ERuby">ERB</a> template for the
   -       workspace, we do something along these lines:
   -     </p>
   - 
   - <pre>
   - &lt;script&gt;
   -   Accounts.reset(&lt;%= @accounts.to_json %&gt;);
   -   Projects.reset(&lt;%= @projects.to_json(:collaborators => true) %&gt;);
   - &lt;/script&gt;
   - </pre>
   - 
   -     <p id="FAQ-mvc">
   -       <b class="header">Backbone是如何处理复杂MVC的？</b>
   -       <br />
   -       Different implementations of the
   -       <a href="http://en.wikipedia.org/wiki/Model–View–Controller">Model-View-Controller</a>
   -       pattern tend to disagree about the definition of a controller. If it helps any, in
   -       Backbone, the <a href="#View">View</a> class can also be thought of as a
   -       kind of controller, dispatching events that originate from the UI, with
   -       the HTML template serving as the true view. We call it a View because it
   -       represents a logical chunk of UI, responsible for the contents of a single
   -       DOM element.
   -     </p>
   - 
   -     <p>
   -       Comparing the overall structure of Backbone to a server-side MVC framework
   -       like <b>Rails</b>, the pieces line up like so:
   -     </p>
   - 
   -     <ul>
   -       <li>
   -         <b>Backbone.Model</b> &ndash; Like a Rails model minus the class
   -         methods. Wraps a row of data in business logic.
   -       </li>
   -       <li>
   -         <b>Backbone.Collection</b> &ndash; A group of models on the client-side,
   -         with sorting/filtering/aggregation logic.
   -       </li>
   -       <li>
   -         <b>Backbone.Router</b> &ndash; Rails <tt>routes.rb</tt> + Rails controller
   -         actions. Maps URLs to functions.
   -       </li>
   -       <li>
   -         <b>Backbone.View</b> &ndash; A logical, re-usable piece of UI. Often,
   -         but not always, associated with a model.
   -       </li>
   -       <li>
   -         <b>Client-side Templates</b> &ndash; Rails <tt>.html.erb</tt> views,
   -         rendering a chunk of HTML.
   -       </li>
   -     </ul>
   - 
   -     <p id="FAQ-this">
   -       <b class="header">绑定"this"</b>
   -       <br />
   -       Perhaps the single most common JavaScript "gotcha" is the fact that when
   -       you pass a function as a callback, its value for <tt>this</tt> is lost. With
   -       Backbone, when dealing with <a href="#Events">events</a> and callbacks,
   -       you'll often find it useful to rely on
   -       <a href="http://documentcloud.github.com/underscore/#bind">_.bind</a> and
   -       <a href="http://documentcloud.github.com/underscore/#bindAll">_.bindAll</a>
   -       from Underscore.js.
   -     </p>
   - 
   -     <p>
   -       When binding callbacks to Backbone events, you can choose to pass an optional
   -       third argument to specify the <tt>this</tt> that will be used when the
   -       callback is later invoked:
   -     </p>
   - 
   - <pre>
   - var MessageList = Backbone.View.extend({
   - 
   -   initialize: function() {
   -     var messages = this.collection;
   -     messages.bind("reset", this.render, this);
   -     messages.bind("add", this.addMessage, this);
   -     messages.bind("remove", this.removeMessage, this);
   -   }
   - 
   - });
   - 
   - // Later, in the app...
   - 
   - Inbox.messages.add(newMessage);
   - </pre>
   -  -->

   <p>终于翻译完毕，感谢支持CSSer的朋友们的来信，感谢你们给出的翻译建议，谢谢。</p>

  </div>

  <script type="text/javascript" src="underscore.js.html"></script>
<script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-3448069-1");
        pageTracker._trackPageview();
    } catch(err) {
    }</script>
<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Ff8be45191941378fa9c93900b0d0be23' type='text/javascript'%3E%3C/script%3E"));
</script>
</body>
</html>
