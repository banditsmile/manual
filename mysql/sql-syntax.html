<html>

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 13. SQL Statement Syntax</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index-2.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index-2.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="functions.html" title="Chapter 12. Functions and Operators"><link rel="next" href="pluggable-storage.html" title="Chapter 14. Pluggable Storage Engine Architecture">
<style>
<!--
 table.MsoNormalTable
	{mso-style-parent:"";
	font-size:10.0pt;
	
	}
span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
span.GramE
	{}
-->
</style>
</head><body><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="sql-syntax"></a>
	第13章：SQL语句语法</h2></div></div></div><div class="toc"><p><b>
	目录</b></p><dl><dt><span class="section"><a href="sql-syntax.html#data-definition" >
			13.1. 数据定义语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#alter-database" >13.1.1. 
				ALTER DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table" >13.1.2. 
				ALTER TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database" >13.1.3. 
				CREATE DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index" >13.1.4. 
				CREATE INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table" >13.1.5. 
				CREATE TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database" >13.1.6. 
				DROP DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index" >13.1.7. 
				DROP INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table" >13.1.8. 
				DROP TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table" >13.1.9. 
				RENAME TABLE语法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#data-manipulation" >
			13.2. 数据操作语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#delete" >13.2.1. 
				DELETE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do" >13.2.2. 
				DO语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler" >13.2.3. 
				HANDLER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert" >13.2.4. 
				INSERT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data" >13.2.5. 
				LOAD DATA INFILE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace" >13.2.6. 
				REPLACE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select" >13.2.7. 
				SELECT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries" >
				13.2.8. Subquery语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate" >13.2.9. 
				TRUNCATE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update" >13.2.10. 
				UPDATE语法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#basic-user-commands" >
			13.3. MySQL实用工具语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#describe" >13.3.1. 
				DESCRIBE语法（获取有关列的信息）</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use" >13.3.2. 
				USE语法</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#transactional-commands" >
			13.4. MySQL事务处理和锁定语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#commit" >13.4.1. 
				START TRANSACTION, COMMIT和ROLLBACK语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#cannot-roll-back" >
				13.4.2. 不能回滚的语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#implicit-commit" >
				13.4.3. 会造成隐式提交的语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#savepoints" >13.4.4. 
				SAVEPOINT和ROLLBACK TO SAVEPOINT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#lock-tables" >13.4.5. 
				LOCK TABLES和UNLOCK TABLES语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-transaction" >13.4.6. 
				SET TRANSACTION语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#xa" >
				13.4.7. XA事务</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#database-administration-statements" >
			13.5. 数据库管理语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#account-management-sql" >
				13.5.1. 账户管理语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#table-maintenance-sql" >
				13.5.2. 表维护语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#set-option" >13.5.3. 
				SET语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#show" >13.5.4. 
				SHOW语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#other-administrative-sql" >
				13.5.5. 其它管理语句</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#replication-sql" >
			13.6. 复制语句</a></span></dt><dd><dl><dt><span class="section"><a href="sql-syntax.html#replication-master-sql" >
				13.6.1. 用于控制主服务器的SQL语句</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replication-slave-sql" >
				13.6.2. 用于控制从服务器的SQL语句</a></span></dt></dl></dd><dt><span class="section"><a href="sql-syntax.html#sqlps" >
			13.7. 用于预处理语句的SQL语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div>
		本章介绍了<span>SQL</span>语句的语法。<h2 class="title"><a name="data-definition"></a>
		13.1.&nbsp;数据定义语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#alter-database" >13.1.1. 
			ALTER DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#alter-table" >13.1.2. 
			ALTER TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-database" >13.1.3. 
			CREATE DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-index" >13.1.4. 
			CREATE INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#create-table" >13.1.5. 
			CREATE TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-database" >13.1.6. 
			DROP DATABASE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-index" >13.1.7. 
			DROP INDEX语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#drop-table" >13.1.8. 
			DROP TABLE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rename-table" >13.1.9. 
			RENAME TABLE语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-database"></a>13.1.1. ALTER 
			DATABASE语法</h3></div></div></div><a class="indexterm" name="id2890117"></a><a class="indexterm" name="id2890126"></a><a class="indexterm" name="id2890135"></a><a class="indexterm" name="id2890145"></a><a class="indexterm" name="id2890156"></a><a class="indexterm" name="id2890166"></a><pre class="programlisting">ALTER {DATABASE | SCHEMA} [<em class="replaceable">db_name</em>]
    <em class="replaceable">alter_specification</em> [, <em class="replaceable">alter_specification</em>] ...

<em class="replaceable">alter_specification</em>:
    [DEFAULT] CHARACTER SET <em class="replaceable">charset_name</em>
  | [DEFAULT] COLLATE <em class="replaceable">collation_name</em>
</pre>
			<p><span>ALTER DATABASE</span>用于更改数据库的全局特性。这些特性储存在数据库目录中的<span>db.opt</span>文件中。要使用<span>ALTER 
			DATABASE</span>，您需要获得数据库<span>ALTER</span>权限。</p>
			<p><span>CHARACTER SET</span>子句用于更改默认的数据库字符集。<span>COLLATE</span>子句用于更改默认的数据库整序。在<a href="charset.html" >第10章</a>：<a href="charset.html"  title="Chapter 10. Character Set Support"><i>字符集支持</i></a>中对字符集和整序名称进行了讨论。</p>
			<p>数据库名称可以忽略，此时，语句对应于默认数据库。也可以使用<span>ALTER SCHEMA</span>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="alter-table"></a>13.1.2. ALTER 
			TABLE语法</h3></div></div></div><a class="indexterm" name="id2890293"></a><a class="indexterm" name="id2890302"></a><a class="indexterm" name="id2890312"></a><pre class="programlisting">ALTER [IGNORE] TABLE <em class="replaceable">tbl_name</em>
    <em class="replaceable">alter_specification</em> [, <em class="replaceable">alter_specification</em>] ...

<em class="replaceable">alter_specification</em>:
    ADD [COLUMN] <em class="replaceable">column_definition</em> [FIRST | AFTER <em class="replaceable">col_name</em> ]
  | ADD [COLUMN] (<em class="replaceable">column_definition</em>,...)
  | ADD INDEX [<em class="replaceable">index_name</em>] [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        PRIMARY KEY [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        UNIQUE [<em class="replaceable">index_name</em>] [<em class="replaceable">index_type</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [FULLTEXT|SPATIAL] [<em class="replaceable">index_name</em>] (<em class="replaceable">index_col_name</em>,...)
  | ADD [CONSTRAINT [<em class="replaceable">symbol</em>]]
        FOREIGN KEY [<em class="replaceable">index_name</em>] (<em class="replaceable">index_col_name</em>,...)
        [<em class="replaceable">reference_definition</em>]
  | ALTER [COLUMN] <em class="replaceable">col_name</em> {SET DEFAULT <em class="replaceable">literal</em> | DROP DEFAULT}
  | CHANGE [COLUMN] <em class="replaceable">old_col_name</em> <em class="replaceable">column_definition</em>
        [FIRST|AFTER <em class="replaceable">col_name</em>]
  | MODIFY [COLUMN] <em class="replaceable">column_definition</em> [FIRST | AFTER <em class="replaceable">col_name</em>]
  | DROP [COLUMN] <em class="replaceable">col_name</em>
  | DROP PRIMARY KEY
  | DROP INDEX <em class="replaceable">index_name</em>
  | DROP FOREIGN KEY <em class="replaceable">fk_symbol</em>
  | DISABLE KEYS
  | ENABLE KEYS
  | RENAME [TO] <em class="replaceable">new_tbl_name</em>
  | ORDER BY <em class="replaceable">col_name</em>
  | CONVERT TO CHARACTER SET <em class="replaceable">charset_name</em> [COLLATE <em class="replaceable">collation_name</em>]
  | [DEFAULT] CHARACTER SET <em class="replaceable">charset_name</em> [COLLATE <em class="replaceable">collation_name</em>]
  | DISCARD TABLESPACE
  | IMPORT TABLESPACE
  | <em class="replaceable">table_options</em>
  | <em class="replaceable">partition_options</em>
  | ADD PARTITION <em class="replaceable">partition_definition</em>
  | DROP PARTITION <em class="replaceable">partition_names</em>
  | COALESCE PARTITION <em class="replaceable">number</em>
  | REORGANIZE PARTITION <em class="replaceable">partition_names</em> INTO (<em class="replaceable">partition_definitions</em>)
  | ANALYZE PARTITION <em class="replaceable">partition_names</em>
  | CHECK PARTITION <em class="replaceable">partition_names</em>
  | OPTIMIZE PARTITION <em class="replaceable">partition_names</em>
  | REBUILD PARTITION <em class="replaceable">partition_names</em>
  | REPAIR PARTITION <em class="replaceable">partition_names</em>
</pre>
			<p><span>ALTER TABLE</span>用于更改原有表的结构。例如，您可以增加或删减列，创建或取消索引，更改原有列的类型，或重新命名列或表。您还可以更改表的评注和表的类型。</p>
			<p>允许进行的变更中，许多子句的语法与<span>CREATE TABLE</span>中的子句的语法相近。其中包括<span><i><span>table_options</span></i>修改，选项有<span>ENGINE, 
			AUTO_INCREMENT</span>和<span>AVG_ROW_LENGTH</span>等。请见</span><a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
		TABLE语法”</a>。</p>
			<p>存储引擎不支持有些操作，如果进行这些操作，会出现警告。使用<span>SHOW WARNINGS</span>可以显示出这些警告。请参见<a href="sql-syntax.html#show-warnings"  title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22节，“SHOW 
		WARNINGS语法”</a>。</p>
			<p>如果您使用<span>ALTER TABLE</span>更改列规约，但是<span>DESCRIBE<span>
			<i>tbl_name</i></span></span><span>提示您列规约并没有改变，则可能是因为<span>MySQL</span>忽略了您所做的更改。忽略更改的原因见</span><a href="sql-syntax.html#silent-column-changes"  title="13.1.5.1. Silent Column Specification Changes">13.1.5.1节，“沉寂的列规格变更”</a><span>。例如，如果您试图把<span>VARCHAR</span>列更改为<span>CHAR</span>列，此时，如果表包含其它长度可变的列，则<span>MySQL</span>仍会使用<span>VARCHAR</span>。</span></p>
			<p><span>ALTER TABLE</span>运行时会对原表进行临时复制，在副本上进行更改，然后删除原表，再对新表进行重命名。在执行<span>ALTER 
			TABLE</span>时，其它用户可以阅读原表，但是对表的更新和修改的操作将被延迟，直到新表生成为止。新表生成后，这些更新和修改信息会自动转移到新表上。</p>
			<p>注意，如果您在执行<span>ALTER TABLE</span>时使用除了<span>RENAME</span>以外的选项，则<span>MySQL</span>会创建一个临时表。即使数据并不需要进行复制（例如当您更改列的名称时），<span>MySQL</span>也会这么操作。对于<span>MyISAM</span>表，您可以通过把<span><span>myisam_sort_buffer_size</span>系统变量设置到一个较高的值，来加快重新创建索引（该操作是变更过程中速度最慢的一部分）的速度。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>要使用<span>ALTER TABLE</span>，您需要获得表的<span>ALTER, 
			INSERT</span>和<span>CREATE</span>权限。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>IGNORE</span>是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。如果在新表中有重复关键字，或者当<span>STRICT</span>模式启动后出现警告，则使用<span>IGNORE</span>控制<span>ALTER 
			TABLE</span>的运行。如果没有指定<span>IGNORE</span>，当重复关键字错误发生时，复制操作被放弃，返回前一步骤。如果指定了<span>IGNORE</span>，则对于有重复关键字的行，只使用第一行，其它有冲突的行被删除。并且，对错误值进行修正，使之尽量接近正确值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以在一个<span>ALTER TABLE</span>语句里写入多个<span>ADD, 
			ALTER, DROP</span>和<span>CHANGE</span>子句，中间用逗号分开。这是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。在标准<span>SQL</span>中，每个<span>ALTER 
			TABLE</span>语句中每个子句只允许使用一次。例如，在一个语句中取消多个列：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CHANGE
			<i>col_name</i></span><span>,
			<span>DROP <i>col_name</i></span></span>和<span><span>DROP 
			INDEX</span>是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MODIFY</span>是<span>Oracle</span>对<span>ALTER 
			TABLE</span>的扩展。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COLUMN</span>只是自选项目，可以忽略。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span><span>ALTER 
			TABLE <i>tbl_name</i> RENAME TO <i>new_tbl_name</i></span>并且没有其它选项，则<span>MySQL</span>只对与</span><span>table
			<span><i>tbl_name</i></span></span><span>相对应的文件进行重命名。不需要创建一个临时表。（您也可以使用<span>RENAME 
			TABLE</span>语句对表进行重命名。请参见</span><a href="sql-syntax.html#rename-table"  title="13.1.9. RENAME TABLE Syntax">13.1.9节，“RENAME 
			TABLE语法”</a><span>。）</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			column_definition</span></i></span>子句使用与<span>CREATE TABLE</span>中的<span>ADD</span>和<span>CHANGE</span>子句相同的语法。注意，此语法包括列名称，而不只是列类型。请参见<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以使用<span><span>CHANGE
			<i>old_col_name</i> <i>column_definition</i></span>子句对列进行重命名。重命名时，需给定旧的和新的列名称和列当前的类型。例如：要把一个<span>INTEGER</span>列的名称从<span>a</span>变更到<span>b</span>，您需要如下操作：</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>ALTER TABLE t1 CHANGE a b INTEGER;</b></span></span></pre>
			<p>如果您想要更改列的类型而不是名称，<span> 
			CHANGE</span>语法仍然要求旧的和新的列名称，即使旧的和新的列名称是一样的。例如：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;</b></span></span></pre>
			<p>您也可以使用<span>MODIFY</span>来改变列的类型，此时不需要重命名：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 MODIFY b BIGINT NOT NULL;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>CHANGE</span>或<span>MODITY</span>缩短列长时，列中存在有索引，并且缩短后的列长小于索引长度，则<span>MySQL</span>会自动缩短索引的长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当您使用<span>CHANGE</span>或<span>MODIFY</span>更改列的类型时，<span>MySQL</span>会尽量把原有的列值转化为新的类型。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以使用<span>FIRST</span>或<span>AFTER
			<span><i>col_name</i></span></span><span>在一个表行中的某个特定位置添加列。默认把列添加到最后。您也可以在<span>CHANGE</span>或<span>MODIFY</span>语句中使用<span>FIRST</span>和<span>AFTER</span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>AFTER COLUMN</span>用于指定列的新默认值，或删除旧的默认值。如果旧的默认值被删除同时列值为<span>NULL</span>，则新的默认值为<span>NULL</span>。如果列值不能为<span>NULL</span>，<span>MySQL</span>会指定一个默认值，请参见<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DROP INDEX</span>用于取消索引。这是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。请参见<a href="sql-syntax.html#drop-index"  title="13.1.7. DROP INDEX Syntax">13.1.7节，“DROP 
			INDEX语法”</a>。 </p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果列从表中被取消了，则这些列也从相应的索引中被取消。如果组成一个索引的所有列均被取消，则该索引也被取消。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果一个表只包含一列，则此列不能被取消。如果您想要取消表，应使用<span>DROP 
			TABLE</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DROP PRIMAY DEY</span>用于取消主索引。注释：在<span>MySQL</span>较早的版本中，如果没有主索引，则<span>DROP 
			PRIMARY KEY</span>会取消表中的第一个<span>UNIQUE</span>索引。在<span>MySQL 
			5.1</span>中不会出现这种情况。如果在<span>MySQL 5.1</span>中对没有主键的表使用<span>DROP 
			PRIMARY KEY</span>，则会出现错误信息。</p>
			<p>如果您向表中添加<span>UNIQUE KEY</span>或<span>PRIMARY 
			KEY</span>，则<span>UNIQUE KEY</span>或<span>PRIMARY 
			KEY</span>会被储存在非唯一索引之前，这样<span>MySQL</span>就可以尽早地检查出重复关键字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ORDER BY</span>用于在创建新表时，让各行按一定的顺序排列。注意，在插入和删除后，表不会仍保持此顺序。当您知道多数情况下您会按照特定的顺序查询各行时，可以使用这个选项；在对表进行了大的改动后，通过使用此选项，您可以提高查询效率。在有些情况下，如果表按列排序，对于<span>MySQL</span>来说，排序可能会更简单。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您对一个<span>MyISAM</span>表使用<span>ALTER 
			TABLE</span>，则所有非唯一索引会被创建到一个单独的批里（和<span>REPAIR TABLE</span>相同）。当您有许多索引时，这样做可以使<span>ALTER 
			TABLE</span>的速度更快。</p>
			<p>这项功能可以明确激活。<span>ALTER 
			TABLE...DISABLE KEYS</span>让<span>MySQL</span>停止更新<span>MyISAM</span>表中的非唯一索引。然后使用<span><span>ALTER 
			TABLE ... ENABLE KEYS</span>重新创建丢失的索引。进行此操作时，<span>MySQL</span>采用一种特殊的算法，比一个接一个地插入关键字要快很多。因此，在进行成批插入操作前先使关键字禁用可以大大地加快速度。使用<span>ALTER 
			TABLE ... DISABLE KEYS</span>除了需要获得以前提到的权限以外，还需要获得<span>INDEX</span>权限。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>Innodb</span>存储引擎支持<span>FOREIGN 
			KEY</span>和<span>REFERENCES</span>子句。<span>Innodb</span>存储引擎执行<span>ADD 
			[CONSTRAINT [<i>symbol</i>]] FOREIGN KEY (...) REFERENCES ... (...)</span>。请参见<a href="storage-engines.html#innodb-foreign-key-constraints"  title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
			KEY约束”</a>。对于其它存储引擎，这些子句会被分析，但是会被忽略。对于所有的存储引擎，<span>CHECK</span>子句会被分析，但是会被忽略。请参见<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。接受这些子句但又忽略子句的原因是为了提高兼容性，以便更容易地从其它<span>SQL</span>服务器中导入代码，并运行应用程序，创建带参考数据的表。请参见<a href="introduction.html#differences-from-ansi"  title="1.8.5. MySQL Differences from Standard SQL">1.8.5节，“MySQL与标准SQL的差别”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><span>InnoDB</span>支持使用<span>ALTER 
			TABLE</span>来取消外键：</span></p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>yourtablename</i></span> DROP FOREIGN KEY <span><i>fk_symbol</i></span>;</span></pre>
			<p>要了解更多信息，请参见<a href="storage-engines.html#innodb-foreign-key-constraints"  title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
			KEY约束”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER TABLE</span>忽略<span>DATA 
			DIRECTORY</span>和<span>INDEX DIRECTORY</span>表选项。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您想要把表默认的字符集和所有字符列（<span>CHAR, VARCHAR, 
			TEXT</span>）改为新的字符集，应使用如下语句：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>tbl_name</i></span> CONVERT TO CHARACTER SET <span><i>charset_name</i></span>;</span></pre>
			<p>警告：前面的操作转换了字符集之间的列类型。如果您有一列使用一种字符集（如<span>latin1</span>），但是存储的值实际上使用了其它的字符集（如<span>utf8</span>），这种情况不是您想要的。此时，您必须对这样的列进行以下操作。</p>
			<pre><span>ALTER TABLE t1 CHANGE c1 c1 BLOB;</span></pre>
			<pre><span>ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;</span></pre>
			<p>这种方法能够实现此功能的原因是，当您转换到<span>BLOB</span>列或从<span>BLOB</span>列转换过来时，并没有发生转换。</p>
			<p>如果您指定<span>CONVERT TO 
			CHARACTER SET</span>为二进制，则<span>TEXT</span>列被转换到相应的二进制字符串类型（<span>BINARY, 
			VARBINARY, BLOB</span>）。这意味着这些列将不再有字符集，接下来的<span>CONVERT 
			TO</span>操作也将不适用于这些列。</p>
			<p>要仅仅改变一个表的默认字符集，应使用此语句：</p>
			<pre><span>ALTER TABLE <span><i>tbl_name</i></span> DEFAULT CHARACTER SET <span><i>charset_name</i></span>;</span></pre>
			<p>词语<span>DEFAULT</span>为自选项。如果您在向表中添加一个新列时（例如，使用<span>ALTER 
			TABLE...ADD column</span>）没有指定字符集，则此时使用的字符集为默认字符集。</p>
			<p>警告：<span>ALTER 
			TABLE...DEFAULT CHARACTER SET</span>和<span>ALTER 
			TABLE...CHARACTER SET</span>是等价的，只用于更改默认的表字符集。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>InnoDB</span>表在创建时，使用了<span>.ibd</span>文件中的自己的表空间，则这样的文件可以被删除和导入。使用此语句删除<span>.ibd</span>文件：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ALTER TABLE <span><i>tbl_name</i></span> DISCARD TABLESPACE;</span></pre>
			<p>此语句用于删除当前的<span>.ibd</span>文件，所以应首先确认您有一个备份。如果在表空间被删除后尝试打开表格，则会出现错误。</p>
			<p>要把备份的<span>.ibd</span>文件还原到表中，需把此文件复制到数据库目录中，然后书写此语句：</p>
			<pre><span>ALTER TABLE <span><i>tbl_name</i></span> IMPORT TABLESPACE;</span></pre>
			<p>见<a href="storage-engines.html#multiple-tablespaces"  title="15.2.6.6. Using Per-Table Tablespaces">15.2.6.6节，“使用按表的表空间”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>mysql_info()</span><span> 
			C API</span>函数，您可以了解有多少记录已被复制，以及（当使用<span>IGNORE</span>时）有多少记录由于重复关键字的原因已被删除。请参见<a href="apis.html#mysql-info"  title="25.2.3.34. mysql_info()">25.2.3.34节，“mysql_info()”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ALTER TABLE</span>也可以用于对带分区的表进行重新分区，功能包括添加、取消、合并和拆分各分区，还可以用于进行分区维护。</p>
			<p>对带分区的表使用<span><i><span>partition_options</span></i></span>子句和<span>ALTER 
			TABLE</span>可以对表进行重新分区，使用时依据<span><i><span>partition_options</span></i>定义的分区方法。本子句以<span>PARTITION 
			BY</span>为开头，然后使用与用于<span>CREATE TABLE</span>的<i><span>partition_options</span></i></span>子句一样的语法和规则（要了解详细信息，请参见<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>）。注释：<span>MySQL 5.1</span>服务器目前接受此语法，但是不实际执行；等<span>MySQL 
			5.1</span>开发出来后，将执行此语法。</p>
			<p>用于<span>ALTER TABLE ADD 
			PARTITION</span>的<span><i><span>partition_definition</span></i></span>子句支持用于<span>CREATE 
			TABLE</span>语句的<span><i><span>partition_definition</span></i></span>子句的同样名称的选项。（要了解语法和介绍，请参见<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>。）例如，假设您有一个按照以下方式创建的带分区的表：</p>
			<pre><span>CREATE TABLE t1 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; year_col INT</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY RANGE (year_col) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1991),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1995),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (1999)</span></pre>
			<pre><span>);&nbsp;&nbsp;&nbsp; </span></pre>
			<p>您可以在表中增加一个新的分区<span>p3</span>，该分区用于储存小于<span>2002</span>的值。添加方法如下：</p>
			<pre><span>ALTER TABLE t1 ADD PARTITION p3 VALUES LESS THAN (2002);</span></pre>
			<p>注释：您不能使用<span>ALTER TABLE</span>向一个没有进行分区的表添加分区。</p>
			<p><span>DROP PARTITION</span>用于取消一个或多个<span>RANGE</span>或<span>LIST</span>分区。此命令不能用于<span>HASH</span>或<span>KEY
			</span>分区；用于这两个分区时，应使用<span>COALESCE PARTITION</span>（见后）。如果被取消的分区其名称列于<span><i><span>partition_names</span></i></span>清单中，则储存在此分区中的数据也被取消。例如，如果以前已定义的表<span>t1</span>，您可以采用如下方法取消名称为<span>p0</span>和<span>p1</span>的分区：</p>
			<pre><span>ALTER TABLE DROP PARTITION p0, p1;</span></pre>
			<p><span>ADD PARTITION</span>和<span>DROP 
			PARTITION</span>目前不支持<span>IF [NOT] EXISTS</span>。也不可能对一个分区或一个已分区的表进行重命名。如果您希望对一个分区进行重命名，您必须取消分区，再重新建立；如果您希望对一个已分区的表进行重新命名，您必须取消所有分区，然后对表进行重命名，再添加被取消的分区。</p>
			<p><span>COALESCE PARTITION</span>可以用于使用<span>HASH</span>或<span>KEY</span>进行分区的表，以便使用<span><i><span>number</span></i></span>来减少分区的数目。例如，假设您使用下列方法创建了表<span>t2</span>：</p>
			<pre><span>CREATE TABLE t2 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; name VARCHAR (30),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; started DATE</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY HASH(YEAR(started))</span></pre>
			<pre><span>PARTITIONS (6);</span></pre>
			<p>您可以使用以下命令，把<span>t2</span>使用的分区的数目由<span>6</span>个减少到<span>4</span>个：</p>
			<pre><span>ALTER TABLE t2 COALESCE PARTITION 2;</span></pre>
			<p>包含在最后一个<span><i><span>number</span></i></span>分区中的数据将被合并到其余的分区中。在此情况下，分区<span>4</span>和分区<span>5</span>将被合并到前<span>4</span>个分区中（编号为<span>0</span>、<span>1</span>、<span>2</span>和<span>3</span>的分区）。</p>
			<p>如果要更改部分分区，但不更改所有的分区，您可以使用<span>REORGANIZE 
			PARTITION</span>。这个命令有多种使用方法：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>把多个分区合并为一个分区。通过把多个分区的名称列入<span><i><span>partition_names</span></i></span>清单，并为<span><i><span>partition_definition</span></i></span>提供一个单一的定义，可以实现这个功能。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>把一个原有的分区拆分为多个分区。通过为<span><i><span>partition_names</span></i></span>命名一个分区，并提供多个<span><i><span>partition_definitions</span></i></span>，可以实现这个功能。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>更改使用<span>VALUES LESS THAN</span>定义的分区子集的范围或更改使用<span>VALUES 
			IN</span>定义的分区子集的值清单。</p>
			<p>注释：对于没有明确命名的分区，<span>MySQL</span>会自动提供默认名称<span>p0, 
			p1, p2</span>等。</p>
			<p>要了解有关<span>ALTER TALBE...REORANIZE 
			PARTITION</span>命令的详细信息，请参见<a href="partitioning.html#partitioning-management"  title="18.3. Partition Management">18.3节，“分区管理”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>多个附加子句用于提供分区维护和修补功能。这些功能与用于非分区表的功能类似。这些功能由<span>CHECK 
			TABLE</span>和<span>REPAIR TABLE</span>等命令（这些命令不支持用于分区表）执行。这些子句包括<span>ANALYZE 
			PARTITION</span><span>,
			<span>CHECK PARTITION</span>,
			<span>OPTIMIZE PARTITION</span>,
			<span>REBUILD PARTITION</span></span>和<span>REPAIR 
			PARTITION</span><span>.</span>每个选项均为一个<span><i><span>partition_names</span></i></span>子句，包括一个或多个分区名称。需要更改的表中必须已存在这些分区。多个分区名称用逗号分隔。要了解更多信息，或要了解举例说明，请参见<a href="partitioning.html#partitioning-maintenance"  title="18.3.3. Maintenance of Partitions">18.3.3节，“分区维护”</a>。</p>
			<p>以下例子展示了<span>ALTER TABLE</span>的使用。首先展示表<span>t1</span>。表<span>t1</span>采用如下方法创建：</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE t1 (a INTEGER,b CHAR(10));</b></span></span></pre>
			<p>把表<span>t1</span>重新命名为<span>t2</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t1 RENAME t2;</b></span></span></pre>
			<p>把列<span>a</span>从<span>INTERGER</span>更改为<span>TINYINT 
			NOT NULL</span>（名称保持不变），并把列<span>b</span>从<span>CHAR(10)</span>更改为<span>CHAR(20)</span>，同时把列<span>b</span>重新命名为列<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);</b></span></span></pre>
			<p>添加一个新的<span>TIMESTAMP</span>列，名称为<span>d</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD d TIMESTAMP;</b></span></span></pre>
			<p>在列<span>d</span>和列<span>a</span>中添加索引：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD INDEX (d), ADD INDEX (a);</b></span></span></pre>
			<p>删除列<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 DROP COLUMN c;</b></span></span></pre>
			<p>添加一个新的<span>AUTO_INCREMENT</span>整数列，名称为<span>c</span>：</p>
			<pre><span>mysql&gt; <span><b>ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ADD PRIMARY KEY (c);</b></span></span></pre>
			<p>注意我们为<span>c</span>编制了索引（作为<span>PRIMARY KEY</span>），因为<span>AUTO_INCREMENT</span>列必须编制索引。同时我们定义<span>c</span>为<span>NOT 
			NULL</span>，因为主键列不能为<span>NULL</span>。</p>
			<p>当您添加一个<span>AUTO_INCREMENT</span>列时，列值被自动地按序号填入。对于<span>MyISAM</span>表，您可以在<span>ALTER 
			TABLE</span>之前执行<span>SET INSERT_ID<span>=<i>value</i></span></span><span>来设置第一个序号，也可以使用<span>AUTO_INCREMENT=<i>value</i></span></span>表选项来设置。请参见<a href="sql-syntax.html#set-option"  title="13.5.3. SET Syntax">13.5.3节，“SET语法”</a>。</p>
			<p>如果值大于<span>AUTO_INCREMENT</span>列中的最大值，则您可以使用用于<span>InnoDB</span>表的<span>ALTER 
			TALBE...AUTO_INCREMENT<span>=<i>value</i></span></span>表选项，来为新行设置序号。如果值小于列中当前的最大值，不会出现错误信息，当前的序列值也不改变。</p>
			<p>使用<span>MyISAM</span>表时，如果您不更改<span>AUTO_INCREMENT</span>列，则序列号不受影响。如果您取消一个<span>AUTO_INCREMENT</span>列，然后添加另一个<span>AUTO_INCREMENT</span>列，则序号重新排列，从<span>1</span>开始。</p>
			<p>见<a href="problems.html#alter-table-problems"  title="A.7.1. Problems with ALTER TABLE">A.7.1节，“与ALTER TABLE有关的问题”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-database"></a>13.1.3. CREATE 
			DATABASE语法</h3></div></div></div><a class="indexterm" name="id2892556"></a><a class="indexterm" name="id2892565"></a><a class="indexterm" name="id2892574"></a><a class="indexterm" name="id2892584"></a><a class="indexterm" name="id2892594"></a><a class="indexterm" name="id2892604"></a>
			<pre><span>CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] <span><i>db_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [<span><i>create_specification</i></span> [, <span><i>create_specification</i></span>] ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>create_specification</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [DEFAULT] CHARACTER SET <span><i>charset_name</i></span></span></pre>
			<pre><span>&nbsp; | [DEFAULT] COLLATE <span><i>collation_name</i></span></span></pre>
			<p><span>CREATE DATABASE</span>用于创建数据库，并进行命名。如果要使用<span>CREATE 
			DATABASE</span>，您需要获得数据库<span>CREATE</span>权限。</p>
			<p>有关合法数据库名称的规定列于<a href="language-structure.html#legal-names"  title="9.2. Database, Table, Index, Column, and Alias Names">9.2节，“数据库、表、索引、列和别名”</a>。如果存在数据库，并且您没有指定<span>IF NOT EXISTS</span>，则会出现错误。</p>
			<p><span><span>
			create_specification</span>选项用于指定数据库的特性。数据库特性储存在数据库目录中的<span>db.opt</span>文件中。<span>CHARACTER 
			SET</span>子句用于指定默认的数据库字符集。<span>COLLATE</span>子句用于指定默认的数据库整序。字符集和整序名称在</span><a href="charset.html" >第10章</a>：<a href="charset.html"  title="Chapter 10. Character Set Support"><i>字符集支持</i></a><span>中讨论。</span></p>
			<p>有些目录包含文件，这些文件与数据库中的表对应。<span>MySQL</span>中的数据库的执行方法与这些目录的执行方法相同。因为当数据库刚刚被创建时，在数据库中没有表，所以<span>CREATE 
			DATABASE</span>只创建一个目录。这个目录位于<span>MySQL</span>数据目录和<span>db.opt</span>文件之下。</p>
			<p>如果您手动在数据目录之下创建一个目录（例如，使用<strong><span>mkdir</span></strong>），则服务器会认为这是一个数据库目录，并在<span>SHOW 
			DATABASES</span>的输出中显示出来。</p>
			<p>也可以使用<span>CREATE SCHEMA</span>。</p>
			<p>您还可以使用<strong><span>mysqladmin</span></strong>程序创建数据库。请参见<a href="client-side-scripts.html#mysqladmin"  title="8.5. mysqladmin — Client for Administering a MySQL Server">8.5节，“mysqladmin：用于管理MySQL服务器的客户端”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-index"></a>13.1.4. CREATE 
			INDEX语法</h3></div></div></div><a class="indexterm" name="id2892800"></a><a class="indexterm" name="id2892809"></a><a class="indexterm" name="id2892816"></a><a class="indexterm" name="id2892826"></a>
			<pre><span>CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX <span><i>index_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [USING <span><i>index_type</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ON <span><i>tbl_name</i></span> (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>index_col_name</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> [(<span><i>length</i></span>)] [ASC | DESC]</span></pre>
			<p><span>CREATE INDEX</span>被映射到一个<span>ALTER 
			TABLE</span>语句上，用于创建索引。请参见<a href="sql-syntax.html#alter-table"  title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
		TABLE语法”</a>。</p>
			<p>通常，当使用<span>CREATE TABLE</span>创建表时，也同时在表中创建了所有的索引。请参见<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
		TABLE语法”</a>。<span>CREATE INDEX</span>允许您向已有的表中添加索引。</p>
			<p>格式为（<span>col1, col2,...</span>）的一个列清单创建出一个多列索引。通过串接给定列中的值，确定索引值的格式。</p>
			<p>对于<span>CHAR</span>和<span>VARCHAR</span>列，只用一列的一部分就可创建索引。创建索引时，使用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>语法，对前缀编制索引。前缀包括每列值的前<span><i><span>length</span></i>个</span>字符。<span>BLOB</span>和<span>TEXT</span>列也可以编制索引，但是必须给出前缀长度。</p>
			<p>此处展示的语句用于创建一个索引，索引使用列名称的前<span>10</span>个字符。</p>
			<pre><span>CREATE INDEX part_of_name ON customer (name(10));</span></pre>
			<p>因为多数名称的前<span>10</span>个字符通常不同，所以此索引不会比使用列的全名创建的索引速度慢很多。另外，使用列的一部分创建索引可以使索引文件大大减小，从而节省了大量的磁盘空间，有可能提高<span>INSERT</span>操作的速度。</p>
			<p>前缀最长为<span>255</span>字节。对于<span>MyISAM</span>和<span>InnoDB</span>表，前缀最长为<span>1000</span>字节。注意前缀的限长以字节计，而<span>CREATE 
			INDEX</span>语句中的前缀长度指的是字符的数目。对于使用多字节字符集的列，在指定列的前缀长度时，要考虑这一点。</p>
			<p>在<span>MySQL 5.1</span>中：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有当您正在使用<span>MyISAM, InnoDB</span>或<span>BDB</span>表类型时，您可以向有<span>NULL</span>值的列中添加索引。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有当您正在使用<span>MyISAM, BDB</span>或<span>InnoDB</span>表类型时，您可以向<span>BLOB</span>或<span>TEXT</span>列中添加索引。</p>
			<p>一个<span><i><span>index_col_name</span></i>规约可以以<span>ASC</span>或<span>DESC</span>为结尾。这些关键词将来可以扩展，用于指定递增或递减索引值存储。目前，这些关键词被分析，但是被忽略；索引值均以递增顺序存储。</span></p>
			<p>部分储存引擎允许在创建索引时指定索引类型。<span><i><span>index_type</span></i></span>指定语句的语法是<span>USING
			<span><i>type_name</i></span></span>。不同的储存引擎所支持的<span><i><span>type_name</span></i></span>值已显示在下表中。如果列有多个索引类型，当没有指定<span><i><span>index_type</span></i>时，第一个类型是默认值</span>。</p>
			<table border="1" cellpadding="0" id="table1">
				<tr>
					<td>
					<p><strong><span>
					存储引擎</span></strong></td>
					<td>
					<p><strong><span>
					允许的索引类型</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MyISAM</span></td>
					<td>
					<p>
					<span>BTREE</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>InnoDB</span></td>
					<td>
					<p>
					<span>BTREE</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MEMORY</span><span>/<span>HEAP</span></span></td>
					<td>
					<p>
					<span>HASH</span><span>,
					<span>BTREE</span></span></td>
				</tr>
			</table>
			<p>示例：</p>
			<pre><span>CREATE TABLE lookup (id INT) ENGINE = MEMORY;</span></pre>
			<pre><span>CREATE INDEX id_index USING BTREE ON lookup (id);</span></pre>
			<p><span>TYPE <i>type_name</i></span>可以作为<span>USING
			<i>type_name</i></span>的同义词，用于指定索引类型。但是，<span>USING</span>是首选的格式。另外，在索引规约语法中，位于索引类型前面的索引名称不能使用<span>TYPE</span>。这是因为，与<span>USING</span>不同，<span>TYPE</span>不是保留词，因此会被认为是一个索引名称。</p>
			<p>如果您指定的索引类型在给定的储存引擎中不合法，但是有其它的索引类型适合引擎使用，并且不会影响查询功能，则引擎应使用此类型。</p>
			<p>要了解更多有关<span>MySQL</span>如何使用索引的信息，请参见<a href="optimization.html#mysql-indexes"  title="7.4.5. How MySQL Uses Indexes">7.4.5节，“MySQL如何使用索引”</a>。</p>
			<p><span>FULLTEXT</span>索引只能对<span>CHAR, VARCHAR</span>和<span>TEXT</span>列编制索引，并且只能在<span>MyISAM</span>表中编制。请参见<a href="functions.html#fulltext-search"  title="12.7. Full-Text Search Functions">12.7节，“全文搜索功能”</a>。</p>
			<p><span>SPATIAL</span>索引只能对空间列编制索引，并且只能在<span>MyISAM</span>表中编制。空间列类型在<a href="spatial-extensions-in-mysql.html" >第19章：</a><a href="spatial-extensions-in-mysql.html"  title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空间扩展</i></a>中进行了描述。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="create-table"></a>13.1.5. CREATE 
			TABLE语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#silent-column-changes" >
				13.1.5.1. 沉寂的列规格变更</a></span></dt></dl></div><a class="indexterm" name="id2893328"></a>
			<pre><span>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>create_definition</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [<span><i>table_options</i></span>] [<span><i>select_statement</i></span>]</span></pre>
			<p>或：</p>
			<pre><span>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(] LIKE <span><i>old_tbl_name</i></span> [)];</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>create_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>column_definition</i></span></span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] PRIMARY KEY [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | KEY [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | INDEX [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] UNIQUE [INDEX]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span><i>index_name</i></span>] [<span><i>index_type</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [FULLTEXT|SPATIAL] [INDEX] [<span><i>index_name</i></span>] (<span><i>index_col_name</i></span>,...)</span></pre>
			<pre><span>&nbsp; | [CONSTRAINT [<span><i>symbol</i></span>]] FOREIGN KEY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<span><i>index_name</i></span>] (<span><i>index_col_name</i></span>,...) [<span><i>reference_definition</i></span>]</span></pre>
			<pre><span>&nbsp; | CHECK (<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>column_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> <span><i>type</i></span> [NOT NULL | NULL] [DEFAULT <span><i>default_value</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT &#39;<span><i>string</i></span>&#39;] [<span><i>reference_definition</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>type</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; TINYINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | SMALLINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | MEDIUMINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | INT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | INTEGER[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | BIGINT[(<span><i>length</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | REAL[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DOUBLE[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | FLOAT[(<span><i>length</i></span>,<span><i>decimals</i></span>)] [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DECIMAL(<span><i>length</i></span>,<span><i>decimals</i></span>) [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | NUMERIC(<span><i>length</i></span>,<span><i>decimals</i></span>) [UNSIGNED] [ZEROFILL]</span></pre>
			<pre><span>&nbsp; | DATE</span></pre>
			<pre><span>&nbsp; | TIME</span></pre>
			<pre><span>&nbsp; | TIMESTAMP</span></pre>
			<pre><span>&nbsp; | DATETIME</span></pre>
			<pre><span>&nbsp; | CHAR(<span><i>length</i></span>) [BINARY | ASCII | UNICODE]</span></pre>
			<pre><span>&nbsp; | VARCHAR(<span><i>length</i></span>) [BINARY]</span></pre>
			<pre><span>&nbsp; | TINYBLOB</span></pre>
			<pre><span>&nbsp; | BLOB</span></pre>
			<pre><span>&nbsp; | MEDIUMBLOB</span></pre>
			<pre><span>&nbsp; | LONGBLOB</span></pre>
			<pre><span>&nbsp; | TINYTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | TEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | MEDIUMTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | LONGTEXT [BINARY]</span></pre>
			<pre><span>&nbsp; | ENUM(<span><i>value1</i></span>,<span><i>value2</i></span>,<span><i>value3</i></span>,...)</span></pre>
			<pre><span>&nbsp; | SET(<span><i>value1</i></span>,<span><i>value2</i></span>,<span><i>value3</i></span>,...)</span></pre>
			<pre><span>&nbsp; | <span><i>spatial_type</i></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>index_col_name</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>col_name</i></span> [(<span><i>length</i></span>)] [ASC | DESC]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>reference_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; REFERENCES <span><i>tbl_name</i></span> [(<span><i>index_col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ON DELETE <span><i>reference_option</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ON UPDATE <span><i>reference_option</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>reference_option</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; RESTRICT | CASCADE | SET NULL | NO ACTION</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>table_options</span></i></span><span>: <span><i>table_option</i></span> [<span><i>table_option</i></span>] ...</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>table_option</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; {ENGINE|TYPE} = <span><i>engine_name</i></span></span></pre>
			<pre><span>&nbsp; | AUTO_INCREMENT = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | AVG_ROW_LENGTH = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | [DEFAULT] CHARACTER SET <span><i>charset_name</i></span> [COLLATE <span><i>collation_name</i></span>]</span></pre>
			<pre><span>&nbsp; | CHECKSUM = {0 | 1}</span></pre>
			<pre><span>&nbsp; | COMMENT = &#39;<span><i>string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | CONNECTION = &#39;<span><i>connect_string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | MAX_ROWS = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | MIN_ROWS = <span><i>value</i></span></span></pre>
			<pre><span>&nbsp; | PACK_KEYS = {0 | 1 | DEFAULT}</span></pre>
			<pre><span>&nbsp; | PASSWORD = &#39;<span><i>string</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | DELAY_KEY_WRITE = {0 | 1}</span></pre>
			<pre><span>&nbsp; | ROW_FORMAT = {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}</span></pre>
			<pre><span>&nbsp; | UNION = (<span><i>tbl_name</i></span>[,<span><i>tbl_name</i></span>]...)</span></pre>
			<pre><span>&nbsp; | INSERT_METHOD = { NO | FIRST | LAST }</span></pre>
			<pre><span>&nbsp; | DATA DIRECTORY = &#39;<span><i>absolute path to directory</i></span>&#39;</span></pre>
			<pre><span>&nbsp; | INDEX DIRECTORY = &#39;<span><i>absolute path to directory</i></span>&#39;</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>partition_options</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION BY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [LINEAR] HASH(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; [LINEAR] KEY(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; RANGE(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; LIST(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [PARTITIONS <span><i>num</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [&nbsp; SUBPARTITION BY</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [LINEAR] HASH(<span><i>expr</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | [LINEAR] KEY(<span><i>column_list</i></span>)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SUBPARTITIONS(<span><i>num</i></span>)]&nbsp; </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>partition_definition</i></span>), [(<span><i>partition_definition</i></span>)], ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>partition_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION <span><i>partition_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [VALUES { </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LESS THAN (<span><i>expr</i></span>) | <span>MAXVALUE</span> </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| IN (<span><i>value_list</i></span>) }]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[STORAGE] ENGINE [=] <span><i>engine-name</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT [=] <span><i>&#39;comment_text&#39;</i></span> ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DATA DIRECTORY [=] &#39;<span><i>data_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [INDEX DIRECTORY [=] &#39;<span><i>index_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MAX_ROWS [=] <span><i>max_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MIN_ROWS [=] <span><i>min_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TABLESPACE [=] (<span><i>tablespace_name</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [NODEGROUP [=] <span><i>node_group_id</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(<span><i>subpartition_definition</i></span>), [(<span><i>subpartition_definition</i></span>)], ...]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>subpartition_definition</span></i></span><span>:</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SUBPARTITION <span><i>logical_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[STORAGE] ENGINE [=] <span><i>engine-name</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [COMMENT [=] <span><i>&#39;comment_text&#39;</i></span> ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [DATA DIRECTORY [=] &#39;<span><i>data_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [INDEX DIRECTORY [=] &#39;<span><i>index_dir</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MAX_ROWS [=] <span><i>max_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [MIN_ROWS [=] <span><i>min_number_of_rows</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TABLESPACE [=] (<span><i>tablespace_name</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [NODEGROUP [=] <span><i>node_group_id</i></span>]</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span><i><span>select_statement:</span></i></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE | REPLACE] [AS] SELECT ...&nbsp;&nbsp; (<span><i>Some legal select statement</i></span>)</span></pre>
			<p><span>CREATE TABLE</span>用于创建带给定名称的表。您必须拥有表<span>CREATE</span>权限。</p>
			<p>允许的表名称的规则列于<a href="language-structure.html#legal-names"  title="9.2. Database, Table, Index, Column, and Alias Names">9.2节，“数据库、表、索引、列和别名”</a>中。默认的情况是，表被创建到当前的数据库中。如果表已存在，或者如果没有当前数据库，或者如果数据库不存在，则会出现错误。</p>
			<p>表名称被指定为<span><i><span>db_name.tbl_name</span></i></span>，以便在特定的数据库中创建表。不论是否有当前数据库，都可以通过这种方式创建表。如果您使用加引号的识别名，则应对数据库和表名称分别加引号。例如，<span><span>`mydb`.`mytbl`</span>是合法的，但是<span>`mydb.mytbl`</span>不合法。</span></p>
			<p>在创建表格时，您可以使用<span>TEMPORARY</span>关键词。只有在当前连接情况下，<span>TEMPORARY</span>表才是可见的。当连接关闭时，<span>TEMPORARY</span>表被自动取消。这意味着两个不同的连接可以使用相同的临时表名称，同时两个临时表不会互相冲突，也不与原有的同名的非临时表冲突。（原有的表被隐藏，直到临时表被取消时为止。）您必须拥有<span>CREATE 
			TEMPORARY TABLES</span>权限，才能创建临时表。</p>
			<p>如果表已存在，则使用关键词<span>IF NOT EXISTS</span>可以防止发生错误。注意，原有表的结构与<span>CREATE 
			TABLE</span>语句中表示的表的结构是否相同，这一点没有验证。注释：如果您在<span>CREATE 
			TABLE...SELECT</span>语句中使用<span>IF NOT EXISTS</span>，则不论表是否已存在，由<span>SELECT</span>部分选择的记录都会被插入。</p>
			<p><span>MySQL</span>通过数据库目录中的<span>.frm</span>表格式（定义）文件表示每个表。表的存储引擎也可能会创建其它文件。对于<span>MyISAM</span>表，存储引擎可以创建数据和索引文件。因此，对于每个<span>MyISAM</span>表<span><i><span>tbl_name</span></i></span>，有三个磁盘文件：</p>
			<table border="1" cellpadding="0" id="table2">
				<tr>
					<td>
					<p><strong><span>
					文件</span></strong></td>
					<td>
					<p><strong><span>
					作用</span></strong></td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.frm</span></span></td>
					<td>
					<p>表格式（定义）文件</td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.MYD</span></span></td>
					<td>
					<p>数据文件</td>
				</tr>
				<tr>
					<td>
					<p><span><i>
					<span>tbl_name</span></i><span>.MYI</span></span></td>
					<td>
					<p>索引文件</td>
				</tr>
			</table>
			<p>用于表示表的由存储引擎创建的文件在<a href="storage-engines.html"  title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>中描述。</p>
			<p>要了解有关各种列类型的性质的一般说明，请参见<a href="column-types.html"  title="Chapter 11. Column Types">第11章：列类型</a>。要了解有关空间列类型的说明，请参见<a href="spatial-extensions-in-mysql.html" >第19章：</a><a href="spatial-extensions-in-mysql.html"  title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空间扩展</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果没有指定是<span>NULL</span>或是<span>NOT 
			NULL</span>，则列在创建时假定指定为<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一个整数列可以拥有一个附加属性<span>AUTO_INCREMENT</span>。当您向一个已编入索引的<span>AUTO_INCREMENT</span>列中插入一个<span>NULL</span>值（建议）或<span>0</span>时，此列被设置为下一个序列的值。通常情况下为<span><i><span>value</span></i><span>+1</span></span>，此处<span><i><span>value</span></i></span>是当前在表中的列的最大值。<span>AUTO_INCREMENT</span>序列从<span>1</span>开始。这样的列必须被定义为一种整数类型，请参见<a href="column-types.html#numeric-type-overview"  title="11.1.1. Overview of Numeric Types">11.1.1节，“数值类型概述”</a>中的叙述。（值<span>1.0</span>不是整数）。请参见<a href="apis.html#mysql-insert-id"  title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a>。</p>
			<p>为<span>--sql-mode</span>服务器选项或<span>sql_mode</span>系统变量指定<span>NO_AUTO_VALUE_ON_ZERO</span>特征位，这样可以把<span>0</span>存储到<span>AUTO_INCREMENT</span>列中，同时不生成一个新的序列值。请参见<a href="database-administration.html#server-options"  title="5.3.1. mysqld Command-Line Options">5.3.1节，“<span><strong class="command">mysqld</strong></span>命令行选项”</a>。</p>
			<p>注释：有时候，每个表只有一个<span>AUTO_INCREMENT</span>列，此列必须编制索引，不能有<span>DEFAULT</span>值。一个<span>AUTO_INCREMENT</span>列只有在只包含正数的情况下，才能运行正常。插入一个负数会被认为是插入了一个非常大的正数。这样做是为了避免当数字由正数转为负数时出现精度问题，同时也为了确保<span>AUTO_INCREMENT</span>列中不会包含<span>0</span>。</p>
			<p>对于<span>MyISAM</span>和<span>BDB</span>表，您可以在一个多列关键字中指定一个<span>AUTO_INCREMENT</span>次级列。请参见<a href="tutorial.html#example-auto-increment"  title="3.6.9. Using AUTO_INCREMENT">3.6.9节，“使用AUTO_INCREMENT”</a>。</p>
			<p>为了让<span>MySQL</span>与部分<span>ODBC</span>应用软件相兼容，您可以使用以下查询方法找到最后一个插入行的<span>AUTO_INCREMENT</span>值：</p>
			<pre><span>SELECT * FROM <span><i>tbl_name</i></span> WHERE <span><i>auto_col</i></span> IS NULL</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>字符列的定义可以包括一个<span>CHARACTER SET</span>属性，用来指定字符集，也可以指定列的整序。要了解详细情况，请参见<a href="charset.html"  title="Chapter 10. Character Set Support">第10章：<i>字符集支持</i></a>。<span>CHARSET</span>是<span>CHARACTER 
			SET</span>的同义词。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);</span></pre>
			<p><span>MySQL 5.1</span>理解，在字符列定义中的长度规约以字符为单位。（有些早期版本以字节为单位。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DEFAULT</span>子句用于为列指定一个默认值。默认值必须为一个常数，不能为一个函数或一个表达式，有一种情况例外。例如，一个日期列的默认值不能被设置为一个函数，如<span>NOW()</span>或<span>CURRENT_DATE</span>。不过，有一种例外，您可以对<span>TIMESTAMP</span>列指定<span>CURRENT_TIMESTAMP</span>为默认值。请参见<a href="column-types.html#timestamp-4-1"  title="11.3.1.1. TIMESTAMP Properties as of MySQL 4.1">11.3.1.1节，“MySQL 4.1中的TIMESTAMP属性”</a>。</p>
			<p><span>BLOB</span>和<span>TEXT</span>列不能被赋予默认值。</p>
			<p>如果在列定义中没有明确的<span>DEFAULT</span>值，则<span>MySQL</span>按照如下规则确定默认值：</p>
			<p>如果列可以使用<span>NULL</span>作为值，则使用<span>DEFAULT 
			NULL</span>子句对列进行定义。（在<span>MySQL</span>的早期版本中也如此。）</p>
			<p>如果列不能使用<span>NULL</span>作为值，则<span>MySQL</span>对列进行定义时不使用<span>DEFAULT</span>子句。输入数据时，如果<span>INSERT</span>或<span>REPLACE</span>语句不包括列的值，则<span>MySQL</span>依据当时的有效的<span>SQL</span>模式操作列：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>如果严格模式没有被启用，则<span>MySQL</span>会根据列数据类型，把列设置为明确的默认值。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>
			如果严格模式已被启用，则事务表会出现错误，语句被回滚。对于非事务表，会出现错误，不过，如果错误出现在一个多行语句中的第二行或后续行，则以前的各行将被插入。</p>
			<p>假设表<span>t</span>按下面的方法进行定义：</p>
			<pre><span>CREATE TABLE t (i INT NOT NULL);</span></pre>
			<p>在这种情况下，<span>i</span>没有明确的默认值，所以在严格模式中，每个后续语句都会产生一个错误，并且没有行被插入。当未使用严格模式时，只有第三个语句产生错误；明确的默认值被插入到前两个语句中，但是第三个语句会出现错误，因为<span>DEFAULT(i)</span>不会产生一个值：</p>
			<pre><span>INSERT INTO t VALUES();</span></pre>
			<pre><span>INSERT INTO t VALUES(DEFAULT);</span></pre>
			<pre><span>INSERT INTO t VALUES(DEFAULT(i));</span></pre>
			<p>见<a href="database-administration.html#server-sql-mode"  title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a>。</p>
			<p>对于一个给定的表，您可以使用<span>SHOW 
			CREATE TABLE</span>语句来查看那些列有明确的<span>DEFAULT</span>子句。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于列的评注可以使用<span>COMMENT</span>选项来进行指定。评注通过<span>SHOW 
			CREATE TABLE</span>和<span>SHOW FULL COLUMNS</span>语句显示。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>属性<span>SERIAL</span>可以用作<span>BIGINT 
			UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</span>的别名。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>KEY</span>通常是<span>INDEX</span>同义词。如果关键字属性<span>PRIMARY 
			KEY</span>在列定义中已给定，则<span>PRIMARY KEY</span>也可以只指定为<span>KEY</span>。这么做的目的是与其它数据库系统兼容。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>UNIQUE</span>索引中，所有的值必须互不相同。如果您在添加新行时使用的关键字与原有行的关键字相同，则会出现错误。例外情况是，如果索引中的一个列允许包含<span>NULL</span>值，则此列可以包含多个<span>NULL</span>值。此例外情况不适用于<span>BDB</span>表。在<span>BDB</span>中，带索引的列只允许一个单一<span>NULL</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PRIMARY KEY</span>是一个唯一<span>KEY</span>，此时，所有的关键字列必须定义为<span>NOT 
			NULL</span>。如果这些列没有被明确地定义为<span>NOT NULL</span>，<span>MySQL</span>应隐含地定义这些列。一个表只有一个<span>PRIMARY 
			KEY</span>。如果您没有<span>PRIMARY KEY</span>并且一个应用程序要求在表中使用<span>PRIMARY 
			KEY</span>，则<span>MySQL</span>返回第一个<span>UNIQUE</span>索引，此索引没有作为<span>PRIMARY 
			KEY</span>的<span>NULL</span>列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在已创建的表中，<span>PRIMARY KEY</span>的位置最靠前，然后是所有的<span>UNIQUE</span>索引，然后是非唯一索引。这可以帮助<span>MySQL</span>优化程序选择优先使用哪个索引，并且更快速的检测出重复的<span>UNIQUE</span>关键字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PRIMARY KEY</span>可以是一个多列索引。但是，在列规约中使用<span>PRIMARY 
			KEY</span>关键字属性无法创建多列索引。这么做只能把一个列标记为主列。您必须使用一个单独的<span>PRIMARY 
			KEY</span>（<span>index_col_name, 
			...</span>）子句。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>PRIMARY KEY</span>或<span>UNIQUE</span>索引只包括一个列，并且此列为整数类型，则您也可以在<span>SELECT</span>语句中把此列作为<span>_rowid</span>引用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>MySQL</span>中，<span>PRIMARY 
			KEY</span>的名称为<span>PRIMARY</span>。对于其它索引，如果您没有赋予名称，则索引被赋予的名称与第一个已编入索引的列的名称相同，并自选添加后缀（<span>_2, 
			_3,...</span>），使名称为唯一名称。您可以使用<span>SHOW INDEX FROM
			<span><i>tbl_name</i></span></span>来查看表的索引名称。请参见<a href="sql-syntax.html#show-index"  title="13.5.4.11. SHOW INDEX Syntax">13.5.4.11节，“SHOW 
			INDEX语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>部分存储引擎允许您在创建索引时指定索引类型。<span><i><span>index_type</span></i>指示语句的语法是<span>USING 
			type_name</span>。</span></p>
			<p>示例：</p>
			<pre><span>CREATE TABLE lookup</span></pre>
			<pre><span>&nbsp; (id INT, INDEX USING BTREE (id))</span></pre>
			<pre><span>&nbsp; ENGINE = MEMORY;</span></pre>
			<p>要了解有关<span>USING</span>的详细说明，请参见<a href="sql-syntax.html#create-index"  title="13.1.4. CREATE INDEX Syntax">13.1.4节，“CREATE 
			INDEX语法”</a>。</p>
			<p>要了解有关<span>MySQL</span>如何使用索引的更多信息，请参见<a href="optimization.html#mysql-indexes"  title="7.4.5. How MySQL Uses Indexes">7.4.5节，“MySQL如何使用索引”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>MySQL 5.1</span>中，只有<span>MyISAM</span>，<span>InnoDB, 
			BDB</span>和<span>MEMORY</span>存储引擎支持在含有<span>NULL</span>值的列中编索引。在其它情况下，您必须定义已编索引的列为<span>NOT 
			NULL</span>，否则会出现错误。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一个索引规约中使用<span><i><span>col_name</span></i><span>(<i>length</i>)</span></span>语法，您可以创建一个索引，此索引只使用一个<span>CHAR</span>或<span>VARCHAR</span>列的第一个<span><i><span>length</span></i></span>字符。只对列值的前缀编制索引可以使索引文件大大减小。请参见<a href="optimization.html#indexes"  title="7.4.3. Column Indexes">7.4.3节，“列索引”</a>。</p>
			<p><span>MyISAM</span>和<span>InnoDB</span>存储引擎也支持对<span>BLOB</span>和<span>TEXT</span>列编索引。当对<span>BLOB</span>或<span>TEXT</span>列编索引时，您必须为索引指定一个前缀长度。例如：</p>
			<pre><span>CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));</span></pre>
			<p>对于<span>MyISAM</span>和<span>InnoDB</span>表，前缀最长可以为<span>1000</span>字节，对于其它表格类型，最长可以为<span>255</span>字节。注意前缀长度限值以字节为单位，而在<span>CREATE 
			TABLE</span>语句中的前缀长度用字符数目来表述。当为一个使用多字节字符集的列指定前缀长度时，一定要考虑到这一点。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>一个<span><i><span>index_col_name</span></i></span>规约可以以<span>ASC</span>或<span>DESC</span>结尾。这些关键词可以在将来进行扩展，用于指定升序或降序的索引值存储。当前，这些关键词被分析但是被忽略；索引值均以升序储存。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当您在<span>SELECT</span>中的<span>TEXT</span>列或<span>BLOB</span>列中使用<span>ORDER 
			BY</span>或<span>GROUP BY</span>时，服务器只使用初始的字节数目对值进行分类。字节数目由<span><span>max_sort_length</span>系统变量进行指示。请参见</span><a href="column-types.html#blob"  title="11.4.3. The BLOB and TEXT Types">11.4.3节，“BLOB和TEXT类型<code class="literal"></code>”</a><span>。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以创建特殊的<span>FULLTEXT</span>索引，用于全文搜索。只有<span>MyISAM</span>表类型支持<span>FULLTEXT</span>索引。<span>FULLTEXT</span>索引只可以从<span>CHAR, 
			VARCHAR</span>和<span>TEXT</span>列中创建。整个列都会被编入索引；不支持对部分列编索引。如果已指定，前缀长度会被忽略。要了解运行的详细说明，请参见<a href="functions.html#fulltext-search"  title="12.7. Full-Text Search Functions">12.7节，“全文搜索功能”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以为空间列类型创建<span>SPATIAL</span>索引。只有<span>MyISAM</span>表支持空间类型，已编索引的列必须声明为<span>NOT 
			NULL</span>。请参见<a href="spatial-extensions-in-mysql.html" >第19章：</a><a href="spatial-extensions-in-mysql.html"  title="Chapter 19. Spatial Extensions in MySQL"><i>MySQL中的空间扩展</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>InnoDB</span>表支持对外键限制条件进行检查。请参见<a href="storage-engines.html#innodb"  title="15.2. The InnoDB Storage Engine">15.2节，“InnoDB存储引擎”</a>。注意，在<span>InnoDB</span>中，<span>FOREIGN 
			KEY</span>语法比本节开始时介绍的<span>CREATE TABLE</span>语句的语法更严格：被引用的表中的列必须有明确的命名。<span>InnoDB</span>支持外键的<span>ON 
			DELETE</span>和<span>ON UPDATE</span>两种操作。有关精确语法的说明，请参见<a href="storage-engines.html#innodb-foreign-key-constraints"  title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
			KEY约束”</a>。</p>
			<p>对于其它存储引擎，<span>MySQL</span>服务器对<span>CREATE 
			TABLE</span>语句中的<span>FOREIGN KEY</span>和<span>REFERENCES</span>语法进行分析，但不采取进一步的行动。所有的存储引擎均对<span>CHECK</span>子句进行分析，但是忽略<span>CHECK</span>子句。请参见<a href="introduction.html#ansi-diff-foreign-keys"  title="1.8.5.5. Foreign Keys">1.8.5.5节，“外键”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于<span>MyISAM</span>表，每个<span>NULL</span>列要多占用一位，进位到距离最近的字节。最大记录长度（以字节为单位）按照如下方法计算：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>row length = 1</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>sum of column lengths</i></span>)</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>number of NULL columns</i></span> + <span><i>delete_flag</i></span> + 7)/8</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (<span><i>number of variable-length columns</i></span>)</span></pre>
			<p>对于采用静态记录格式的表，<span><i><span>delete_flag</span></i></span>为<span>1</span>。静态表在行记录中使用一位用作位标记。位标记指示该行是否已被删除。对于动态表，<span><i><span>delete_flag</span></i></span>为<span>0</span>，因为在动态行标题中已存储了位标记。</p>
			<p>这些计算方法不适用于<span>InnoDB</span>表。对于<span>InnoDB</span>表，<span>NULL</span>列的存储量与<span>NOT 
			NULL</span>列的存储量没有区别。</p>
			<p><span>ENGINE</span>和<span>TYPE</span>选项用于为表指定存储引擎。<span>ENGINE</span>是首选的选项名称。</p>
			<p><span>ENGINE</span>和<span>TYPE</span>选项采用以下值：</p>
			<table border="1" cellpadding="0" id="table3">
				<tr>
					<td>
					<p><strong><span>
					存储引擎</span></strong></td>
					<td>
					<p><strong><span>
					说明</span></strong></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>ARCHIVE</span></td>
					<td>
					<p>档案存储引擎。请参见<a href="storage-engines.html#archive-storage-engine"  title="15.8. The ARCHIVE Storage Engine">15.8节，“ARCHIVE存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>BDB</span></td>
					<td>
					<p>带页面锁定的事务安全表。也称为<span>BerkeleyDB</span>。请参见<a href="storage-engines.html#bdb-storage-engine"  title="15.5. The BDB (BerkeleyDB) Storage Engine">15.5节，“BDB (BerkeleyDB)存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>CSV</span></td>
					<td>
					<p>值之间用逗号隔开的表。请参见<a href="storage-engines.html#csv-storage-engine"  title="15.9. The CSV Storage Engine">15.9节，“CSV存储引擎</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>EXAMPLE</span></td>
					<td>
					<p>示例引擎。请参见<a href="storage-engines.html#example-storage-engine"  title="15.6. The EXAMPLE Storage Engine">15.6节，“EXAMPLE存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>FEDERATED</span></td>
					<td>
					<p>可以访问远程表的存储引擎。请参见<a href="storage-engines.html#federated-storage-engine"  title="15.7. The FEDERATED Storage Engine">15.7节，“FEDERATED存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>HEAP</span></td>
					<td>
					<p>见<a href="storage-engines.html#memory-storage-engine"  title="15.4. The MEMORY (HEAP) Storage Engine">15.4节，“MEMORY (HEAP)存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p><span>(<em><span>OBSOLETE</span></em>)
					<span>ISAM</span></span></td>
					<td>
					<p>在<span>MySQL 5.1</span>中没有此引擎。如果您要从以前的版本升级到<span>MySQL 
					5.1</span>，您应该在进行升级前把原有的<span>ISAM</span>表转换为<span>MyISAM</span>表。请参见<a href="storage-engines.html"  title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>InnoDB</span></td>
					<td>
					<p>带行锁定和外键的事务安全表。请参见<a href="storage-engines.html#innodb"  title="15.2. The InnoDB Storage Engine">15.2节，“InnoDB存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MEMORY</span></td>
					<td>
					<p>本表类型的数据只保存在存储器里。（在早期<span>MySQL</span>版本中被称为<span>HEAP</span>。）</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MERGE</span></td>
					<td>
					<p><span>MyISAM</span>表的集合，作为一个表使用。也称为<span>MRG_MyISAM</span>。请参见<a href="storage-engines.html#merge-storage-engine"  title="15.3. The MERGE Storage Engine">15.3节，“MERGE存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>MyISAM</span></td>
					<td>
					<p>二进制轻便式存储引擎，此引擎是<span>MySQL</span>所用的默认存储引擎。请参见<a href="storage-engines.html#myisam-storage-engine"  title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a>。</td>
				</tr>
				<tr>
					<td>
					<p>
					<span>NDBCLUSTER</span></td>
					<td>
					<p>成簇表，容错表，以存储器为基础的表。也称为<span>NDB</span>。请参见<a href="ndbcluster.html" >第17章：</a><a href="ndbcluster.html"  title="Chapter 17. MySQL Cluster"><i>MySQL簇</i></a>。</td>
				</tr>
			</table>
			<p>要了解有关<span>MySQL</span>存储引擎的更多信息，请参见<a href="storage-engines.html"  title="Chapter 15. Storage Engines and Table Types">第15章：<i>存储引擎和表类型</i></a>。</p>
			<p>如果被指定的存储引擎无法利用，则<span>MySQL</span>使用<span>MyISAM</span>代替。例如，一个表定义包括<span>ENGINE=BDB</span>选项，但是<span>MySQL</span>服务器不支持<span>BDB</span>表，则表被创建为<span>MyISAM</span>表。这样，如果您在主机上有事务表，但在从属机上创建的是非交互式表（以加快速度）时，可以进行复制设置。在<span>MySQL 
			5.1</span>中，如果没有遵守存储引擎规约，则会出现警告。</p>
			<p>其它表选项用于优化表的性质。在多数情况下，您不必指定表选项。这些选项适用于所有存储引擎，另有说明除外：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AUTO_INCREMENT</span><span> </span></p>
			<p>表的初始<span>AUTO_INCREMENT</span>值。在<span>MySQL 
			5.1</span>中，本选项只适用于<span>MyISAM</span>和<span>MEMORY</span>表。<span>InnoDB</span>也支持本选项。如果引擎不支持<span>AUTO_INCREMENT</span>表选项，则要设置引擎的第一个<span>auto-increment</span>值，需插入一个“假”行。该行的值比创建表后的值小一，然后删除该假行。</p>
			<p>对于在<span>CREATE TABLE</span>语句中支持<span>AUTO_INCREMENT</span>表选项的引擎，您也可以使用<span>ALTER 
			TABLE <i>tbl_name</i> AUTO_INCREMENT = <i>n</i></span>来重新设置<span>AUTO_INCREMENT</span>值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			AVG_ROW_LENGTH</span><span> </span></p>
			<p>表中平均行长度的近似值。只需要对含尺寸可变的记录的大型表进行此项设置。</p>
			<p >
			当创建一个<span>MyISAM</span>表时，<span>MySQL</span>使用<span>MAX_ROWS</span>和<span>AVG_ROW_LENGTH</span>选项的乘积来确定得出的表有多大。如果有一个选项未指定，则表的最大尺寸为<span>65,536TB</span>数据。（如果操作系统不支持这么大的文件，则表的尺寸被限定在操作系统的限值处。）如果您想缩小指针尺寸使索引更小，速度更快，并且您不需要大文件，则您可以通过设置<span>myisam_data_pointer_size</span>系统变量来减少默认指针的尺寸。（见<a href="database-administration.html#server-system-variables"  title="5.3.3. Server System Variables">5.3.3节，“服务器系统变量”</a>。）如果您希望所有的表可以扩大，超过默认限值，并且愿意让表稍微慢点，并稍微大点，则您可以通过设置此变量增加默认指针的尺寸。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			[DEFAULT] CHARACTER SET</span><span> </span></p>
			<p>用于为表指定一个默认字符集。<span>CHARSET</span>是<span><span>CHARACTER 
			SET</span>的同义词。</span></p>
			<p>对于<span>CHARACTER 
			SET</span><span>. </span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COLLATE</span><span>
			</span></p>
			<p>用于为表指定一个默认整序。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>CHECKSUM</span><span>
			</span></p>
			<p>如果您希望<span>MySQL</span>随时对所有行进行实时检验求和（也就是，表变更后，<span>MySQL</span>自动更新检验求和），则应把此项设置为<span>1</span>。这样做，表的更新速度会略微慢些，但是更容易寻找到受损的表。<span>CHECKSUM 
			TABLE</span>语句用于报告检验求和（仅限于<span>MyISAM</span>）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>COMMENT</span><span>
			</span></p>
			<p>表的注释，最长<span>60</span>个字符。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			CONNECTION</span><span> </span></p>
			<p><span>FEDERATED</span>表的连接字符串。（
			注释：较早版本的<span>MySQL</span>使用<span>COMMENT</span>选项用于连接字符串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MAX_ROWS</span><span>
			</span></p>
			<p>
			您打算储存在表中的行数目的最大值。这不是一个硬性限值，而更像一个指示语句，指示出表必须能存储至少这么多行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MIN_ROWS</span><span>
			</span></p>
			<p>您打算存储在表中的行数目的最小值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			PACK_KEYS</span><span> </span></p>
			<p>如果您希望索引更小，则把此选项设置为<span>1</span>。这样做通常使更新速度变慢，同时阅读速度加快。把选项设置为<span>0</span>可以取消所有的关键字压缩。把此选项设置为<span>DEFAULT</span>时，存储引擎只压缩长的<span>CHAR</span>或<span>VARCHAR</span>列（仅限于<span>MyISAM</span>）。</p>
			<p>如果您不使用<span>PACK_KEYS</span>，则默认操作是只压缩字符串，但不压缩数字。如果您使用<span>PACK_KEYS=1</span>，则对数字也进行压缩。</p>
			<p>在对二进制数字关键字进行压缩时，<span>MySQL</span>采用前缀压缩：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>每个关键字需要一个额外的字节来指示前一个关键字中有多少字节与下一个关键字相同。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>指向行的指针以高位字节优先的顺序存储在关键字的后面，用于改进压缩效果。</p>
			<p>
			这意味着，如果两个连续行中有许多相同的关键字，则后续的“相同”的关键字通常只占用两个字节（包括指向行的指针）。与此相比，常规情况下，后续的关键字占用<span><span>storage_size_for_key 
			+ pointer_size</span>（指针尺寸通常为<span>4</span>）。但是，只有在许多数字相同的情况下，前缀压缩才有好处。如果所有的关键字完全不同，并且关键字不能含有<span>NULL</span>值，则每个关键字要多使用一个字节。（在这种情况中，储存压缩后的关键字的长度的字节与用于标记关键字是否为<span>NULL</span>的字节是同一字节。）</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>PASSWORD</span><span>
			</span></p>
			<p>使用密码对<span>.frm</span>文件加密。在标准<span>MySQL</span>版本中，本选项不起任何作用。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			DELAY_KEY_WRITE</span><span> </span></p>
			<p>如果您想要延迟对关键字的更新，等到表关闭后再更新，则把此项设置为<span>1</span>（仅限于<span>MyISAM</span>）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			ROW_FORMAT</span><span> </span></p>
			<p>定义各行应如何储存。当前，此选项只适用于<span>MyISAM</span>表。对于静态行或长度可变行，此选项值可以为<span>FIXED</span>或<span>DYNAMIC</span>。<strong><span>myisampack</span></strong>用于把类型设置为<span>COMPRESSED</span>。请参见<a href="storage-engines.html#myisam-table-formats"  title="15.1.3. MyISAM Table Storage Formats">15.1.3节，“MyISAM表的存储格式”</a>。</p>
			<p>在默认情况下，<span>InnoDB</span>记录以压缩格式存储（<span>ROW_FORMAT=COMPACT</span>）。通过指定<span>ROW_FORMAT=REDUNDANT</span>，仍然可以申请用于较早版本的<span>MySQL</span>中的非压缩格式。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			RAID_TYPE</span><span> </span></p>
			<p>在<span>MySQL 5.0</span>中<span>,RAID</span>支持被删除了。要了解有关<span>RAID</span>的说明，请参见<span class="MsoHyperlink"><span>http://dev.mysql.com/doc/refman/4.1/en/create-table.html</span></span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>UNION</span><span>
			</span></p>
			<p>当您想要把一组相同的表当作一个表使用时，采用<span>UNION</span>。<span>UNION</span>仅适用于<span>MERGE</span>表。请参见<a href="storage-engines.html#merge-storage-engine"  title="15.3. The MERGE Storage Engine">15.3节，“MERGE存储引擎”</a>。</p>
			<p>对于您映射到一个<span>MERGE</span>表上的表，您必须拥有<span>SELECT, 
			UPDATE</span>和<span>DELETE</span>权限。（注释：以前，所有被使用的表必须位于同一个数据库中，并作为<span>MERGE</span>表。这些限制不再适用。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>
			INSERT_METHOD</span><span> </span></p>
			<p>如果您希望在<span>MERGE</span>表中插入数据，您必须用<span>INSERT_METHOD</span>指定应插入行的表。<span>INSERT_METHOD</span>选项仅用于<span>MERGE</span>表。使用<span>FIRST</span>或<span>LAST</span>把行插入到第一个或最后一个表中；或者使用<span>NO</span>，阻止插入行。请参见<a href="storage-engines.html#merge-storage-engine"  title="15.3. The MERGE Storage Engine">15.3节，“MERGE存储引擎”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>DATA 
			DIRECTORY</span><span>,
			<span>INDEX DIRECTORY</span> </span></p>
			<p>通过使用<span>DATA 
			DIRECTORY=&#39;<i>directory</i>&#39;</span>或<span>INDEX 
			DIRECTORY=&#39;<i>directory</i>&#39;</span>，您可以指定<span>MyISAM</span>存储引擎放置表格数据文件和索引文件的位置。注意，目录应是通向目录的完整路径（不是相对路径）。</p>
			<p>仅当您没有使用<span>--skip-symbolic-links</span>选项时，<span>DATA 
			DIRECTORY</span><span>,
			<span>INDEX DIRECTORY</span></span>才能使用。操作系统必须有一个正在工作的、线程安全的<span>realpath()</span>调用。要了解全面信息，请参见<a href="optimization.html#symbolic-links-to-tables"  title="7.6.1.2. Using Symbolic Links for Tables on Unix">7.6.1.2节，“在Unix平台上使用表的符号链接</a>”。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于用<span>CREATE TABLE</span>创建的表，可以使用<span><i><span>partition_options</span></i></span>控制分区。如果使用了<span><i><span>partition_options</span></i></span>，则其中必须包含至少一个<span>PARTITION 
			BY</span>子句。本子句包含用于确定分区的函数；该函数会返回一个整值，范围从<span>1</span>到<span><i><span>num</span></i></span>。此处<span><i><span>num</span></i></span>为分区的数目。此函数中可以使用的选项显示在下面的清单中。
			要点：在本节开始时介绍的用于<span><i><span>partition_options</span></i></span>的语法中显示的选项，并不是都能用于所有分区类型。要了解各种类型具体的信息
			，请参见以下各类型的清单。要了解有关在<span>MySQL</span>中的分区的操作和使用情况的全面说明，以及要了解表创建的示例和与<span>MySQL</span>分区有关的其它命令，请参见<a href="partitioning.html" >第18章：</a><a href="partitioning.html"  title="Chapter 18. Partitioning"><i>分区</i></a>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>HASH</span>（<span><i><span>expr</span></i></span>）：用于混编一个或多个列，创建一个关键字，用于放置行，并确定行的位置。<span><i><span>expr</span></i></span>是一个表达式，使用一个或多个表中的列。该表达式可以是任何能够生成单一整值的合法的<span>MySQL</span>表达式（包括<span>MySQL</span>函数）。例如，这些都是有效的<span>CREATE 
			TABLE</span>语句，语句中使用了<span>PARTITION BY HASH</span>：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5)) </span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH(col1);</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5))</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH( ORD(col2) );</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH ( YEAR(col3) );</span></pre>
			<p><span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>子句不能和<span>PARTITION BY HASH</span>一起使用。</p>
			<p><span>PARTITION BY HASH</span>使用<span><i><span>expr</span></i></span>被分区数目所除后的余数（也就是模数）。要了解示例和其它信息，请参见<a href="partitioning.html#partitioning-hash"  title="18.2.3. HASH Partitioning">18.2.3节，“HASH分区”</a>。</p>
			<p><span>LENEAR</span>关键词需要一种不同的算法。在这种情况下，通过一次或多次逻辑<span>AND</span>运算得出的结果，计算出存储记录的分区的数目。要了解线形混编的讨论和示例，请参见<a href="partitioning.html#partitioning-linear-hash"  title="18.2.3.1. LINEAR HASH Partitioning">18.2.3.1节，“LINEAR 
				HASH分区”</a>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>KEY(<i>column_list</i>)</span>：与<span>HASH</span>近似，除了有一点不一样，即<span>MySQL</span>提供了混编函数，以保证均匀的数据分布。<i><span>column_list</span></i>自变量只是各列的一个清单。本示例显示了由关键字进行分区的一个简单的表，分为<span>4</span>个分区：</span></p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY KEY(col3)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITIONS 4;</span></pre>
			<p>采用<span>LINEAR</span>关键词，您可以对由关键字分区的表进行线形分区。这与由<span>HASH</span>进行分区的表格有同样的效果；也就是说，使用<span>&amp;</span>操作符查找分区数目，而不是使用模数（详细说明见<a href="partitioning.html#partitioning-linear-hash"  title="18.2.3.1. LINEAR HASH Partitioning">18.2.3.1节，“LINEAR 
				HASH分区”</a>和<a href="partitioning.html#partitioning-key"  title="18.2.4. KEY Partitioning">18.2.4节，“KEY分区”</a>）。本示例采用了关键字线形分区，用来在<span>5</span>个分区之间分配数据：</p>
			<pre><span>CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)</span></pre>
			<pre><span> &nbsp;&nbsp;&nbsp;PARTITION BY LINEAR KEY(col3)</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITIONS 5;</span></pre>
			<p><span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>子句不能和<span>PARTITION BY KEY</span>一起使用。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>RANGE</span>：在此情况下，<span><i><span>expr</span></i>使用一套<span>VALUES 
			LESS THAN</span>操作符</span>显示了某一范围内的值。当使用范围分区时，您必须使用<span>VALUES 
			LESS THAN</span>定义至少一个分区。<span>VALUES IN</span>不能和范围分区一起使用。</p>
			<p><span>VALUES LESS THAN</span>可以与一个文字值同时使用，或者与一个可以求算单一值的表达式同时使用。</p>
			<p>举例说明，假设您有一个表，您希望采用以下方法对包含年份值的一列进行分区：</p>
			<table border="1" cellpadding="0" id="table4">
				<tr>
					<td>
					<p>分区编号：</td>
					<td>
					<p>年份范围：</td>
				</tr>
				<tr>
					<td>
					<p><span>0</span></td>
					<td>
					<p><span>1990</span>以前</td>
				</tr>
				<tr>
					<td>
					<p><span>1</span></td>
					<td>
					<p><span>1991 - 1994</span></td>
				</tr>
				<tr>
					<td>
					<p><span>2</span></td>
					<td>
					<p><span>1995 - 1998</span></td>
				</tr>
				<tr>
					<td>
					<p><span>3</span></td>
					<td>
					<p><span>1999 - 2002</span></td>
				</tr>
				<tr>
					<td>
					<p><span>4</span></td>
					<td>
					<p><span>2003 - 2005</span></td>
				</tr>
				<tr>
					<td>
					<p><span>5</span></td>
					<td>
					<p><span>2006</span>年以后</td>
				</tr>
			</table>
			<p>采用这种分区方法的表可以通过如下<span>CREATE 
			TABLE</span>语句实现：</p>
			<pre><span>CREATE TABLE t1 (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; year_col INT, </span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;some_data INT </span></pre>
			<pre><span>) </span></pre>
			<pre><span>PARTITION BY RANGE (year_col) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1991),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1995),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (1999),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p3 VALUES LESS THAN (2002),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p4 VALUES LESS THAN (2006),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION p5 VALUES LESS THAN MAXVALUE</span></pre>
			<pre><span>);</span></pre>
			<p><span>
			<span>PARTITION ... VALUES LESS THAN ...</span>语句按顺序执行。<span>VALUES 
			LESS THAN MAXVALUE</span>的作用是指定大于最大值的“其余”的值。</span></p>
			<p>注意，<span>VALUES LESS THAN</span>子句按顺序执行，执行方式类似于<span><span>switch 
			... case</span>语段的一部分</span>（许多编程语言，如<span>C, Java</span>和<span>PHP</span>也如此）。也就是说，子句必须按照这样一种方法排列，每一个后续的<span>VALUES 
			LESS THAN</span>中指定的上限值大于前一个<span>VALUES LESS THAN</span>中指定的上限值，并在清单的最后加一个参照性的<span>MAXVALUE</span>。</p>
			<p><span>VALUES IN</span>与一系列的值同时使用。举例说明，您可以创建如下的分区方法：</p>
			<pre><span>CREATE TABLE client_firms (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; id INT,</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; name VARCHAR(35)</span></pre>
			<pre><span>)</span></pre>
			<pre><span>PARTITION BY RANGE (id) (</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)</span></pre>
			<pre><span>);</span></pre>
			<p>当前，与<span>VALUES IN...</span>同时使用的值必须只包含整数值。</p>
			<p>（因为此表只使用<span>VALUES IN</span>表达式进行分区，您也可以用<span>PARTITION 
			BY LIST</span>代替，而不是使用<span>PARTITION BY RANGE</span>。请参见下一条。）</p>
			<p>在使用<span>VALUES LESS THAN</span>或<span>VALUES 
			IN</span>情况下，每个分区使用<span>PARTITION
			<span><i>name</i></span></span>定义，此处<span><i><span>name</span></i></span>是分区的标识名，后面接<span>VALUES...</span>子句。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span><span>LIST(<i>expr</i>)</span>：当根据含有一系列限定性值（例如州代码或国家代码）的列进行分区时使用。在这种情况下，所有与特定的州或国家有关的记录都被分配到一个单一分区中，或者可以预留出一个分区，用于一系列特定的州或国家。<span>LIST(<i>expr</i>)</span>与<span>RANGE</span>类似，除了一点以外，即只有<span>VALUES 
			IN</span>可以被用于为每个分区指定值。</span></p>
			<p>当使用清单分区时，您必须使用<span>VALUES 
			IN</span>定义至少一个分区。<span>VALUES LESS THAN</span>不能与<span>PARTITION 
			BY LIST</span>一起使用。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分区数目可以使用<span>PARTITION
			<span><i>num</i></span></span>子句，自选进行指定，此处，<span><i><span>num</span></i></span>是分区的数目。如果本子句和其它<span>PARTITION</span>子句同时使用，则<span><i><span>num</span></i></span>必须与使用<span>PARTITION</span>子句说明的分区的总数相等。</p>
			<p>注释：不论您在创建一个由<span>RANGE</span>或<span>LIST</span>进行分区的表时是否使用了<span>PARTITIONS</span>子句，您必须在表定义中包括至少一个<span>PARTITION 
			VALUES</span>（见后）。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>一个分区可以自选分隔成多个子分区。使用自选的<span>SUBPARTITION BY</span>子句可以指示。子分区可以由<span>HASH</span>或<span>KEY</span>进行分隔。两种方法建立的子分区均为<span>LINEAR</span>。分隔子分区时的操作方式与以前描述的分区类型的操作方式一样。（无法由<span>LIST</span>或<span>RANGE</span>进行子分区分隔。）</p>
			<p>使用<span>SUBPARTITIONS</span>关键词，后面接一个整值，可以对子分区的数目进行指示。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用一个<span><i><span>partition_definition</span></i></span>子句可以对每个分区分别进行定义。下面是组成这个子句的各个部分：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>PARTITION <i>
			partition_name</i></span>：用于为分区指定一个逻辑名称。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>VALUE</span>子句：对于范围分区，每个分区必须包括一个<span>VALUES 
			LESS THAN</span>子句；对于清单分区，您必须为每个分区指定一个<span>VALUES IN</span>子句。本子句用于确定哪些行将被存储到此分区中。要了解语法示例，请参见<a href="partitioning.html" >第18章：</a><a href="partitioning.html"  title="Chapter 18. Partitioning"><i>分区</i></a>中对分区类型的讨论。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自选的<span>COMMENT</span>子句可以用于描述分区。注释必须加单引号。举例说明：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>COMMENT = &#39;Data for the years previous to 1999&#39;</span></pre>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>DATA DIRECTORY</span>和<span>INDEX 
			DIRECTORY</span>可以被用于指示本分区的数据和索引各自的存储位置的目录。<span><i><span>data_dir</span></i></span>和<span><i><span>index_dir</span></i></span>都必须是绝对系统路径。例如：</p>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>PARTITION BY LIST(YEAR(adate))</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p1999 VALUES IN (1995, 1999, 2003) DATA DIRECTORY = &#39;<span>/var/appdata/95/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/95/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2000 VALUES IN (1996, 2000, 2004) DATA DIRECTORY = &#39;<span>/var/appdata/96/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/96/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2001 VALUES IN (1997, 2001, 2005) DATA DIRECTORY = &#39;<span>/var/appdata/97/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/97/idx</span>&#39;,</span></pre>
			<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;PARTITION p2000 VALUES IN (1998, 2002, 2006) DATA DIRECTORY = &#39;<span>/var/appdata/98/data</span>&#39; INDEX DIRECTORY = &#39;<span>/var/appdata/98/idx</span>&#39;</span></pre>
			<pre><span>);</span></pre>
			<p><span>DATA DIRECTORY</span>和<span>INDEX 
			DIRECTORY</span>的操作方法与<span>CREATE TABLE</span>语句中的<span><i><span>table_option</span></i></span>子句的操作方法一样。此<span><i><span>table_option</span></i></span>子句用于位于<span>MyISAM</span>表管理程序下的各表。</p>
			<p>
			可以为每个分区指定一个数据目录和一个索引目录。如果不指定，则数据和索引被存储在默认的<span>MySQL</span>数据目录中。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>MAX_ROWS</span>和<span>MIN_ROWS</span>分别用于将被存储在分区中的行数目最大值和行数目最小值。<span><i><span>max_number_of_rows</span></i></span>和<span><i><span>min_number_of_rows</span></i>的值</span>必须为正整数。和具有同样名称的桌面选项一样，<span><i><span>max_number_of_rows</span></i></span>和<span><i><span>min_number_of_rows</span></i></span>只作为对服务器的“建议”值，并不是硬性限值。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自选的<span>TABLESPACE</span>子句可以用于为分区指定一个桌面空间。仅用于<span>MySQL 
			Cluster</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>自选的<span>[STORAGE] ENGINE</span>子句可以把本分区中表的类型改为指定的类型。表的类型可以是本<span>MySQL</span>服务器支持的所有类型。<span>STORAGE</span>关键字和等号<span>(=)</span>均为自选项。如果没有使用此选项设置分区存储引擎，则适用于整个表的引擎可以用于此分区。</p>
			<p>注释：分区管理程序对于<span>PARTITION</span>和<span>SUBPARTITION</span>均接受<span>[STORAGE] 
			ENGINE</span>选项。目前，此子句的使用方式仅限于对所有的分区或子分区设置同一个存储引擎，如果试图在同一个表内对不同的分区或子分区设置不同的存储引擎，则会出现错误<span>ERROR 
			1469 (HY000)</span>：在本版本的<span>MySQL</span>中，不允许在各分区中混用管理程序。我们打算在将来的<span>MySQL 
			5.1</span>版本中加入这种对分区的限定。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>NODEGROUP</span>选项可以用于使本分区可以作为节点组的一部分，节点组使用<span><i><span>node_group_id</span></i></span>识别。本选项仅适用于<span>MySQL 
			Cluster</span>。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>分区定义可以自选地包含一个或多个<span><i><span>subpartition_definition</span></i></span>子句。每个这种子句至少包括<span>SUBPARTITION
			<i>name</i></span>，此处，<span><i><span>name</span></i></span>是子分区的识别名称。除了用<span>SUBPARTITION</span>代替<span>PARTITION</span>关键词外，用于子分区定义的语法与用于分区定义的语法一样。</p>
			<p>子分区必须由<span>HASH</span>或<span>KEY</span>完成，并且只能对<span>RANGE</span>或<span>LIST</span>分区进行子分区。请参见<a href="partitioning.html#partitioning-subpartitions"  title="18.2.5. Subpartitioning">18.2.5节，“子分区”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>分区可以修改、合并、添加到表中，或从表中删去。要了解有关完成这些任务的<span>MySQL</span>命令的基本说明，请参见<a href="sql-syntax.html#alter-table"  title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
			TABLE语法”</a>。要了解详细的说明和示例，请参见<a href="partitioning.html#partitioning-management"  title="18.3. Partition Management">18.3节，“分区管理”</a>。</p>
			<p>您可以在<span>CREATE TABLE</span>语句的末尾添加一个<span>SELECT</span>语句，在一个表的基础上创建表。</p>
			<pre><span>CREATE TABLE <span><i>new_tbl</i></span> SELECT * FROM <span><i>orig_tbl</i></span>;</span></pre>
			<p><span>MySQL</span>会对<span>SELECT</span>中的所有项创建新列。举例说明：</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>PRIMARY KEY (a), KEY(b))</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>TYPE=MyISAM SELECT b,c FROM test2;</b></span></span></pre>
			<p>本语句用于创建含三个列（<span>a, b, c</span>）的<span>MyISAM</span>表。注意，用<span>SELECT</span>语句创建的列附在表的右侧，而不是覆盖在表上。参考以下示例：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM foo;</b></span></span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>| n |</span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>| 1 |</span></pre>
			<pre><span>+---+</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>CREATE TABLE bar (m INT) SELECT n FROM foo;</b></span></span></pre>
			<pre><span>Query OK, 1 row affected (0.02 sec)</span></pre>
			<pre><span>Records: 1&nbsp; Duplicates: 0&nbsp; Warnings: 0</span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>SELECT * FROM bar;</b></span></span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>| m&nbsp;&nbsp;&nbsp; | n |</span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>| NULL | 1 |</span></pre>
			<pre><span>+------+---+</span></pre>
			<pre><span>1 row in set (0.00 sec)</span></pre>
			<p>对应于表<span>foo</span>中的每一行，在表<span>bar</span>中插入一行，含有表<span>foo</span>中的值以及新列中的默认值。</p>
			<p>在由<span>CREATE TABLE...SELECT</span>生成的表中，只在<span>CREATE 
			TABLE</span>部分中命名的列首先出现。在两个部分中都命名的列和只在<span>SELECT</span>部分中命名的列随后出现。也可以通过指定<span>CREATE 
			TABLE</span>部分中的列覆盖<span>SELECT</span>列中的数据类型。</p>
			<p>如果在把数据复制到表中时出现错误，则表会自动被取消，不会被创建。</p>
			<p><span>CREATE TABLE...SELECT</span>不会自动创建任何索引。索引需要专门创建，以便使语句的灵活性更强。如果您希望为已创建的表建立索引，您应在<span>SELECT</span>语句前指定索引。</p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;</b></span></span></pre>
			<p>列的类型会发生部分转化。例如，<span>AUTO_INCREAMENT</span>属性不会被保留，<span>VARCHAR</span>列会变成<span>CHAR</span>列。</p>
			<p>当使用<span>CREATE...SELECT</span>创建表时，在查询时一定要对功能调用和表达式起别名。如果不起别名，则<span>CREATE</span>语句会出现错误或者生成不符合需要的列名称。</p>
			<pre><span>CREATE TABLE artists_and_works</span></pre>
			<pre><span>SELECT artist.name, COUNT(work.artist_id) AS number_of_works</span></pre>
			<pre><span>FROM artist LEFT JOIN work ON artist.id = work.artist_id</span></pre>
			<pre><span>GROUP BY artist.id;</span></pre>
			<p>您也可以明确地为一个已生成的列指定类型：</p>
			<pre><span>CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;</span></pre>
			<p>根据其它表的定义（包括在原表中定义的所有的列属性和索引），使用<span>LIKE</span>创建一个空表<span>:</span></p>
			<pre><span>CREATE TABLE <span><i>new_tbl</i></span> LIKE <span><i>orig_tbl</i></span>;</span></pre>
			<p><span>CREATE TABLE...LIKE</span>不会复制对原表或外键定义指定的<span>DATA 
			DIRECTORY</span>或<span>INDEX DIRECTORY</span>表选项。</p>
			<p>您可以在<span>SELECT</span>前增加<span>IGNORE</span>或<span>REPLACE</span>，指示如何对复制唯一关键字值的记录进行操纵。使用<span>IGNORE</span>后，如果新记录复制了原有的唯一关键字值的记录，则新记录被丢弃。使用<span>REPLACE</span>后，新记录替换具有相同的唯一关键字值的记录。如果没有指定<span>IGNORE</span>或<span>REPLACE</span>，则出现多重唯一关键字值时会导致发生错误。</p>
			<p>为了确保更新日志<span>/</span>二进位日志可以被用于再次创建原表，<span>MySQL</span>不允许在<span>CREATE 
			TABLE...SELECT</span>过程中进行联合插入。</p>
			<div class="section">
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="silent-column-changes"></a>
				13.1.5.1.&nbsp;沉寂的列规格变更</h4></div></div></div><a class="indexterm" name="id2897793"></a>
				<p>在有些情况下，较早版本的<span>MySQL</span>会静默地更改在<span>CREATE 
				TABLE</span>或<span>ALTER TABLE</span>语句中给定的列规约。在<span>MySQL 
				5.1</span>中不会进行这类变更。如果使用指定的数据类型无法创建列，则会出现错误。</p>
				<div>
					<div>
						<h3 class="title"><a name="drop-database"></a>13.1.6. DROP 
			DATABASE语法</h3></div></div></div>
			<a class="indexterm" name="id2897830"></a>
			<a class="indexterm" name="id2897840"></a>
			<a class="indexterm" name="id2897848"></a>
			<a class="indexterm" name="id2897859"></a>
			<a class="indexterm" name="id2897869"></a>
			<a class="indexterm" name="id2897879"></a>
			<pre><span>DROP {DATABASE | SCHEMA} [IF EXISTS] <span><i>db_name</i></span></span></pre>
			<p><span>DROP DATABASE</span>用于取消数据库中的所用表格和取消数据库。使用此语句时要非常小心！如果要使用<span>DROP 
			DATABASE</span>，您需要获得数据库<span>DROP</span>权限。</p>
			<p><span>IF EXISTS</span>用于防止当数据库不存在时发生错误。</p>
			<p>也可以使用<span>DROP SCHEMA</span>。</p>
			<p>如果您对一个带有符号链接的数据库使用<span>DROP DATABASE</span>，则链接和原数据库都被取消。</p>
			<p><span>DROP DATABASE</span>会返回已被取消的表的数目。此数目相当于被取消的<span>.frm</span>文件的数目。</p>
			<p>在正常操作中<span>MySQL</span>自身会创建出一些文件和目录。<span>DROP 
			DATABASE</span>语句会从给定的数据库目录中取消这些文件和目录：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>所有带这些扩展名的文件：</p>
			<table border="1" cellpadding="0" id="table5">
				<tr>
					<td>
					<p>
					<span>.BAK</span></td>
					<td>
					<p>
					<span>.DAT</span></td>
					<td>
					<p>
					<span>.HSH</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>.MRG</span></td>
					<td>
					<p>
					<span>.MYD</span></td>
					<td>
					<p>
					<span>.ISD</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
				<tr>
					<td>
					<p>
					<span>.MYI</span></td>
					<td>
					<p>
					<span>.db</span></td>
					<td>
					<p>
					<span>.frm</span></td>
					<td>
					<p><span>&nbsp;</span></td>
				</tr>
			</table>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>名称中包含两位<span>16</span>进制数<span>00-ff</span>的所有子目录。这些子目录用于<span>RAID</span>表。（当对<span>RAID</span>表的支持被取消时，在<span>MySQL 
			5.0</span>中，这些目录不会被取消。您应该在升级到<span>MySQL 5.0</span>或更新的版本前转化原有的<span>RAID</span>表，并人工取消这些目录。请参见<span>MySQL 
			5.0</span>参考手册中有关从较早版本升级到<span>MySQL 5.0</span>的章节。<span>MySQL 
			5.0</span>参考手册可以从<span>MySQL</span>网站中获取。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>db.opt</span>文件</p>
			<p>如果在<span>MySQL</span>取消了上述这些文件之后，在数据库目录中仍保留有其它文件和目录，则数据库目录不能被取消。在这种情况下，您必须人工取消所有保留下的文件或目录，并再次发送<span>DROP 
			DATABASE</span>语句。</p>
			<p>您还可以使用<strong><span>mysqladmin</span></strong>来取消文件。请参见<a href="client-side-scripts.html#mysqladmin"  title="8.5. mysqladmin — Client for Administering a MySQL Server">8.5节，“mysqladmin：用于管理MySQL服务器的客户端”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-index"></a>13.1.7. DROP 
			INDEX语法</h3></div></div></div><a class="indexterm" name="id2898172"></a><a class="indexterm" name="id2898181"></a><a class="indexterm" name="id2898191"></a>
			<pre><span>DROP INDEX <span><i>index_name</i></span> ON <span><i>tbl_name</i></span></span></pre>
			<p><span>DROP INDEX</span>用于从表<span><i><span>tbl_name</span></i></span>中取消名称为<span><i><span>index_name</span></i></span>的索引。本语句被映射到一个<span>ALTER 
			TABLE</span>语句中，用于取消索引。请参见<a href="sql-syntax.html#alter-table"  title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
		TABLE语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="drop-table"></a>13.1.8. DROP 
			TABLE语法</h3></div></div></div><a class="indexterm" name="id2898277"></a><a class="indexterm" name="id2898286"></a><a class="indexterm" name="id2898296"></a>
			<pre><span>DROP [TEMPORARY] TABLE [IF EXISTS]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span> [, <span><i>tbl_name</i></span>] ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [RESTRICT | CASCADE]</span></pre>
			<p><span>DROP TABLE</span>用于取消一个或多个表。您必须有每个表的<span>DROP</span>权限。所有的表数据和表定义会被取消，所以使用本语句要小心！</p>
			<p>注意，对于一个带分区的表，<span>DROP TABLE</span>会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。<span>DROP 
			TABLE</span>还会取消与被取消的表有关联的分区定义（<span>.par</span>）文件。</p>
			<p>对与不存在的表，使用<span>IF EXISTS</span>用于防止错误发生。当使用<span>IF 
			EXISTS</span>时，对于每个不存在的表，会生成一个<span>NOTE</span>。请参见<a href="sql-syntax.html#show-warnings"  title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22节，“SHOW 
		WARNINGS语法”</a>。</p>
			<p><span>RESTRICT</span>和<span>CASCADE</span>可以使分区更容易。目前，<span>RESTRICT</span>和<span>CASCADE</span>不起作用。</p>
			<p>注释：除非您使用<span>TEMPORARY</span>关键词，<span>DROP 
			TABLE</span>会自动提交当前的有效的事务。</p>
			<p><span>TEMPORARY</span>关键词具有以下作用：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>语句只取消<span>TEMPORARY</span>表。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>语句不会终止正在进行中的事务。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不会查验存取权。（<span>TEMPORARY</span>表仅对于创建该表的客户端是可见的，所以查验是不必要的。）</p>
			<p>使用<span>TEMPORARY</span>是确保您不会意外取消一个非<span>TEMPORARY</span>表的良好方法。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="rename-table"></a>13.1.9. RENAME 
			TABLE语法</h3></div></div></div><a class="indexterm" name="id2898503"></a></div></div><div class="section"><div class="titlepage"><div><div>
		<pre><span>RENAME TABLE <span><i>tbl_name</i></span> TO <span><i>new_tbl_name</i></span></span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp; [, <span><i>tbl_name2</i></span> TO <span><i>new_tbl_name2</i></span>] ...</span></pre>
		<p>本语句用于对一个或多个表进行重命名。</p>
		<p>重命名操作自动进行，这意味着当重命名正在运行时，其它线程不能读取任何表。例如，如果您有一个原有的表<span>old_table</span>，您可以创建另一个具有相同结构的空表<span>new_table</span>，然后用此空表替换原有的表：</p>
		<pre><span>CREATE TABLE <span><i>new_table</i></span> (...);</span></pre>
		<pre><span>RENAME TABLE <span><i>old_table</i></span> TO <span><i>backup_table</i></span>, <span><i>new_table</i></span> TO <span><i>old_table</i></span>;</span></pre>
		<p>如果此语句用于对多个表进行重命名，则重命名操作从左至右进行。如果您想要交换两个表的名称，您可以这样做（假设不存在名称为<span>tmp_table</span>的表）：</p>
		<pre><span>RENAME TABLE <span><i>old_table</i></span> TO <span><i>tmp_table</i></span>,</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>new_table</i></span> TO <span><i>old_table</i></span>,</span></pre>
		<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><i>tmp_table</i></span> TO <span><i>new_table</i></span>;</span></pre>
		<p>只要两个数据库位于同一文件系统中，您还可以对表进行重命名，把表从一个数据库中移动到另一个数据库中：</p>
		<pre><span>RENAME TABLE <span><i>current_db.tbl_name</i></span> TO <span><i>other_db.tbl_name;</i></span></span></pre>
		<p>当您执行<span>RENAME</span>时，您不能有被锁定的表，也不能有处于活性状态的事务。您还必须拥有原表的<span>ALTER</span>和<span>DROP</span>权限，以及新表的<span>CREATE</span>和<span>INSERT</span>权限。</p>
		<p>如果<span>MySQL</span>对多个表进行重命名时遇到了错误，<span>MySQL</span>会对所有已被重命名的表进行反向重命名，返回到原来的状态。</p>
		<p>只要您不尝试通过重命名把视图加入另一个数据库中，则<span>RENAME TABLE</span>也可以用于视图。</p>
		<h2 class="title"><a name="data-manipulation"></a>
		13.2.&nbsp;数据操作语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#delete" >13.2.1. 
			DELETE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#do" >13.2.2. 
			DO语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#handler" >13.2.3. 
			HANDLER语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert" >13.2.4. 
			INSERT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#load-data" >13.2.5. 
			LOAD DATA INFILE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#replace" >13.2.6. 
			REPLACE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#select" >13.2.7. 
			SELECT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#subqueries" >
			13.2.8. Subquery语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#truncate" >13.2.9. 
			TRUNCATE语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#update" >13.2.10. 
			UPDATE语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="delete"></a>13.2.1. DELETE语法</h3></div></div></div><a class="indexterm" name="id2898726"></a>
			<p>单表语法：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT <span><i>row_count</i></span>]</span></pre>
			<p>多表语法：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>tbl_name</i></span>[.*] [, <span><i>tbl_name</i></span>[.*] ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p>或：</p>
			<pre><span>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; FROM <span><i>tbl_name</i></span>[.*] [, <span><i>tbl_name</i></span>[.*] ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; USING <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p><span><i><span>tbl_name</span></i></span>中有些行满足由<span><i><span>where_definition</span></i></span>给定的条件。<span>DELETE</span>用于删除这些行，并返回被删除的记录的数目。</p>
			<p>如果您编写的<span>DELETE</span>语句中没有<span>WHERE</span>子句，则所有的行都被删除。当您不想知道被删除的行的数目时，有一个更快的方法，即使用<span>TRUNCATE 
			TABLE</span>。请参见<a href="sql-syntax.html#truncate"  title="13.2.9. TRUNCATE Syntax">13.2.9节，“TRUNCATE语法”</a>。</p>
			<p>如果您删除的行中包括用于<span>AUTO_INCREMENT</span>列的最大值，则该值被重新用于<span>BDB</span>表，但是不会被用于<span>MyISAM</span>表或<span>InnoDB</span>表。如果您在<span>AUTOCOMMIT</span>模式下使用<span>DELETE 
			FROM <span><i>tbl_name</i></span></span>（不含<span>WHERE</span>子句）删除表中的所有行，则对于所有的表类型（除<span>InnoDB</span>和<span>MyISAM</span>外），序列重新编排。对于<span>InnoDB</span>表，此项操作有一些例外，在<a href="storage-engines.html#innodb-auto-increment-column"  title="15.2.6.3. How an AUTO_INCREMENT Column Works in InnoDB">15.2.6.3节，“AUTO_INCREMENT列如何在InnoDB中运行”</a>中进行了讨论。</p>
			<p>对于<span>MyISAM</span>和<span>BDB</span>表，您可以把<span>AUTO_INCREMENT</span>次级列指定到一个多列关键字中。在这种情况下，从序列的顶端被删除的值被再次使用，甚至对于<span>MyISAM</span>表也如此。请参见<a href="tutorial.html#example-auto-increment"  title="3.6.9. Using AUTO_INCREMENT">3.6.9节，“使用AUTO_INCREMENT”</a>。</p>
			<p><span>DELETE</span>语句支持以下修饰符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定<span>LOW_PRIORITY</span>，则<span>DELETE</span>的执行被延迟，直到没有其它客户端读取本表时再执行。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于<span>MyISAM</span>表，如果您使用<span>QUICK</span>关键词，则在删除过程中，存储引擎不会合并索引端结点，这样可以加快部分种类的删除操作的速度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在删除行的过程中，<span>IGNORE</span>关键词会使<span>MySQL</span>忽略所有的错误。（在分析阶段遇到的错误会以常规方式处理。）由于使用本选项而被忽略的错误会作为警告返回。</p>
			<p>删除操作的速度会受到一些因素的影响，这些因素在<a href="optimization.html#delete-speed"  title="7.2.18. Speed of DELETE Statements">7.2.18节，“DELETE语句的速度”</a>中进行了讨论。 </p>
			<p>在<span>MyISAM</span>表中，被删除的记录被保留在一个带链接的清单中，后续的<span>INSERT</span>操作会重新使用旧的记录位置。要重新使用未使用的空间并减小文件的尺寸，则使用<span>OPTIMIZE 
			TABLE</span>语句或<strong><span>myisamchk</span></strong>应用程序重新编排表。<span>OPTIMIZE 
			TABLE</span>更简便，但是<strong><span>myisamchk</span></strong>速度更快。请参见<a href="sql-syntax.html#optimize-table"  title="13.5.2.5. OPTIMIZE TABLE Syntax">13.5.2.5节，“OPTIMIZE 
		TABLE语法”</a>和<a href="optimization.html" >第7章：</a><a href="optimization.html"  title="Chapter 7. Optimization"><i>优化</i></a>。</p>
			<p><span>QUICK</span>修饰符会影响到在删除操作中索引端结点是否合并。当用于被删除的行的索引值被来自后插入的行的相近的索引值代替时，<span>DELETE 
			QUICK</span>最为适用。在此情况下，被删除的值留下来的空穴被重新使用。</p>
			<p>未充满的索引块跨越某一个范围的索引值，会再次发生新的插入。当被删除的值导致出现未充满的索引块时，<span>DELETE 
			QUICK</span>没有作用。在此情况下，使用<span>QUICK</span>会导致未利用的索引中出现废弃空间。下面是此种情况的举例说明：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>创建一个表，表中包含已编索引的<span>AUTO_INCREMENT</span>列。</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>在表中插入很多记录。每次插入会产生一个索引值，此索引值被添加到索引的高端处。</p>
			<p>
			<span>3.<span>&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>DELETE QUICK</span>从列的低端处删除一组记录。</p>
			<p>在此情况下，与被删除的索引值相关的索引块变成未充满的状态，但是，由于使用了<span>QUICK</span>，这些索引块不会与其它索引块合并。当插入新值时，这些索引块仍为未充满的状态，原因是新记录不含有在被删除的范围内的索引值。另外，即使您此后使用<span>DELETE</span>时不包含<span>QUICK</span>，这些索引块也仍是未充满的，除非被删除的索引值中有一部分碰巧位于这些未充满的块的之中，或与这些块相邻。在这些情况下，如果要重新利用未使用的索引空间，需使用<span>OPTIMIZE 
			TABLE</span>。</p>
			<p>如果您打算从一个表中删除许多行，使用<span>DELETE QUICK</span>再加上<span>OPTIMIZE 
			TABLE</span>可以加快速度。这样做可以重新建立索引，而不是进行大量的索引块合并操作。</p>
			<p>用于<span>DELETE</span>的<span>MySQL</span>唯一的<span>LIMIT<span>
			<i>row_count</i></span></span>选项用于告知服务器在控制命令被返回到客户端前被删除的行的最大值。本选项用于确保一个<span>DELETE</span>语句不会占用过多的时间。您可以只重复<span>DELETE</span>语句，直到相关行的数目少于<span>LIMIT</span>值为止。</p>
			<p>如果<span>DELETE</span>语句包括一个<span>ORDER BY</span>子句，则各行按照子句中指定的顺序进行删除。此子句只在与<span>LIMIT</span>联用是才起作用。例如，以下子句用于查找与<span>WHERE</span>子句对应的行，使用<span>timestamp_column</span>进行分类，并删除第一（最旧的）行：</p>
			<pre><span>DELETE FROM somelog</span></pre>
			<pre><span>WHERE user = &#39;jcole&#39;</span></pre>
			<pre><span>ORDER BY timestamp_column</span></pre>
			<pre><span>LIMIT 1;</span></pre>
			<p>您可以在一个<span>DELETE</span>语句中指定多个表，根据多个表中的特定条件，从一个表或多个表中删除行。不过，您不能在一个多表<span>DELETE</span>语句中使用<span>ORDER 
			BY</span>或<span>LIMIT</span>。</p>
			<p><span><i><span>table_references</span></i></span>部分列出了包含在联合中的表。此语法在<a href="sql-syntax.html#join"  title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中进行了说明。</p>
			<p>对于第一个语法，只删除列于<span>FROM</span>子句之前的表中的对应的行。对于第二个语法，只删除列于<span>FROM</span>子句之中（在<span>USING</span>子句之前）的表中的对应的行。作用是，您可以同时删除许多个表中的行，并使用其它的表进行搜索：</p>
			<pre><span>DELETE t1, t2 FROM t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span></pre>
			<p>或：</p>
			<pre><span>DELETE FROM t1, t2 USING t1, t2, t3 WHERE t1.id=t2.id AND t2.id=t3.id;</span></pre>
			<p>当搜索待删除的行时，这些语句使用所有三个表，但是只从表<span>t1</span>和表<span>t2</span>中删除对应的行。</p>
			<p>以上例子显示了使用逗号操作符的内部联合，但是多表<span>DELETE</span>语句可以使用<span>SELECT</span>语句中允许的所有类型的联合，比如<span>LEFT 
			JOIN</span>。</p>
			<p>本语法允许在名称后面加<span>.*</span>，以便与<span>Access</span>相容。</p>
			<p>如果您使用的多表<span>DELETE</span>语句包括<span>InnoDB</span>表，并且这些表受外键的限制，则<span>MySQL</span>优化程序会对表进行处理，改变原来的从属关系。在这种情况下，该语句出现错误并返回到前面的步骤。要避免此错误，您应该从单一表中删除，并依靠<span>InnoDB</span>提供的<span>ON 
			DELETE</span>功能，对其它表进行相应的修改。</p>
			<p>注释：当引用表名称时，您必须使用别名（如果已给定）：</p>
			<pre><span>DELETE t1 FROM test AS t1, test2 WHERE ...</span></pre>
			<p>进行多表删除时支持跨数据库删除，但是在此情况下，您在引用表时不能使用别名。举例说明：</p>
			<pre><span>DELETE test1.tmp1, test2.tmp2 FROM test1.tmp1, test2.tmp2 WHERE ...</span></pre>
			<p>目前，您不能从一个表中删除，同时又在子查询中从同一个表中选择。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="do"></a>13.2.2. DO语法</h3></div></div></div><a class="indexterm" name="id2899415"></a><pre class="programlisting">DO <em class="replaceable">expr</em> [, <em class="replaceable">expr</em>] ...
</pre></div><div class="section"><div class="titlepage"><div><div>
			<span>DO</span>用于执行表达式，但是不返回任何结果。<span>DO</span>是<span>SELECT<span>
			<i>expr</i></span></span><span>的简化表达方式</span>。<span>DO</span>有一个优势，就是如果您不太关心结果的话，<span>DO</span>的速度稍快。<p>
			<span>DO</span>主要用于执行有副作用的函数，比如<span>RELEASE_LOCK()</span>。</p>
			<h3 class="title"><a name="handler"></a>13.2.3. HANDLER语法</h3></div></div></div><a class="indexterm" name="id2899497"></a><pre class="programlisting">HANDLER <em class="replaceable">tbl_name</em> OPEN [ AS <em class="replaceable">alias</em> ]
HANDLER <em class="replaceable">tbl_name</em> READ <em class="replaceable">index_name</em> { = | &gt;= | &lt;= | &lt; } (<em class="replaceable">value1</em>,<em class="replaceable">value2</em>,...)
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> READ <em class="replaceable">index_name</em> { FIRST | NEXT | PREV | LAST }
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> READ { FIRST | NEXT }
    [ WHERE <em class="replaceable">where_condition</em> ] [LIMIT ... ]
HANDLER <em class="replaceable">tbl_name</em> CLOSE
</pre>
			<p><span>HANDLER</span>语句提供通往表存储引擎接口的直接通道。<span>HANDLER</span>可以用于<span>MyISAM</span>和<span>InnoDB</span>表。</p>
			<p><span>HANDLER...OPEN</span>语句用于打开一个表，通过后续的<span>HANDLER...READ</span>语句建立读取表的通道。本表目标不会被其它线程共享，也不会关闭，直到线程调用<span>HANDLER...CLOSE</span>或线程中止时为止。如果您使用一个别名打开表，则使用其它<span>HANDLER</span>语句进一步参阅表是必须使用此别名，而不能使用表名。</p>
			<p>如果被指定的索引满足给定的值并且符合了<span>WHERE</span>条件，则第一个<span>HANDLER...READ</span>语法取出一行。如果您有一个多列索引，则指定索引列值为一个用逗号隔开的清单。既可以为索引中的所有列指定值，也可以为索引列的最左边的前缀指定值。假设一个索引包括三个列，名称为<span>col_a</span><span>,
			<span>col_b</span>,</span>和<span>col_c</span>，并按此顺序排列。<span>HANDLER</span>语句可以为索引中的所有三个列指定值，或者为一个最左边前缀中的各列指定值。举例说明：</p>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val,col_b_val,col_c_val) ...</span></pre>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val,col_b_val) ...</span></pre>
			<pre><span>HANDLER ... <span><i>index_name</i></span> = (col_a_val) ...</span></pre>
			<p>第二个<span>HANDLER...READ</span>语法按索引的顺序从表中取出一行。索引的顺序符合<span>WHERE</span>条件。</p>
			<p>第三个<span>HANDLER...READ</span>语法按自然行的顺序从表中取出一行。自然行的顺序符合<span>WHERE</span>条件。当想要对整个表进行扫描时，此语句比<span>HANDLER
			<i>tbl_name</i> READ index_name</span>更快。自然行的顺序指的是行存储在<span>MyISAM</span>表数据文件的顺序。本语句也适用于<span>InnoDB</span>表，但是因为没有独立的数据文件，所以没有这类概念。</p>
			<p>不使用<span>LIMIT</span>子句时，所有形式的<span>HANDLER...READ</span>语句均只取出一行。 
			如果要返回多个行，应加入一个<span>LIMIT</span>子句。本语句于<span>SELECT</span>语句的语法一样。请参见<a href="sql-syntax.html#select"  title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
			<p><span>HANDLER...CLOSE</span>用于关闭使用<span>HANDLER...OPEN</span>打开的表。</p>
			<p>注释：要使用<span>HANDLER</span>接口来查阅一个表的<span>PRIMARY 
			KEY</span>，应使用带引号的识别符<span>`PRIMARY`</span>：</p>
			<pre><span>HANDLER <span><i>tbl_name</i></span> READ `PRIMARY` &gt; (...);</span></pre>
			<p><span>HANDLER</span>是比较低级别的语句。例如，它不能提供一致性。也就是说，<span>HANDLER...OPEN</span>不能为表做快照，也不能锁定表。这意味着，当一个<span>HANDLER...OPEN</span>语句被编写后，表数据可以被更改（用此线程或用其它线程），并且这些更改只会部分地出现在<span>HANDLER...NEXT</span>或<span>HANDLER...PREV</span>扫描中。</p>
			<p>使用<span>HANDLER</span>接口代替常规的<span>SELECT</span>语句有多个原因：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HANDLER</span>比<span>SELECT</span>更快：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>一个指定的存储引擎管理程序目标为了<span>HANDLER...OPEN</span>进行整序。该目标被重新用于该表的后续的<span>HANDLER</span>语句；不需要对每个语句进行重新初始化。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>涉及的分析较少。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>没有优化程序或查询校验开销。 </p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>在两个管理程序请求之间，不需要锁定表。</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span>管理程序接口不需要提供外观一致的数据（例如，允许无条理的读取），所以存储引擎可以使用优化，而<span>SELECT</span>通常不允许使用优化。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有些应用程序使用与<span>ISAM</span>近似的接口与<span>MySQL</span>连接。使用<span>HANDLER</span>可以更容易地与这些应用程序连接。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HANDLER</span>允许您采用一种特殊的方式进出数据库。而使用<span>SELECT</span>时难以采用（或不可能采用）这种方式。有些应用程序可以提供一个交互式的用户接口与数据库连接。当与这些应用程序同时使用时，用<span>HANDLER</span>接口观看数据更加自然。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="insert"></a>13.2.4. INSERT语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#insert-select" >13.2.4.1. 
			INSERT ... SELECT语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#insert-delayed" >13.2.4.2. 
			INSERT DELAYED语法</a></span></dt></dl></div><a class="indexterm" name="id2899968"></a><a class="indexterm" name="id2899975"></a>
			<pre><span>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; VALUES ({<span><i>expr</i></span> | DEFAULT},...),(...),...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p>或：</p>
			<pre><span>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name</i></span>={<span><i>expr</i></span> | DEFAULT}, ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p>或：</p>
			<pre><span>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
			<p><span>INSERT</span>用于向一个已有的表中插入新行。<span>INSERT...VALUES</span>和<span>INSERT...SET</span>形式的语句根据明确指定的值插入行。<span>INSERT...SELECT</span>形式的语句插入从其它表中选出的行。在<a href="sql-syntax.html#insert-select"  title="13.2.4.1. INSERT ... SELECT Syntax">13.2.4.1节，“INSERT 
		... SELECT语法”</a>中对<span>INSERT...SELECT</span>进行了进一步的讨论。</p>
			<p>行应被插入到<span><i><span>tbl_name</span></i>表中。可以按以下方法指定列。本语句向这些列提供值。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>列名称清单或<span>SET</span>子句明确的指示了列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您不为<span>INSERT...VALUES</span>或<span>INSERT...SELECT</span>指定列的清单，则表中每列的值必须在<span>VALUES</span>清单中提供，或由<span>SELECT</span>提供。如果您不知道表中各列的顺序，则使用<span>DESCRIBE
			<i>tbl_name</i></span>查询。</p>
			<p>列值可以采用多种方法给定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931016"></a>

            如果不是在严格模式下运行，则所有没有明确给定值的列都被设置为默认值（明确的或隐含的）。例如，如果您指定了一个列清单，但此清单没有对表中所有的列进行命名，则未命名的各列被设置为默认值。默认值的赋值在<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
			TABLE语法”</a>中进行了说明。也可参见<a href="introduction.html#constraint-invalid-data"  title="1.8.6.2. Constraints on Invalid Data">1.8.6.2节，“对无效数据的约束”</a>。</p>
			<p>
			有时候，您需要对所有没有默认值的列明确地指定值。如果您希望，在没有明确指定值时，<span>INSERT</span>语句可以生成错误信息，则您应该使用<span>STRICT</span>模式。请参见<a href="database-administration.html#server-sql-mode"  title="5.3.2. The Server SQL Mode">5.3.2节，“SQL服务器模式”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用关键词<span>DEFAULT</span>，明确地把列设置为默认值。这样，编写向所有列赋值的<span>INSERT</span>语句时可以更容易，因为使用<span>DEFAULT</span>可以避免编写出不完整的、未包含全部列值的<span>VALUES</span>清单。如果不使用<span>DEFUALT</span>，您必须编写一个列名称清单，与<span>VALUES</span>清单中的每个值对应。</p>
			<p>您还可以使用<span>DEFAULT(<i>col_name</i>)</span>作为一种更通用的形式，在表达式中使用，用于生成一个列的默认值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果列清单和<span>VALUES</span>清单均为空清单，则<span>INSERT</span>会创建一个行，每个列都被设置为默认值：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> () VALUES();</b></span></span></pre>
			<p>在<span>STRICT</span>模式中，如果有一列没有默认值，则会出现错误。或者，<span>MySQL</span>会对所有没有明确定义默认值的列使用隐含的默认值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以指定一个表达式<span><i><span>expr</span></i></span>来提供一个列值。如果表达式的类型与列值不匹配，这样做会造成类型转化。并且，给定值的转化会导致不同的插入值，插入何值由列类型而定。例如，向一个<span>INT, 
			FLOAT, DECIMAL(10,6)</span>或<span>YEAR</span>列插入字符串<span><span>&#39;1999.0e-2&#39;</span>，插入值分别是<span>1999</span>，<span>19.9921</span>，<span>19.992100</span>和<span>1999</span>。存储在<span>INT</span>和<span>YEAR</span>列中的值为<span>1999</span>的原因是，在从字符串到整数的转化中，只把字符串的前面部分看作有效的整数或年份。对于浮点列和固定点列，在从字符串到浮点的转化中，把整个字符串均看作有效的浮点值。</span></p>
			<p>表达式<span><i><span>expr</span></i></span>可以引用在值清单中已设置的所有列。例如，您可以这么操作，因为用于<span>col2</span>的值引用了<span>col1</span>，而<span>col1</span>已经被赋值：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> (<i>col1</i>,<i>col2</i>) VALUES(15,<i>col1</i>*2);</b></span></span></pre>
			<p>但是以下语句不合法，因为用于<span>col1</span>的值引用了<span>col2</span>，而<span>col2</span>在<span>col1</span>之后被赋值：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO <i>tbl_name</i> (<i>col1</i>,<i>col2</i>) VALUES(<i>col2</i>*2,15);</b></span></span></pre>
			<p>有一种例外情况，那就是含有<span>AUTO_INCREMENT</span>值的列。因为<span>AUTO_INCREMENT</span>值在其它值赋值之后被生成，所以任何在赋值时对<span>AUTO_INCREMENT</span>列的引用都会返回<span>0</span>。</p>
			<p><span>INSERT</span>语句支持下列修改符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>DELAYED</span>关键字，则服务器会把待插入的行放到一个缓冲器中，而发送<span>INSERT 
			DELAYED</span>语句的客户端会继续运行。如果表正在被使用，则服务器会保留这些行。当表空闲时，服务器开始插入行，并定期检查是否有新的读取请求。如果有新的读取请求，则被延迟的行被延缓执行，直到表再次空闲时为止。请参见<a href="sql-syntax.html#insert-delayed"  title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2节，“INSERT 
			DELAYED语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>LOW_PRIORITY</span>关键词，则<span>INSERT</span>的执行被延迟，直到没有其它客户端从表中读取为止。当原有客户端正在读取时，有些客户端刚开始读取。这些客户端也被包括在内。此时，<span>INSERT 
			LOW_PRIORITY</span>语句等候。因此，在读取量很大的情况下，发出<span>INSERT 
			LOW_PRIORITY</span>语句的客户端有可能需要等待很长一段时间（甚至是永远等待下去）。（这与<span>INSERT 
			DELAYED</span>形成对比，<span>INSERT DELAYED</span>立刻让客户端继续执行。请参见<a href="sql-syntax.html#insert-delayed"  title="13.2.4.2. INSERT DELAYED Syntax">13.2.4.2节，“INSERT 
			DELAYED语法”</a>。）注意<span>LOW_PRIORITY</span>通常不应用于<span>MyISAM</span>表，因为这么做会取消同时进行的插入。请参见<a href="storage-engines.html#myisam-storage-engine"  title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定了<span>HIGH_PRIORITY</span>，同时服务器采用<span>--low-priority-updates</span>选项启动，则<span>HIGH_PRIORITY</span>将覆盖<span><span>--low-priority-updates</span>选项。这么做还会导致同时进行的插入被取消。</span></p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span>mysql_affected_rows()</span><span> 
			C API</span>函数，可以获得用于<span>INSERT</span>的受影响行的值。请参见<a href="apis.html#mysql-affected-rows"  title="25.2.3.1. mysql_affected_rows()">25.2.3.1节，“mysql_affected_rows()”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您在一个<span>INSERT</span>语句中使用<span>IGNORE</span>关键词，在执行语句时出现的错误被当作警告处理。例如，没有使用<span>IGNORE</span>时，如果一个行复制了原有的<span>UNIQUE</span>索引或<span>PRIMARY 
			KEY</span>值，会导致出现重复关键字错误，语句执行失败。使用<span>IGNORE</span>时，该行仍然未被插入，但是不会出现错误。<span>IGNORE</span>未被指定时，如果数据转化引发错误，则会使语句执行失败。使用<span>IGNORE</span>后，无效数据被调整到最接近的值，并被插入；此时，生成警告，但是语句执行不会失败。您可以使用<span>mysql_info()</span><span> 
			C API</span>函数测定有多少行被插入到表中。</p>
			<p>如果您指定了<span>ON DUPLICATE KEY UPDATE</span>，并且插入行后会导致在一个<span>UNIQUE</span>索引或<span>PRIMARY 
			KEY</span>中出现重复值，则执行旧行<span>UPDATE</span>。例如，如果列<span>a</span>被定义为<span>UNIQUE</span>，并且包含值<span>1</span>，则以下两个语句具有相同的效果：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=c+1;</b></span></span></pre>
			<pre><span>&nbsp;</span></pre>
			<pre><span>mysql&gt; <span><b>UPDATE table SET c=c+1 WHERE a=1;</b></span></span></pre>
			<p>如果行作为新记录被插入，则受影响行的值为<span>1</span>；如果原有的记录被更新，则受影响行的值为<span>2</span>。</p>
			<p>注释：如果列<span>b</span>也是唯一列，则<span>INSERT</span>与此<span>UPDATE</span>语句相当：</p>
			<pre><span>mysql&gt; <span><b>UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;</b></span></span></pre>
			<p>如果<span><span>a=1 OR b=2</span>与多个行向匹配，则只有一个行被更新。通常，您应该尽量避免对带有多个唯一关键字的表使用<span>ON 
			DUPLICATE KEY</span>子句。</span></p>
			<p>您可以在<span>UPDATE</span>子句中使用<span>VALUES(col_name)</span>函数从<span>INSERT...UPDATE</span>语句的<span>INSERT</span>部分引用列值。换句话说，如果没有发生重复关键字冲突，则<span>UPDATE</span>子句中的<span><span>VALUES(<i>col_name</i>)</span>可以引用被插入的<i><span>col_name</span></i>的值。本函数特别适用于多行插入。<span>VALUES()</span>函数只在<span>INSERT...UPDATE</span>语句中有意义，其它时候会返回<span>NULL</span>。</span></p>
			<p>示例：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);</b></span></span></pre>
			<p>本语句与以下两个语句作用相同：</p>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (1,2,3)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=3;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>INSERT INTO table (a,b,c) VALUES (4,5,6)</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>ON DUPLICATE KEY UPDATE c=9;</b></span></span></pre>
			<p>当您使用<span>ON DUPLICATE KEY UPDATE</span>时，<span>DELAYED</span>选项被忽略。</p>
			<p>您可以使用<span>SQL LAST_INSERT_ID()</span>函数查找用于<span>AUTO_INCREMENT</span>列的值。从<span>C 
			API</span>的内部，使用<span>mysql_insert_id()</span>函数。不过，您应该注意，两个函数的作用并不总是相同的。在<a href="functions.html#information-functions"  title="12.9.3. Information Functions">12.9.3节，“信息函数”</a>和<a href="apis.html#mysql-insert-id"  title="25.2.3.36. mysql_insert_id()">25.2.3.36节，“mysql_insert_id()”</a>中进一步讨论了与<span>AUTO_INCREMENT</span>列有关的<span>INSERT</span>语句的作用。</p>
			<p>如果您使用<span>INSERT...VALUES</span>语句时采用了多个值清单或<span>INSERT...SELECT</span>，则该语句按以下格式返回一个信息字符串：</p>
			<pre><span>Records: 100 Duplicates: 0 Warnings: 0</span></pre>
			<p>
			记录指示了经过语句处理的行的数目。（因为重复数目可以不是零，所以该数目不一定是实际被插入的行的数目。）重复数目指的是不能被插入的行的数目，因为这些行会复制部分原有的唯一索引值。警告指的是插入有错误或有问题的列值的次数。在以下情况下会出现警告：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一个已定义为<span>NOT NULL</span>的列中插入<span>NULL</span>。对于一个多行<span>INSERT</span>语句或<span>INSERT 
			INTO...SELECT</span>语句，根据列数据的类型，列被设置为隐含的默认值。对于数字类型，默认值为<span>0</span>；对于字符串类型，默认值为空字符串<span>(<span>&#39;&#39;</span>)</span>；对于日期和时间类型，默认值为“<span>zero</span>”值。对<span>INSERT 
			INTO...SELECT</span>语句的处理方法与对多行插入的处理方法一样，因为服务器不能检测来自<span>SELECT</span>的结果，不能判断是否返回单一行。（对于单一行<span>INSERT</span>，当<span>NULL</span>被插入一个<span>NOT 
			NULL</span>列时，不会出现警告，而是出现错误，并且语句运行失败。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>数字列的值被设置在列的值范围之外。此值被修改为未最接近的值范围端点。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一个数字列赋予一个例如<span>&#39;10.34 
			a&#39;</span>的值。尾部的非数字文本被删节，其余的数字部分被插入，如果字符串值没有前导的数字部分，则该列被设置为<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向一个字符串列（<span>CHAR, VARCHAR, TEXT</span>或<span>BLOB</span>）中插入的字符串超过了列的最大长度。此值被删节到列的最大长度。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>向日期或时间列中插入的值对于该列的类型是不合法的。根据列的类型，该列被设置到相应的零值。</p>
			<p>如果您正在使用<span>C API</span>，则可以通过调用<span>mysql_info()</span>函数获取信息字符串。请参见<a href="apis.html#mysql-info"  title="25.2.3.34. mysql_info()">25.2.3.34节，“mysql_info()”</a>。</p>
			<a class="indexterm" name="id2900883"></a><a class="indexterm" name="id2900892"></a><a class="indexterm" name="id2901132"></a><a class="indexterm" name="id2901141"></a><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="insert-select"></a>13.2.4.1. INSERT 
				... SELECT语法</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				<pre><span>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; [ ON DUPLICATE KEY UPDATE <span><i>col_name</i></span>=<span><i>expr</i></span>, ... ]</span></pre>
				<p>使用<span>INSERT...SELECT</span>，您可以快速地从一个或多个表中向一个表中插入多个行。</p>
				<p>示例：</p>
				<pre><span>INSERT INTO tbl_temp2 (fld_id)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; SELECT tbl_temp1.fld_order_id</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; FROM tbl_temp1 WHERE tbl_temp1.fld_order_id &gt; 100;</span></pre>
				<p>使用<span>INSERT...SELECT</span>语句时会出现以下情况：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>明确地指定<span>IGNORE</span>，用于忽略会导致重复关键字错误的记录。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>不要同时使用<span>DELAYED</span>和<span>INSERT...SELECT</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT</span>语句的目标表会显示在查询的<span>SELECT</span>部分的<span>FROM</span>子句中。（在有些旧版本的<span>MySQL</span>中不会出现这种情况。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>AUTO_INCREMENT</span>列照常运行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>为了确保二进制日志可以被用于再次创建原表，<span>MySQL</span>不允许在<span>INSERT...SELECT</span>运行期间同时进行插入操作。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>目前，您不能在向一个表插入的同时，又在一个子查询中从同一个表中选择。</p>
				<p>在<span>ON DUPLICATE KEY UPDATE</span>的值部分中，只要您不使用<span>SELECT</span>部分中的<span>GROUP 
				BY</span>，您就可以引用在其它表中的列。有一个副作用是，您必须使值部分中的非唯一列的名称符合要求。</p>
				<p>您可以使用<span>REPLACE</span>替代<span>INSERT</span>，来覆盖旧行。对于包含唯一关键字值，并复制了旧行的新行，在进行处理时，<span>REPLACE</span>可以作为<span>INSERT 
				IGNORE</span>的同类子句：新行被用于替换旧行，而不是被丢弃。</p>
				<h4 class="title"><a name="insert-delayed"></a>13.2.4.2. INSERT 
				DELAYED语法</h4></div></div></div><a class="indexterm" name="id2901376"></a><a class="indexterm" name="id2901385"></a><a class="indexterm" name="id2901394"></a>
				<pre><span>INSERT DELAYED ...</span></pre>
				<p>用于<span>INSERT</span>语句的<span>DELAYED</span>选项是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。如果您的客户端不能等待<span>INSERT</span>完成，则这个选项是非常有用的。当您使用<span>MySQL</span>进行日志编写时，这是非常常见的问题。您也可以定期运行<span>SELECT</span>和<span>UPDATE</span>语句，这些语句花费的时间较长。</p>
				<p>当一个客户端使用<span>INSERT DELAYED</span>时，会立刻从服务器处得到一个确定。并且行被排入队列，当表没有被其它线程使用时，此行被插入。</p>
				<p>使用<span>INSERT DELAYED</span>的另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。</p>
				<p>使用<span>DELAYED</span>时有一些限制：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>仅适用于<span>MyISAM, 
				MEMORY</span>和<span>ARCHIVE</span>表。对于<span>MyISAM</span>表，如果在数据文件的中间没有空闲的块，则支持同时采用<span>SELECT</span>和<span>INSERT</span>语句。在这些情况下，基本不需要对<span>MyISAM</span>使用<span>INSERT 
				DELAYED</span>。请参见<a href="storage-engines.html#myisam-storage-engine"  title="15.1. The MyISAM Storage Engine">15.1节，“MyISAM存储引擎”</a><span>,
				</span>
              <a href="storage-engines.html#memory-storage-engine"  title="15.4. The MEMORY (HEAP) Storage Engine">
				15.4节，“MEMORY (HEAP)存储引擎”</a>和<a href="storage-engines.html#archive-storage-engine"  title="15.8. The ARCHIVE Storage Engine">15.8节，“ARCHIVE存储引擎”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INSERT DELAYED</span>应该仅用于指定值清单的<span>INSERT</span>语句。服务器忽略用于<span>INSERT 
				DELAYED...SELECT</span>语句的<span>DELAYED</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>服务器忽略用于<span>INSERT DELAYED...ON 
				DUPLICATE UPDATE</span>语句的<span>DELAYED</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>因为在行被插入前，语句立刻返回，所以您不能使用<span>LAST_INSERT_ID()</span>来获取<span>AUTO_INCREMENT</span>值。<span>AUTO_INCREMENT</span>值可能由语句生成。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于<span>SELECT</span>语句，<span>DELAYED</span>行不可见，直到这些行确实被插入了为止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>DELAYED</span>在从属复制服务器中被忽略了，因为<span>DELAYED</span>不会在从属服务器中产生与主服务器不一样的数据。</p>
				<p>注意，目前在队列中的各行只保存在存储器中，直到它们被插入到表中为止。这意味着，如果您强行中止了<strong><span>mysqld</span></strong>（例如，使用<span>kill 
				-9</span>）或者如果<strong><span>mysqld</span></strong>意外停止，则所有没有被写入磁盘的行都会丢失。</p>
				<p>以下详细描述了当您对<span>INSERT</span>或<span>REPLACE</span>使用<span>DELAYED</span>选项时会发生什么情况。在这些描述中，“线程”指的是已接受了一个<span>INSERT 
				DELAYED</span>语句的线程，“管理程序”指的是为某个特定的表处理所有<span>INSERT 
				DELAYED</span>语句的线程。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>当一个线程对一个表执行<span>DELAYED</span>语句时，会创建出一个管理程序线程（如果原来不存在），对用于本表的所有<span>DELAYED</span>语句进行处理。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>线程会检查是否管理程序以前已获取了<span>DELAYED</span>锁定；如果没有获取，则告知管理程序线程进行此项操作。即使其它线程对表有<span>READ</span>或<span>WRITE</span>锁定，也可以获得<span>DELAYED</span>锁定。但是管理程序会等待所有的<span>ALTER 
				TABLE</span>锁定或<span>FLUSH TABLE</span>锁定，以确保表的结构是最新的。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>线程执行<span>INSERT</span>语句，但不是把行写入表中，而是把最终行的拷贝放入一个由管理程序线程管理的队列中。线程会提示出现语法错误，这些错误会被报告到客户端中。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>因为在插入操作之前，<span>INSERT</span>返回已经完成，所以客户端不能从服务器处获取重复记录的数目，也不能获取生成的行的<span>AUTO_INCREMENT</span>值。（如果您使用<span>C 
				API</span>，则出于同样的原因，<span><span>mysql_info()</span>函数</span>不会返回任何有意义的东西。）</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>
				当行被插入表中时，二进制日志被管理程序线程更新。在多行插入情况下，当第一行被插入时，二进制日志被更新。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>每次<span>delayed_insert_limit</span>行被编写时，管理程序会检查是否有<span>SELECT</span>语句仍然未执行。如果有，则会在继续运行前，让这些语句先执行。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>当管理程序的队列中没有多余的行时，表被解锁。如果在<span>delayed_insert_timeout</span>时间内，没有接收到新的<span>INSERT 
				DELAYED</span>语句，则管理程序中止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果在某个特定的管理程序队列中，有超过<span><span>delayed_queue_size</span>的行未被执行，则申请<span>INSERT 
				DELAYED</span>的线程会等待，直到队列中出现空间为止。这么做可以确保</span><strong><span>mysqld</span></strong><span>不会把所有的存储器都用于被延迟的存储队列。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>管理程序线程会显示在<span>MySQL</span>进程清单中，其命令列中包含<span>delayed_insert</span>。如果您执行一个<span>FLUSH 
				TABLES</span>语句或使用<span>KILL thread_id</span>进行删除，则会删除此线程。不过，在退出前，线程会首先把所有排入队列的行存储到表中。在这期间，该线程不会从其它线程处接受任何新的<span>INSERT</span>语句。如果您在此之后执行一个<span>INSERT 
				DELAYED</span>语句，则会创建出一个新的管理程序线程。</p>
				<p>注意，如果有一个<span>INSERT 
				DELAYED</span>管理程序正在运行，则这意味着<span>INSERT DELAYED</span>语句比常规的<span>INSERT</span>语句具有更高的优先权。其它更新语句必须等待，直到<span>INSERT 
				DELAYED</span>语句队列都运行完毕，或者管理程序线程被中止（使用<span>KILL 
				thread_id</span>），或者执行了一个<span>FLUSH TABLES</span>时为止。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>以下状态变量提供了有关<span>INSERT DELAYED</span>语句的信息：</p>
				<table border="1" cellpadding="0" id="table6">
					<tr>
						<td>
						<p><strong>
						<span>状态变量</span></strong></td>
						<td>
						<p><strong>
						<span>意义</span></strong></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Delayed_insert_threads</span></td>
						<td>
						<p>管理程序线程的数目</td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Delayed_writes</span></td>
						<td>
						<p><span>使用<span>INSERT 
						DELAYED</span>写入的行的数目</span></td>
					</tr>
					<tr>
						<td>
						<p>
						<span>Not_flushed_delayed_rows</span></td>
						<td>
						<p>等待被写入的行的数目</td>
					</tr>
				</table>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>您可以通过发送一个<span>SHOW STATUS</span>语句，或者执行一个<strong><span>mysqladmin 
				extended-status</span></strong>命令，来阅览这些变量。</p>
				<p>注意，当没有使用表时，<span>INSERT DELAYED</span>比常规的<span>INSERT</span>要慢。对于服务器来说，为每个含有延迟行的表操纵一个独立的线程，也是一个额外的系统开销。这意味着只有当您确认您需要时，才应使用<span>INSERT 
				DELAYED</span>。</div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="load-data"></a>13.2.5. LOAD 
			DATA INFILE语法</h3></div></div></div><a class="indexterm" name="id2902077"></a>
			<pre><span>LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &#39;<span><i>file_name</i></span>.txt&#39;</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [REPLACE | IGNORE]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; INTO TABLE <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FIELDS</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TERMINATED BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [[OPTIONALLY] ENCLOSED BY &#39;<span><i>char</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ESCAPED BY &#39;<span><i>char</i></span>&#39; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LINES</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STARTING BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [TERMINATED BY &#39;<span><i>string</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [IGNORE <span><i>number</i></span> LINES]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [(<span><i>col_name_or_user_var</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [SET <span><i>col_name</i></span> = <span><i>expr</i></span>,...)]</span></pre>
			<p><span>LOAD DATA INFILE</span>语句用于高速地从一个文本文件中读取行，并装入一个表中。文件名称必须为一个文字字符串。</p>
			<p>要了解有关<span>INSERT</span>和<span>LOAD DATA 
			INFILE</span>的效率的对比和有关<span>LOAD DATA INFILE</span>加速的更多信息，请参见<a href="optimization.html#insert-speed"  title="7.2.16. Speed of INSERT Statements">7.2.16节，“INSERT语句的速度”</a>。</p>
			<p>由<span>character_set_database</span>系统变量指示的字符集被用于解释文件中的信息。<span>SET 
			NAMES</span>和<span>character_set_client</span>的设置不会影响对输入的解释。</p>
			<p>注意，目前不能载入<span>UCS2</span>数据文件。</p>
			<p>您也可以通过使用<strong><span>mysqlimport</span></strong>应用程序载入数据文件；通过向服务器发送一个<span>LOAD 
			DATA INFILE</span>语句实现此功能。<span>--local</span>选项用于使<strong><span>mysqlimport</span></strong>从客户主机中读取数据文件。如果客户端和服务器支持压缩协议，则您可以指定—<span>compress</span>选项提高在慢速网络中的性能。请参见<a href="client-side-scripts.html#mysqlimport"  title="8.10. mysqlimport — A Data Import Program">8.10节，“mysqlimport：数据导入程序</a>。</p>
			<p>如果您使用<span>LOW_PRIORITY</span>，则<span>LOAD 
			DATA</span>语句的执行被延迟，直到没有其它的客户端从表中读取为止。</p>
			<p>如果一个<span>MyISAM</span>表满足同时插入的条件（即该表在中间有空闲块），并且您对这个<span>MyISAM</span>表指定了<span>CONCURRENT</span>，则当<span>LOAD 
			DATA</span>正在执行时，其它线程会从表中重新获取数据。即使没有其它线程在同时使用本表格，使用本选项也会略微影响<span>LOAD 
			DATA</span>的性能。</p>
			<p>如果指定了<span>LOCAL</span>，则被认为与连接的客户端有关：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果指定了<span>LOCAL</span>，则文件会被客户主机上的客户端读取，并被发送到服务器。文件会被给予一个完整的路径名称，以指定确切的位置。如果给定的是一个相对的路径名称，则此名称会被理解为相对于启动客户端时所在的目录。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>LOCAL</span>没有被指定，则文件必须位于服务器主机上，并且被服务器直接读取。</p>
			<p>当在服务器主机上为文件定位时，服务器使用以下规则：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果给定了一个绝对的路径名称，则服务器使用此路径名称。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果给定了带有一个或多个引导组件的相对路径名称，则服务器会搜索相对于服务器数据目录的文件。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果给定了一个不带引导组件的文件名称，则服务器会在默认数据库的数据库目录中寻找文件。</p>
			<p>注意，这些规则意味着名为<span>./myfile.txt</span>的文件会从服务器数据目录中被读取，而名为<span>myfile.txt</span>的同样的文件会从默认数据库的数据库目录中读取。例如，下面的<span>LOAD 
			DATA</span>语句会从<span>db1</span>数据库目录中读取文件<span>data.txt</span>，因为<span>db1</span>是当前数据库。即使语句明确把文件载入到<span>db2</span>数据库中的表里，也会从<span>db1</span>目录中读取。</p>
			<pre><span>mysql&gt; <span><b>USE db1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE db2.my_table;</b></span></span></pre>
			<p>注意，使用正斜杠指定<span>Windows</span>路径名称，而不是使用反斜杠。如果您使用反斜杠，您必须使用两个。</p>
			<p>出于安全原因，当读取位于服务器中的文本文件时，文件必须位于数据库目录中，或者是全体可读的。另外，要对服务器文件使用<span>LOAD 
			DATA INFILE</span>，您必须拥有<span>FILE</span>权限。</p>
			<p>见<a href="database-administration.html#privileges-provided"  title="5.7.3. Privileges Provided by MySQL">5.7.3节，“MySQL提供的权限”</a>。</p>
			<p>与让服务器直接读取文件相比，使用<span>LOCAL</span>速度略慢，这是因为文件的内容必须通过客户端发送到服务器上。不过，您不需要<span>FILE</span>权限来载入本地文件。</p>
			<p>只有当您的服务器和您的客户端都许可时，<span>LOCAL</span>才可运行。例如，如果使用—<span>local-infile=0</span>启动<strong><span>mysqld</span></strong>，则<span>LOCAL</span>不运行。请参见<a href="database-administration.html#load-data-local"  title="5.6.4. Security Issues with LOAD DATA LOCAL">5.6.4节，“LOAD DATA LOCAL安全问题<code class="literal"></code>”</a>。</p>
			<p>如果您需要<span>LOAD DATA</span>来从一个管道中读取，您可以使用以下方法（此处我们把<span>/</span>目录清单载入一个表格）：</p>
			<pre><span>mkfifo /mysql/db/x/x</span></pre>
			<pre><span>chmod 666 /mysql/db/x/x</span></pre>
			<pre><span>find / -ls &gt; /mysql/db/x/x</span></pre>
			<pre><span>mysql -e &quot;LOAD DATA INFILE &#39;x&#39; INTO TABLE x&quot; x</span></pre>
			<p>有些输入记录把原有的记录复制到唯一关键字值上。<span>REPLACE</span>和<span>IGNORE</span>关键字用于控制这些输入记录的操作。</p>
			<p>如果您指定了<span>REPLACE</span>，则输入行会替换原有行（换句话说，与原有行一样，对一个主索引或唯一索引具有相同值的行）。请参见<a href="sql-syntax.html#replace"  title="13.2.6. REPLACE Syntax">13.2.6节，“REPLACE语法”</a>。</p>
			<p>如果您指定<span>IGNORE</span>，则把原有行复制到唯一关键字值的输入行被跳过。如果您这两个选项都不指定，则运行情况根据<span>LOCAL</span>关键词是否被指定而定。不使用<span>LOCAL</span>时，当出现重复关键字值时，会发生错误，并且剩下的文本文件被忽略。使用<span>LOCAL</span>时，默认的运行情况和<span>IGNORE</span>被指定时的情况相同；这是因为在运行中间，服务器没有办法中止文件的传输。</p>
			<p>如果您希望在载入运行过程中忽略外键的限制，您可以在执行<span>LOAD DATA</span>前发送一个<span>SET 
			FOREIGN_KEY_CHECKS=0</span>语句。</p>
			<p>如果您对一个空的<span>MyISAM</span>表使用<span>LOAD DATA 
			INFILE</span>，则所有的非唯一索引会被创建在一个独立批中（对于<span>REPAIR TABLE</span>）。当您有许多索引时，这通常会使<span>LOAD 
			DATA INFILE</span>大大加快。通常，<span>LOAD DATA INFILE</span>的速度会非常快，但是在某些极端情况下，您可以在把文件载入到表中之前使用<span>ALTER 
			TABLE...DISABLE KEYS</span>关闭<span>LOAD DATA INFILE</span>，或者在载入文件之后使用<span>ALTER 
			TABLE...ENABLE KEYS</span>再次创建索引，使创建索引的速度更快。请参见<a href="optimization.html#insert-speed"  title="7.2.16. Speed of INSERT Statements">7.2.16节，“INSERT语句的速度”</a>。</p>
			<p><span>LOAD DATA INFILE</span>是<span>SELECT...INTO 
			OUTFILE</span>的补语。（见<a href="sql-syntax.html#select"  title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。）要从一个表中把数据写入一个文件中，应使用<span>SELECT...INTO 
			OUTFILE</span>。要读取文件，放回到表中，应使用<span>LOAD DATA INFILE</span>。<span>FIELDS</span>和<span>LINES</span>子句的语法对于两个语句是一样的。两个子句都是自选的，但是如果两个都被指定了，<span>FIELDS</span>必须位于<span>LINES</span>的前面。</p>
			<p>如果您指定了一个<span>FIELDS</span>子句，则每个亚子句（<span>TERMINATED 
			BY, [OPTIONALLY] ENCLOSED BY</span>和<span>ESCAPED BY</span>）也是自选的。不过，您必须指定其中至少一个。</p>
			<p>如果您不指定<span>FIELDS</span>子句，则默认值为假设您写下如下语句时的值：</p>
			<pre><span>FIELDS TERMINATED BY &#39;\t&#39; ENCLOSED BY &#39;&#39; ESCAPED BY &#39;\\&#39;</span></pre>
			<p>如果您不指定<span>LINES</span>子句，则默认值为假设您写下如下语句时的值：</p>
			<pre><span>LINES TERMINATED BY &#39;\n&#39; STARTING BY &#39;&#39;</span></pre>
			<p>换句话说，当读取输入值时，默认值会使<span>LOAD DATA INFILE</span>按如下方式运行：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在新行处寻找行的边界。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不会跳过任何行前缀。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在制表符处把行分解为字段。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不希望字段被包含在任何引号字符之中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>出现制表符、新行、或在‘<span>\</span>’前有‘<span>\</span>’时，理解为作为字段值一部分的文字字符。</p>
			<p>相反的，当编写输出值时，默认值会使<span>SELECT...INTO OUTFILE</span>按如下方式运行：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在字段之间写入制表符。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>不把字段包含在任何引号字符中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当字段值中出现制表符、新行或‘<span>\</span>’时，使用‘<span>\</span>’进行转义。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在行的末端写入新行。</p>
			<p>注意，要写入<span>FIELDS ESCAPED BY </span>‘<span>\\</span>’，您必须为待读取的值指定两个反斜杠，作为一个单反斜杠使用。</p>
			<p>注释：如果您已经在<span>Windows</span>系统中生成了文本文件，您可能必须使用<span>LINES 
			TERMINATED BY </span>‘<span>\r\n</span>’来正确地读取文件，因为<span>Windows</span>程序通常使用两个字符作为一个行终止符。部分程序，比如<strong><span>WordPad</span></strong>，当编写文件时，可能会使用<span>\r</span>作为行终止符。要读取这样的文件，应使用<span>LINES 
			TERMINATED BY </span>‘<span>\r</span>’。</p>
			<p>如果所有您希望读入的行都含有一个您希望忽略的共用前缀，则您可以使用<span>&#39;<i>prefix_string</i>&#39;</span>来跳过前缀（和前缀前的字符）。如果某行不包括前缀，则整个行被跳过。注释：<span><i><span>prefix_string</span></i></span>会出现在一行的中间。</p>
			<p>示例： </p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/test.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>INTO TABLE test LINES STARTING BY &quot;xxx&quot;;</b></span></span></pre>
			<p>使用此语句，您可以读入包含有如下内容的文件：</p>
			<pre><span>xxx&quot;row&quot;,1</span></pre>
			<pre><span>something xxx&quot;row&quot;,2</span></pre>
			<p>并只得到数据<span>(&quot;row&quot;,1)</span>和<span>(&quot;row&quot;,2)</span>。</p>
			<p><span>IGNORE <i>number</i> 
			LINES</span>选项可以被用于在文件的开始处忽略行。例如，您可以使用<span>IGNORE 
			1 LINES</span>来跳过一个包含列名称的起始标题行：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/test.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>INTO TABLE test IGNORE 1 LINES;</b></span></span></pre>
			<p>当您联合使用<span>SELECT...INTO OUTFILE</span>和<span>LOAD 
			DATA INFILE</span>来从一个数据库中把数据写入一个文件中，然后再读取文件，返回到数据库中时，用于两个语句的<span>field-</span>和<span>line-handling</span>选项必须匹配。否则，<span>LOAD 
			DATA INFILE</span>不会正确地理解文件的内容。假设您使用<span>SELECT...INTO 
			OUTFILE</span>来编写一个的文件，字段由逗号分隔：</p>
			<pre><span>mysql&gt; <span><b>SELECT * INTO OUTFILE &#39;data.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FROM table2;</b></span></span></pre>
			<p>要读取由逗号分隔的文件并返回，则正确的语句应该是：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE table2</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39;;</b></span></span></pre>
			<p>如果您尝试使用以下所示的语句读入文件，则不会运行，因为该语句命令<span>LOAD DATA INFILE</span>寻找位于字段之间的制表符：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE table2</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;\t&#39;;</b></span></span></pre>
			<p>结果很可能是，每个输入行被理解为一个单一字段。</p>
			<p><span>LOAD DATA INFILE</span>也可以被用于读取从外源中获取的文件。例如，一个<span>dBASE</span>格式的文件具有以逗号分隔并且包含在双引号中的字段。如果文件中的各行以新行为结尾，则此处所示的语句描述了您可以用于载入文件的<span>field-</span>和<span>line-handling</span>选项：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE <i>tbl_name</i></b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;&quot;&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LINES TERMINATED BY &#39;\n&#39;;</b></span></span></pre>
			<p>所有<span>field-</span>或<span>line-handling</span>选项都可以指定一个空字符串<span>(<span>&#39;&#39;</span>)</span>。如果字符串不是空的，则<span>FIELDS 
			[OPTIONALLY] ENCLOSED BY</span>和<span>FIELDS ESCAPED BY</span>值必须为单一字符。<span>FIELDS 
			TERMINATED BY, LINES STARTING BY</span>和<span>LINES 
			TERMINATED BY</span>值可以超过一个字符。例如，要编写由回车<span>/</span>换行成对字符作为结尾的行，或读取包含这类行的文件，则应指定一个<span>LINES 
			TERMINATED BY </span>‘<span>\r\n</span>’子句。</p>
			<p>如果<span>jokes</span>被由<span>%%</span>组成的行分隔，<span>要读取包含<span>jokes</span>的文件，您可以这么操作：</span></p>
			<pre><span>mysql&gt; <span><b>CREATE TABLE jokes</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>(a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>joke TEXT NOT NULL);</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;/tmp/jokes.txt&#39; INTO TABLE jokes</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>FIELDS TERMINATED BY &#39;&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LINES TERMINATED BY &#39;\n%%\n&#39; (joke);</b></span></span></pre>
			<p><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>用于控制字段的引号。对于（<span>SELECT...INTO 
			OUTFILE</span>），如果您忽略了词语<span>OPTIONALLY</span>，则所有的字段都被包含在<span>ENCLOSED 
			BY</span>字符串中。此处展示了此类输出的一个示例（使用逗号作为字段分隔符）：</p>
			<pre><span>&quot;1&quot;,&quot;a string&quot;,&quot;100.20&quot;</span></pre>
			<pre><span>&quot;2&quot;,&quot;a string containing a , comma&quot;,&quot;102.20&quot;</span></pre>
			<pre><span>&quot;3&quot;,&quot;a string containing a \&quot; quote&quot;,&quot;102.20&quot;</span></pre>
			<pre><span>&quot;4&quot;,&quot;a string containing a \&quot;, quote and comma&quot;,&quot;102.20&quot;</span></pre>
			<p>如果您指定了<span>OPTINALLY</span>，则<span>ENCLOSED 
			BY</span>字符只被用于包含具有字符串数据类型（比如<span>CHAR, BINARY, TEXT</span>或<span>ENUM</span>）的列中的值：</p>
			<pre><span>1,&quot;a string&quot;,100.20</span></pre>
			<pre><span>2,&quot;a string containing a , comma&quot;,102.20</span></pre>
			<pre><span>3,&quot;a string containing a \&quot; quote&quot;,102.20</span></pre>
			<pre><span>4,&quot;a string containing a \&quot;, quote and comma&quot;,102.20</span></pre>
			<p>注意，如果在字段值内出现<span>ENCLOSED BY</span>字符，则通过使用<span>ESCAPED 
			BY</span>字符作为前缀，对<span>ENCLOSED BY</span>字符进行转义。另外，要注意，如果您指定了一个空的<span>ESCAPED 
			BY</span>值，则可能会生成不能被<span>LOAD DATA INFILE</span>正确读取的输出值。例如，如果转义符为空字符，则刚显示的先前输出值应显示如下。请观察，第四行中的第二个字段在引号后面包含一个逗号，该引号（错误地）显示出来，作为字段的结尾：</p>
			<pre><span>1,&quot;a string&quot;,100.20</span></pre>
			<pre><span>2,&quot;a string containing a , comma&quot;,102.20</span></pre>
			<pre><span>3,&quot;a string containing a &quot; quote&quot;,102.20</span></pre>
			<pre><span>4,&quot;a string containing a &quot;, quote and comma&quot;,102.20</span></pre>
			<p>对于输入值，<span>ENCLOSED BY</span>字符被从字段字的末尾剥离。（不论<span>OPTIONALLY</span>是否被指定都会剥离；<span>OPTIONALLY</span>对输入值的解释没有影响。）如果<span>ENCLOSED 
			BY</span>字符前面带有<span>ESCAPED BY</span>字符，则被理解为当前字段值的一部分。</p>
			<p>如果字段以<span>ENCLOSED BY</span>字符为开始，当出现这类字符时，只有后面接着字段或行<span>TERMINATED 
			BY</span>序列时，这类字符被认为是一个字段值的结尾。为了避免意思不明确，当在一个字段值中出现<span>ENCLOSED 
			BY</span>字符时，此字符可以重复书写，并被理解为单一的字符。例如，如果指定了<span>ENCLOSED 
			BY <span>&#39;&quot;&#39;</span></span>，则按照以下方法操作引号：</p>
			<pre><span>&quot;The &quot;&quot;BIG&quot;&quot; boss&quot;&nbsp; -&gt; The &quot;BIG&quot; boss</span></pre>
			<pre><span>The &quot;BIG&quot; boss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; The &quot;BIG&quot; boss</span></pre>
			<pre><span>The &quot;&quot;BIG&quot;&quot; boss&nbsp;&nbsp;&nbsp; -&gt; The &quot;&quot;BIG&quot;&quot; boss</span></pre>
			<p><span>FIELDS ESCAPED BY</span>用于控制如何写入或读取特殊字符。如果<span>FIELDS 
			ESCAPED BY</span>字符不是空字符，则可以在输出中用于对以下字符加前缀：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS ESCAPED BY</span>字符</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>字符</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FIELDS TERMINATED BY</span>和<span>LINES 
			TERMINATED BY</span>值的第一个字符</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>ASCII 0</span>（在转义符之后编写的字符实际上是<span>ASCII</span>‘<span>0</span>’，而不是一个值为<span>0</span>的字节）</p>
			<p>如果<span>FIELDS ESCAPED BY</span>字符为空字符，则没有字符被转义，并且<span>NULL</span>被作为<span>NULL</span>输出，而不是<span>\N</span>。去指定一个空的转义符不是一个好办法，特别是如果数据的字段值包含任何刚给定的清单中的字符时，更不能这么做。</p>
			<p>对于输入值，如果<span>FIELDS ESCAPED BY</span>字符不是空字符，则出现这种字符时会被剥离，然后以下字符被作为字段值的一部分。例外情况是，被转义的‘<span>0</span>’或‘<span>N</span>’（例如，<span>\0</span>或<span>\N</span>，此时转义符为‘<span>\</span>’）。这些序列被理解为<span>ASCII 
			NUL</span>（一个零值字节）和<span>NULL</span>。用于<span>NULL</span>处理的规则在本节的后部进行说明。</p>
			<p>要了解有关‘<span>\</span>’<span>-escape</span>语法的更多信息，请参见<a href="language-structure.html#literals"  title="9.1. Literal Values">9.1节，“文字值”</a>。</p>
			<p>在特定情况下，<span>field-</span>和<span>line-handling</span>选项相互影响：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>LINES TERMINATED BY</span>是空字符串，并且<span>FIELDS 
			TERMINATED BY</span>不是空字符串，则各行以<span>FIELDS TERMINATED BY</span>作为结尾。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>值均为空值<span>(<span>&#39;&#39;</span>)</span>，则使用固定行（无分隔）格式。使用固定行格式时，在字段之间不使用分隔符（但是您仍然可以有行终止符）。列值使用列的显示宽度进行写入和读取。例如，如果某列被定义为<span>INT(7)</span>，则使用<span>7</span>字符字段写入列值。输出时，通过读取<span>7</span>个字符获取列值。</p>
			<p><span>LINES TERMINATED BY</span>仍然用于分隔行。如果某行不包含所有字段，则其余的各列被设置到默认值。如果您没有行终止符，您应该把终止符设置为<span>&#39;&#39;</span>。在此情况下，文本文件必须包含每行的所有字段。</p>
			<p>固定行格式也会影响<span>NULL</span>值的操作，这将在以后进行介绍。注意，如果您正在使用一个多字节字符集，则固定规格格式不会运行。</p>
			<p>根据正在使用中的<span>FIELDS</span>和<span>LINES</span>选项的不同，<span>NULL</span>值的操作有所变化：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于默认的<span>FIELDS</span>和<span>LINES</span>值，<span>NULL</span>被作为<span>\N</span>的字段值编写，用于输出；<span>\N</span>字段值被作为<span>NULL</span>读取，用于输入（假设<span>ESCAPED 
			BY</span>字符为‘<span>\</span>’）。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ENCLOSED BY</span>不是空值，则包含以文字词语<span>NULL</span>为值的字段被作为<span>NULL</span>值读取。这与被<span>FIELDS 
			ENCLOSED BY</span>字符包围的词语<span>NULL</span>不同。该词语被作为字符串<span>&#39;NULL&#39;</span>读取。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ESCAPED BY</span>是空值，则<span>NULL</span>被作为词语<span>NULL</span>写入。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>采用固定行格式时（当<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>均为空值时采用），<span>NULL</span>被作为一个空字符串写入。注意，这会导致在被写入文件时，表中的<span>NULL</span>值和空字符串均无法辨别，这是因为两者都被作为空字符串写入。如果您需要在读取文件并返回时能够分辨两者，则您不应使用固定行格式。</p>
			<p><span>LOAD DATA INFILE</span>不支持有些情况：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>固定规格行（<span>FIELDS TERMINATED BY</span>和<span>FIELDS 
			ENCLOSED BY</span>均为空值）和<span>BLOB</span>或<span>TEXT</span>列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您指定了一个分隔符，并且该分隔符与其它的前缀一样，则<span>LOAD DATA 
			INFILE</span>不能正确地理解输入值。例如，下面的<span>FIELDS</span>子句会导致问题：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>FIELDS TERMINATED BY &#39;&quot;&#39; ENCLOSED BY &#39;&quot;&#39;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果<span>FIELDS ESCAPED BY</span>为空值，则包含<span>FIELDS 
			ENCLOSED BY</span>或<span>LINES TERMINATED BY</span>的字段值后面再接<span>FIELDS 
			TERMINATED BY</span>值会导致<span>LOAD DATA INFILE</span>过早地停止读取一个字段或行。出现这种情况的原因是<span>LOAD 
			DATA INFILE</span>不能正确地决定字段或行值在哪里结束。</p>
			<p>以下的例子载入了<span>persondata</span>表中的所有列：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;persondata.txt&#39; INTO TABLE persondata;</b></span></span></pre>
			<p>默认情况下，如果在<span>LOAD DATA INFILE</span>语句的末尾处没有设列清单时，则输入行预计会包含一个字段，用于表中的每个列。如果您只想载入一个表的部分列，则应指定一个列清单：</p>
			<pre><span>mysql&gt; <span><b>LOAD DATA INFILE &#39;persondata.txt&#39;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>INTO TABLE persondata (col1,col2,...);</b></span></span></pre>
			<p>如果输入文件中各字段的顺序与表中各列的顺序不同，您也必须指定一个列清单。否则，<span>MySQL</span>不能把输入字段和表中的列匹配起来。</p>
			<p>列清单可以包含列名称或用户变量。支持<span>SET</span>子句。这使您可以把输入值赋予用户变量，然后在把结果赋予列之前，对这些值进行变换。</p>
			<p><span>SET</span>子句中的用户变量可以采用多种方式使用。以下例子使用数据文件中的第一列，直接用于<span>t1.column1</span>的值。在用户变量被用于<span>t2.column2</span>值之前，把第二列赋予用户变量。该变量从属于一个分割运行。</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, @var1)</span></pre>
			<pre><span>&nbsp; SET column2 = @var1/100;</span></pre>
			<p><span>SET</span>子句可以被用于提供不是来源于输入文件的值。以下语句把<span>column3</span>设置为当前的日期和时间：</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, column2)</span></pre>
			<pre><span>&nbsp; SET column3 = CURRENT_TIMESTAMP;</span></pre>
			<p>您也可以通过把输入值赋予一个用户变量，同时不把变量赋予表中的列，来丢弃此输入值：</p>
			<pre><span>LOAD DATA INFILE &#39;file.txt&#39;</span></pre>
			<pre><span>&nbsp; INTO TABLE t1</span></pre>
			<pre><span>&nbsp; (column1, @dummy, column2, @dummy, column3);</span></pre>
			<p>列<span>/</span>变量清单和<span>SET</span>子句的使用受到以下限定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>SET</span>子句中的赋值应只含有位于赋值操作符的左侧的列名称。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以在<span>SET</span>赋值的右侧使用子查询。如果子查询可以返回一个值，并且此值将被赋予到一个列中，则此子查询只能是标量子查询。另外，您不能使用子查询从一个正在被载入的表中选择。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于于列<span>/</span>变量清单或<span>SET</span>子句，被<span>IGNORE</span>子句忽略的行不被处理。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当载入采用固定行格式的数据时，不能使用用户变量，因为用户变量没有显示宽度。</p>
			<p>当处理一个输入行时，<span>LOAD DATA</span>会依据列<span>/</span>变量清单和<span>SET</span>子句，把行拆分成字段，并使用值。然后，得到的行被插入表中。如果有用于表的<span>BEFORE 
			INSERT</span>或<span>AFTER INSERT</span>触发器，则在插入行之前和插入行之后分别启动触发器。</p>
			<p>如果一个输入行含有过多的字段，则多余的字段被忽略，并且警告的数量增加。</p>
			<p>如果一个输入行含有的字段过少，则输入字段缺失的表中的列被设置为默认值。默认值赋值在<a href="sql-syntax.html#create-table"  title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
		TABLE语法”</a>中进行了说明。</p>
			<p>如果字段值缺失，则对一个空字段值会被按不同方式理解：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于字符串类型，列被设置为空字符串。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于数字类型，列被设置为<span>0</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>对于日期和时间类型，列被设置为该类型相应的“<span>zero</span>”。请参见<a href="column-types.html#date-and-time-types"  title="11.3. Date and Time Types">11.3节，“日期和时间类型”</a>。</p>
			<p>如果您明确地把一个空字符串赋予一个<span>INSERT</span>或<span>UPDATE</span>语句中的字符串类型、数字类型或日期或时间类型，则产生的这些值相同。</p>
			<p>只有在两种情况下<span>TIMESTAMP</span>列被设置为当前日期和时间。一种情况时当列有一个<span>NULL</span>值（也就是<span>\N</span>）时；另一种情况是（仅对于第一个<span>TIMESTAMP</span>列），当一个字段清单被指定时，<span>TIMESTAMP</span>列会从字段清单中被略去。</p>
			<p><span>LOAD DATA INFILE</span>把所有的输入值当作字符串，所以您不能按照使用<span>INSERT</span>语句的方式使用<span>ENUM</span>或<span>SET</span>列的数字值。所有的<span>ENUM</span>和<span>SET</span>值必须被指定为字符串。</p>
			<p>当<span>LOAD DATA INFILE</span>语句结束时，会按以下格式返回一个信息字符串： 
			</p>
			<pre><span>Records: 1&nbsp; Deleted: 0&nbsp; Skipped: 0&nbsp; Warnings: 0</span></pre>
			<p>如果您正在使用<span>C API</span>，您可以通过调用<span>mysql_info()</span>函数获取有关语句的信息。请参见<a href="apis.html#mysql-info"  title="25.2.3.34. mysql_info()">25.2.3.34节，“mysql_info()”</a>。</p>
			<p>当值通过<span>INSERT</span>语句被插入时或出现相同情况时，会发生警告（见<a href="sql-syntax.html#insert"  title="13.2.4. INSERT Syntax">13.2.4节，“INSERT语法”</a>）。例外情况是，当输入行中字段过多或过少时，<span>LOAD 
			DATA INFILE</span>也生成警告。这些警告并不存储；警告的数量只用于指示运行是否良好。</p>
			<p>您可以使用<span>SHOW WARNINGS</span>来得到第一批<span>max_error_count</span>警告的清单，作为有关运行错误的信息。请参见<a href="sql-syntax.html#show-warnings"  title="13.5.4.22. SHOW WARNINGS Syntax">13.5.4.22节，“SHOW 
		WARNINGS语法”</a>。</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="replace"></a>13.2.6. REPLACE语法</h3></div></div></div><a class="indexterm" name="id2904199"></a>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; VALUES ({<span><i>expr</i></span> | DEFAULT},...),(...),...</span></pre>
			<p>或：</p>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name</i></span>={<span><i>expr</i></span> | DEFAULT}, ...</span></pre>
			<p>或：</p>
			<pre><span>REPLACE [LOW_PRIORITY | DELAYED]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO] <span><i>tbl_name</i></span> [(<span><i>col_name</i></span>,...)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SELECT ...</span></pre>
			<p><span>REPLACE</span>的运行与<span>INSERT</span>很相像。只有一点除外，如果表中的一个旧记录与一个用于<span>PRIMARY 
			KEY</span>或一个<span>UNIQUE</span>索引的新记录具有相同的值，则在新记录被插入之前，旧记录被删除。请参见<a href="sql-syntax.html#insert"  title="13.2.4. INSERT Syntax">13.2.4节，“INSERT语法”</a>。</p>
			<p>注意，除非表有一个<span>PRIMARY KEY</span>或<span>UNIQUE</span>索引，否则，使用一个<span>REPLACE</span>语句没有意义。该语句会与<span>INSERT</span>相同，因为没有索引被用于确定是否新行复制了其它的行。</p>
			<p>所有列的值均取自在<span>REPLACE</span>语句中被指定的值。所有缺失的列被设置为各自的默认值，这和<span>INSERT</span>一样。您不能从当前行中引用值，也不能在新行中使用值。如果您使用一个例如“<span>SET
			<i>col_name</i> = <i>col_name</i> + 1<span>”的赋值，则对位于右侧的列名称的引用会被作为</span>DEFAULT(<i>col_name</i>)</span>处理。因此，该赋值相当于<span>SET
			<i>col_name</i> = DEFAULT(<i>col_name</i>) + 1</span>。</p>
			<p>为了能够使用<span>REPLACE</span>，您必须同时拥有表的<span>INSERT</span>和<span>DELETE</span>权限。</p>
			<p><span>REPLACE</span>语句会返回一个数，来指示受影响的行的数目。该数是被删除和被插入的行数的和。如果对于一个单行<span>REPLACE</span>该数为<span>1</span>，则一行被插入，同时没有行被删除。如果该数大于<span>1</span>，则在新行被插入前，有一个或多个旧行被删除。如果表包含多个唯一索引，并且新行复制了在不同的唯一索引中的不同旧行的值，则有可能是一个单一行替换了多个旧行。</p>
			<p>受影响的行数可以容易地确定是否<span>REPLACE</span>只添加了一行，或者是否<span>REPLACE</span>也替换了其它行：检查该数是否为<span>1</span>（添加）或更大（替换）。</p>
			<p>如果您正在使用<span>C API</span>，则可以使用<span>mysql_affected_rows()</span>函数获得受影响的行数。</p>
			<p>目前，您不能在一个子查询中，向一个表中更换，同时从同一个表中选择。</p>
			<p>以下是所用算法的更详细的说明（该算法也用于<span>LOAD DATA...REPLACE</span>）：</p>
			<p>
			<span>1.<span>&nbsp;&nbsp;&nbsp;
			</span></span>尝试把新行插入到表中</p>
			<p>
			<span>2.<span>&nbsp;&nbsp;&nbsp;
			</span></span>当因为对于主键或唯一关键字出现重复关键字错误而造成插入失败时：</p>
			<p>
			<span>a.<span>&nbsp;&nbsp;&nbsp;
			</span></span>从表中删除含有重复关键字值的冲突行</p>
			<p>
			<span>b.<span>&nbsp;&nbsp;&nbsp;
			</span></span>再次尝试把新行插入到表中</div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="select"></a>13.2.7. SELECT语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#join" >13.2.7.1. 
			JOIN语法</a></span></dt><dt><span class="section"><a href="sql-syntax.html#union" >13.2.7.2. 
			UNION语法<br>
&nbsp;</a></span></dt></dl></div><a class="indexterm" name="id2904508"></a>
			<pre><span>SELECT</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ALL | DISTINCT | DISTINCTROW ]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HIGH_PRIORITY]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [STRAIGHT_JOIN]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; <span><i>select_expr</i></span>, ...</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [INTO OUTFILE &#39;<span><i>file_name</i></span>&#39; <span><i>export_options</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | INTO DUMPFILE &#39;<span><i>file_name</i></span>&#39;]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FROM <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [GROUP BY {<span><i>col_name</i></span> | <span><i>expr</i></span> | <span><i>position</i></span>}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ASC | DESC], ... [WITH ROLLUP]]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [HAVING <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY {<span><i>col_name</i></span> | <span><i>expr</i></span> | <span><i>position</i></span>}</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ASC | DESC] , ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT {[<span><i>offset</i></span>,] <span><i>row_count</i></span> | <span><i>row_count</i></span> OFFSET <span><i>offset</i></span>}]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [PROCEDURE <span><i>procedure_name</i></span>(<span><i>argument_list</i></span>)]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [FOR UPDATE | LOCK IN SHARE MODE]]</span></pre>
			<p><span>SELECT</span>用于恢复从一个或多个表中选择的行，并可以加入<span>UNION</span>语句和子查询。请参见<a href="sql-syntax.html#union"  title="13.2.7.2. UNION Syntax">13.2.7.2节，“UNION语法<br>
		”</a>和<a href="sql-syntax.html#subqueries"  title="13.2.8. Subquery Syntax">13.2.8节，“Subquery语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>每个<span><i><span>select_expr</span></i></span>都指示一个您想要恢复的列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			table_references</span></i></span>指示行从哪个表或哪些表中被恢复。在<a href="sql-syntax.html#join"  title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中对该语法进行了说明。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span><i><span>
			where_definition</span></i></span>包括关键词<span>WHERE</span>，后面接一个表达式。该表达式指示被选择的行必须满足的条件。</p>
			<p>有的行在计算时未引用任何表。<span>SELECT</span>也可以用于恢复这类行。</p>
			<p>举例说明：</p>
			<pre><span>mysql&gt; <span><b>SELECT 1 + 1;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></pre>
			<p>所有被使用的子句必须按语法说明中显示的顺序严格地排序。例如，一个<span>HAVING</span>子句必须位于<span>GROUP 
			BY</span>子句之后，并位于<span>ORDER BY</span>子句之前。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931017"></a>

            <a class="indexterm" name="id2931018"></a>

            使用<span>AS <i>alias_name</i></span>可以为<span><i><span>select_expr</span></i></span>给定一个别名。此别名用作表达式的列名，可以用于<span>GROUP 
			BY</span>、<span>ORDER BY</span>或<span>HAVING</span>子句。例如：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT CONCAT(last_name,&#39;, &#39;,first_name) AS full_name</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span><b>FROM mytable ORDER BY full_name;</b></span></span></pre>
			<p>在为<span><i><span>select_expr</span></i></span>给定别名时，<span>AS</span>关键词是自选的。前面的例子可以这样编写：</p>
			<pre><span>mysql&gt; <span><b>SELECT CONCAT(last_name,&#39;, &#39;,first_name) full_name</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; -&gt; <span><b>FROM mytable ORDER BY full_name;</b></span></span></pre>
			<p>因为<span>AS</span>是自选的，如果您忘记在两个<span><i><span>select_expr</span></i></span>表达式之间加逗号，则会出现一个小问题：<span>MySQL</span>会把第二个表达式理解为一个别名。例如，在以下语句中，<span>columnb</span>被作为别名对待：</p>
			<pre><span>mysql&gt; <span><b>SELECT columna columnb FROM mytable;</b></span></span></pre>
			<p>因此，使用<span>AS</span>明确地指定列的别名，把它作为习惯，是一个良好的操作规范。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在一个<span>WHERE</span>子句中使用列别名是不允许的，因为当执行<span>WHERE</span>子句时，列值可能还没有被确定。请参见<a href="problems.html#problems-with-alias"  title="A.5.4. Problems with Column Aliases">A.5.4节，“与列别名有关的问题”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>FROM <i>
			table_references</i></span>子句指示行从哪些表中被恢复。如果您命名的表多于一个，则您在进行一个联合操作。要了解有关联合语法的说明，请参见<a href="sql-syntax.html#join"  title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>。对于每一个被指定的表，您可以自选地指定一个别名。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>tbl_name</span></i></span><span> [[AS] <span><i>alias</i></span>]</span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;[{USE|IGNORE|FORCE} INDEX (<span><i>key_list</i></span>)]</span></pre>
			<p>使用<span>USE INDEX</span>、<span>IGNORE 
			INDEX</span>、<span>FORCE INDEX</span>可以向优化符提示如何选择索引。这部分内容在<a href="sql-syntax.html#join"  title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中进行了讨论。</p>
			<p>您可以使用<span>SET 
			max_seeks_for_key=<i>value</i></span>作为一种替代方法，来促使<span>MySQL</span>优先采用关键字扫描，替代表扫描。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>您可以把当前数据库中的一个表作为<span><i><span>tbl_name</span></i></span>（在当前数据库中）引用，或作为<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span></span><span>引用</span>，来明确地指定一个数据库。您可以把一列作为<span><i><span>col_name</span></i></span><span>,
			<span><i>tbl_name</i></span>.<span><i>col_name</i></span></span><span>引用</span>或作为<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span>.<span><i>col_name</i></span></span>引用。您不需要对一个列引用指定一个<span><i><span>tbl_name</span></i></span>或<span><i><span>db_name</span></i></span><span>.<span><i>tbl_name</i></span></span>前缀，除非此引用意义不明确。意义不明确时，要求指定明确的列引用格式。有关示例见<a href="language-structure.html#legal-names"  title="9.2. Database, Table, Index, Column, and Alias Names">9.2节，“数据库、表、索引、列和别名”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>
            <a class="indexterm" name="id2931019"></a>

            <a class="indexterm" name="id2931020"></a>

            <a class="indexterm" name="id2931021"></a>

            在没有表被引用的情况下，允许您指定<span>DUAL</span>作为一个假的表名。</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT 1 + 1 FROM DUAL;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; 2</span></pre>
			<p>有些服务器要求一个<span>FROM</span>子句。<span>DUAL</span>仅用于与这些服务器兼容。如果没有表被引用，则<span>MySQL</span>不要求该子句，前面的语句可以按以下方法编写：</p>
			<pre><span>mysql&gt; <span><b>SELECT 1 + 1;</b></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; 2</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>使用<span><i><span>tbl_name</span></i><span> 
			AS <i>alias_name</i></span></span>或<span><i><span>tbl_name 
			alias_name</span></i></span>可以为一个表引用起别名：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee AS t1, info AS t2</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee t1, info t2</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在<span>WHERE</span>子句中，您可以使用<span>MySQL</span>支持的所有函数，不过总计（总结）函数除外。请参见<a href="functions.html" >第12章：</a><a href="functions.html"  title="Chapter 12. Functions and Operators"><i>函数和操作符</i></a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被选择的用于输出的列可以使用列名称、列别名或列位置被引用到<span>ORDER BY</span>和<span>GROUP 
			BY</span>子句中。列位置为整数，从<span>1</span>开始：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region, seed FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY region, seed;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region AS r, seed AS s FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY r, s;</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT college, region, seed FROM tournament</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>ORDER BY 2, 3;</b></span></span></pre>
			<p>要以相反的顺序进行分类，应把<span>DESC</span>（降序）关键字添加到<span>ORDER 
			BY</span>子句中的列名称中。默认值为升序；该值可以使用<span>ASC</span>关键词明确地指定。</p>
			<p>不建议使用列位置，因为该语法已经从<span>SQL</span>标准中删除。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>GROUP BY</span>，则输出行根据<span>GROUP 
			BY</span>列进行分类，如同您对相同的列进行了<span>ORDER BY</span>。<span>MySQL</span>对<span>GROUP 
			BY</span>进行了扩展，因此您可以在各列（在子句中进行命名）的后面指定<span>ASC</span>和<span>DESC</span>：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT a, COUNT(b) FROM test_table GROUP BY a DESC</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>MySQL</span>对<span>GROUP BY</span>的使用进行了扩展，允许选择在<span>GROUP 
			BY</span>子句中没有被提到的字段。如果您没有得到预期的结果，请阅读<span>GROUP BY</span>的说明，请参见<a href="functions.html#group-by-functions-and-modifiers"  title="12.10. Functions and Modifiers for Use with GROUP BY Clauses">12.10节，“与GROUP BY子句同时使用的函数和修改程序<code class="literal"></code>”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>GROUP BY</span>允许一个<span>WITH 
			ROLLUP</span>修饰符。请参见<a href="functions.html#group-by-modifiers"  title="12.10.2. GROUP BY Modifiers">12.10.2节，“GROUP 
			BY修改程序”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>子句基本上是最后使用，只位于被发送给客户端的条目之前，没有进行优化。（<span>LIMIT</span>用于<span>HAVING</span>之后。）</p>
			<p><span>SQL</span>标准要求<span>HAVING</span>必须引用<span>GROUP 
			BY</span>子句中的列或用于总计函数中的列。不过，<span>MySQL</span>支持对此工作性质的扩展，并允许<span>HAVING</span>因为<span>SELECT</span>清单中的列和外部子查询中的列。</p>
			<p>如果<span>HAVING</span>子句引用了一个意义不明确的列，则会出现警告。在下面的语句中，<span>col2</span>意义不明确，因为它既作为别名使用，又作为列名使用：</p>
			<pre><span>mysql&gt; <span><b>SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2;</b></span></span></pre>
			<p>标准<span>SQL</span>工作性质具有优先权，因此如果一个<span>HAVING</span>列名既被用于<span>GROUP 
			BY</span>，又被用作输出列清单中的起了别名的列，则优先权被给予<span>GROUP BY</span>列中的列。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>不能用于应被用于<span>WHERE</span>子句的条目。例如，不能编写如下语句：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT <i>col_name</i> FROM <i>tbl_name</i> HAVING <i>col_name</i> &gt; 0;</b></span></span></pre>
			<p>而应这么编写：</p>
			<pre><span>mysql&gt; <span><b>SELECT <i>col_name</i> FROM <i>tbl_name</i> WHERE <i>col_name</i> &gt; 0;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HAVING</span>子句可以引用总计函数，而<span>WHERE</span>子句不能引用：</p>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT user, MAX(salary) FROM users</b></span></span></pre>
			<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>GROUP BY user HAVING MAX(salary)&gt;10;</b></span></span></pre>
			<p>（在有些较早版本的<span>MySQL</span>中，本语句不运行。）</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>LIMIT</span>子句可以被用于限制被<span>SELECT</span>语句返回的行数。<span>LIMIT</span>取一个或两个数字自变量，自变量必须是非负的整数常数（当使用已预备的语句时除外）。</p>
			<p>
			使用两个自变量时，第一个自变量指定返回的第一行的偏移量，第二个自变量指定返回的行数的最大值。初始行的偏移量为<span>0</span>（不是<span>1</span>）：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 5,10;&nbsp; # Retrieve rows 6-15</b></span></span></pre>
			<p>为了与<span>PostgreSQL</span>兼容，<span>MySQL</span>也支持<span>LIMIT
			<span><i>row_count</i> OFFSET <i>offset</i></span></span>语法。</p>
			<p>
			如果要恢复从某个偏移量到结果集合的末端之间的所有的行，您可以对第二个参数是使用比较大的数。本语句可以恢复从第<span>96</span>行到最后的所有行：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 95,18446744073709551615;</b></span></span></pre>
			<p>使用<span>1</span>个自变量时，该值指定从结果集合的开头返回的行数：</p>
			<pre><span>mysql&gt; <span><b>SELECT * FROM tbl LIMIT 5;&nbsp;&nbsp;&nbsp;&nbsp; # Retrieve first 5 rows</b></span></span></pre>
			<p>换句话说，<span>LIMIT n</span>与<span>LIMIT 
			0,n</span>等价。</p>
			<p>对于已预备的语句，您可以使用位置保持符。以下语句将从<span>tb1</span>表中返回一行：</p>
			<pre><span>mysql&gt; <span><b>SET @a=1;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?&quot;;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>EXECUTE STMT USING @a;</b></span></span></pre>
			<p>以下语句将从<span>tb1</span>表中返回第二到第六行：</p>
			<pre><span>mysql&gt; <span><b>SET @skip=1; SET @numrows=5;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>PREPARE STMT FROM &quot;SELECT * FROM tbl LIMIT ?, ?&quot;;</b></span></span></pre>
			<pre><span>mysql&gt; <span><b>EXECUTE STMT USING @skip, @numrows;</b></span></span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SELECT...INTO OUTFILE<span> 
			&#39;<i>file_name</i>&#39;</span></span>形式的<span>SELECT</span>可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有<span>FILE</span>权限，才能使用此语法。<span><i><span>file_name</span></i></span>不能是一个原有的文件。原有文件会阻止例如“<span>/etc/passwd</span>”的文件和数据库表被销毁。</p>
			<p><span>SELECT...INTO OUTFILE</span>语句的主要作用是让您可以非常快速地把一个表转储到服务器机器上。如果您想要在服务器主机之外的部分客户主机上创建结果文件，您不能使用<span>SELECT...INTO 
			OUTFILE</span>。在这种情况下，您应该在客户主机上使用比如“<span>mysql </span>–<span>e
			<span>&quot;SELECT ...&quot; &gt; file_name</span></span><span>”的命令，来生成文件。</span></p>
			<p><span>SELECT...INTO OUTFILE</span>是<span>LOAD 
			DATA INFILE</span>的补语；用于语句的<span>exort_options</span>部分的语法包括部分<span>FIELDS</span>和<span>LINES</span>子句，这些子句与<span>LOAD 
			DATA INFILE</span>语句同时使用。请参见<a href="sql-syntax.html#load-data"  title="13.2.5. LOAD DATA INFILE Syntax">13.2.5节，“LOAD DATA INFILE语法”</a>。</p>
			<p><span>FIELDS ESCAPED BY</span>用于控制如何写入特殊字符。如果<span>FIELDS 
			ESCAPED BY</span>字符不是空字符，则被用于在输出中对以下字符设前缀：</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS ESCAPED BY</span>字符</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS [OPTIONALLY] ENCLOSED BY</span>字符</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>FIELDS TERMINATED BY</span>和<span>LINES 
			TERMINATED BY</span>值的第一个字符</p>
			<p>
			<span>
			o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>
			</span><span>ASCII 0</span>（在编写时接在转义符后面的是<span>ASCII
			</span>‘<span>0</span>’，而不是一个零值字节）</p>
			<p>如果<span>FIELDS ESCAPED BY</span>字符是空字符，则没有字符被转义，并且<span>NULL</span>被作为<span>NULL</span>输出，而不是作为<span>\N</span>输出。指定一个空的转义符不是一个好的主意。特别是当您的数据中的字段值包含刚被给予的清单中的字符时，更是如此。</p>
			<p>其原因是您必须对所有<span>FIELDS 
			TERMINATED BY, ENCLOSED BY, ESCAPED BY</span>或<span>LINES 
			TERMINATED BY</span>字符进行转义，才能可靠地读取文件并返回。<span>ASCII NUL</span>被转义，以便更容易地使用调页程序观看。</p>
			<p>生成的文件不必符合<span>SQL</span>语法，所以没有其它的字符需要被转义。</p>
			<p>在下面的例子中，生成一个文件，各值用逗号隔开。这种格式可以被许多程序使用。</p>
			<pre><span>SELECT a,b,a+b INTO OUTFILE &#39;/tmp/result.text&#39;</span></pre>
			<pre><span>FIELDS TERMINATED BY &#39;,&#39; OPTIONALLY ENCLOSED BY &#39;&quot;&#39;</span></pre>
			<pre><span>LINES TERMINATED BY &#39;\n&#39;</span></pre>
			<pre><span>FROM test_table;</span></pre>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>INTO DUMPFILE</span>代替<span>INTO 
			OUTFILE</span>，则<span>MySQL</span>只把一行写入到文件中，不对任何列或行进行终止，也不执行任何转义处理。如果您想要把一个<span>BLOB</span>值存储到文件中，则这个语句是有用的。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>注释：任何由<span>INTO OUTFILE</span>或<span>INTO 
			DUMPFILE</span>创建的文件都可以被服务器主机上的所有用户编写。原因是，<span>MySQL</span>服务器不能创建这样的文件，即文件的所有者不是该文件运行时所属的用户（任何时候，您都不能出于此原因或出于其它原因把<strong><span>mysqld</span></strong>作为根段运行）。该文件必须是全局可写的，这样您就可以操作其中的内容。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有的过程应在结果集合内处理数据。<span>PROCEDURE</span>子句用于对这些过程进行命名。要了解示例，请参见<a href="extending-mysql.html#procedure-analyse"  title="27.3.1. Procedure Analyse">27.3.1节，“步骤分析”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>存储引擎使用页面或行锁。如果您对存储引擎使用<span>FOR UPDATE</span>，则受到查询检验的行会被进行写锁定，直到当前事务结束为止。使用<span>LOCK 
			IN SHARE MODE</span>可以设置一个共享锁。共享锁可以防止其它事务更新或删除被检验的行。请参见<a href="storage-engines.html#innodb-locking-reads"  title="15.2.10.5. Locking Reads SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE">15.2.10.5节，“锁定读取SELECT ... FOR UPDATE和SELECT ... LOCK IN SHARE MODE”</a>。</p>
			<p>在<span>SELECT</span>关键词的后面，您可以使用许多选项。这些选项可以影响语句的运行。</p>
			<p><span>ALL, DISTINCT</span>和<span>DISTINCTROW</span>选项指定是否重复行应被返回。如果这些选项没有被给定，则默认值为<span>ALL</span>（所有的匹配行被返回）。<span>DISTINCT</span>和<span>DISTINCTROW</span>是同义词，用于指定结果集合中的重复行应被删除。</p>
			<p><span>HIGH_PRIORITY, STRAIGHT_JOIN</span>和以<span>SQL_</span>为开头的选项是<span>MySQL</span>相对于标准<span>SQL</span>的扩展。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HIGH_PRIORITY</span>给予<span>SELECT</span>更高的优先权，高于用于更新表的语句。您应该只对查询使用<span>HIGH_PRIORITY</span>。查询速度非常快，而且立刻被执行。<span>SELECT 
			HIGH_PRIORITY</span>查询在表被锁定用于读取时被发出。即使有一个新的语句正在等待表变为空闲，查询也会运行。</p>
			<p><span>HIGH_PRIORITY</span>不能和<span>SELECT</span>语句同时使用。<span>SELECT</span>语句是<span>UNION</span>的一部分。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>STRAIGHT_JOIN</span>用于促使优化符把表联合在一起，顺序按照这些表在<span>FROM</span>子句中排列的顺序。如果优化符联合表时顺序不佳，您可以使用<span>STRAIGHT_JOIN</span>来加快查询的速度。请参见<a href="optimization.html#explain"  title="7.2.1. EXPLAIN Syntax (Get Information About a SELECT)">7.2.1节，“EXPLAIN语法（获取关于SELECT的信息）<code class="literal"></code>”</a>。<span>STRAIGHT_JOIN</span>也可以被用于<span><i><span>table_references</span></i></span>清单中。请参见<a href="sql-syntax.html#join"  title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_BIG_RESULT</span>可以与<span>GROUP 
			BY</span>或<span>DISTINCT</span>同时使用，来告知优化符结果集合有很多行。在这种情况下，<span>MySQL</span>直接使用以磁盘为基础的临时表（如果需要的话）。在这种情况下，<span>MySQL</span>还会优先进行分类，不优先使用临时表。临时表对于<span>GROUP 
			BY</span>组分带有关键字。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_BUFFER_RESULT</span>促使结果被放入一个临时表中。这可以帮助<span>MySQL</span>提前解开表锁定，在需要花费较长时间的情况下，也可以帮助把结果集合发送到客户端中。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_SMALL_RESULT</span>可以与<span>GROUP 
			BY</span>或<span>DISTINCT</span>同时使用，来告知优化符结果集合是较小的。在此情况下，<span>MySAL</span>使用快速临时表来储存生成的表，而不是使用分类。在<span>MySQL 
			5.1</span>中，通常不需要这样。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_CALC_FOUND_ROWS</span>告知<span>MySQL</span>计算有多少行应位于结果集合中，不考虑任何<span>LIMIT</span>子句。行的数目可以使用<span>SELECT 
			FOUND_ROWS()</span>恢复。请参见<a href="functions.html#information-functions"  title="12.9.3. Information Functions">12.9.3节，“信息函数”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您正在使用一个<span>query_cache_type</span>值，值为<span>2</span>或<span>DEMAND</span>，则<span>SQL_CACHE</span>告知<span>MySQL</span>把查询结果存储在查询缓存中。对于使用<span>UNION</span>的查询或子查询，本选项会影响查询中的所有<span>SELECT</span>。请参见<a href="database-administration.html#query-cache"  title="5.13. The MySQL Query Cache">5.13节，“MySQL查询高速缓冲”</a>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>SQL_NO_CACHE</span>告知<span>MySQL</span>不要把查询结果存储在查询缓存中。请参见<a href="database-administration.html#query-cache"  title="5.13. The MySQL Query Cache">5.13节，“MySQL查询高速缓冲”</a>。对于一个使用<span>UNION</span>或子查询的查询，本选项会影响查询中的<span>SELECT</span>。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="join"></a>13.2.7.1. JOIN语法</h4></div></div></div><a class="indexterm" name="id2906549"></a><a class="indexterm" name="id2906558"></a><a class="indexterm" name="id2906567"></a><a class="indexterm" name="id2906576"></a><a class="indexterm" name="id2906585"></a><a class="indexterm" name="id2906594"></a><a class="indexterm" name="id2906603"></a><a class="indexterm" name="id2906612"></a><a class="indexterm" name="id2906621"></a><a class="indexterm" name="id2906630"></a><a class="indexterm" name="id2906639"></a><a class="indexterm" name="id2906648"></a><a class="indexterm" name="id2906658"></a>
				<p><span>MySQL</span>支持以下<span>JOIN</span>语法。这些语法用于<span>SELECT</span>语句的<span><i><span>table_references</span></i></span>部分和多表<span>DELETE</span>和<span>UPDATE</span>语句：</p>
				<pre class="programlisting"><em class="replaceable">table_references:</em>
    <em class="replaceable">table_reference</em> [, <em class="replaceable">table_reference</em>] …

<em class="replaceable">table_reference</em>:
    <em class="replaceable">table_factor</em>
  | <em class="replaceable">join_table</em>

<em class="replaceable">table_factor</em>:
    <em class="replaceable">tbl_name</em> [[AS] <em class="replaceable">alias</em>]
        [{USE|IGNORE|FORCE} INDEX (<em class="replaceable">key_list</em>)]
  | ( <em class="replaceable">table_references</em> )
  | { OJ <em class="replaceable">table_reference</em> LEFT OUTER JOIN <em class="replaceable">table_reference</em>
        ON <em class="replaceable">conditional_expr</em> }

<em class="replaceable">join_table</em>:
    <em class="replaceable">table_reference</em> [INNER | CROSS] JOIN <em class="replaceable">table_factor</em> [<em class="replaceable">join_condition</em>]
  | <em class="replaceable">table_reference</em> STRAIGHT_JOIN <em class="replaceable">table_factor</em>
  | <em class="replaceable">table_reference</em> STRAIGHT_JOIN <em class="replaceable">table_factor</em> ON <em class="replaceable">condition</em>
  | <em class="replaceable">table_reference</em> LEFT [OUTER] JOIN <em class="replaceable">table_reference</em> <em class="replaceable">join_condition</em>
  | <em class="replaceable">table_reference</em> NATURAL [LEFT [OUTER]] JOIN <em class="replaceable">table_factor</em>
  | <em class="replaceable">table_reference</em> RIGHT [OUTER] JOIN <em class="replaceable">table_reference</em> <em class="replaceable">join_condition</em>
  | <em class="replaceable">table_reference</em> NATURAL [RIGHT [OUTER]] JOIN <em class="replaceable">table_factor</em>

<em class="replaceable">join_condition</em>:
    ON <em class="replaceable">conditional_expr</em>
  | USING (<em class="replaceable">column_list</em>)
</pre>
				<p>一个表引用还被称为一个联合表达式。</p>
				<p>与<span>SQL</span>标准相比，<span><i><span>table_factor</span></i></span>的语法被扩展了。<span>SQL</span>标准只接受<span><i><span>table_reference</span></i></span>，而不是圆括号内的一系列条目。</p>
				<p>如果我们把一系列<span><i><span>table_reference</span></i></span>条目中的每个逗号都看作相当于一个内部联合，则这是一个稳妥的扩展。例如：</p>
				<pre><span>SELECT * FROM t1 LEFT JOIN (t2, t3, t4)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
				<p>相当于：</p>
				<pre><span>SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)</span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)</span></pre>
				<p>在<span>MySQL</span>中，<span>CROSS JOIN</span>从语法上说与<span>INNER 
				JOIN</span>等同（两者可以互相替换。在标准<span>SQL</span>中，两者是不等同的。<span>INNER 
				JOIN</span>与<span>ON</span>子句同时使用，<span>CROSS 
				JOIN</span>以其它方式使用。</p>
				<p>通常，在只含有内部联合运行的联合表达式中，圆括号可以被忽略。<span>MySQL</span>也支持嵌套的联合（见<a href="optimization.html#nested-joins"  title="7.2.10. How MySQL Optimizes Nested Joins">7.2.10节，“MySQL如何优化嵌套Join”</a>）。</p>
				<p>通常，您不应对<span>ON</span>部分有任何条件。<span>ON</span>部分用于限定在结果集合中您想要哪些行。但是，您应在<span>WHERE</span>子句中指定这些条件。这条规则有一些例外。</p>
				<p>在前面的清单中显示的<span><span>{ OJ 
				... LEFT OUTER JOIN ...}</span>语法的目的只是为了保持与<span>ODBC</span>的兼容性。语法中的花括号应按字面书写；该括号不是中间语法。中间语法用于语法描述的其它地方。</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>表引用可以使用<span><i><span>tbl_name</span></i><span> 
				AS <i>alias_name</i></span></span>或<span><i><span>tbl_name 
				alias_name</span></i></span>指定别名：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee AS t1, info AS t2</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT t1.name, t2.salary FROM employee t1, info t2</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE t1.name = t2.name;</b></span></span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>ON</span>条件句是可以被用于<span>WHERE</span>子句的格式的任何条件表达式。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>如果对于在<span>LEFT JOIN</span>中的<span>ON</span>或<span>USING</span>部分中的右表没有匹配的记录，则所有列被设置为<span>NULL</span>的一个行被用于右表。如果一个表在其它表中没有对应部分，您可以使用这种方法在这种表中查找记录：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>mysql&gt; <span><b>SELECT table1.* FROM table1</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LEFT JOIN table2 ON table1.id=table2.id</b></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE table2.id IS NULL;</b></span></span></pre>
				<p>本例查找在<span>table1</span>中含有一个<span>id</span>值的所有行。同时，在<span>table2</span>中没有此<span>id</span>值（即，<span>table1</span>中的所有行在<span>table2</span>中没有对应的行）。本例假设<span>table2.id</span>被定义为<span>NOT 
				NULL</span>。请参见<a href="optimization.html#left-join-optimization"  title="7.2.9. How MySQL Optimizes LEFT JOIN and RIGHT JOIN">7.2.9节，“MySQL如何优化LEFT JOIN和RIGHT 
				JOIN”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>
				USING(<i>column_list</i>)</span>子句用于为一系列的列进行命名。这些列必须同时在两个表中存在。如果表<span>a</span>和表<span>b</span>都包含列<span>c1, 
				c2</span>和<span>c3</span>，则以下联合会对比来自两个表的对应的列：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b USING (c1,c2,c3)</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>两个表的<span>NATURAL [LEFT] JOIN</span>被定义为与<span>INNER 
				JOIN</span>语义相同，或与使用<span>USING</span>子句的<span>LEFT 
				JOIN</span>语义相同。<span>USING</span>子句用于为同时存在于两个表中的所有列进行命名。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>INNER JOIN</span>和，（逗号）在无联合条件下是语义相同的：两者都可以对指定的表计算出笛卡儿乘积（也就是说，第一个表中的每一行被联合到第二个表中的每一行）。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>RIGHT JOIN</span>的作用与<span>LEFT 
				JOIN</span>的作用类似。要使代码可以在数据库内移植，建议您使用<span>LEFT JOIN</span>代替<span>RIGHT 
				JOIN</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>STRAIGHT_JOIN</span>与<span>JOIN</span>相同。除了有一点不一样，左表会在右表之前被读取。<span>STRAIGH_JOIN</span>可以被用于这样的情况，即联合优化符以错误的顺序排列表。</p>
				<p>您可以提供提示，当从一个表中恢复信息时，<span>MySQL</span>应使用哪个索引。通过指定<span>USE 
				INDEX</span>（<span>key_list</span>），您可以告知<span>MySQL</span>只使用一个索引来查找表中的行。另一种语法<span>IGNORE 
				INDEX</span>（<span>key_list</span>）可以被用于告知<span>MySQL</span>不要使用某些特定的索引。如果<span>EXPLAIN</span>显示<span>MySQL</span>正在使用来自索引清单中的错误索引时，这些提示会有用处。</p>
				<p>您也可以使用<span>FORCE INDEX</span>，其作用接近<span>USE 
				INDEX</span>（<span>key_list</span>），不过增加了一项作用，一次表扫描被假设为代价很高。换句话说，只有当无法使用一个给定的索引来查找表中的行时，才使用表扫描。</p>
				<p><span>USE KEY</span>、<span>IGNORE KEY</span>和<span>FORCE 
				KEY</span>是<span>USE INDEX</span>、<span>IGNORE 
				INDEX</span>和<span>FORCE INDEX</span>的同义词。</p>
				<p>注释：当<span>MySQL</span>决定如何在表中查找行并决定如何进行联合时，使用<span>USE 
				INDEX</span>、<span>IGNORE INDEX</span>和<span>FORCE 
				INDEX</span>只会影响使用哪些索引。当分解一个<span>ORDER BY</span>或<span>GROUP 
				BY</span>时，这些语句不会影响某个索引是否被使用。</p>
				<p>部分的联合示例：</p>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1,table2 WHERE table1.id=table2.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 USING (id);</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>LEFT JOIN table3 ON table2.id=table3.id;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 USE INDEX (key1,key2)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE key1=1 AND key2=2 AND key3=3;</b></span></span></pre>
				<pre><span>mysql&gt; <span><b>SELECT * FROM table1 IGNORE INDEX (key3)</b></span></span></pre>
				<pre><span>&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span><b>WHERE key1=1 AND key2=2 AND key3=3;</b></span></span></pre>
				<p>见<a href="optimization.html#left-join-optimization"  title="7.2.9. How MySQL Optimizes LEFT JOIN and RIGHT JOIN">7.2.9节，“MySQL如何优化LEFT JOIN和RIGHT 
				JOIN”</a>。</p>
				<p>注释：自然联合和使用<span>USING</span>的联合，包括外部联合变量，依据<span>SQL:2003</span>标准被处理。这些变更时<span>MySQL</span>与标准<span>SQL</span>更加相符。不过，对于有些联合，这些变更会导致不同的输出列。另外，有些查询在旧版本（<span>5.0.12</span>以前）工作正常，但也必须重新编写，以符合此标准。对于有关当前联合处理和旧版本中的联合处理的效果的对比，以下列表提供了更详细的信息。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>NATURAL</span>联合或<span>USING</span>联合的列会与旧版本不同。特别是，不再出现冗余的输出列，用于<span>SELECT 
				*</span>扩展的列的顺序会与以前不同。</p>
				<p>示例：</p>
				<pre><span>CREATE TABLE t1 (i INT, j INT);</span></pre>
				<pre><span>CREATE TABLE t2 (k INT, j INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t2 VALUES(1,1);</span></pre>
				<pre><span>SELECT * FROM t1 NATURAL JOIN t2;</span></pre>
				<pre><span>SELECT * FROM t1 JOIN t2 USING (j);</span></pre>
				<p>对于旧版本，语句会产生以下输出：</p>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>| i&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>| i&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; | j&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+------+</span></pre>
				<p>在第一个<span>SELECT</span>语句中，列<span>i</span>同时出现在两个表中，为一个联合列，所以，依据标准<span>SQL</span>，该列在输出中只出现一次。与此类似，在第二个<span>SELECT</span>语句中，列<span>j</span>在<span>USING</span>子句中被命名，应在输出中只出现一次。但是，在两种情况下，冗余的列均没被消除。另外，依据标准<span>SQL</span>，列的顺序不正确。</p>
				<p>现在，语句产生如下输出：</p>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>| j&nbsp;&nbsp;&nbsp; | i&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>| j&nbsp;&nbsp;&nbsp; | i&nbsp;&nbsp;&nbsp; | k&nbsp;&nbsp;&nbsp; |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<pre><span>|&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |&nbsp;&nbsp;&nbsp; 1 |</span></pre>
				<pre><span>+------+------+------+</span></pre>
				<p>冗余的列被消除，并且依据标准<span>SQL</span>，列的顺序是正确的：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第一，两表共有的列，按在第一个表中的顺序排列</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第二，第一个表中特有的列，按该表中的顺序排列</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>第三，第二个表中特有的列，按该表中的顺序排列</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对多方式自然联合的估算会不同。方式要求重新编写查询。假设您有三个表<span>t1(a,b)</span><span>,
				<span>t2(c,b)</span></span>和<span>t3(a,c)</span>，每个表有一行：<span>t1(1,2)</span><span>,
				<span>t2(10,2)</span></span>和<span>t3(7,10)</span>。同时，假设这三个表具有<span>NATURAL 
				JOIN</span>：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT </span>…<span> FROM t1 NATURAL JOIN t2 NATURAL JOIN t3;</span></pre>
				<p>在旧版本中，第二个联合的左操作数被认为是<span>t2</span>，然而它应该为嵌套联合（<span>t1 
				NATURAL JOIN t2</span>）。结果，对<span>t3</span>的列进行检查时，只检查其在<span>t2</span>中的共有列。如果<span>t3</span>与<span>t1</span>有共有列，这些列不被用作<span>equi-join</span>列。因此，在旧版本的<span>MySQL</span>中，前面的查询被转换为下面的<span>equi-join</span>：</p>
				<pre><span>SELECT </span>…<span> FROM t1, t2, t3</span></pre>
				<pre><span>&nbsp; WHERE t1.b = t2.b AND t2.c = t3.c;</span></pre>
				<p>此联合又省略了一个<span>equi-join</span>谓语（<span>t1.a 
				= t3.a</span>）。结果是，该联合产生一个行，而不是空结果。正确的等价查询如下：</p>
				<pre><span>SELECT </span>…<span> FROM t1, t2, t3</span></pre>
				<pre><span>&nbsp; WHERE t1.b = t2.b AND t2.c = t3.c AND t1.a = t3.a;</span></pre>
				<p>如果您要求在当前版本的<span>MySQL</span>中获得和旧版本中相同的查询结果，应把自然联合改写为第一个<span>equi-join</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在旧版本中，逗号操作符（，）和<span>JOIN</span>均有相同的优先权，所以联合表达式<span>t1, 
				t2 JOIN t3</span>被理解为<span>((t1, 
				t2) JOIN t3)</span>。现在，<span>JOIN</span>有更高的优先权，所以表达式被理解为<span>(t1, 
				(t2 JOIN t3))</span>。这个变更会影响使用<span>ON</span>子句的语句，因为该子句只参阅联合操作数中的列。优先权的变更改变了对什么是操作数的理解。</p>
				<p>示例：</p>
				<pre><span>CREATE TABLE t1 (i1 INT, j1 INT);</span></pre>
				<pre><span>CREATE TABLE t2 (i2 INT, j2 INT);</span></pre>
				<pre><span>CREATE TABLE t3 (i3 INT, j3 INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t2 VALUES(1,1);</span></pre>
				<pre><span>INSERT INTO t3 VALUES(1,1);</span></pre>
				<pre><span>SELECT * FROM t1, t2 JOIN t3 ON (t1.i1 = t3.i3);</span></pre>
				<p>在旧版本中，<span>SELECT</span>是合法的，因为<span>t1, 
				t2</span>被隐含地归为<span>(t1,t2)</span>。现在，<span>JOIN</span>取得了优先权，因此用于<span>ON</span>子句的操作数是<span>t2</span>和<span>t3</span>。因为<span>t1.i1</span>不是任何一个操作数中的列，所以结果是出现在<span><span>&#39;on 
				clause&#39;</span>中有未知列<span>&#39;t1.i1&#39;</span>的错误。要使联合可以被处理，用使用圆括号把前两个表明确地归为一组，这样用于<span>ON</span>子句的操作数为<span>(t1,t2)</span>和<span>t3</span>：</span></p>
				<pre><span>SELECT * FROM (t1, t2) JOIN t3 ON (t1.i1 = t3.i3);</span></pre>
				<p>本变更也适用于<span>INNER JOIN</span>，<span>CROSS 
				JOIN</span>，<span>LEFT JOIN</span>和<span>RIGHT 
				JOIN</span>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在旧版本中，<span>ON</span>子句可以参阅在其右边命名的表中的列。现在，<span>ON</span>子句只能参阅操作数。</p>
				<p>示例：</p>
				<pre><span>CREATE TABLE t1 (i1 INT);</span></pre>
				<pre><span>CREATE TABLE t2 (i2 INT);</span></pre>
				<pre><span>CREATE TABLE t3 (i3 INT);</span></pre>
				<pre><span>SELECT * FROM t1 JOIN t2 ON (i1 = i3) JOIN t3;</span></pre>
				<p>在旧版本中，<span>SELECT</span>语句是合法的。现在该语句会运行失败，出现在<span>&#39;on 
				clause&#39;</span>中未知列<span>&#39;i3&#39;</span>的错误。这是因为<span>i3</span>是<span>t3</span>中的一个表，而<span>t3</span>不是<span>ON</span>子句中的操作数。本语句应进行如下改写：</p>
				<pre><span>SELECT * FROM t1 JOIN t2 JOIN t3 ON (i1 = i3);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在旧版本中，一个<span>USING</span>子句可以被改写为一个<span>ON</span>子句。<span>ON</span>子句对比了相应的列。例如，以下两个子句具有相同的语义：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b USING (c1,c2,c3)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>a LEFT JOIN b ON a.c1=b.c1 AND a.c2=b.c2 AND a.c3=b.c3</span></pre>
				<p>现在，这两个子句不再是一样的：</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在决定哪些行满足联合条件时，两个联合保持语义相同。</p>
				<p>
				<span>
				o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在决定哪些列显示<span>SELECT *</span>扩展时，两个联合的语义不相同。<span>USING</span>联合选择对应列中的合并值，而<span>ON</span>联合选择所有表中的所有列。对于前面的<span>USING</span>联合，<span>SELECT 
				*</span>选择这些值：</p>
				<pre><span>o<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>COALESCE(a.c1,b.c1), COALESCE(a.c2,b.c2), COALESCE(a.c3,b.c3)</span></pre>
				<p>对于<span>ON</span>联合，<span>SELECT 
				*</span>选择这些值：</p>
				<pre><span>a.c1, a.c2, a.c3, b.c1, b.c2, b.c3</span></pre>
				<p>使用内部联合时，<span>COALESCE<span>(a.c1,b.c1)</span></span><span>与<span>a.c1</span>或<span>b.c1</span>相同，因为两列将具有相同的值。使用外部联合时（比如<span>LEFT 
				JOIN</span>），两列中有一列可以为<span>NULL</span>。该列将会从结果中被忽略。</span></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="union"></a>13.2.7.2. UNION语法<br>
&nbsp;</h4></div></div></div><a class="indexterm" name="id2908061"></a></div></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>SELECT ...</span></pre>
			<pre><span>UNION [ALL | DISTINCT]</span></pre>
			<pre><span>SELECT ...</span></pre>
			<pre><span>[UNION [ALL | DISTINCT]</span></pre>
			<pre><span>SELECT ...]</span></pre>
			<p><span>UNION</span>用于把来自许多<span>SELECT</span>语句的结果组合到一个结果集合中。</p>
			<p>列于每个<span>SELECT</span>语句的对应位置的被选择的列应具有相同的类型。（例如，被第一个语句选择的第一列应和被其它语句选择的第一列具有相同的类型。）在第一个<span>SELECT</span>语句中被使用的列名称也被用于结果的列名称。</p>
			<p><span>SELECT</span>语句为常规的选择语句，但是受到如下的限定：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只有最后一个<span>SELECT</span>语句可以使用<span>INTO 
			OUTFILE</span>。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span><span>HIGH_PRIORITY</span>不能与作为<span>UNION</span>一部分的<span>SELECT</span>语句同时使用。如果您对第一个<span>SELECT</span>指定了<span>HIGH_PRIORITY</span>，则不会起作用。如果您对其它后续的<span>SELECT</span>语句指定了<span>HIGH_PRIORITY</span>，则会产生语法错误。</p>
			<p>如果您对<span>UNION</span>不使用关键词<span>ALL</span>，则所有返回的行都是唯一的，如同您已经对整个结果集合使用了<span>DISTINCT</span>。如果您指定了<span>ALL</span>，您会从所有用过的<span>SELECT</span>语句中得到所有匹配的行。</p>
			<p><span>DISTINCT</span>关键词是一个自选词，不起任何作用，但是根据<span>SQL</span>标准的要求，在语法中允许采用。（在<span>MySQL</span>中，<span>DISTINCT</span>代表一个共用体的默认工作性质。）</p>
			<p>您可以在同一查询中混合<span>UNION ALL</span>和<span>UNION 
			DISTINCT</span>。被混合的<span>UNION</span>类型按照这样的方式对待，即<span>DISTICT</span>共用体覆盖位于其左边的所有<span>ALL</span>共用体。<span>DISTINCT</span>共用体可以使用<span>UNION 
			DISTINCT</span>明确地生成，或使用<span>UNION</span>（后面不加<span>DISTINCT</span>或<span>ALL</span>关键词）隐含地生成。</p>
			<p>如果您想使用<span>ORDER BY</span>或<span>LIMIT</span>子句来对全部<span>UNION</span>结果进行分类或限制，则应对单个地<span>SELECT</span>语句加圆括号，并把<span>ORDER 
			BY</span>或<span>LIMIT</span>放到最后一个的后面。以下例子同时使用了这两个子句：</p>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=10 AND B=1)</span></pre>
			<pre><span>UNION</span></pre>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=11 AND B=2)</span></pre>
			<pre><span>ORDER BY a LIMIT 10;</span></pre>
			<p>这种<span>ORDER BY</span>不能使用包括表名称（也就是，采用<span><i><span>tbl_name</span></i></span><span>.<span><i>col_name</i></span></span>格式的名称）列引用。可以在第一个<span>SELECT</span>语句中提供一个列别名，并在<span>ORDER 
			BY</span>中参阅别名，或使用列位置在<span>ORDER BY</span>中参阅列。（首选采用别名，因为不建议使用列位置。）</p>
			<p>另外，如果带分类的一列有别名，则<span>ORDER BY</span>子句必须引用别名，而不能引用列名称。以下语句中的第一个语句必须运行，但是第二个会运行失败，出现在<span>&#39;order 
			clause&#39;</span>中有未知列<span>&#39;a&#39;</span>的错误：</p>
			<pre><span>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;</span></pre>
			<pre><span>(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;</span></pre>
			<p><span>To apply <span>ORDER BY</span> 
			or <span>LIMIT</span> to an individual
			<span>SELECT</span>, place the clause inside 
			the parentheses that enclose the <span>
			SELECT</span>:&nbsp;&nbsp; </span>为了对单个<span>SELECT</span>使用<span>ORDER 
			BY</span>或<span>LIMIT</span>，应把子句放入圆括号中。圆括号包含了<span>SELECT</span>：</p>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=10 AND B=1 ORDER BY a LIMIT 10)</span></pre>
			<pre><span>UNION</span></pre>
			<pre><span>(SELECT a FROM <span><i>tbl_name</i></span> WHERE a=11 AND B=2 ORDER BY a LIMIT 10);</span></pre>
			<p>圆括号中用于单个<span>SELECT</span>语句的<span>ORDER BY</span>只有当与<span>LIMIT</span>结合后，才起作用。否则，<span>ORDER 
			BY</span>被优化去除。</p>
			<p><span>UNION</span>结果集合中的列的类型和长度考虑了被所有<span>SELECT</span>语句恢复的数值。例如，考虑如下语句：</p>
			<pre><span>mysql&gt; <span><b>SELECT REPEAT(&#39;a&#39;,1) UNION SELECT REPEAT(&#39;b&#39;,10);</b></span></span></pre>
			<pre><span>+---------------+</span></pre>
			<pre><span>| REPEAT(&#39;a&#39;,1) |</span></pre>
			<pre><span>+---------------+</span></pre>
			<pre><span>| a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| bbbbbbbbbb&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+---------------+</span></pre>
			<p>（在部分早期版本的<span>MySQL</span>中，第二行已被删节到长度为<span>1</span>。）</p>
			<h3 class="title"><a name="subqueries"></a>
			13.2.8.&nbsp;Subquery语法</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#scalar-subqueries" >
				13.2.8.1. 子查询作为标量操作数</a></span></dt><dt><span class="section"><a href="sql-syntax.html#comparisons-using-subqueries" >13.2.8.2. 
				使用子查询进行比较</a></span></dt><dt><span class="section"><a href="sql-syntax.html#any-in-some-subqueries" >13.2.8.3. 
				使用ANY, IN和SOME进行子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#all-subqueries" >13.2.8.4. 
				使用ALL进行子查询<code class="literal"></code></a></span></dt><dt><span class="section"><a href="sql-syntax.html#row-subqueries" >
				13.2.8.5. 行子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#exists-and-not-exists-subqueries" >13.2.8.6. 
				EXISTS和NOT EXISTS</a></span></dt><dt><span class="section"><a href="sql-syntax.html#correlated-subqueries" >
				13.2.8.7. 关联子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#unnamed-views" >
				13.2.8.8. FROM子句中的子查询<code class="literal"></code></a></span></dt><dt><span class="section"><a href="sql-syntax.html#subquery-errors" >13.2.8.9. 
				子查询错误</a></span></dt><dt><span class="section"><a href="sql-syntax.html#optimizing-subqueries" >
				13.2.8.10. 优化子查询</a></span></dt><dt><span class="section"><a href="sql-syntax.html#rewriting-subqueries" >
				13.2.8.11. 把子查询作为用于早期MySQL版本的联合进行改写</a></span></dt></dl></div><a class="indexterm" name="id2908464"></a><a class="indexterm" name="id2908470"></a><a class="indexterm" name="id2908477"></a><a class="indexterm" name="id2908484"></a>
			<p>子查询是另一个语句中的一个<span>SELECT</span>语句。</p>
			<p><span>MySQL</span>支持<span>SQL</span>标准要求的所有子查询格式和操作，也支持<span>MySQL</span>特有的几种特性。</p>
			<p>以下是一个子查询的例子：</p>
			<pre><span>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</span></pre>
			<p>在本例中，<span>SELECT * FROM t1...</span>是外部查询（或外部语句）<span>,</span>（<span>SELECT 
			column1 FROM t2</span>）是子查询。我们可以说子查询嵌套在外部查询中。实际上，子查询也可以嵌套在其它子查询中，嵌套程度可以很深。子查询必须要位于圆括号中。</p>
			<p>子查询的主要优势为：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>子查询允许结构化的查询，这样就可以把一个语句的每个部分隔离开。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>有些操作需要复杂的联合和关联。子查询提供了其它的方法来执行这些操作。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>在许多人看来，子查询是可读的。实际上，子查询给予人们调用早期<span>SQL</span>“结构化查询语言”的原本的想法，这是子查询的创新。</p>
			<p>以下是一个示例语句。该语句显示了有关子查询语法的要点。子查询语法由<span>SQL</span>标准指定并被<span>MySQL</span>支持。</p>
			<pre><span>DELETE FROM t1</span></pre>
			<pre><span>WHERE s11 &gt; ANY</span></pre>
			<pre><span>(SELECT COUNT(*) /* no hint */ FROM t2</span></pre>
			<pre><span>WHERE NOT EXISTS</span></pre>
			<pre><span>(SELECT * FROM t3</span></pre>
			<pre><span>WHERE ROW(5*t2.s1,77)=</span></pre>
			<pre><span>(SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM</span></pre>
			<pre><span>(SELECT * FROM t5) AS t5)));</span></pre>
			<p>
			一个子查询会返回一个标量（单一值）、一个行、一个列或一个表（一行或多行及一列或多列）。这些子查询被称为标量、列、行和表子查询。可返回一个特定种类结果的子查询经常只被用于特定的语境中，在后面各节中有说明。</p>
			<p>有些语句可以使用子查询。对这些语句的类型基本没有限定。子查询可以包括普通<span>SELECT</span>可以包括的任何关键词或子句：<span>DISTINCT</span><span>,
			<span>GROUP BY</span>,
			<span>ORDER BY</span>,
			<span>LIMIT</span>, </span>联合<span>,
			</span>索引提示<span>, <span>UNION</span></span><span>结构化</span><span>,
			</span>评注和函数等。</p>
			<p>有一个限定是，一个子查询的外部语句必须是以下语句之一：<span>SELECT, INSERT, 
			UPDATE, DELETE, SET</span>或<span>DO</span>。还有一个限定是，目前，您不能在一个子查询中修改一个表，又在同一个表中选择。这适用于<span>DELETE, 
			INSERT, REPLACE</span>和<span>UPDATE</span>语句。在<a href="restrictions.html" >附录</a><a href="restrictions.html"  title="Appendix I. Feature Restrictions">I：<i>特性限制</i></a>中给出了对子查询使用的更综合的讨论。</p>
			<div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="scalar-subqueries"></a>
				13.2.8.1.&nbsp;子查询作为标量操作数</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				子查询最简单的形式是返回单一值的标量子查询。标量子查询是一个单一操作数。只要单一列值或文字是合法的，并且您希望子查询具有所有操作数都具有的特性，则您就可以使用子查询。操作数具有的特性包括：一个数据类型、一个长度、一个指示是否可以为<span>NULL</span>的标志等。举例说明：<pre><span>CREATE TABLE t1 (s1 INT, s2 CHAR(5) NOT NULL);</span></pre>
				<pre><span>INSERT INTO t1 VALUES(100, &#39;abcde&#39;);</span></pre>
				<pre><span>SELECT (SELECT s2 FROM t1);</span></pre>
				<p>在本<span>SELECT</span>中的子查询返回一个单一值<span>(<span>&#39;abcde&#39;</span>)</span>。该单一值的数据类型为<span>CHAR</span>，长度为<span>5</span>，字符集和整序与在<span>CREATE 
				TABLE</span>时有效的默认值相同，并有一个指示符号，指示列中的值可以为<span>NULL</span>。实际上，基本上所有的子查询都为<span>NULL</span>。如果在本例中使用的表为空表，则子查询的值应为<span>NULL</span>。</p>
				<p>在有些情况下，标量子查询不能使用。如果一个语句只允许一个文字值，您不能使用子查询。例如，<span>LIMIT</span>要求文字整数自变量，<span>LOAD 
				DATA</span>要求一个文字字符串文件名。您不能使用子查询来提供这些值。</p>
				<p>后面各节包括更简练的结构（<span>SELECT column1 FROM t1</span>）。当您在这些章节中观看例子时，请设想一下您自己的代码包含更多样、更复杂的结构。</p>
				<p>举例说明，假设我们制作两个表：</p>
				<pre><span>CREATE TABLE t1 (s1 INT);</span></pre>
				<pre><span>INSERT INTO t1 VALUES (1);</span></pre>
				<pre><span>CREATE TABLE t2 (s1 INT);</span></pre>
				<pre><span>INSERT INTO t2 VALUES (2);</span></pre>
				<p>然后执行一个<span>SELECT</span>：</p>
				<pre><span>SELECT (SELECT s1 FROM t2) FROM t1;</span></pre>
				<p>结果为<span>2</span>，因为<span>t2</span>中有一行包含<span>s1</span>，<span>s1</span>有一个值为<span>2</span>。</p>
				<p>
				一个标量子查询可以为一个表达式的一部分。不要忘记圆括号。即使是子查询是一个为函数提供自变量的操作数时，也不要忘记圆括号。举例说明：</p>
				<pre><span>SELECT UPPER((SELECT s1 FROM t1)) FROM t2;</span></pre>
				<h4 class="title"><a name="comparisons-using-subqueries"></a>
				13.2.8.2.&nbsp;使用子查询进行比较</h4></div></div></div>
				<p>子查询最常见的一种使用方式如下：</p>
				<pre><span><i><span>non_subquery_operand</span></i></span><span> <span><i>comparison_operator</i></span> (<span><i>subquery</i></span>)</span></pre>
				<p>当<span><i><span>comparison_operator</span></i></span>是以下
				操作符之一时：</p>
				<pre><span>=&nbsp; &gt;&nbsp; &lt;&nbsp; &gt;=&nbsp; &lt;=&nbsp; &lt;&gt;</span></pre>
				<p>例如：</p>
				<pre><span>&nbsp; ... &#39;a&#39; = (SELECT column1 FROM t1)</span></pre>
				<p>有时，子查询的合法位置只能在比较式的右侧，您可以发现，在有些旧的<span>DBMSs</span>中仍保持这一点。</p>
				<p>以下是一个常见格式的子查询比较的例子。您不能使用联合进行此类比较。表<span>t1</span>中有些值与表<span>t2</span>中的最大值相同。该比较可以查找出所有这类值：</p>
				<pre><span>SELECT column1 FROM t1</span></pre>
				<pre><span>WHERE column1 = (SELECT MAX(column2) FROM t2);</span></pre>
				<p>下面还有另一个例子，该例子也不可能使用联合，因为该例子涉及对其中一个表进行总计。表<span>t1</span>中的有些行含有的值会在给定的列中出现两次。该例子可以查找出所有这些行：</p>
				<pre><span>SELECT * FROM t1 AS t</span></pre>
				<pre><span>WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);</span></pre>
				<p>对于采用这些操作符之一进行的比较，子查询必须返回一个标量。有一个例外，那就是＝可以和行子查询同时使用。请参见<a href="sql-syntax.html#row-subqueries"  title="13.2.8.5. Row Subqueries">13.2.8.5节，“行子查询”</a>。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="any-in-some-subqueries"></a>
				13.2.8.3.&nbsp;使用ANY, IN和SOME进行子查询</h4></div></div></div>
				<p>语法：</p>
				<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> ANY (<span><i>subquery</i></span>)</span></pre>
				<pre><span><i><span>operand</span></i></span><span> IN (<span><i>subquery</i></span>)</span></pre>
				<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> SOME (<span><i>subquery</i></span>)</span></pre>
				<p><span>ANY</span>关键词必须后面接一个比较操作符。<span>ANY</span>关键词的意思是“对于在子查询返回的列中的任一数值，如果比较结果为<span>TRUE</span>的话，则返回<span>TRUE</span>”。例如：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &gt; ANY (SELECT s1 FROM t2);</span></pre>
				<p>假设表<span>t1</span>中有一行包含（<span>10</span>）。如果表<span>t2</span>包含（<span>21</span>，<span>14</span>，<span>7</span>），则表达式为<span>TRUE</span>，因为<span>t2</span>中有一个值为<span>7</span>，该值小于<span>10</span>。如果表<span>t2</span>包含（<span>20</span>，<span>10</span>），或者如果表<span>t2</span>为空表，则表达式为<span>FALSE</span>。如果表<span>t2</span>包含（<span>NULL, 
				NULL, NULL</span>），则表达式为<span>UNKNOWN</span>。</p>
				<p>词语<span>IN</span>是＝<span>ANY</span>的别名。因此，这两个语句是一样的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 IN&nbsp;&nbsp;&nbsp; (SELECT s1 FROM t2);</span></pre>
				<p>不过，<span>NOT IN</span>不是<span>&lt;&gt; ANY</span>的别名，但是是<span>&lt;&gt; 
				ALL</span>的别名。请参见<a href="sql-syntax.html#all-subqueries"  title="13.2.8.4. Subqueries with ALL">13.2.8.4节，“使用ALL进行子查询<code class="literal"></code>”</a>。</p>
				<p>词语<span>SOME</span>是<span>ANY</span>的别名。因此，这两个语句是一样的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ANY&nbsp; (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; SOME (SELECT s1 FROM t2);</span></pre>
				<p>使用词语<span>SOME</span>的机会很少，但是本例显示了为什么<span>SOME</span>是有用的。对于多数人来说，英语短语“<span>a 
				is not equal to any b</span>”的意思是“没有一个<span>b</span>与<span>a</span>相等”，但是在<span>SQL</span>语法中不是这个意思。该语法的意思是“有部分<span>b</span>与<span>a</span>不相等”。使用<span>&lt;&gt; 
				SOME</span>有助于确认每个人都理解该查询的真正含义。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="all-subqueries"></a>
				13.2.8.4.&nbsp;使用ALL进行子查询<code class="literal"></code></h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				语法：<pre><span><i><span>operand</span></i></span><span> <span><i>comparison_operator</i></span> ALL (<span><i>subquery</i></span>)</span></pre>
				<p>词语<span>ALL</span>必须接在一个比较操作符的后面。<span>ALL</span>的意思是“对于子查询返回的列中的所有值，如果比较结果为<span>TRUE</span>，则返回<span>TRUE</span>。”例如：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &gt; ALL (SELECT s1 FROM t2);</span></pre>
				<p>假设表<span>1</span>中有一行包含（<span>10</span>）。如果表<span>t2</span>包含（<span>-5</span>，<span>0</span>，＋<span>5</span>），则表达式为<span>TRUE</span>，因为<span>10</span>比<span>t2</span>中的所有三个值都大。如果表<span>t2</span>包含（<span>12</span>，<span>6</span>，<span>NULL</span>，－<span>100</span>），则表达式为<span>FALSE</span>，因为表<span>t2</span>中有一个值<span>12</span>大于<span>10</span>。如果表<span>t2</span>包含（<span>0</span>，<span>NULL</span>，<span>1</span>），则表达式为<span>unknown</span>。</p>
				<p>最后，如果表<span>t2</span>为空表，则结果为<span>TRUE</span>。因此，当表<span>t2</span>为空表时，以下语句为<span>TRUE</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT s1 FROM t2);</span></pre>
				<p>但是，当表<span>t2</span>为空表时，本语句为<span>NULL</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; (SELECT s1 FROM t2);</span></pre>
				<p>另外，当表<span>t2</span>为空表时，以下语句为<span>NULL</span>：</p>
				<pre><span>SELECT * FROM t1 WHERE 1 &gt; ALL (SELECT MAX(s1) FROM t2);</span></pre>
				<p>通常，包含<span>NULL</span>值的表和空表为“边缘情况”。当编写子查询代码时，都要考虑您是否把这两种可能性计算在内。</p>
				<p><span>NOT IN</span>是<span>&lt;&gt; ALL</span>的别名。因此，以下两个语句是相同的：</p>
				<pre><span>SELECT s1 FROM t1 WHERE s1 &lt;&gt; ALL (SELECT s1 FROM t2);</span></pre>
				<pre><span>SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);</span></pre>
				<h4 class="title"><a name="row-subqueries"></a>13.2.8.5.&nbsp;行子查询</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				对于本点的讨论属于标量或列子查询，即返回一个单一值或一列值的子查询。行子查询是一个能返回一个单一行的子查询变量，因此可以返回一个以上的列值。以下是两个例子：<pre><span>SELECT * FROM t1 WHERE (1,2) = (SELECT column1, column2 FROM t2);</span></pre>
				<pre><span>SELECT * FROM t1 WHERE ROW(1,2) = (SELECT column1, column2 FROM t2);</span></pre>
				<p>如果在表<span>t2</span>的一个行中，<span>column1=1</span>并且<span>column2=2</span>，则查询结果均为<span>TRUE</span>。</p>
				<p>表达式（<span>1</span>，<span>2</span>）和<span>ROW</span>（<span>1</span>，<span>2</span>）有时被称为行构造符。两者是等同的，在其它的语境中，也是合法的。例如，以下两个语句在语义上是等同的（但是目前只有第二个语句可以被优化）：</p>
				<pre><span>&nbsp; SELECT * FROM t1 WHERE (column1,column2) = (1,1);</span></pre>
				<pre><span>&nbsp; SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;</span></pre>
				<p>行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。例如，以下查询可以答复请求，“在表<span>t1</span>中查找同时也存在于表<span>t2</span>中的所有的行”：</p>
				<pre><span>SELECT column1,column2,column3</span></pre>
				<pre><span>FROM t1</span></pre>
				<pre><span>WHERE (column1,column2,column3) IN</span></pre>
				<pre><span>(SELECT column1,column2,column3 FROM t2);</span></pre>
				<h4 class="title"><a name="exists-and-not-exists-subqueries"></a>13.2.8.6. EXISTS和NOT 
				EXISTS</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				如果一个子查询返回任何的行，则<span>EXISTS
				<span><i>subquery</i></span></span>为<span>FALSE</span>。例如：<pre><span>SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2);</span></pre>
				<p>过去，<span>EXISTS</span>子查询以<span>SELECT *</span>为开始，但是可以以<span>SELECT 
				5</span>或<span>SELECT column1</span>或其它的为开始。<span>MySQL</span>在这类子查询中忽略了<span>SELECT</span>清单，因此没有区别。</p>
				<p>对于前面的例子，如果<span>t2</span>包含任何行，即使是只含有<span>NULL</span>值的行，<span>EXISTS</span>条件也为<span>TRUE</span>。这实际上是一个不可能的例子，因为基本上所有的<span>[NOT] 
				EXISTS</span>子查询均包含关联。以下是一些更现实的例子：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些种类的商店出现在一个或多个城市里？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE EXISTS (SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.store_type = stores.store_type);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些种类的商店没有出现在任何城市里？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE NOT EXISTS (SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.store_type = stores.store_type);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>哪些种类的商店出现在所有城市里？</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT store_type FROM stores s1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;WHERE NOT EXISTS (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM cities WHERE NOT EXISTS (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT * FROM cities_stores</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE cities_stores.city = cities.city</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND cities_stores.store_type = stores.store_type));</span></pre>
				<p>最后一个例子是一个双嵌套<span>NOT EXISTS</span>查询。也就是，该查询包含一个<span>NOT 
				EXISTS</span>子句，该子句又包含在一个<span>NOT EXISTS</span>子句中。该查询正式地回答了这个问题，“是否有某个城市拥有没有列在<span>Stores</span>中的商店？”。可以比较容易的说，一个带嵌套的<span>NOT 
				EXISTS</span>可以回答这样的问题，“是否对于所有的<span>y</span>，<span>x</span>都为<span>TRUE</span>？”</p>
				<h4 class="title"><a name="correlated-subqueries"></a>
				13.2.8.7.&nbsp;关联子查询</h4></div></div></div></div><div class="section"><div class="titlepage"><div><div>
				相关联的子查询是一个包含对表的引用的子查询。该表也显示在外部查询中。例如：<pre><span>SELECT * FROM t1 WHERE column1 = ANY</span></pre>
				<pre><span>(SELECT column1 FROM t2 WHERE t2.column2 = t1.column2);</span></pre>
				<p>注意，即使子查询的<span>FROM</span>子句不提及表<span>t1</span>，该子查询也会包含一个对<span>t1</span>中一列的引用。所以，<span>MySQL</span>看上去位于子查询的外部，并在外部查询中查找<span>t1</span>。</p>
				<p>假设表<span>t1</span>包含一行，在此行中<span>column1=5</span>并且<span>column2=6</span>；同时，表<span>t2</span>包含一行，在此行中<span>column1=5</span>并且<span>column2=7</span>。简单的表达式<span><span>... 
				WHERE column1 = ANY (SELECT column1 FROM t2)</span>会为<span>TRUE</span>。但是在本例中，在子查询中的<span>WHERE</span>子句为<span>FALSE</span>（因为（<span>5</span>，<span>6</span>）不等于（<span>5</span>，<span>7</span>）），所以子查询总体上为<span>FALSE</span>。</span></p>
				<p>范围划分规则：<span>MySQL</span>从内到外进行评估。例如：</p>
				<pre><span>SELECT column1 FROM t1 AS x</span></pre>
				<pre><span>WHERE x.column1 = (SELECT column1 FROM t2 AS x</span></pre>
				<pre><span>WHERE x.column1 = (SELECT column1 FROM t3</span></pre>
				<pre><span>WHERE x.column2 = t3.column1));</span></pre>
				<p>在本语句中，<span>x.column2</span>必须是表<span>t2</span>中的列，因为<span><span>SELECT 
				column1 FROM t2 AS x ...</span>对<span>t2</span>进行了重命名。它不是表<span>t1</span>中的列，因为<span>SELECT 
				column1 FROM t1 ...</span>是一个更靠外的外部查询。</span></p>
				<p>对于<span>HAVING</span>或<span>ORDER BY</span>子句中的子查询，<span>MySQL</span>也会在外部选择清单中寻找列名称。</p>
				<p>对于特定的情况，相关联的子查询被优化。例如：</p>
				<pre><span><i><span>val</span></i></span><span> IN (SELECT <span><i>key_val</i></span> FROM <span><i>tbl_name</i></span> WHERE <span><i>correlated_condition</i></span>)</span></pre>
				<p>否则，这些子查询效率不高，可能速度会慢。把查询作为联合进行改写可能会改进效率。</p>
				<p>相关联的子查询不能从外部查询中引用总计函数的结果。</p>
				<h4 class="title"><a name="unnamed-views"></a>
				13.2.8.8.&nbsp;FROM子句中的子查询<code class="literal"></code></h4></div></div></div><a class="indexterm" name="id2909893"></a><a class="indexterm" name="id2909900"></a>
				<p>在<span>SELECT</span>语句的<span>FROM</span>子句中，子查询是合法的。实际的语法是：</p>
				<pre><span>SELECT ... FROM (<span><i>subquery</i></span>) [AS] <span><i>name</i></span> ...</span></pre>
				<p><span>[AS]<span><i> name</i></span></span>子句是强制性的，因为<span>FROM</span>子句中的每个表必须有一个名称。在子查询选择列表中的任何列都必须有唯一的名称。您可以在本手册中的其它地方找到对本语法的说明。在该处，所用的词语是“导出表”。</p>
				<p>为了进行详细说明，假设您有如下一个表：</p>
				<pre><span>CREATE TABLE t1 (s1 INT, s2 CHAR(5), s3 FLOAT);</span></pre>
				<p>下面使用了示例表，解释了在<span>FROM</span>子句中如何使用子查询：</p>
				<pre><span>INSERT INTO t1 VALUES (1,&#39;1&#39;,1.0);</span></pre>
				<pre><span>INSERT INTO t1 VALUES (2,&#39;2&#39;,2.0);</span></pre>
				<pre><span>SELECT sb1,sb2,sb3</span></pre>
				<pre><span>FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb</span></pre>
				<pre><span>WHERE sb1 &gt; 1;</span></pre>
				<p>结果：<span>2, &#39;2&#39;, 4.0</span>。</p>
				<p>下面是另一个例子：假设您想了解一个分类后的表的一组和的平均值。采用如下操作：</p>
				<pre><span>SELECT AVG(SUM(column1)) FROM t1 GROUP BY column1;</span></pre>
				<p>不过，本查询提供所需的信息：</p>
				<pre><span>SELECT AVG(sum_column1)</span></pre>
				<pre><span>FROM (SELECT SUM(column1) AS sum_column1</span></pre>
				<pre><span>FROM t1 GROUP BY column1) AS t1;</span></pre>
				<p>注意，在子查询中使用的列名称（<span>sum_column1</span>）被整理到外部查询中。</p>
				<p><span>FROM</span>子句中的子查询可以返回标量、列、行或表。<span>FROM</span>子句中的子查询不能为有关联的子查询。</p>
				<p>即使对<span>EXPLAIN</span>语句（即建立临时导出表），<span>FROM</span>子句中的子查询也会被执行。这是因为在优化过程中，上一级的查询需要有关所有表的信息。</p>
				<div class="titlepage">
					<div>
						<div>
							<h4 class="title"><a name="subquery-errors"></a>
							13.2.8.9.&nbsp;子查询错误</h4></div></div></div>
				<p>以下错误只适用于子查询。本节把这些错误归在一起。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>来自子查询的列的数目不正确</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1241 (ER_OPERAND_COL)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = 21000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;Operand should contain 1 column(s)&quot;</span></pre>
				<p>在出现以下情况时，发生此错误：</p>
				<pre><span>SELECT (SELECT column1, column2 FROM t2) FROM t1;</span></pre>
				<p>如果您的目的是进行比较，您可以使用能返回多个列的子查询。请参见<a href="sql-syntax.html#row-subqueries"  title="13.2.8.5. Row Subqueries">13.2.8.5节，“行子查询”</a>。不过，在其它的语境下，子查询必须为标量操作数。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>来自子查询的行的数目不正确：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>ERROR 1242 (ER_SUBSELECT_NO_1_ROW)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = 21000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;Subquery returns more than 1 row&quot;</span></pre>
				<p>
				如果在语句中，子查询返回的行多于一个，则发生此错误。请考虑以下例子：</p>
				<pre><span>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</span></pre>
				<p>如果<span>SELECT column1 
				FROM t2</span>只返回一行，则将执行以前的查询。如果子查询返回的行多于一个，则将出现错误<span>1242</span>。在这种情况下，该查询将被改写为：</p>
				<pre><span>SELECT * FROM t1 WHERE column1 = ANY (SELECT column1 FROM t2);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>在子查询中表格使用不正确：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Error 1093 (ER_UPDATE_TABLE_USED)</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SQLSTATE = HY000</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>Message = &quot;You can&#39;t specify target table &#39;x&#39;</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>for update in FROM clause&quot;</span></pre>
				<p>在如下情况下，发生该错误：</p>
				<pre><span>UPDATE t1 SET column2 = (SELECT MAX(column1) FROM t1);</span></pre>
				<p>和<span>SELECT</span>语句一样，在<span>UPDATE</span>和<span>DELETE</span>语句中，子查询是合法的。所以您可以在<span>UPDATE</span>语句中使用子查询进行赋值。不过，您不能把同一个表（在本例中为表<span>t1</span>）既用于子查询的<span>FROM</span>子句，又用于更新目标。</p>
				<p>对于事务存储引擎，子查询的错误会导致整个语句失效。对于非事务存储引擎，在遇到错误之前进行的数据修订会被保留。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="optimizing-subqueries"></a>
				13.2.8.10.&nbsp;优化子查询</h4></div></div></div>
				<p>开发过程不断进展，所以从长远来看，没有一个可靠的优化技巧。有些技巧您可能会感兴趣，并原意采用：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>有些子句会影响在子查询中的行的数量和顺序。使用这类子句。例如：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.column1 IN</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT column1 FROM t2 ORDER BY column1);</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.column1 IN</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT DISTINCT column1 FROM t2);</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE EXISTS</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>(SELECT * FROM t2 LIMIT 1);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>用子查询替换联合。例如，试进行如下操作：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT column1 FROM t2);</span></pre>
				<p>代替如下操作：</p>
				<pre><span>SELECT DISTINCT t1.column1 FROM t1, t2</span></pre>
				<pre><span>WHERE t1.column1 = t2.column1;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>部分子查询可以被转换为联合，以便与不支持子查询的旧版本的<span>MySQL</span>相兼容。不过，在有些情况下，把子查询转化为联合可以提高效果。请参见<a href="sql-syntax.html#rewriting-subqueries"  title="13.2.8.11. Rewriting Subqueries as Joins for Earlier MySQL Versions">13.2.8.11节，“把子查询作为用于早期MySQL版本的联合进行改写”</a>。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>把子句从子查询的外部转移到内部。例如，使用此查询：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>WHERE s1 IN (SELECT s1 FROM t1 UNION ALL SELECT s1 FROM t2);</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT * FROM t1</span></pre>
				<pre><span>WHERE s1 IN (SELECT s1 FROM t1) OR s1 IN (SELECT s1 FROM t2);</span></pre>
				<p>另一个例子是，使用此查询：</p>
				<pre><span>SELECT (SELECT column1 + 5 FROM t1) FROM t2;</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT (SELECT column1 FROM t1) + 5 FROM t2;</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>使用行子查询，代替关联子查询。举例说明，使用此查询：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1</span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>WHERE (column1,column2) IN (SELECT column1,column2 FROM t2);</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT * FROM t1</span></pre>
				<pre><span>WHERE EXISTS (SELECT * FROM t2 WHERE t2.column1=t1.column1</span></pre>
				<pre><span>AND t2.column2=t1.column2);</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				NOT (a = ANY (...))</span> rather than
				<span>a &lt;&gt; ALL (...)</span>. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				x = ANY (table containing (1,2))</span> rather than
				<span>x=1 OR x=2</span>. </span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>Use <span>
				= ANY</span> rather than <span>EXISTS</span>.
				</span></p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>对于只返回一行的无关联子查询，<span>IN</span>的速度慢于＝。举例说明，使用此查询：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>SELECT * FROM t1 WHERE t1.<span><i>col_name</i></span></span></pre>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>= (SELECT a FROM t2 WHERE b = <span><i>some_const</i></span>);</span></pre>
				<p>代替此查询：</p>
				<pre><span>SELECT * FROM t1 WHERE t1.<span><i>col_name</i></span></span></pre>
				<pre><span>IN (SELECT a FROM t2 WHERE b = <span><i>some_const</i></span>);</span></pre>
				<p>使用这些技巧可以使程序更快或更慢。使用<span>BENCHMARK()</span>函数等<span>MySQL</span>工具，您可以了解到在您所处的情况下，哪些技巧会有帮助。</p>
				<p><span>MySQL</span>本身进行的部分优化包括：</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>只执行一次无关联子查询。使用<span>EXPLAIN</span>确认给定的子查询确实是无关联的。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>改写<span>IN, 
				ALL, ANY</span>和<span>SOME</span>子查询，目的是如果子查询中的<span>select-list</span>列已编制索引，则能发挥出此优势。</p>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span><span>MySQL</span>使用<span>index-lookup</span>函数代替以下格式的子查询。<span>EXPLAIN</span>把此函数描述为特殊的联合类型（<span>unique_subquery</span>或<span>index_subquery</span>）：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>... IN (SELECT <span><i>indexed_column</i></span> FROM <span><i>single_table</i></span> ...)</span></pre>
				<p>
				<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				</span></span>当表达式中不包含<span>NULL</span>值或空集时，<span>MySQL</span>使用一个包含<span>MIN()</span>或<span>MAX()</span>的表达式，对以下格式的表达式进行扩展：</p>
				<pre><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span><i><span>value</span></i></span><span> {ALL|ANY|SOME} {&gt; | &lt; | &gt;= | &lt;=} (<span><i>non-correlated subquery</i></span>)</span></pre>
				<p>例如，本<span>WHERE</span>子句：</p>
				<pre><span>WHERE 5 &gt; ALL (SELECT x FROM t)</span></pre>
				<p>可以用优化符进行如下处理：</p>
				<pre><span>WHERE 5 &gt; (SELECT MAX(x) FROM t)</span></pre>
				<p>在<span>MySQL</span>内部手册中有一章名为“<span>MySQL</span>如何转换子查询”，可以从<span><a target="_top"  href="http://dev.mysql.com/doc/" >http://dev.mysql.com/doc/</a></span>获取。</div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="rewriting-subqueries"></a>
				13.2.8.11.&nbsp;把子查询作为用于早期MySQL版本的联合进行改写</h4></div></div></div></div></div><div class="section"><div class="titlepage"><div><div>
			在较早版本的<span>MySQL</span>中（早于<span>MySQL 4.1</span>），只支持<span>INSERT...SELECT</span>和<span>REPLACE...SELECT...</span>格式的带嵌套的查询。虽然在<span>MySQL 
			5.1</span>中没有这种情况，但有时，仍然有其它的方法测试一组值的从属关系。并且，在有些情况下，不仅可以在没有子查询时对查询进行改写，而且有时使用这些方法比使用子查询效率更高。这些方法之一是<span>IN()</span>结构：<p>
			举例说明，本查询：</p>
			<pre><span>SELECT * FROM t1 WHERE id IN (SELECT id FROM t2);</span></pre>
			<p>可以被改写为：</p>
			<pre><span>SELECT DISTINCT t1.* FROM t1, t2 WHERE t1.id=t2.id;</span></pre>
			<p>以下查询：</p>
			<pre><span>SELECT * FROM t1 WHERE id NOT IN (SELECT id FROM t2);</span></pre>
			<pre><span>SELECT * FROM t1 WHERE NOT EXISTS (SELECT id FROM t2 WHERE t1.id=t2.id);</span></pre>
			<p>也可以使用<span>IN()</span>进行改写：</p>
			<pre><span>SELECT table1.* FROM table1 LEFT JOIN table2 ON table1.id=table2.id</span></pre>
			<pre><span>WHERE table2.id IS NULL;</span></pre>
			<p><span>LEFT [OUTER] JOIN</span>可以比对应的子查询更快，因为服务器可能对其进行更好的优化——这一点对于单独的<span>MySQL</span>服务器并不明确。在<span>SQL-92</span>之前，不存在外部联合，因此在做某些事情时，子查询是唯一的方法。现在，<span>MySQL</span>服务器和其它许多先进的数据库系统都能提供多种的外部联合类型。</p>
			<p><span>MySQL</span>支持<span>multiple-table 
			DELETE</span>语句，该语句可以被用于高效地删除行。删除时依据来自一个表或同时来自多个表的信息。同时也支持<span>Multiple-table 
			UPDATE</span>语句。</p>
			<h3 class="title"><a name="truncate"></a>13.2.9. TRUNCATE语法</h3></div></div></div><a class="indexterm" name="id2910732"></a></div><div class="section"><div class="titlepage"><div><div>
			<pre><span>TRUNCATE [TABLE] <span><i>tbl_name</i></span></span></pre>
			<p><span>TRUNCATE TABLE</span>用于完全清空一个表。从逻辑上说，该语句与用于删除所有行的<span>DELETE</span>语句等同，但是在有些情况下，两者在使用上有所不同。</p>
			<p>对于<span>InnoDB</span>表，如果有需要引用表的外键限制，则<span>TRUNCATE 
			TABLE</span>被映射到<span>DELETE</span>上；否则使用快速删减（取消和重新创建表）。使用<span>TRUNCATE 
			TABLE</span>重新设置<span>AUTO_INCREMENT</span>计数器，设置时不考虑是否有外键限制。</p>
			<p>对于其它存储引擎，在<span>MySQL 5.1</span>中，<span>TRUNCATE 
			TABLE</span>与<span>DELETE FROM</span>有以下几处不同：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>删减操作会取消并重新创建表，这比一行一行的删除行要快很多。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>删减操作不能保证对事务是安全的；在进行事务处理和表锁定的过程中尝试进行删减，会发生错误。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>被删除的行的数目没有被返回。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>只要表定义文件<span><i><span>tbl_name</span></i><span>.frm</span></span>是合法的，则可以使用<span>TRUNCATE 
			TABLE</span>把表重新创建为一个空表，即使数据或索引文件已经被破坏。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>表管理程序不记得最后被使用的<span>AUTO_INCREMENT</span>值，但是会从头开始计数。即使对于<span>MyISAM</span>和<span>InnoDB</span>也是如此。<span>MyISAM</span>和<span>InnoDB</span>通常不再次使用序列值。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>当被用于带分区的表时，<span>TRUNCATE TABLE</span>会保留分区；即，数据和索引文件被取消并重新创建，同时分区定义（<span>.par</span>）文件不受影响。</p>
			<p><span>TRUNCATE TABLE</span>是在<span>MySQL</span>中采用的一个<span>Oracle 
			SQL</span>扩展。</p>
			<h3 class="title"><a name="update"></a>13.2.10. UPDATE语法</h3></div></div></div><a class="indexterm" name="id2910933"></a>
			<p><span>Single-table</span>语法：</p>
			<pre><span>UPDATE [LOW_PRIORITY] [IGNORE] <span><i>tbl_name</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name1</i></span>=<span><i>expr1</i></span> [, <span><i>col_name2</i></span>=<span><i>expr2</i></span> ...]</span></pre>
			<pre><span>&nbsp;&nbsp; &nbsp;[WHERE <span><i>where_definition</i></span>]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [ORDER BY ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [LIMIT <span><i>row_count</i></span>]</span></pre>
			<p><span>Multiple-table</span>语法：</p>
			<pre><span>UPDATE [LOW_PRIORITY] [IGNORE] <span><i>table_references</i></span></span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; SET <span><i>col_name1</i></span>=<span><i>expr1</i></span> [, <span><i>col_name2</i></span>=<span><i>expr2</i></span> ...]</span></pre>
			<pre><span>&nbsp;&nbsp;&nbsp; [WHERE <span><i>where_definition</i></span>]</span></pre>
			<p><span>UPDATE</span>语法可以用新值更新原有表行中的各列。<span>SET</span>子句指示要修改哪些列和要给予哪些值。<span>WHERE</span>子句指定应更新哪些行。如果没有<span>WHERE</span>子句，则更新所有的行。如果指定了<span>ORDER 
			BY</span>子句，则按照被指定的顺序对行进行更新。<span>LIMIT</span>子句用于给定一个限值，限制可以被更新的行的数目。</p>
			<p><span>UPDATE</span>语句支持以下修饰符：</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>LOW_PRIORITY</span>关键词，则<span>UPDATE</span>的执行被延迟了，直到没有其它的客户端从表中读取为止。</p>
			<p>
			<span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			</span></span>如果您使用<span>IGNORE</span>关键词，则即使在更新过程中出现错误，更新语句也不会中断。如果出现了重复关键字冲突，则这些行不会被更新。如果列被更新后，新值会导致数据转化错误，则这些行被更新为最接近的合法的值。</p>
			<p>如果您在一个表达式中通过<span><i><span>tbl_name</span></i></span>访问一列，则<span>UPDATE</span>使用列中的当前值。例如，以下语句把年龄列设置为比当前值多一：</p>
			<pre><span>mysql&gt; <span><b>UPDATE persondata SET age=age+1;</b></span></span></pre>
			<p><span>UPDATE</span>赋值被从左到右评估。例如，以下语句对年龄列加倍，然后再进行增加：</p>
			<pre><span>mysql&gt; <span><b>UPDATE persondata SET age=age*2, age=age+1;</b></span></span></pre>
			<p>如果您把一列设置为其当前含有的值，则<span>MySQL</span>会注意到这一点，但不会更新。</p>
			<p>如果您把被已定义为<span>NOT NULL</span>的列更新为<span>NULL</span>，则该列被设置到与列类型对应的默认值，并且累加警告数。对于数字类型，默认值为<span>0</span>；对于字符串类型，默认值为空字符串<span>(<span>&#39;&#39;</span>)</span>；对于日期和时间类型，默认值为“<span>zero</span>”值。</p>
			<p><span>UPDATE</span>会返回实际被改变的行的数目。<span>Mysql_info() 
			C API</span>函数可以返回被匹配和被更新的行的数目，以及在<span>UPDATE</span>过程中产生的警告的数量。</p>
			<p>您可以使用<span>LIMIT <i>
			row_count</i></span>来限定<span>UPDATE</span>的范围。<span>LIMIT</span>子句是一个与行匹配的限定。只要发现可以满足<span>WHERE</span>子句的<span><i><span>row_count</span></i></span>行，则该语句中止，不论这些行是否被改变。</p>
			<p>如果一个<span>UPDATE</span>语句包括一个<span>ORDER BY</span>子句，则按照由子句指定的顺序更新行。</p>
			<p>您也可以执行包括多个表的<span>UPDATE</span>操作。<span><i><span>table_references</span></i></span>子句列出了在联合中包含的表。该语法在<a href="sql-syntax.html#join"  title="13.2.7.1. JOIN Syntax">13.2.7.1节，“JOIN语法”</a>中进行了说明。以下是一个例子：</p>
			<pre><span>UPDATE items,month SET items.price=month.price</span></pre>
			<pre><span>WHERE items.id=month.id;</span></pre>
			<p>以上的例子显示出了使用逗号操作符的内部联合，但是<span>multiple-table UPDATE</span>语句可以使用在<span>SELECT</span>语句中允许的任何类型的联合，比如<span>LEFT 
			JOIN</span>。</p>
			<p>注释：您不能把<span>ORDER BY</span>或<span>LIMIT</span>与<span>multiple-table 
			UPDATE</span>同时使用。</p>
			<p>在一个被更改的<span>multiple-table UPDATE</span>中，有些列被引用。您只需要这些列的<span>UPDATE</span>权限。有些列被读取了，但是没被修改。您只需要这些列的<span>SELECT</span>权限。</p>
			<p>如果您使用的<span>multiple-table UPDATE</span>语句中包含带有外键限制的<span>InnoDB</span>表，则<span>MySQL</span>优化符处理表的顺序可能与上下层级关系的顺序不同。在此情况下，语句无效并被
			回滚。同时，更新一个单一表，并且依靠<span>ON 
			UPDATE</span>功能。该功能由<span>InnoDB</span>提供，用于对其它表进行相应的修改。请参见<a href="storage-engines.html#innodb-foreign-key-constraints"  title="15.2.6.4. FOREIGN KEY Constraints">15.2.6.4节，“FOREIGN 
		KEY约束”</a>。</p>
			<p>目前，您不能在一个子查询中更新一个表，同时从同一个表中选择。</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="basic-user-commands"></a>
		13.3.&nbsp;MySQL实用工具语句</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="sql-syntax.html#describe" >13.3.1. 
			DESCRIBE语法（获取有关列的信息）</a></span></dt><dt><span class="section"><a href="sql-syntax.html#use" >13.3.2. 
			USE语法</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="describe"></a>13.3.1. DESCRIBE语法（获取有关列的信息）</h3></div></div></div><a class="indexterm" name="id2911402"></a><a class="indexterm" name="id2911411"></a>
			<pre><span>{DESCRIBE | DESC} <span><i>tbl_name</i></span> [<span><i>col_name</i></span> | <span><i>wild</i></span>]</span></pre>
			<p><span>DESCRIBE</span>可以提供有关表中各列的信息。它是<span>SHOW 
			COLUMNS FROM</span>的快捷方式。这些语句也可以显示语句，用于阅览。</p>
			<p>见<a href="sql-syntax.html#show-columns"  title="13.5.4.3. SHOW COLUMNS Syntax">13.5.4.3节，“SHOW 
		COLUMNS语法”</a>。</p>
			<p><span><i><span>col_name</span></i></span>可以是一个列名称，或一个包含‘％’和‘<span>_</span>’的通配符的字符串，用于获得对于带有与字符串相匹配的名称的各列的输出。没有必要在引号中包含字符串，除非其中包含空格或其它特殊字符。</p>
			<pre><span>mysql&gt; <span><b>DESCRIBE city;</b></span></span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>| Field&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;| Type&nbsp;&nbsp;&nbsp;&nbsp; | Null | Key | Default | Extra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>| Id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | int(11)&nbsp; | NO&nbsp;&nbsp; | PRI | NULL&nbsp;&nbsp;&nbsp; | auto_increment |</span></pre>
			<pre><span>| Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | char(35) | NO&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| Country&nbsp;&nbsp;&nbsp; | char(3)&nbsp; | NO&nbsp;&nbsp; | UNI |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| District&nbsp;&nbsp; | char(20) | YES&nbsp; | MUL |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>| Population | int(11)&nbsp; | NO&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; | 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</span></pre>
			<pre><span>+------------+----------+------+-----+---------+----------------+</span></pre>
			<pre><span>5 rows in set (0.00 sec)</span></pre>
			<p><span>NULL</span>字段指示是否<span>NULL</span>可以被存储在列中。</p>
			<p><span>Key</span>字段指示是否该列已编制索引。<span>PRI</span>的值指示该列是表的主键的一部分。<span>UNI</span>指示，该列是<span>UNIQUE</span>索引的一部分。<span>MUL</span>值指示，在列中某个给定值多次出现是允许的。</p>
			<p><span>MUL</span>将被显示在<span>UNIQUE</span>索引中，原因之一是多个列会组合成一个复合<span>UNIQUE</span>索引；尽管列的组合是唯一的，但每个列仍可以多次出现同一个给定值。注意，在复合索引中，只有索引最左边的列可以进入<span>Key</span>字段中。</p>
			<p>默认字段指示，默认值被赋予该列。</p>
			<p><span>Extra</span>字段包含可以获取的与给定列有关的附加信息。在我们的例子中，<span>Extra</span>字段指示，<span>Id</span>