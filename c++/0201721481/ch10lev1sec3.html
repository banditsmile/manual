<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 10.3.  The map Type</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch10lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch10lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch10lev1sec3"></a>

        <h3 class="docSection1Title">10.3. The <tt>map</tt> Type</h3>
        <h3 class="docSection1Title">10.3. <tt>map</tt> 类型</h3>

	<a name="idd1e77269"></a><a name="idd1e77274"></a><a name="idd1e77279"></a><a name="idd1e77284"></a><a name="idd1e77290"></a><a name="idd1e77296"></a><a name="idd1e77302"></a><a name="idd1e77308"></a><a name="idd1e77314"></a><a name="idd1e77320"></a><a name="idd1e77326"></a><a name="idd1e77332"></a><a name="idd1e77338"></a><a name="idd1e77341"></a><a name="idd1e77347"></a><a name="idd1e77350"></a>
        <p class="docText">A <tt>map</tt> is a collection of keyvalue pairs. The <tt>map</tt> type is often referred to as an <b><a name="ch10term1"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_01" >associative array</a></b>: It is like the built-in array type, in that the key can be used as an index to fetch a value. It is associative in that values are associated with a particular key rather than being fetched by position in the array.</p>
	<p class="docText"><tt>map</tt> 是键－值对的集合。<tt>map</tt> 类型通常可理解为<b><a class="docLink" href="ch10lev1sec8.html#gloss10_01" >关联数组（associative array）</a></b>：可使用键作为下标来获取一个值，正如内置数组类型一样。而关联的本质在于元素的值与某个特定的键相关联，而并非通过元素在数组中的位置来获取。</p>
	<a name="ch10lev2sec5"></a>
        <h4 class="docSection2Title">10.3.1. Defining a <tt>map</tt></h4>
        <h4 class="docSection2Title">10.3.1. <tt>map</tt> 对象的定义</h4>

        <p class="docText">To use a <b><a name="ch10term4"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_04" ><span class="docEmphStrong"><tt>map</tt></span></a></b>, we must include the <tt>map</tt> header. When we define a <tt>map</tt> object, we must indicate both the key and <b><a name="ch10term11"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_11" >value type</a></b>:</p>
	<p class="docText">要使用 <b><a class="docLink" href="ch10lev1sec8.html#gloss10_04" ><span class="docEmphStrong"><tt>map</tt></span></a></b> 对象，则必须包含 <tt>map</tt> 头文件。在定义 <tt>map</tt> 对象时，必须分别指明键和<b><a class="docLink" href="ch10lev1sec8.html#gloss10_11" >值的类型（value type）</a></b>（<a class="docLink" href="ch10lev1sec3.html#ch10table04" >表 10.4</a>）：</p>
        <pre>
     // <span class="docEmphItalicAlt">count number of times each word occurs in the input</span>
     map&lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">from string to</span> <span class="docEmphasis">int</span>
</pre><br>

        <p class="docText">defines a <tt>map</tt> object <tt>word_count</tt> that is indexed by a <tt>string</tt> and that holds an associated <tt>int</tt> value.</p>
	<p class="docText">这个语句定义了一个名为 <tt>word_count</tt> 的 <tt>map</tt> 对象，由 <tt>string</tt> 类型的键索引，关联的值则 <tt>int</tt> 型。</p>
	
	<a name="ch10table03"></a>
        <h5 class="docTableTitle">Table 10.3. Constructors for <tt>map</tt></h5>
        <h5 class="docTableTitle">表 10.3. <tt>map</tt> 的构造函数</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="175">
            <col width="325">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>map&lt;k, v&gt; m;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Create an empty <tt>map</tt> named <tt>m</tt> with key and value types <tt>k</tt> and <tt>v</tt>.</p>
              <p class="docText">创建一个名为 <tt>m</tt> 的空 <tt>map</tt> 对象，其键和值的类型分别为 <tt>k</tt> 和 <tt>v</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>map&lt;k, v&gt; m(m2);</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Create <tt>m</tt> as a copy of <tt>m2</tt>; <tt>m</tt> and <tt>m2</tt> must have the same key and value types.</p>
              <p class="docText">创建 <tt>m2</tt> 的副本 <tt>m</tt>，<tt>m</tt> 与 <tt>m2</tt> 必须有相同的键类型和值类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>map&lt;k, v&gt; m(b, e);</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Create <tt>m</tt> as a copy of the elements from the range denoted by iterators <tt>b</tt> and <tt>e</tt>. Elements must have a type that can be converted to <tt>pair&lt;const k, v&gt;</tt>.</p>
	      <p class="docText">创建 <tt>map</tt> 类型的对象 <tt>m</tt>，存储迭代器 <tt>b</tt> 和 <tt>e</tt> 标记的范围内所有元素的副本。元素的类型必须能转换为 <tt>pair&lt;const k, v&gt;</tt></p>
            </td>
          </tr>
        </table><br>
        <a name="ch10lev3sec1"></a>

        <h5 class="docSection3Title">Constraints on the Key Type</h5>
        <h5 class="docSection3Title">键类型的约束</h5>

        <p class="docText">Whenever we use an associative container, its keys have not only a type, but also an associated comparison function. By default, the library uses the <tt>&lt;</tt> operator for the <span class="docEmphRoman"><a name="ch10term3"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_03" >key type</a></span> to compare the keys. <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec23" >Section 15.8.3</a> (p. <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec23" >605</a>) will show how we can override the default and provide our own function.</p>
        <p class="docText">在使用关联容器时，它的键不但有一个类型，而且还有一个相关的比较函数。默认情况下，标准库使用键类型定义的 <tt>&lt;</tt> 操作符来实现<span class="docEmphRoman"><a class="docLink" href="ch10lev1sec8.html#gloss10_03" >键（key type）</a></span>的比较。<a class="docLink" href="ch15lev1sec8.html#ch15lev2sec23" >第 15.8.3 节</a>将介绍如何重写默认的操作符，并提供自定义的操作符函数。</p>

        <p class="docText">Whichever comparison function we use must define a <b><a name="ch10term10"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_10" >strict weak ordering</a></b> over the key type. We can think of a strict weak ordering as "less than," although we might choose to define a more complicated comparison function. However we define it, such a comparison function must always yield false when we compare a key with itself. Moreover, if we compare two keys, they cannot both be "less than" each other, and if <tt>k1</tt> is "less than" <tt>k2</tt>, which in turn is "less than" <tt>k3</tt>, then <tt>k1</tt> must be "less than" <tt>k3</tt>. If we have two keys, neither of which is "less than" the other, the container will treat them as equal. When used as a key to a <tt>map</tt>, either value could be used to access the corresponding element.</p>
	<p class="docText">所用的比较函数必须在键类型上定义<b><a class="docLink" href="ch10lev1sec8.html#gloss10_10" >严格弱排序（strict weak ordering）</a></b>。所谓的严格弱排序可理解为键类型数据上的“小于”关系，虽然实际上可以选择将比较函数设计得更复杂。但无论这样的比较函数如何定义，当用于一个键与自身的比较时，肯定会导致 <tt>false</tt> 结果。此外，在比较两个键时，不能出现相互“小于”的情况，而且，如果 <tt>k1</tt>“小于”<tt>k2</tt>，<tt>k2</tt>“小于”<tt>k3</tt>，则 <tt>k1</tt> 必然“小于”<tt>k3</tt>。对于两个键，如果它们相互之间都不存在“小于”关系，则容器将之视为相同的键。用做 <tt>map</tt> 对象的键时，可使用任意一个键值来访问相应的元素。</p>
	
	<a name="ch10note02"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">In practice, what's important is that the key type must define the <tt>&lt;</tt> operator and that that operator should "do the right thing."</p>
                <p class="docText">在实际应用中，键类型必须定义 <tt>&lt;</tt> 操作符，而且该操作符应能“正确地工作”，这一点很重要。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

	<a name="idd1e77572"></a><a name="idd1e77577"></a><a name="idd1e77584"></a><a name="idd1e77591"></a>
	<p class="docText">
	<p class="docText">例如，在书店问题中，可增加一个名为 <tt>ISBN</tt> 的类型，封装与国际标准图书编号（<tt>ISBN</tt>）相关的规则。在我们的实现中，国际标准图书编号是 <tt>string</tt> 类型，可做比较运算以确定编号之间的大小关系。因此，<tt>ISBN</tt> 类型可以支持 <tt>&lt;</tt> 运算。假设我们已经定义了这样的类型，则可定义一个 <tt>map</tt> 容器对象，以便高效地查找书店中存放的某本书。</p>
        <pre>
     map&lt;ISBN, Sales_item&gt; bookstore;
</pre><br>

        <p class="docText">defines a <tt>map</tt> object named <tt>bookstore</tt> that is indexed by an <tt>ISBN</tt>. Each element in the <tt>map</tt> holds an associated instance of our <tt>Sales_item</tt> class.</p>

        <p class="docText">该语句定义了一个名为 <tt>bookstore</tt> 的 <tt>map</tt> 对象，以 <tt>ISBN</tt> 类型的对象为索引，其所有元素都存储了一个关联的 <tt>Sales_item</tt> 类类型实例。</p>
	
	<a name="ch10note03"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The key type needs to support only the <tt>&lt;</tt> operator. There is no requirement that it support the other relational or equality operators.</p>
                <p class="docText">对于键类型，唯一的约束就是必须支持 <tt>&lt;</tt> 操作符，至于是否支持其他的关系或相等运算，则不作要求。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch10sb03"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.3.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa3q1"></a><b>Exercise 10.5:</b></td>

                    <td>
                      <p class="docText">Define a <tt>map</tt> that associates words with a <tt>list</tt> of line numbers on which the word might occur.</p>
		      <p class="docText">定义一个 <tt>map</tt> 对象，将单词与一个 <tt>list</tt> 对象关联起来，该 <tt>list</tt> 对象存储对应的单词可能的行号。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa3q2"></a><b>Exercise 10.6:</b></td>

                    <td>
                      <p class="docText">Could we define a <tt>map</tt> from <tt>vector&lt;int&gt;::iterator to int</tt>? What about from <tt>list&lt;int&gt;::iterator</tt> to <tt>int</tt>? What about from <tt>pair&lt;int, string&gt;</tt> to <tt>int</tt>? In each case, if not, explain why not.</p>
		      <p class="docText">可否定义一个 <tt>map</tt> 对象以 <tt>vector&lt;int&gt;::iterator</tt> 为键关联 <tt>int</tt> 型对象？如果以 <tt>list&lt;int&gt;::iterator</tt> 关联 <tt>int</tt>？对于每种情况，如果不允许，请解释其原因。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch10lev2sec6"></a>

        <h4 class="docSection2Title">10.3.2. Types Defined by <tt>map</tt></h4>
        <h4 class="docSection2Title">10.3.2. <tt>map</tt> 定义的类型</h4>

        <p class="docText">The elements of a <tt>map</tt> are keyvalue pairs That is, each element has two parts: its key and the value associated with that key. The <tt>value_type</tt> for a <tt>map</tt> reflects this fact. This type is more complicated than those we've seen for other containers: <tt>value_type</tt> is a <tt>pair</tt> that holds the key and value of a given element. Moreover, the key is <tt>const</tt>. For example, the <tt>value_type</tt> of the <tt>word_count</tt> array is <tt>pair&lt;const string, int&gt;</tt>.</p>
	<p class="docText"><tt>map</tt> 对象的元素是键－值对，也即每个元素包含两个部分：键以及由键关联的值。<tt>map</tt> 的 <tt>value_type</tt> 就反映了这个事实。该类型比前面介绍的容器所使用的元素类型要复杂得多：<tt>value_type</tt> 是存储元素的键以及值的 <tt>pair</tt> 类型，而且键为 <tt>const</tt>。例如，<tt>word_count</tt> 数组的 <tt>value_type</tt> 为 <tt>pair&lt;const string, int&gt;</tt> 类型。</p>
	
	<a name="ch10table04"></a>
        <h5 class="docTableTitle">Table 10.4. Types Defined by the <tt>map</tt> Class</h5>
        <h5 class="docTableTitle">表 10.4. <tt>map</tt> 类定义的类型</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="200">
            <col width="325">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>map&lt;K, V&gt;::key_type</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">The type of the keys used to index the <tt>map</tt>.</p>
              <p class="docText">在 <tt>map</tt> 容器中，用做索引的键的类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>map&lt;K, V&gt;::mapped_type</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">The type of the values associated with the keys in the <tt>map</tt>.</p>
              <p class="docText">在 <tt>map</tt> 容器中，键所关联的值的类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>map&lt;K, V&gt;::value_type</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">A pair whose first element has type <tt>const</tt> <tt>map&lt;K, V&gt;::key_type</tt> and <tt>second</tt> has type <tt>map&lt;K, V&gt;::mapped_type</tt>.</p>
	      <p class="docText">一个 <tt>pair</tt> 类型，它的 first 元素具有 <tt>const</tt> <tt>map&lt;K, V&gt;::key_type</tt> 类型，而 <tt>second</tt> 元素则为 <tt>map&lt;K, V&gt;::mapped_type</tt> 类型</p>
            </td>
          </tr>

        </table><br>
        <a name="ch10note04"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">When learning the <tt>map</tt> interface, it is essential to remember that the <tt>value_type</tt> is a <tt>pair</tt> and that we can change the value but not the key member of that <tt>pair</tt>.</p>
                <p class="docText">在学习 <tt>map</tt> 的接口时，需谨记 <tt>value_type</tt> 是 <tt>pair</tt> 类型，它的值成员可以修改，但键成员不能修改。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch10lev3sec2"></a>

        <h5 class="docSection3Title">Dereferencing a <tt>map</tt> Iterator Yields a <tt>pair</tt></h5>
        <h5 class="docSection3Title"><tt>map</tt> 迭代器进行解引用将产生 <tt>pair</tt> 类型的对象</h5>

	<a name="idd1e77866"></a><a name="idd1e77878"></a><a name="idd1e77891"></a><a name="idd1e77895"></a><a name="idd1e77901"></a><a name="idd1e77909"></a><a name="idd1e77916"></a><a name="idd1e77923"></a><a name="idd1e77930"></a><a name="idd1e77940"></a><a name="idd1e77948"></a><a name="idd1e77955"></a><a name="idd1e77962"></a><a name="idd1e77969"></a>
        <p class="docText">When we dereference an iterator, we get a reference to a value of the container's <tt>value_type</tt>. In the case of <tt>map</tt>, the <tt>value_type</tt> is a <tt>pair</tt>:</p>
        <p class="docText">对迭代器进行解引用时，将获得一个引用，指向容器中一个 <tt>value_type</tt> 类型的值。对于 <tt>map</tt> 容器，其 <tt>value_type</tt> 是 <tt>pair</tt> 类型：</p>
        <pre>
     // <span class="docEmphItalicAlt">get an iterator to an element in</span> <span class="docEmphasis">word_count</span>
     map&lt;string, int&gt;::iterator map_it = word_count.begin();

     // <span class="docEmphasis">*map_it is</span> <span class="docEmphItalicAlt">a reference to a</span> <span class="docEmphasis">pair&lt;const string, int&gt;</span> <span class="docEmphItalicAlt">object</span>
     cout &lt;&lt; map_it-&gt;first;                  // <span class="docEmphItalicAlt">prints the key for this element</span>
     cout &lt;&lt; " " &lt;&lt; map_it-&gt;second;          // <span class="docEmphItalicAlt">prints the value of the element</span>
     map_it-&gt;first = "new key";              // <span class="docEmphItalicAlt">error: key is</span> <span class="docEmphasis">const</span>
     ++map_it-&gt;second;     // <span class="docEmphItalicAlt">ok: we can change value through an iterator</span>
</pre><br>

        <p class="docText">Dereferencing the iterator yields a <tt>pair</tt> object in which <tt>first</tt> member holds the <tt>const</tt> key and <tt>second</tt> member holds the value.</p>
	<p class="docText">对迭代器进行解引用将获得一个 <tt>pair</tt> 对象，它的 <tt>first</tt> 成员存放键，为 <tt>const</tt>，而 <tt>second</tt> 成员则存放值。</p>
	
	<a name="ch10lev3sec3"></a>
        <h5 class="docSection3Title">Additional <tt>map</tt> Typedefs</h5>
        <h5 class="docSection3Title"><tt>map</tt> 容器额外定义的类型别名（typedef）</h5>

        <p class="docText">The <tt>map</tt> class defines two additional types, <tt>key_type</tt> and <b><a name="ch10term5"></a><a class="docLink" href="ch10lev1sec8.html#gloss10_05" ><span class="docEmphStrong"><tt>mapped_type</tt></span></a></b>, that let us access the type of either the key or the value. For <tt>word_count</tt>, the <tt>key_type</tt> is <tt>string</tt> and <tt>mapped_type</tt> is <tt>int</tt>. As with the sequential containers (<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec6" >Section 9.3.1</a>, p. <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec6" >317</a>), we use the scope operator to fetch a type memberfor example, <tt>map&lt;string, int&gt;::key_type</tt>.</p><a name="ch10sb04"></a>
	<p class="docText"><tt>map</tt> 类额外定义了两种类型：<tt>key_type</tt> 和 <b><a class="docLink" href="ch10lev1sec8.html#gloss10_05" ><span class="docEmphStrong"><tt>mapped_type</tt></span></a></b>，以获得键或值的类型。对于 <tt>word_count</tt>，其 <tt>key_type</tt> 是 <tt>string</tt> 类型，而 <tt>mapped_type</tt> 则是 <tt>int</tt> 型。如同顺序容器（<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec6" >第 9.3.1 节</a>）一样，可使用作用域操作符（scope operator）来获取类型成员，如 <tt>map&lt;string, int&gt;::key_type</tt>。</p>
	
	<a name="ch10sb04"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.3.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa4q1"></a><b>Exercise 10.7:</b></td>

                    <td>
                      <p class="docText">What are the <tt>mapped_type, key_type</tt>, and <tt>value_type</tt> of a <tt>map</tt> from <tt>int</tt> to <tt>vector&lt;int&gt;?</tt></p>
		      <p class="docText">对于以 <tt>int</tt> 型对象为索引关联 <tt>vector&lt;int&gt;</tt> 型对象的 <tt>map</tt> 容器，它的 <tt>mapped_type</tt>、<tt>key_type</tt> 和 <tt>value_type</tt> 分别是什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa4q2"></a><b>Exercise 10.8:</b></td>

                    <td>
                      <p class="docText">Write an expression using a <tt>map</tt> iterator to assign a value to an element.</p>
                      <p class="docText">编写一个表达式，使用 <tt>map</tt> 的迭代器给其元素赋值。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch10lev2sec7"></a>

        <h4 class="docSection2Title">10.3.3. Adding Elements to a <tt>map</tt></h4>
        <h4 class="docSection2Title">10.3.3. 给 <tt>map</tt> 添加元素</h4>

        <p class="docText">Once the <tt>map</tt> is defined, the next step is to populate it with the keyvalue element pairs. We can do so either by using the <tt>insert</tt> member or by fetching an element using the subscript operator and then assigning a value to the element returned. In both cases, the fact that there can be only a single element for a given key affects the behavior of these operations.</p>
	<p class="docText">定义了 <tt>map</tt> 容器后，下一步工作就是在容器中添加键－值元素对。该项工作可使用 <tt>insert</tt> 成员实现；或者，先用下标操作符获取元素，然后给获取的元素赋值。在这两种情况下，一个给定的键只能对应于一个元素这一事实影响了这些操作的行为。</p>
	
	<a name="ch10lev2sec8"></a>
        <h4 class="docSection2Title">10.3.4. Subscripting a <tt>map</tt></h4>
        <h4 class="docSection2Title">10.3.4. 使用下标访问 <tt>map</tt> 对象</h4>

        <p class="docText">When we write</p>
        <p class="docText">如下编写程序时：</p>
        <pre>
     map &lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span>

     // <span class="docEmphItalicAlt">insert default initialzed element with key</span> <span class="docEmphasis">Anna;</span> <span class="docEmphItalicAlt">then assign 1 to its value</span>
     word_count["Anna"] = 1;
</pre><br>

	<a name="idd1e78200"></a><a name="idd1e78208"></a><a name="idd1e78214"></a><a name="idd1e78228"></a><a name="idd1e78233"></a><a name="idd1e78242"></a><a name="idd1e78249"></a>
	<p class="docText">the following steps take place:</p>
	<p class="docText">将发生以下事情：</p>

	<a name="ch10pro01"></a>
        <table border="0" class="docText">
          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>1.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                <tt>word_count</tt> is searched for the element whose key is <tt>Anna</tt>. The element is not found.<br>
              <div class="docText">
                在 <tt>word_count</tt> 中查找键为 <tt>Anna</tt> 的元素，没有找到。<br>
              </div>
            </td>
          </tr>

          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>2.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                A new keyvalue pair is inserted into <tt>word_count</tt>. The key is a <tt>const string</tt> holding <tt>Anna</tt>. The value is value initialized, meaning in this case that the value is 0.<br>
		<div class="docText">
			将一个新的键－值对插入到 <tt>word_count</tt> 中。它的键是 <tt>const string</tt> 类型的对象，保存 <tt>Anna</tt>。而它的值则采用值初始化，这就意味着在本例中值为 0。<br>
              </div>
            </td>
          </tr>

          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>3.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                The new keyvalue pair is inserted into <tt>word_count</tt>.<br>
              <div class="docText">
              将这个新的键－值对插入到 <tt>word_count</tt> 中。
                <br>
              </div>
            </td>
          </tr>

          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>4.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                The newly inserted element is fetched and is given the value 1.<br>
              <div class="docText">
		      读取新插入的元素，并将它的值赋为 1。
                <br>
              </div>
            </td>
          </tr>
        </table><a name="ch10note05"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Subscripting a <tt>map</tt> behaves quite differently from subscripting an array or <tt>vector</tt>: Using an index that is not already present <span class="docEmphasis">adds</span> an element with that index to the <tt>map</tt>.</p>
                <p class="docText">使用下标访问 <tt>map</tt> 与使用下标访问数组或 <tt>vector</tt> 的行为截然不同：用下标访问不存在的元素将导致在 <tt>map</tt> 容器中添加一个新元素，它的键即为该下标值。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">As with other subscript operators, the <tt>map</tt> subscript takes an index (that is, a key) and fetches the value associated with that key. When we look for a key that is already in the <tt>map</tt>, then the behavior is the same for a <tt>map</tt> subscript or a <tt>vector</tt> subscript: The value associated with the key is returned. For <tt>map</tt>s only, if the key is not already present, <span class="docEmphasis">a new element is created and inserted</span> into the <tt>map</tt> for that key. The associated value is value-initialized: An element of class type is initialized using the default constructor for the element type; a built-in type is initialized to 0.</p>
	<p class="docText">如同其他下标操作符一样，<tt>map</tt> 的下标也使用索引（其实就是键）来获取该键所关联的值。如果该键已在容器中，则 <tt>map</tt> 的下标运算与 <tt>vector</tt> 的下标运算行为相同：返回该键所关联的值。只有在所查找的键不存在时，<tt>map</tt> 容器才为该键创建一个新的元素，并将它插入到此 <span class="docEmphasis"></span><tt>map</tt> 对象中。此时，所关联的值采用值初始化：类类型的元素用默认构造函数初始化，而内置类型的元素初始化为 0。</p>
	
	<a name="ch10lev3sec4"></a>
        <h5 class="docSection3Title">Using the Value Returned from a Subscript Operation</h5>
        <h5 class="docSection3Title">下标操作符返回值的使用</h5>

        <p class="docText">As usual, the subscript operator returns an lvalue. The lvalue it returns is the value associated with the key. We can read or write the element:</p>
        <p class="docText">通常来说，下标操作符返回左值。它返回的左值是特定键所关联的值。可如下读或写元素：</p>
        <pre>
     cout &lt;&lt; word_count["Anna"]; // <span class="docEmphItalicAlt">fetch element indexed by</span> <span class="docEmphasis">Anna;</span> <span class="docEmphItalicAlt">prints</span> 1
     ++word_count["Anna"];       // <span class="docEmphItalicAlt">fetch the element and add one to it</span>
     cout &lt;&lt; word_count["Anna"]; // <span class="docEmphItalicAlt">fetch the element and print it; prints</span> <span class="docEmphasis">2</span>
</pre><br>

        <a name="ch10note06"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Unlike <tt>vector</tt> or <tt>string</tt>, the type returned by <tt>map</tt> subscript operator differs from the type obtained by dereferencing a <tt>map</tt> iterator.</p>
                <p class="docText">有别于 <tt>vector</tt> 或 <tt>string</tt> 类型，<tt>map</tt> 下标操作符返回的类型与对 <tt>map</tt> 迭代器进行解引用获得的类型不相同。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">As we've seen, a <tt>map</tt> iterator returns a <tt>value_type</tt>, which is a <tt>pair</tt> that contains a <tt>const key_type</tt> and <tt>mapped_type;</tt> the subscript operator returns a value of type <tt>mapped_type</tt>.</p>
	<p class="docText">显然，<tt>map</tt> 迭代器返回 <tt>value_type</tt> 类型的值——包含 <tt>const key_type</tt> 和 <tt>mapped_type</tt> 类型成员的 <tt>pair</tt> 对象；下标操作符则返回一个 <tt>mapped_type</tt> 类型的值。</p>
	
	<a name="ch10lev3sec5"></a>
        <h5 class="docSection3Title">Programming Implications of the Subscript Behavior</h5>
        <h5 class="docSection3Title">下标行为的编程意义</h5>

        <p class="docText">The fact that subscript adds an element if it is not already in the <tt>map</tt> allows us to write surprisingly succinct programs:</p>
        <p class="docText">对于 <tt>map</tt> 容器，如果下标所表示的键在容器中不存在，则添加新元素，这一特性可使程序惊人地简练：</p>
        <pre>
     // <span class="docEmphItalicAlt">count number of times each word occurs in the input</span>
     map&lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">from string to</span> <span class="docEmphasis">int</span>
     string word;
     while (cin &gt;&gt; word)
       ++word_count[word];
</pre><br>

	<a name="idd1e78447"></a><a name="idd1e78453"></a><a name="idd1e78460"></a>
        <p class="docText">This program creates a <tt>map</tt> that keeps track of how many times each word occurs. The <tt>while</tt> loop reads the standard input one word at a time. Each time it reads a new word, it uses that word to index <tt>word_count</tt>. If <tt>word</tt> is already in the <tt>map</tt>, then its value is incremented.</p>
        <p class="docText">这段程序创建一个 <tt>map</tt> 对象，用来记录每个单词出现的次数。<tt>while</tt> 循环每次从标准输入读取一个单词。如果这是一个新的单词，则在 <tt>word_count</tt> 中添加以该单词为索引的新元素。如果读入的单词已在 <tt>map</tt> 对象中，则将它所对应的值加 1。</p>

        <p class="docText">The interesting part is what happens when a word is encountered for the first time: A new element indexed by <tt>word</tt>, with an initial value of zero, is created and inserted into <tt>word_count</tt>. The value of that element is immediately incremented so that each time we insert a new word into the <tt>map</tt> it starts off with an occurrence count of one.</p>
	<p class="docText">其中最有趣的是，在单词第一次出现时，会在 <tt>word_count</tt> 中创建并插入一个以该单词为索引的新元素，同时将它的值初始化为 0。然后其值立即加 1，所以每次在 <tt>map</tt> 中添加新元素时，所统计的出现次数正好从 1 开始。</p>
	
	<a name="ch10sb05"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.3.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa5q1"></a><b>Exercise 10.9:</b></td>

                    <td>
                      <p class="docText">Write a program to count and print the number of times each word occurs in the input.</p>
                      <p class="docText">编写程序统计并输出所读入的单词出现的次数。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa5q2"></a><b>Exercise 10.10:</b></td>

                    <td>
                      <p class="docText">What does the following program do?</p>
                      <p class="docText">解释下面的程序的功能：</p>
                      <pre>
     map&lt;int, int&gt; m;
     m[0] = 1;
</pre><br>

                      <p class="docText">Contrast the behavior of the previous program with this one:</p>
                      <p class="docText">比较上一程序和下面程序的行为</p>
                      <pre>
     vector&lt;int&gt; v;
     v[0] = 1;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa5q3"></a><b>Exercise 10.11:</b></td>

                    <td>
                      <p class="docText">What type can be used to subscript a <tt>map</tt>? What type does the sub-script operator return? Give a concrete examplethat is, define a <tt>map</tt> and then write the types that could be used to subscript the <tt>map</tt> and the type that would be returned from the subscript operator.</p>
                      <p class="docText">哪些类型可用做 <tt>map</tt> 容器对象的下标？下标操作符返回的又是什么类型？给出一个具体例子说明，即定义一个 <tt>map</tt> 对象，指出哪些类型可用作其下标，以及下标操作符返回的类型。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch10lev2sec9"></a>
        <h4 class="docSection2Title">10.3.5. Using <tt>map::insert</tt></h4>
        <h4 class="docSection2Title">10.3.5. <tt>map::insert</tt> 的使用</h4>

        <p class="docText">The <tt>insert</tt> members operate similarly to the operations on sequential containers (<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec8" >Section 9.3.3</a>, p. <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec8" >318</a>), with one important caveat: We must account for the effect of the key. The key impacts the argument types: The versions that insert a single element take a value that is a keyvalue <tt>pair</tt>. Similarly, for the version that takes an iterator pair, the iterators must refer to elements that are keyvalue <tt>pair</tt>s. The other difference is the return type from the version of <tt>insert</tt> that takes a single value, which we will cover in the remainder of this section.</p>
	<p class="docText"><tt>map</tt> 容器的 <tt>insert</tt> 成员与<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec8" >顺序容器</a>的类似，但有一点要注意：必须考虑键的作用。键影响了实参的类型：插入单个元素的 <tt>insert</tt> 版本使用键－值 <tt>pair</tt> 类型的参数。类似地，对于参数为一对迭代器的版本，迭代器必须指向键－值 <tt>pair</tt> 类型的元素。另一个差别则是：<tt>map</tt> 容器的接受单个值的 <tt>insert</tt> 版本的返回类型。本节的后续部分将详细阐述这一特性。</p>
	
        <a name="ch10table05"></a>
        <h5 class="docTableTitle">Table 10.5. <tt>insert</tt> Operations on maps</h5>
	<h5 class="docTableTitle">表 10.5. <tt>map</tt> 容器提供的 <tt>insert</tt> 操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
		<a name="idd1e78653"></a><a name="idd1e78661"></a><a name="idd1e78669"></a>
		<p class="docText"><tt>m.insert(e)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>e</tt> is a value of the <tt>value_type</tt> for <tt>m</tt>. If the key(<tt>e.first)</tt> is not in <tt>m</tt>, inserts a new element with value <tt>e.second</tt>. If the key is in <tt>m</tt>, then <tt>m</tt> is unchanged. Returns a <tt>pair</tt> containing a <tt>map</tt> iterator referring to the element with key <tt>e.first</tt> and a <tt>bool</tt> indicating whether the element was inserted or not.</p>
              <p class="docText"><tt>e</tt> 是一个用在 <tt>m</tt> 上的 <tt>value_type</tt> 类型的值。如果键（<tt>e.first</tt>）不在 <tt>m</tt> 中，则插入一个值为 <tt>e.second</tt> 的新元素；如果该键在 <tt>m</tt> 中已存在，则保持 <tt>m</tt> 不变。该函数返回一个 <tt>pair</tt> 类型对象，包含指向键为 <tt>e.first</tt> 的元素的 <tt>map</tt> 迭代器，以及一个 <tt>bool</tt> 类型的对象，表示是否插入了该元素</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>m.insert(beg, end)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>beg</tt> and <tt>end</tt> are iterators that denote a range of values that are keyvalue <tt>pair</tt>s with the same type as <tt>m</tt>'s <tt>value_type</tt>. For each element in the range, if the given key is not already in <tt>m</tt>, it inserts the key and its associated value into <tt>m</tt>. Returns <tt>void</tt>.</p>
              <p class="docText"><tt>beg</tt> 和 <tt>end</tt> 是标记元素范围的迭代器，其中的元素必须为 <tt>m.value_type</tt> 类型的键－值对。对于该范围内的所有元素，如果它的键在 <tt>m</tt> 中不存在，则将该键及其关联的值插入到 <tt>m</tt>。返回 <tt>void</tt> 类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>m.insert(iter, e)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>e is</tt> a value of the <tt>value_type</tt> for <tt>m</tt>. If the key(<tt>e.first)</tt> is not in <tt>m</tt>, inserts the new element using the iterator <tt>iter</tt> as a hint for where to begin the search for where the new element should be stored. Returns an iterator that refers to the element in <tt>m</tt> with given key.</p>
              <p class="docText"><tt>e</tt> 是一个用在 <tt>m</tt> 上的 <tt>value_type</tt> 类型的值。如果键（<tt>e.first</tt>）不在 <tt>m</tt> 中，则创建新元素，并以迭代器 <tt>iter</tt> 为起点搜索新元素存储的位置。返回一个迭代器，指向 <tt>m</tt> 中具有给定键的元素</p>
            </td>
          </tr>
        </table><br>

	<a name="ch10lev3sec6"></a>
        <h5 class="docSection3Title">Using <tt>insert</tt> Instead of Subscripting</h5>
        <h5 class="docSection3Title">以 <tt>insert</tt> 代替下标运算</h5>

        <p class="docText">When we use a subscript to add an element to a <tt>map</tt>, the value part of the element is value-initialized. Often we immediately assign to that value, which means that we've initialized and assigned the same object. Alternatively, we could insert the element directly by using the syntactically more intimidating <tt>insert</tt> member:</p>
        <p class="docText">使用下标给 <tt>map</tt> 容器添加新元素时，元素的值部分将采用值初始化。通常，我们会立即为其赋值，其实就是对同一个对象进行初始化并赋值。而插入元素的另一个方法是：直接使用 <tt>insert</tt> 成员，其语法更紧凑：</p>
        <pre>
     // <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">Anna</span> <span class="docEmphItalicAlt">not already in</span> <span class="docEmphasis">word_count</span>, <span class="docEmphItalicAlt">inserts new element with value</span> <span class="docEmphasis">1</span>
     word_count.insert(map&lt;string, int&gt;::value_type("Anna", 1));
</pre><br>

        <p class="docText">The argument to this version of <tt>insert</tt></p>
        <p class="docText">这个 <tt>insert</tt> 函数版本的实参：</p>
        <pre>
     map&lt;string, int&gt;::value_type(anna, 1)
</pre><br>

        <p class="docText">is a newly created <tt>pair</tt> that is directly inserted into the <tt>map</tt>. Remember that <tt>value_type</tt> is a synonym for the type <tt>pair&lt;const K, V&gt;</tt>, where <tt>K</tt> is the key type and <tt>V</tt> is the type of the associated value. The argument to <tt>insert</tt> constructs a new object of the appropriate <tt>pair</tt> type to insert into the <tt>map</tt>. By using <tt>insert</tt>, we can avoid the extraneous initialization of the value that happens when we insert a new <tt>map</tt> element as a side-effect of using a subscript.</p>
        <p class="docText">是一个新创建的 <tt>pair</tt> 对象，将直接插入到 <tt>map</tt> 容器中。谨记 <tt>value_type</tt> 是 <tt>pair&lt;const K, V&gt;</tt> 类型的同义词，<tt>K</tt> 为键类型，而 <tt>V</tt> 是键所关联的值的类型。<tt>insert</tt> 的实参创建了一个适当的 <tt>pair</tt> 类型新对象，该对象将插入到 <tt>map</tt> 容器。在添加新 <tt>map</tt> 元素时，使用 <tt>insert</tt> 成员可避免使用下标操作符所带来的副作用：不必要的初始化。</p>

        <p class="docText">The argument to <tt>insert</tt> is fairly unwieldy. There are two ways to simplify it. We might use <tt>make_pair:</tt></p>
        <p class="docText">传递给 <tt>insert</tt> 的实参相当笨拙。可用两种方法简化：使用 <tt>make_pair:</tt></p>
        <pre>
     word_count.insert(make_pair("Anna", 1));
</pre><br>

        <p class="docText">Or use a typedef:</p>
	<p class="docText">或使用 <tt>typedef</tt></p>
        <pre>
     typedef map&lt;string,int&gt;::value_type valType;
     word_count.insert(valType("Anna", 1));
</pre><br>

        <p class="docText">Either approach improves readability by making the call less complicated.</p>
	<p class="docText">这两种方法都使用调用变得简单，提高了程序的可读性。</p>
	
	<a name="ch10lev3sec7"></a>
        <h5 class="docSection3Title">Testing the Return from <tt>insert</tt></h5>
        <h5 class="docSection3Title">检测 <tt>insert</tt> 的返回值</h5>

        <p class="docText">There can be only one element with a given key in a <tt>map</tt>. If we attempt to <tt>insert</tt> an element with a key that is already in the <tt>map</tt>, then <tt>insert</tt> does nothing. The versions of <tt>insert</tt> that take an iterator or iterator pair do not indicate whether or how many elements were inserted.</p>
        <p class="docText"><tt>map</tt> 对象中一个给定键只对应一个元素。如果试图插入的元素所对应的键已在容器中，则 <tt>insert</tt> 将不做任何操作。含有一个或一对迭代器形参的 <tt>insert</tt> 函数版本并不说明是否有或有多少个元素插入到容器中。</p>

        <p class="docText">However, the version of <tt>insert</tt> that takes a single keyvalue <tt>pair</tt> does return a value. That value is a <tt>pair</tt> that contains an iterator that refers to the element in the <tt>map</tt> with the corresponding key, and a <tt>bool</tt> that indicates whether the element was inserted. If the key is already in the <tt>map</tt>, then the value is unchanged, and the <tt>bool</tt> portion of the return is <tt>false</tt>. If the key isn't present, then the element is inserted and the <tt>bool</tt> is <tt>TRue</tt>. In either case, the iterator refers to the element with the given key. We could rewrite our word count program to use <tt>insert</tt>:</p>
        <p class="docText">但是，带有一个键－值 <tt>pair</tt> 形参的 <tt>insert</tt> 版本将返回一个值：包含一个迭代器和一个 <tt>bool</tt> 值的 <tt>pair</tt> 对象，其中迭代器指向 <tt>map</tt> 中具有相应键的元素，而 <tt>bool</tt> 值则表示是否插入了该元素。如果该键已在容器中，则其关联的值保持不变，返回的 <tt>bool</tt> 值为 <tt>true</tt>。在这两种情况下，迭代器都将指向具有给定键的元素。下面是使用 <tt>insert</tt> 重写的单词统计程序：</p>
        <pre>
     // <span class="docEmphItalicAlt">count number of times each word occurs in the input</span>
     map&lt;string, int&gt; word_count; // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">from string to</span> <span class="docEmphasis">int</span>
     string word;
     while (cin &gt;&gt; word) {
         // <span class="docEmphItalicAlt">inserts element with key equal to</span> <span class="docEmphasis">word</span> <span class="docEmphItalicAlt">and value</span> 1;
         // <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">word</span> <span class="docEmphItalicAlt">already in</span> <span class="docEmphasis">word_count</span>, <span class="docEmphItalicAlt">insert</span> <span class="docEmphItalicAlt">does nothing</span>
         pair&lt;map&lt;string, int&gt;::iterator, bool&gt; ret =
                   word_count.insert(make_pair(word, 1));
         if (!ret.second)          // <span class="docEmphasis">word</span> <span class="docEmphItalicAlt">already in</span> <span class="docEmphasis">word_count</span>
             ++ret.first-&gt;second;  // <span class="docEmphItalicAlt">increment counter</span>
     }
</pre><br>

        <p class="docText">For each <tt>word</tt>, we attempt to <tt>insert</tt> it with a value 1. The <tt>if</tt> test examines the <tt>bool</tt> in the return from the <tt>insert</tt>. If it is <tt>false</tt>, then the insertion didn't happen and an element indexed by <tt>word</tt> was already in <tt>word_count</tt>. In this case we increment the value associated with that element.</p>
	<p class="docText">对于每个单词，都尝试 <tt>insert</tt> 它，并将它的值赋 1。<tt>if</tt> 语句检测 <tt>insert</tt> 函数返回值中的 <tt>bool</tt> 值。如果该值为 <tt>false</tt>，则表示没有做插入操作，按 <tt>word</tt> 索引的元素已在 <tt>word_count</tt> 中存在。此时，将该元素所关联的值加 1。</p>
	
	<a name="ch10lev3sec8"></a>
        <h5 class="docSection3Title">Unwinding the Syntax</h5>
        <h5 class="docSection3Title">语法展开</h5>

        <p class="docText">The definition of <tt>ret</tt> and the increment may be hard to decipher:</p>
        <p class="docText"><tt>ret</tt> 的定义和自增运算可能比较难解释：</p>
        <pre>
     pair&lt;map&lt;string, int&gt;::iterator, bool&gt; ret =
             word_count.insert(make_pair(word, 1));
</pre><br>

        <p class="docText">It should be easy to see that we're defining a <tt>pair</tt> and that the second type of the <tt>pair</tt> is <tt>bool</tt>. The first type of that <tt>pair</tt> is a bit harder to understand. It is the <tt>iterator</tt> type defined by the <tt>map&lt;string, int&gt;</tt> type.</p>
	<p class="docText">首先，应该很容易看出我们定义的是一个 <tt>pair</tt> 对象，它的 <tt>second</tt> 成员为 <tt>bool</tt> 类型。而它的 <tt>first</tt> 成员则比较难理解，这是 <tt>map&lt;string, int&gt;</tt> 容器所定义的迭代器类型。</p>

        <p class="docText">We can understand the increment by first parenthesizing it to reflect the precedence (<a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14" >Section 5.10.1</a>, p. <a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14" >168</a>) of the operators:</p>
        <p class="docText">根据操作符的优先级次序（<a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14" >第 5.10.1 节</a>），可如下从添加圆括号开始理解自增操作：</p>
        <pre>
     ++((ret.first)-&gt;second); // <span class="docEmphItalicAlt">equivalent expression</span>
</pre><br>

        <p class="docText">Explaining this expression step by step, we have</p>
        <p class="docText">下面对这个表达式一步步地展开解释：</p>

        <ul>
          <li>
            <p class="docList"><tt>ret</tt> holds return value from <tt>insert</tt>, which is a <tt>pair</tt>. The <tt>first</tt> member of that <tt>pair</tt> is a <tt>map</tt> iterator referring to the key that was inserted.</p>
            <p class="docList"><tt>ret</tt> 存储 <tt>insert</tt> 函数返回的 <tt>pair</tt> 对象。该 <tt>pair</tt> 的 <tt>first</tt> 成员是一个 <tt>map</tt> 迭代器，指向插入的键。</p>
          </li>

          <li>
            <p class="docList"><tt>ret.first</tt> fetches the <tt>map</tt> iterator from the <tt>pair</tt> returned by <tt>insert</tt>.</p>
            <p class="docList"><tt>ret.first</tt> 从 <tt>insert</tt> 返回的 <tt>pair</tt> 对象中获取 <tt>map</tt> 迭代器。</p>
          </li>

          <li>
            <p class="docList"><tt>ret.first-&gt;second</tt> dereferences that iterator obtaining a <tt>value_type</tt> object. That object is also a <tt>pair</tt>, in which the <tt>second</tt> member is the value part of the element we added.</p>
            <p class="docList"><tt>ret.first-&gt;second</tt> 对该迭代器进行解引用，获得一个 <tt>value_type</tt> 类型的对象。这个对象同样是 <tt>pair</tt> 类型的，它的 <tt>second</tt> 成员即为我们所添加的元素的值部分。</p>
          </li>

          <li>
            <p class="docList"><tt>++ret.first-&gt;second</tt> increments that value.</p>
            <p class="docList"><tt>++ret.first-&gt;second</tt> 实现该值的自增运算。</p>
          </li>
        </ul>

        <p class="docText">Putting it back together, the increment statement fetches the iterator for the element indexed by <tt>word</tt> and increments the value part of that element.</p>
	<p class="docText">归结起来，这个自增语句获取指向按 <tt>word</tt> 索引的元素的迭代器，并将该元素的值加 1。</p>
	
	<a name="ch10sb06"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.3.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa6q1"></a><b>Exercise 10.12:</b></td>

                    <td>
                      <p class="docText"><a name="idd1e79158"></a><a name="idd1e79165"></a>Rewrite the word-count program that you wrote in the exercises for <a class="docLink" href="ch10lev1sec3.html#ch10lev2sec8">Section 10.3.4</a> (p. <a class="docLink" href="ch10lev1sec3.html#ch10lev2sec8">364</a>) to use <tt>insert</tt> instead of subscripting. Explain which program you think is easier to write and read. Explain your reasoning.</p>
                      <p class="docText">重写<a class="docLink" href="ch10lev1sec3.html#ch10lev2sec8">第 10.3.4 节</a>习题的单词统计程序，要求使用 <tt>insert</tt> 函数代替下标运算。你认为哪个程序更容易编写和阅读？请解释原因。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa6q2"></a><b>Exercise 10.13:</b></td>

                    <td>
                      <p class="docText">Given a <tt>map&lt;string, vector&lt;int&gt; &gt;</tt>, write the types used as an argument and as the return value for the version of <tt>insert</tt> that inserts one element.</p>
                      <p class="docText">假设有 <tt>map&lt;string, vector&lt;int&gt; &gt;</tt> 类型，指出在该容器中插入一个元素的 <tt>insert</tt> 函数应具有的参数类型和返回值类型。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch10lev2sec10"></a>

        <h4 class="docSection2Title">10.3.6. Finding and Retrieving a <tt>map</tt> Element</h4>
        <h4 class="docSection2Title">10.3.6. 查找并读取 <tt>map</tt> 中的元素</h4>

        <p class="docText">The subscript operator provides the simplest method of retrieving a value:</p>
        <p class="docText">下标操作符给出了读取一个值的最简单方法：</p>
        <pre>
     map&lt;string,int&gt; word_count;
     int occurs = word_count["foobar"];
</pre><br>

        <p class="docText">As we've seen, using a subscript has an important side effect: If that key is not already in the <tt>map</tt>, then subscript inserts an element with that key.</p>
        <p class="docText">但是，使用下标存在一个很危险的副作用：如果该键不在 <tt>map</tt> 容器中，那么下标操作会插入一个具有该键的新元素。</p>

        <p class="docText">Whether this behavior is correct depends on our expectations. In this example, if "foobar" weren't already present, it would be added to the <tt>map</tt> with an associated value of 0. In this case, <tt>occurs</tt> gets a value of 0.</p>
        <p class="docText">这样的行为是否正确取决于程序员的意愿。在这个例子中，如果“foobar”不存在，则在 <tt>map</tt> 中插入具有该键的新元素，其关联的值为 0。在这种情况下，<tt>occurs</tt> 获得 0 值。</p>

        <p class="docText">Our word-counting programs relied on the fact that subscripting a nonexistent element inserts that element and initializes the value to 0. There are times, though, when we want to know if an element is present but do not want the element inserted if it is not present. In such cases, we cannot use the subscript operator to determine whether the element is present.</p>
        <p class="docText">我们的单词统计程序的确是要通过下标引用一个不存在的元素来实现新元素的插入，并将其关联的值初始化为 0。然而，大多数情况下，我们只想知道某元素是否存在，而当该元素不存在时，并不想做做插入运算。对于这种应用，则不能使用下标操作符来判断元素是否存在。</p>

        <p class="docText">There are two operations, <tt>count</tt> and <tt>find</tt>, that we can use to determine if a key is present without causing it to be inserted.</p>
	<p class="docText"><tt>map</tt> 容器提供了两个操作：<tt>count</tt> 和 <tt>find</tt>，用于检查某个键是否存在而不会插入该键。</p>
	
	<a name="ch10table06"></a>
        <h5 class="docTableTitle">Table 10.6. Interrogating a <tt>map</tt> Without Changing It</h5>
        <h5 class="docTableTitle">表 10.6. 不修改 <tt>map</tt> 对象的查询操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>m.count(k)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns the number of occurrences of <tt>k</tt> within <tt>m</tt>.</p>
              <p class="docText">返回 <tt>m</tt> 中 <tt>k</tt> 的出现次数</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>m.find(k)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns an iterator to the element indexed by <tt>k</tt>, if there is one, or returns an off-the-end iterator (<a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4" >Section 3.4</a>, p. <a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4" >97</a>) if the key is not present.</p>
              <p class="docText">如果 m 容器中存在按 <tt>k</tt> 索引的元素，则返回指向该元素的迭代器。如果不存在，则返回超出末端迭代器（<a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4" >第 3.4 节</a>）</p>
            </td>
          </tr>
        </table><br>

        <a name="ch10lev3sec9"></a>
        <h5 class="docSection3Title">Using <tt>count</tt> to Determine Whether a Key is in the <tt>map</tt></h5>
        <h5 class="docSection3Title">使用 <tt>count</tt> 检查 <tt>map</tt> 对象中某键是否存在</h5>

        <p class="docText">The <tt>count</tt> member for a <tt>map</tt> always returns either 0 or 1. A <tt>map</tt> may have only one instance of any given key, so <tt>count</tt> effectively indicates whether the key is present. The return from <tt>count</tt> is more useful for <tt>multimaps</tt>, which we cover in <a class="docLink" href="ch10lev1sec5.html#ch10lev1sec5" >Section 10.5</a> (p. <a class="docLink" href="ch10lev1sec5.html#ch10lev1sec5" >375</a>). If the return value is nonzero, we can use the subscript operator to fetch the value associated with the key without worrying that doing so will insert the element into the <tt>map</tt>:</p>
        <p class="docText">对于 <tt>map</tt> 对象，<tt>count</tt> 成员的返回值只能是 0 或 1。<tt>map</tt> 容器只允许一个键对应一个实例，所以 <tt>count</tt> 可有效地表明一个键是否存在。而对于 <tt>multimaps</tt> 容器，<tt>count</tt> 的返回值将有更多的用途，相关内容将会在<a class="docLink" href="ch10lev1sec5.html#ch10lev1sec5" >第 10.5 节</a>中介绍。如果返回值非 0，则可以使用下标操作符来获取该键所关联的值，而不必担心这样做会在 <tt>map</tt> 中插入新元素：</p>
        <pre>
     int occurs = 0;
     if (word_count.count("foobar"))
         occurs = word_count["foobar"];
</pre><br>

	<a name="idd1e79358"></a><a name="idd1e79365"></a><a name="idd1e79372"></a><a name="idd1e79379"></a>
        <p class="docText">Of course, executing <tt>count</tt> followed by the subscript effectively looks for the element twice. If we want to use the element if it is present, we should use <tt>find</tt>.</p>
	<p class="docText">当然，在执行 <tt>count</tt> 后再使用下标操作符，实际上是对元素作了两次查找。如果希望当元素存在时就使用它，则应该用 <tt>find</tt> 操作。</p>
	
	<a name="ch10lev3sec10"></a>
        <h5 class="docSection3Title">Retrieving an Element Without Adding It</h5>
        <h5 class="docSection3Title">读取元素而不插入该元素</h5>

        <p class="docText">The <tt>find</tt> operation returns an iterator to the element or the <tt>end</tt> iterator if the element is not present:</p>
        <p class="docText"><tt>find</tt> 操作返回指向元素的迭代器，如果元素不存在，则返回 <tt>end</tt> 迭代器：</p>
        <pre>
     int occurs = 0;
     map&lt;string,int&gt;::iterator it = word_count.find("foobar");
     if (it != word_count.end())
         occurs = it-&gt;second;
</pre><br>

        <p class="docText">We should use <tt>find</tt> when we want to obtain a reference to the element with the specified key if it exists, and do not want to create the element if it does not exist.</p>
	<p class="docText">如果希望当具有指定键的元素存在时，就获取该元素的引用，否则就不在容器中创建新元素，那么应该使用 <tt>find</tt>。</p>
	
	<a name="ch10sb07"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.3.6</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa7q1"></a><b>Exercise 10.14:</b></td>

                    <td>
                      <p class="docText">What is the difference between the <tt>map</tt> operations <tt>count</tt> and <tt>find</tt>?</p>
                      <p class="docText"><tt>map</tt> 容器的 <tt>count</tt> 和 <tt>find</tt> 运算有何区别？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa7q2"></a><b>Exercise 10.15:</b></td>

                    <td>
                      <p class="docText">What kinds of problems would you use <tt>count</tt> to solve? When might you use <tt>find</tt> instead?</p>
                      <p class="docText">你认为 <tt>count</tt> 适合用于解决哪一类问题？而 <tt>find</tt> 呢？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa7q3"></a><b>Exercise 10.16:</b></td>

                    <td>
                      <p class="docText">Define and initialize a variable to hold the result of a call to <tt>find</tt> on a <tt>map</tt> from <tt>string</tt> to <tt>vector</tt> of <tt>int</tt>.</p>
		      <p class="docText">定义并初始化一个变量，用来存储调用键为 <tt>string</tt>、值为 <tt>vector&lt;int&gt;</tt> 的 <tt>map</tt> 对象的 <tt>find</tt> 函数的返回结果。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch10lev2sec11"></a>
        <h4 class="docSection2Title">10.3.7. Erasing Elements from a <tt>map</tt></h4>
        <h4 class="docSection2Title">10.3.7. 从 <tt>map</tt> 对象中删除元素</h4>

        <p class="docText">There are three variants of the <tt>erase</tt> operation to remove elements from a <tt>map</tt>. As with the sequential containers, we can <tt>erase</tt> a single element or a range of elements by passing <tt>erase</tt> an iterator or an iterator pair. These versions of <tt>erase</tt> are similar to the corresponding operations on sequential containers with one exception: The <tt>map</tt> operations return <tt>void</tt>, whereas those on the sequential containers return an iterator to the element following the one that was removed.</p>
	<p class="docText">从 <tt>map</tt> 容器中删除元素的 <tt>erase</tt> 操作有三种变化形式（表 10.7）。与顺序容器一样，可向 <tt>erase</tt> 传递一个或一对迭代器，来删除单个元素或一段范围内的元素。其删除功能类似于顺序容器，但有一点不同：<tt>map</tt> 容器的 <tt>erase</tt> 操作返回 <tt>void</tt>，而顺序容器的 <tt>erase</tt> 操作则返回一个迭代器，指向被删除元素后面的元素。</p>

        <p class="docText">The <tt>map</tt> type supplies an additional <tt>erase</tt> operation that takes a value of the <tt>key_type</tt> and removes the element with the given key if the element exists. We could use this version to remove a specific word from <tt>word_count</tt> before printing the results:</p>
	<p class="docText">除此之外，<tt>map</tt> 类型还提供了一种额外的 <tt>erase</tt> 操作，其参数是 <tt>key_type</tt> 类型的值，如果拥有该键的元素存在，则删除该元素。对于单词统计程序，可使用这个版本的 <tt>erase</tt> 函数来删除 <tt>word_count</tt> 中指定的单词，然后输出被删除的单词：</p>
        <pre>
     // <span class="docEmphItalicAlt">erase of a key returns number of elements removed</span>
     if (word_count.erase(removal_word))
          cout &lt;&lt; "ok: " &lt;&lt; removal_word &lt;&lt; " removed\n";
     else cout &lt;&lt; "oops: " &lt;&lt; removal_word &lt;&lt; " not found!\n";
</pre><br>

        <p class="docText">The <tt>erase</tt> function returns a count of how many elements were removed. In the case of a <tt>map</tt>, that number is either zero or one. If the return value is zero, then the element we wanted to erase was not in the <tt>map</tt>.</p>
	<p class="docText"><tt>erase</tt> 函数返回被删除元素的个数。对于 <tt>map</tt> 容器，该值必然是 0 或 1。如果返回 0，则表示欲删除的元素在 <tt>map</tt> 不存在。</p>
	
	<a name="ch10table07"></a>
        <h5 class="docTableTitle">Table 10.7. Removing Elements from a <tt>map</tt></h5>
        <h5 class="docTableTitle">表 10.7. 从 <tt>map</tt> 对象中删除元素</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
		<a name="idd1e79581"></a><a name="idd1e79587"></a><a name="idd1e79594"></a><a name="idd1e79601"></a><a name="idd1e79608"></a><a name="idd1e79615"></a>
		<p class="docText"><tt>m.erase(k)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes the element with key <tt>k</tt> from <tt>m</tt>. Returns <tt>size_type</tt> indicating the number of elements removed.</p>
              <p class="docText">删除 m 中键为 <tt>k</tt> 的元素。返回 <tt>size_type</tt> 类型的值，表示删除的元素个数</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>m.erase(p)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes element referred to by the iterator <tt>p</tt> from <tt>m</tt>. <tt>p</tt> must refer to an actual element in <tt>m</tt>; it must not be equal to <tt>m.end()</tt>. Returns <tt>void</tt>.</p>
              <p class="docText">从 m 中删除迭代器 <tt>p</tt> 所指向的元素。<tt>p</tt> 必须指向 <tt>m</tt> 中确实存在的元素，而且不能等于 <tt>m.end()</tt>。返回 <tt>void</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>m.erase(b, e)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes the elements in the range denoted by the iterator pair <tt>b, e</tt>. <tt>b</tt> and <tt>e</tt> must be a valid range of elements in <tt>m</tt>: <tt>b</tt> and <tt>e</tt> must refer to elements in <tt>m</tt> or one past the last element in <tt>m</tt>. <tt>b</tt> and <tt>e</tt> must either be equalin which case the range is emptyor the element to which <tt>b</tt> refers must occur before the element referred to by <tt>e</tt>. Returns <tt>void</tt>.</p>
	      <p class="docText">从 m 中删除一段范围内的元素，该范围由迭代器对 <tt>b</tt> 和 <tt>e</tt> 标记。<tt>b</tt> 和 <tt>e</tt> 必须标记 <tt>m</tt> 中的一段有效范围：即 <tt>b</tt> 和 <tt>e</tt> 都必须指向 <tt>m</tt> 中的元素或最后一个元素的下一个位置。而且，<tt>b</tt> 和 <tt>e</tt> 要么相等（此时删除的范围为空），要么 <tt>b</tt> 所指向的元素必须出现在 <tt>e</tt> 所指向的元素之前。返回 <tt>void</tt> 类型</p>
            </td>
          </tr>
        </table><br>

        <a name="ch10lev2sec12"></a>
        <h4 class="docSection2Title">10.3.8. Iterating across a <tt>map</tt></h4>
        <h4 class="docSection2Title">10.3.8. <tt>map</tt> 对象的迭代遍历</h4>

        <p class="docText">Like any other container, <tt>map</tt> provides <tt>begin</tt> and <tt>end</tt> operations that yield iterators that we can use to traverse the <tt>map</tt>. For example, we could print the <tt>map</tt> named <tt>word_count</tt> that we built on page <a class="docLink" href="ch10lev1sec3.html#ch10note05">363</a> as follows:</p>
        <p class="docText">与其他容器一样，<tt>map</tt> 同样提供 <tt>begin</tt> 和 <tt>end</tt> 运算，以生成用于遍历整个容器的迭代器。例如，可如下将 <tt>map</tt> 容器 <tt>word_count</tt> 的内容输出：</p>
        <pre>
     // <span class="docEmphItalicAlt">get iterator positioned on the first element</span>
     map&lt;string, int&gt;::const_iterator
                             map_it = word_count.begin();
     // <span class="docEmphItalicAlt">for each element in the</span> <span class="docEmphasis">map</span>
     while (map_it != word_count.end()) {
         // <span class="docEmphItalicAlt">print the element key, value pairs</span>
         cout &lt;&lt; map_it-&gt;first &lt;&lt; " occurs "
              &lt;&lt; map_it-&gt;second &lt;&lt; " times" &lt;&lt; endl;
         ++map_it; // <span class="docEmphItalicAlt">increment iterator to denote the next element</span>
     }
</pre><br>

        <p class="docText">The <tt>while</tt> condition and increment for the iterator in this loop look a lot like the programs we wrote that printed the contents of a <tt>vector</tt> or a <tt>string</tt>. We initialize an iterator, <tt>map_it</tt>, to refer to the first element in <tt>word_count</tt>. As long as the iterator is not equal to the <tt>end</tt> value, we print the current element and then increment the iterator. The body of the loop is more complicated than those earlier programs because we must print both the key and value for each element.</p>
	<p class="docText"><tt>while</tt> 循环的条件判断以及循环体中迭代器的自增都与输出 <tt>vector</tt> 或 <tt>string</tt> 容器内容的程序非常相像。首先，初始化 <tt>map_it</tt> 迭代器，使之指向 <tt>word_count</tt> 的第一元素。只要该迭代器不等于 <tt>end</tt> 的值，就输出当前元素并给迭代器加 1。这段程序的循环体要比前面类似的程序更加复杂，原因在于对于 <tt>map</tt> 的每个元素都必须分别输出它的键和值。</p>
	
	<a name="ch10note07"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The output of our word-count program prints the words in alphabetical order. When we use an iterator to traverse a <tt>map</tt>, the iterators yield elements in ascending key order.</p>
                <p class="docText">这个单词统计程序依据字典顺序输出单词。在使用迭代器遍历 <tt>map</tt> 容器时，迭代器指向的元素按键的升序排列。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch10lev2sec13"></a>

        <h4 class="docSection2Title">10.3.9. A Word Transformation Map</h4>
	<h4 class="docSection2Title">10.3.9. “单词转换” <tt>map</tt> 对象</h4>

        <p class="docText">We'll close this section with a program to illustrate creating, searching, and iterating across a <tt>map</tt>. Our problem is to write a program that, given one <tt>string</tt>, transforms it into another. The input to our program is two files. The first file contains several word pairs. The first word in the pair is one that might be in the input <a name="idd1e79823"></a><a name="idd1e79829"></a><a name="idd1e79834"></a><a name="idd1e79839"></a><a name="idd1e79842"></a><a name="idd1e79849"></a>string. The second is the word to use in the output. Essentially, this file provides a set of word transformationswhen we find the first word, we should replace it by the second. The second file contains the text to transform. If the contents of the word transformation file is</p>
	<p class="docText">下面的程序说明如何创建、查找和迭代遍历一个 <tt>map</tt> 对象，我们将以此结束本节内容。这个程序求解的问题是：给出一个 <tt>string</tt> 对象，把它转换为另一个 <tt>string</tt> 对象。本程序的输入是两个文件。第一个文件包括了若干单词对，每对的第一个单词将出现在输入的字符串中，而第二个单词则是用于输出。本质上，这个文件提供的是单词转换的集合——在遇到第一个单词时，应该将之替换为第二个单词。第二个文件则提供了需要转换的文本。如果单词转换文件的内容是：</p>

        <table cellspacing="0" frame="void" rules="none" cellpadding="5">
          <colgroup>
            <col width="200">
            <col width="300">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>'em</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>them</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>cuz</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>because</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>gratz</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>grateful</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>i</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>I</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>nah</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>no</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>pos</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>supposed</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>sez</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>said</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>tanx</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>thanks</tt></span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>wuz</tt></span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphStrong"><tt>was</tt></span></p>
            </td>
          </tr>
        </table><br>

        <p class="docText">and the text we are given to transform is</p>
        <p class="docText">而要转换的文本是：</p>
        <pre>
     <span class="docEmphStrong">nah i sez tanx cuz i wuz pos to</span>
     <span class="docEmphStrong">not cuz i wuz gratz</span>
</pre><br>

        <p class="docText">then the program should generate the following output:</p>
        <p class="docText">则程序将产生如下输出结果：</p>
        <pre>
     <span class="docEmphStrong">no I said thanks because I was supposed to</span>
     <span class="docEmphStrong">not because I was grateful</span>
</pre><br>

        <a name="ch10lev3sec11"></a>
        <h5 class="docSection3Title">The Word Transformation Program</h5>
        <h5 class="docSection3Title">单词转换程序</h5>

        <p class="docText">Our solution, which appears on the next page, stores the word transformation file in a <tt>map</tt>, using the word to be replaced as the key and the word to use as the replacement as its corresponding value. We then read the input, looking up each word to see if it has a transformation. If so, we do the transformation and then print the transformed word. If not, we print the original word.</p>
        <p class="docText">下面给出的解决方案是将单词转换文件的内容存储在一个 <tt>map</tt> 容器中，将被替换的单词作为键，而用作替换的单词则作为其相应的值。接着读取输入，查找输入的每个单词是否对应有转换。若有，则实现转换，然后输出其转换后的单词，否则，直接输出原词。</p>

        <p class="docText">Our <tt>main</tt> program takes two arguments (<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec11" >Section 7.2.6</a>, p. <a class="docLink" href="ch07lev1sec2.html#ch07lev2sec11" >243</a>): the name of the word transformation file and the name of the file to transform. We start by checking the number of arguments. The first argument, <tt>argv[0]</tt>, is always the name of the command. The file names will be in <tt>argv[1]</tt> and <tt>argv[2]</tt>.</p>
        <p class="docText">该程序的 <tt>main</tt> 函数需要两个实参（<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec11" >第 7.2.6 节</a>）：单词转换文件的名字以及需要转换的文件名。程序执行时，首先检查实参的个数。第一个实参 <tt>argv[0]</tt> 是命令名，而执行该程序所需要的两个文件名参数则分别存储在 <tt>argv[1]</tt> 及 <tt>argv[2]</tt> 中。</p>

        <p class="docText">Once we know that <tt>argv[1]</tt> is valid, we call <tt>open_file</tt> (<a class="docLink" href="ch08lev1sec4.html#ch08lev2sec12" >Section 8.4.3</a>, p. <a class="docLink" href="ch08lev1sec4.html#ch08lev2sec12" >299</a>) to <tt>open</tt> the word transformation file. Assuming the <tt>open</tt> succeeded, we read the transformation pairs. We call <tt>insert</tt> using the first word as the key and the second as the value. When the <tt>while</tt> concludes, <tt>trans_map</tt> contains the data we need to transform the input. If there's a problem with the arguments, we <tt>throw</tt> (<a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13" >Section 6.13</a>, p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13" >215</a>) an exception and exit the program.</p>
        <p class="docText">如果 <tt>argv[1]</tt> 的值合法，则调用 <tt>open_file</tt>（<a class="docLink" href="ch08lev1sec4.html#ch08lev2sec12" >第 8.4.3 节</a>）打开单词转换文件。假设 <tt>open</tt> 操作成功，则读入“单词转换对”。以“转换对”中的第一个单词为键，第二个为值，调用 <tt>insert</tt> 函数在容器中插入新元素。<tt>while</tt> 循环结束后，<tt>trans_map</tt> 容器对象包含了转换输入文本所需的数据。而如果该实参有问题，则抛出异常（<a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13" >第 6.13 节</a>）并结束程序的运行。</p>

        <p class="docText">Next, we call <tt>open_file</tt> to open the file we want to transform. The second <tt>while</tt> uses <tt>getline</tt> to read that file a line at a time. We read by line so that our output will have line breaks at the same position as our input file. To get the words from each line we use a nested <tt>while</tt> loop that uses an <tt>istringstream</tt>. This part of the program is similar to the sketch we wrote on page <a class="docLink" href="ch08lev1sec5.html#ch08lev2sec13" >300</a>.</p>
        <p class="docText">接下来，调用 <tt>open_file</tt> 打开要转换的文件。第二个 <tt>while</tt> 循环使用 <tt>getline</tt> 函数逐行读入文件。因为程序每次读入一行，从而可在输出文件的相同位置进行换行。然后在内嵌的 <tt>while</tt> 循环中使用 <tt>istringstream</tt> 将每一行中的单词提取出来。这部分程序与<a class="docLink" href="ch08lev1sec5.html#ch08lev2sec13" >第 8.5 节</a>的程序框架类似。</p>

        <p class="docText">The inner <tt>while</tt> checks each word to see if it is in the transformation map. If it is, then we replace the word by its corresponding value from the <tt>map</tt>. Finally, we print the word, transformed or not. We use the <tt>bool firstword</tt> to determine whether to print a space. If it is the first word in the line, we don't print a space.</p>
	<p class="docText">内层的 <tt>while</tt> 循环检查每个单词，判断它是否在转换的 <tt>map</tt> 中出现。如果在，则从该 <tt>map</tt> 对象中取出对应的值替代此单词。最后，无论是否做了转换，都输出该单词。同时，程序使用 <tt>bool</tt> 值 <tt>firstword</tt> 判断是否需要输出空格。如果当前处理的是这一行的第一个单词，则无须输出空格。</p>
        <pre>
    /*
     * <span class="docEmphItalicAlt">A program to transform words.</span>
     * <span class="docEmphItalicAlt">Takes two arguments: The first is name of the word transformation file</span>
     *                      <span class="docEmphItalicAlt">The second is name of the input to transform</span>
     */
    int main(int argc, char **argv)
    {
        // <span class="docEmphasis">map</span> <span class="docEmphItalicAlt">to hold the word transformation pairs:</span>
        // <span class="docEmphasis">key</span> <span class="docEmphItalicAlt">is the word to look for in the input;</span> value <span class="docEmphasis">is word to use in the output</span>
        map&lt;string, string&gt; trans_map;
        string key, value;
        if (argc != 3)
            throw runtime_error("wrong number of arguments");
        // <span class="docEmphItalicAlt">open transformation file and check that open succeeded</span>
        ifstream map_file;
        if (!open_file(map_file, argv[1]))
            throw runtime_error("no transformation file");
        // <span class="docEmphItalicAlt">read the transformation map and build the map</span>
         while (map_file &gt;&gt; key &gt;&gt; value)
             trans_map.insert(make_pair(key, value));
        // <span class="docEmphItalicAlt">ok, now we're ready to do the transformations</span>
        // <span class="docEmphItalicAlt">open the input file and check that the open succeeded</span>
        ifstream input;
        if (!open_file(input, argv[2]))
            throw runtime_error("no input file");
        string line;    // <span class="docEmphItalicAlt">hold each line from the input</span>
        // <span class="docEmphItalicAlt">read the text to transform it a line at a time</span>
        while (getline(input, line)) {
            istringstream stream(line);   // <span class="docEmphItalicAlt">read the line a word at a time</span>
            string word;
            bool firstword = true;   // <span class="docEmphItalicAlt">controls whether a space is printed</span>
            while (stream &gt;&gt; word) {
               // <span class="docEmphItalicAlt">ok: the actual mapwork, this part is the heart of the program</span>
               map&lt;string, string&gt;::const_iterator map_it =
                                  trans_map.find(word);
               // <span class="docEmphItalicAlt">if this word is in the transformation map</span>
               if (map_it != trans_map.end())
                   // <span class="docEmphItalicAlt">replace it by the transformation value in the map</span>
                   word = map_it-&gt;second;
               if (firstword)
                   firstword = false;
               else
                   cout &lt;&lt; " ";  // <span class="docEmphItalicAlt">print space between words</span>
               cout &lt;&lt; word;
            }
            cout &lt;&lt; endl;        // <span class="docEmphItalicAlt">done with this line of input</span>
    }
    return 0;
 }
</pre><br>
        <a name="ch10sb08"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.3.9</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa8q1"></a><b>Exercise 10.17:</b></td>

                    <td>
			<a name="idd1e80223"></a><a name="idd1e80230"></a><a name="idd1e80237"></a><a name="idd1e80244"></a><a name="idd1e80251"></a><a name="idd1e80258"></a><a name="idd1e80265"></a><a name="idd1e80271"></a><a name="idd1e80278"></a><a name="idd1e80286"></a><a name="idd1e80293"></a><a name="idd1e80299"></a><a name="idd1e80306"></a><a name="idd1e80313"></a><a name="idd1e80320"></a><a name="idd1e80327"></a><a name="idd1e80334"></a>
			<p class="docText">Our transformation program uses <tt>find</tt> to look for each word:</p>
			<p class="docText">上述转换程序使用了 <tt>find</tt> 函数来查找单词：</p>
                      <pre>
     map&lt;string, string&gt;::const_iterator map_it =
              trans_map.find(word);
</pre><br>

                      <p class="docText">Why do you suppose the program uses <tt>find</tt>? What would happen if it used the subscript operator instead?</p>
                      <p class="docText">你认为这个程序为什么要使用 <tt>find</tt> 函数？如果使用下标操作符又会怎么样？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa8q2"></a><b>Exercise 10.18:</b></td>

                    <td>
                      <p class="docText">Define a <tt>map</tt> for which the key is the family surname and the value is a <tt>vector</tt> of the children's names. Populate the <tt>map</tt> with at least six entries. Test it by supporting user queries based on a surname, which should list the names of children in that family.</p>
                      <p class="docText">定义一个 <tt>map</tt> 对象，其元素的键是家庭姓氏，而值则是存储该家庭孩子名字的 <tt>vector</tt> 对象。为这个 <tt>map</tt> 容器输入至少六个条目。通过基于家庭姓氏的查询检测你的程序，查询应输出该家庭所有孩子的名字。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa8q3"></a><b>Exercise 10.19:</b></td>

                    <td>
                      <p class="docText">Extend the <tt>map</tt> from the previous exercise by having the <tt>vector</tt> store a <tt>pair</tt> that holds a child's name and birthday. Revise the program accordingly. Test your modified test program to verify its correctness.</p>
		      <p class="docText">把上一题的 <tt>map</tt> 对象再扩展一下，使其 <tt>vector</tt> 对象存储 <tt>pair</tt> 类型的对象，记录每个孩子的名字和生日。相应地修改程序，测试修改后测试程序以检查所编写的 <tt>map</tt> 是否正确。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa8q4"></a><b>Exercise 10.20:</b></td>

                    <td>
                      <p class="docText">List at least three possible applications in which the <tt>map</tt> type might be of use. Write the definition of each <tt>map</tt> and indicate how the elements are likely to be inserted and retrieved.</p>
                      <p class="docText">列出至少三种可以使用 <tt>map</tt> 类型的应用。为每种应用定义 <tt>map</tt> 对象，并指出如何插入和读取元素。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch10lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch10lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
