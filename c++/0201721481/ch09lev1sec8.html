<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Chapter Summary</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch09lev1sec7.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch09lev1sec9.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch09lev1sec8"></a>

        <h3 class="docSection1Title">Chapter Summary</h3>
        <h3 class="docSection1Title">小结</h3>

	<a name="idd1e75452"></a><a name="idd1e75455"></a><a name="idd1e75459"></a><a name="idd1e75462"></a><a name="idd1e75466"></a><a name="idd1e75470"></a><a name="idd1e75473"></a>
        <p class="docText">The C++ library defines a number of sequential container types. A container is a template type that holds objects of a given type. In a sequential container, elements are ordered and accessed by position. The sequential containers share a common, standardized interface: If two sequential containers offer a particular operation, then the operation has the same interface and meaning for both containers. All the containers provide (efficient) dynamic memory management. We may add elements to the container without worrying about where to store the elements. The container itself manages its storage.</p>
        <p class="docText">C++ 标准库定义了一系列顺序容器类型。容器是用于存储某种给定类型对象的模板类型。在顺序容器中，所有元素根据其位置排列和访问。顺序容器共享一组通用的已标准化的接口：如果两种顺序容器都提供某一操作，那么该操作具有相同的接口和含义。所有容器都提供（有效的）动态内存管理。程序员在容器中添加元素时，不必操心元素存放在哪里。容器自己实现其存储管理。</p>

        <p class="docText">The most commonly used container, <tt>vector</tt>, supports fast, random access to elements. Elements can be added and removed efficiently from the end of a <tt>vector</tt>. Inserting or deleting elements elsewhere can be expensive. The <tt>deque</tt> class is like a <tt>vector</tt>, but also supports fast insertion and deletion at the front of the <tt>deque</tt>. The <tt>list</tt> class supports only sequential access to elements, but it can be quite fast to insert or remove elements anywhere within the list.</p>
	<p class="docText">最经常使用的容器类型是 <tt>vector</tt>，它支持对元素的快速随机访问。可高效地在 <tt>vector</tt> 容器尾部添加和删除元素，而在其他任何位置上的插入或删除运算则要付出比较昂贵的代价。<tt>deque</tt> 类与 <tt>vector</tt> 相似，但它还支持在 <tt>deque</tt> 首部的快速插入和删除运算。<tt>list</tt> 类只支持元素的顺序访问，但在 <tt>list</tt> 内部任何位置插入和删除元素都非常快速。</p>

        <p class="docText">The containers define surprisingly few operations. Containers define constructors, operations to add or remove elements, operations to determine the size of the container, and operations to return iterators to particular elements. Other useful operations, such as sorting or searching, are defined not by the container types but by the standard algorithms, which we shall cover in <a class="docLink" href="ch11.html#ch11" >Chapter 11</a>.</p>
        <p class="docText">容器定义的操作非常少，只定义了构造函数、添加或删除元素的操作、设置容器长度的操作以及返回指向特殊元素的迭代器的操作。其他一些有用的操作，如排序、查找，则不是由容器类型定义，而是由<a class="docLink" href="ch11.html#ch11" >第十一章</a>介绍的标准算法定义。</p>

        <p class="docText">Container operations that add or remove elements can invalidate existing iterators. When mixing actions on iterators and container operations, it is essential to keep in mind whether a given container operation could invalidate the iterators. Many operations that invalidate an iterator, such as <tt>insert</tt> or <tt>erase</tt>, return a new iterator that allows the programmer to maintain a position within the container. Loops that use container operations that change the size of a container should be particularly careful in their use of iterators.</p>
        <p class="docText">在容器中添加或删除元素可能会使已存在的迭代器失效。当混合使用迭代器操作和容器操作时，必须时刻留意给定的容器操作是否会使迭代器失效。许多使一个迭代器失效的操作，例如 <tt>insert</tt> 或 <tt>erase</tt>，将返回一个新的迭代器，让程序员保留容器中的一个位置。使用改变容器长度的容器操作的循环必须非常小心其迭代器的使用。</p>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch09lev1sec7.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch09lev1sec9.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
