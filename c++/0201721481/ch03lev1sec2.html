<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 3.2.  Library string Type</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch03lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch03lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br />

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch03lev1sec2"></a>

        <h3 class="docSection1Title">3.2. Library <tt>string</tt> Type</h3>

        <h3 class="docSection1Title">3.2. 标准库 <tt>string</tt> 类型</h3>

        <p class="docText">The <tt>string</tt> type supports variable-length character strings. The library takes care of managing the memory associated with storing the characters and provides various useful operations. The library <tt>string</tt> type is intended to be efficient enough for general use.</p>

        <p class="docText"><tt>string</tt> 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。标准库 string 类型的目的就是满足对字符串的一般应用。</p>

        <p class="docText">As with any library type, programs that use <tt>string</tt>s must first include the associated header. Our programs will be shorter if we also provide an appropriate <tt>using</tt> declaration:</p>

        <p class="docText">与其他的标准库类型一样，用户程序要使用 <tt>string</tt> 类型对象，必须包含相关头文件。如果提供了合适的 <tt>using</tt> 声明，那么编写出来的程序将会变得简短些：</p>
        <pre>
     #include &lt;string&gt;
     using std::string;
</pre>
        <a name="ch03lev2sec2"></a>

        <h4 class="docSection2Title">3.2.1. Defining and Initializing <tt>string</tt>s</h4>

        <h4 class="docSection2Title">3.2.1. <tt>string</tt> 对象的定义和初始化</h4>

        <p class="docText">The <tt>string</tt> library provides several constructors (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >Section 2.3.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >49</a>). A constructor is a special member function that defines how objects of that type can be <a name="idd1e15771"></a><a name="idd1e15779"></a><a name="idd1e15787"></a><a name="idd1e15793"></a><a name="idd1e15802"></a><a name="idd1e15811"></a><a name="idd1e15820"></a><a name="idd1e15829"></a><a name="idd1e15835"></a><a name="idd1e15841"></a><a name="idd1e15847"></a><a name="idd1e15855"></a>initialized. <a class="docLink" href="ch03lev1sec2.html#ch03table01">Table 3.1</a> on the facing page lists the most commonly used <tt>string</tt> constructors. The default constructor (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13" >Section 2.3.4</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13" >52</a>) is used "by default" when no initializer is specified.</p>

        <p class="docText"><tt>string</tt> 标准库支持几个构造函数（<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >第 2.3.3 节</a>）。构造函数是一个特殊成员函数，定义如何初始化该类型的对象。<a class="docLink" href="ch03lev1sec2.html#ch03table01">表 3.1</a> 列出了几个 <tt>string</tt> 类型常用的构造函数。当没有明确指定对象初始化式时，系统将使用默认构造函数（<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13" >第 2.3.4 节</a>）。</p><a name="ch03table01"></a>

        <h5 class="docTableTitle">Table 3.1. Ways to Initialize a <tt>string</tt></h5>

        <h5 class="docTableTitle">表 3.1. 几种初始化 <tt>string</tt> 对象的方式</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="200">
            <col width="300">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>string s1;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Default constructor; <tt>s1</tt> is the empty string</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valing="top">
              <p class="docText"> </p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">默认构造函数 <tt>s1</tt> 为空串</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>string s2(s1);</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Initialize <tt>s2</tt> as a copy of <tt>s1</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valing="top">
              <p class="docText"> </p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">将 <tt>s2</tt> 初始化为 <tt>s1</tt> 的一个副本</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>string s3("value");</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Initialize <tt>s3</tt> as a copy of the string literal</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valing="top">
              <p class="docText"> </p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">将 <tt>s3</tt> 初始化为一个字符串字面值副本</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>string s4(n, 'c');</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Initialize <tt>s4</tt> with <tt>n</tt> copies of the character <tt>'c'</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valing="top">
              <p class="docText"> </p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">将 <tt>s4</tt> 初始化为字符 <tt>'c'</tt> 的 <tt>n</tt> 个副本</p>
            </td>
          </tr>
  </table><br />
        <a name="ch03sb02"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Caution: Library <tt>string</tt> Type and String Literals</h2>

              <h2 class="docSidebarTitle">警告：标准库 <tt>string</tt> 类型和字符串字面值</h2>

              <p class="docText"><span class="docEmphStrong">For historical reasons, and for compatibility with C, character string literals are <span class="docEmphasis">not</span> the same type as the standard library <tt>string</tt> type. This fact can cause confusion and is important to keep in mind when using a string literal or the <tt>string</tt> data type.</span></p>

              <p class="docText"><span class="docEmphStrong">因为历史原因以及为了与 C 语言兼容，字符串字面值与标准库 <tt>string</tt> 类型不是同一种类型。这一点很容易引起混乱，编程时一定要注意区分字符串字面值和 <tt>string</tt> 数据类型的使用，这很重要。</span></p>
            </td>
          </tr>
  </table><br />
        <a name="ch03sb03"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 3.2.1</h2>

              <blockquote>
                <a name="ch03qa2q1"></a>

                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><b>Exercise 3.2:</b></td>

                    <td>
                      <p class="docText">What is a default constructor?</p>

                      <p class="docText">什么是默认构造函数？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa2q2"></a><b>Exercise 3.3:</b></td>

                    <td>
                      <p class="docText">Name the three ways to initialize a <tt>string</tt>.</p>

                      <p class="docText">列举出三种初始化 <tt>string</tt> 对象的方法。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa2q3"></a><b>Exercise 3.4:</b></td>

                    <td>
                      <p class="docText">What are the values of <tt>s</tt> and <tt>s2</tt>?</p>

                      <p class="docText"><tt>s</tt> 和 <tt>s2</tt> 的值分别是什么？</p>
                      <pre>
     string s;
     int main() {
      string s2;
     }
</pre>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
  </table><br />
        <a name="ch03lev2sec3"></a>

        <h4 class="docSection2Title">3.2.2. Reading and Writing <tt>string</tt>s</h4>

        <h4 class="docSection2Title">3.2.2. <tt>string</tt> 对象的读写</h4>

        <p class="docText">我们已在<a class="docLink" href="ch01.html#ch01" >第一章</a>学习了用 <tt>iostream</tt> 标准库来读写内置类型的值，如 <tt>int</tt> <tt>double</tt> 等。同样地，也可以用 <tt>iostream</tt> 和 <tt>string</tt> 标准库，使用标准输入输出操作符来读写 <tt>string</tt> 对象：</p>
        <pre>
     // <span class="docEmphItalicAlt">Note:</span> <span class="docEmphasis">#include</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">declarations must be added to compile this code</span>
     int main()
     {
         string s;          // <span class="docEmphItalicAlt">empty string</span>
         cin &gt;&gt; s;          // <span class="docEmphItalicAlt">read whitespace-separated string into</span> <span class="docEmphasis">s</span>
         cout &lt;&lt; s &lt;&lt; endl; // <span class="docEmphItalicAlt">write</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">to the output</span>
         return 0;
     }
</pre>

        <p class="docText">This program begins by defining a <tt>string</tt> named <tt>s</tt>. The next line,</p>

        <p class="docText">以上程序首先定义命名为 <tt>s</tt> 的 <tt>string</tt> 第二行代码：</p>
        <pre>
     cin &gt;&gt; s;        // <span class="docEmphItalicAlt">read whitespace-separated string into</span> <span class="docEmphasis">s</span>
</pre>

        <p class="docText">reads the standard input storing what is read into <tt>s</tt>. The <tt>string</tt> input operator:</p>

        <p class="docText">从标准输入读取 <tt>string</tt> 并将读入的串存储在 <tt>s</tt> 中。<tt>string</tt> 类型的输入操作符：</p>

        <ul>
          <li>
            <p class="docList">Reads and discards any leading whitespace (e.g., spaces, newlines, tabs)</p>
            <p class="docList">读取并忽略开头所有的空白字符（如空格，换行符，制表符）。</p>
          </li>

          <li>
            <p class="docList">It then reads characters until the next whitespace character is encountered</p>
            <p class="docList">读取字符直至再次遇到空白字符，读取终止。</p>
          </li>
        </ul><a name="idd1e16152"></a><a name="idd1e16159"></a><a name="idd1e16163"></a><a name="idd1e16170"></a><a name="idd1e16177"></a>

        <p class="docText">So, if the input to this program is "<span class="docEmphStrong"><tt>Hello World!</tt></span>", (note leading and trailing spaces) then the output will be "<span class="docEmphStrong"><tt>Hello</tt></span>" with no extra spaces.</p>

        <p class="docText">如果给定和上一个程序同样的输入，则输出的结果是"<span class="docEmphStrong"><tt>Hello World!</tt></span>"（注意到开头和结尾的空格），则屏幕上将输出"<span class="docEmphStrong"><tt>Hello</tt></span>"，而不含任何空格。</p>

        <p class="docText">The input and output operations behave similarly to the operators on the builtin types. In particular, the operators return their left-hand operand as their result. Thus, we can chain together multiple reads or writes:</p>

        <p class="docText">输入和输出操作的行为与内置类型操作符基本类似。尤其是，这些操作符返回左操作数作为运算结果。因此，我们可以把多个读操作或多个写操作放在一起：</p>
        <pre>
     string s1, s2;
     cin &gt;&gt; s1 &gt;&gt; s2; // <span class="docEmphItalicAlt">read first input into</span> <span class="docEmphasis">s1</span>, <span class="docEmphItalicAlt">second into</span> <span class="docEmphasis">s2</span>
     cout &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl; // <span class="docEmphItalicAlt">write both</span> <span class="docEmphasis">string</span><span class="docEmphItalicAlt">s</span>
</pre>

        <p class="docText">If we give this version of the program the same input as in the previous paragraph, our output would be</p>

        <p class="docText">如果给定和上一个程序同样的输入，则输出的结果将是：</p>
        <pre>
     <span class="docEmphStrong">HelloWorld!</span>
</pre>
        <a name="ch03note03"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">To compile this program, you must add <tt>#include</tt> directives for both the <tt>iostream</tt> and <tt>string</tt> libraries and must issue <tt>using</tt> declarations for all the names used from the library: <tt>string, cin, cout</tt>, and <tt>endl</tt>.</p>

                <p class="docText">对于上例，编译时必须加上 <tt>#include</tt> 来标示 <tt>iostream</tt> 和 <tt>string</tt> 标准库，以及给出用到的所有标准库中的名字（如 <tt>string</tt>，<tt>cin</tt>，<tt>cout</tt>，<tt>endl</tt>）的 <tt>using</tt> 声明。</p>
              </td>
            </tr>
          </table>

          <p class="docText">The programs presented from this point on will assume that the needed <tt>#include</tt> and <tt>using</tt> declarations have been made.</p>

          <p class="docText">从本例开始的程序均假设程序中所有必须 <tt>#include</tt> 和 <tt>using</tt> 声明已给出。</p>
        </div>
        <a name="ch03lev3sec2"></a>

        <h5 class="docSection3Title">Reading an Unknown Number of <tt>string</tt>s</h5>

        <h5 class="docSection3Title">读入未知数目的 <tt>string</tt> 对象</h5>

        <p class="docText">Like the input operators that read built-in types, the <tt>string</tt> input operator returns the stream from which it read. Therefore, we can use a <tt>string</tt> input operation as a condition, just as we did when reading <tt>int</tt>s in the program on page 18. The following program reads a set of <tt>string</tt>s from the standard input and writes what it has read, one <tt>string</tt> per line, to the standard output:</p>

        <p class="docText">和内置类型的输入操作一样，<tt>string</tt> 的输入操作符也会返回所读的数据流。因此，可以把输入操作作为判断条件，这与我们在 1.4.4 节读取整型数据的程序做法是一样的。下面的程序将从标准输入读取一组 <tt>string</tt> 对象，然后在标准输出上逐行输出：</p>
        <pre>
     int main()
     {
         string word;
         // <span class="docEmphItalicAlt">read until end-of-file, writing each word to a new line</span>
         while (cin &gt;&gt; word)
             cout &lt;&lt; word &lt;&lt; endl;
         return 0;
     }
</pre>

        <p class="docText">In this case, we read into a <tt>string</tt> using the input operator. That operator returns the <tt>istream</tt> from which it read, and the <tt>while</tt> condition tests the stream after the read completes. If the stream is validit hasn't hit end-of-file or encountered an invalid inputthen the body of the <tt>while</tt> is executed and the value we read is printed to the standard output. Once we hit end-of-file, we fall out of the <tt>while</tt>.</p>

        <p class="docText">上例中，用输入操作符来读取 <tt>string</tt> 对象。该操作符返回所读的 <tt>istream</tt> 对象，并在读取结束后，作为 <tt>while</tt> 的判断条件。如果输入流是有效的，即还未到达文件尾且未遇到无效输入，则执行 <tt>while</tt> 循环体，并将读取到的字符串输出到标准输出。如果到达了文件尾，则跳出 <tt>while</tt> 循环。</p><a name="ch03lev3sec3"></a>

        <h5 class="docSection3Title">Using <tt>getline</tt> to Read an Entire Line</h5>

        <h5 class="docSection3Title">使用 <tt>getline</tt> 读取整行文本</h5>

        <p class="docText">There is an additional useful <tt>string</tt> IO operation: <b><a name="ch03term8"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_08" ><span class="docEmphStrong"><tt>getline</tt></span></a></b>. This is a function that takes both an input stream and a <tt>string</tt>. The <tt>getline</tt> function reads the <a name="idd1e16348"></a><a name="idd1e16355"></a><a name="idd1e16362"></a><a name="idd1e16369"></a>next line of input from the stream and stores what it read, <span class="docEmphasis">not including</span> the newline, in its <tt>string</tt> argument. Unlike the input operator, <tt>getline</tt> does not ignore leading newlines. Whenever <tt>getline</tt> encounters a newline, even if it is the first character in the input, it stops reading the input and returns. The effect of encountering a newline as the first character in the input is that the <tt>string</tt> argument is set to the empty <tt>string</tt>.</p>

        <p class="docText">另外还有一个有用的 <tt>string</tt> IO 操作：<b><a name="ch03term8"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_08" ><span class="docEmphStrong"><tt>getline</tt></span></a></b>。这个函数接受两个参数：一个输入流对象和一个 <tt>string</tt> 对象。<tt>getline</tt><a name="idd1e16348"></a><a name="idd1e16355"></a><a name="idd1e16362"></a><a name="idd1e16369"></a> 函数从输入流的下一行读取，并保存读取的内容到<span class="docEmphasis">不包括</span>换行符。和输入操作符不一样的是，<tt>getline</tt> 并不忽略行开头的换行符。只要 <tt>getline</tt> 遇到换行符，即便它是输入的第一个字符，<tt>getline</tt> 也将停止读入并返回。如果第一个字符就是换行符，则 <tt>string</tt> 参数将被置为空 <tt>string</tt>。</p>

        <p class="docText">The <tt>getline</tt> function returns its <tt>istream</tt> argument so that, like the input operator, it can be used as a condition. For example, we could rewrite the previous program that wrote one word per line to write a line at a time instead:</p>

        <p class="docText"><tt>getline</tt> 函数将 <tt>istream</tt> 参数作为返回值，和输入操作符一样也把它用作判断条件。例如，重写前面那段程序，把每行输出一个单词改为每次输出一行文本：</p>
        <pre>
     int main()
     {
         string line;
         // <span class="docEmphItalicAlt">read line at time until end-of-file</span>
         while (getline(cin, line))
             cout &lt;&lt; line &lt;&lt; endl;
         return 0;
     }
</pre>

        <p class="docText">Because <tt>line</tt> does not contain a newline, we must write our own if we want the <tt>string</tt>s written one to a line. As usual, we use <tt>endl</tt> to write a newline and flush the output buffer.</p>

        <p class="docText">由于 <tt>line</tt> 不含换行符，若要逐行输出需要自行添加。照常，我们用 <tt>endl</tt> 来输出一个换行符并刷新输出缓冲区。</p><a name="ch03note04"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The newline that causes <tt>getline</tt> to return is discarded; it does <span class="docEmphasis">not</span> get stored in the <tt>string</tt>.</p>

                <p class="docText">由于 <tt>getline</tt> 函数返回时丢弃换行符，换行符将不会存储在 <tt>string</tt> 对象中。</p>
              </td>
            </tr>
          </table>
        </div>
        <a name="ch03sb04"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 3.2.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa3q1"></a><b>Exercise 3.5:</b></td>

                    <td>
                      <p class="docText">Write a program to read the standard input a line at a time. Modify your program to read a word at a time.</p>

                      <p class="docText">编写程序实现从标准输入每次读入一行文本。然后改写程序，每次读入一个单词。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa3q2"></a><b>Exercise 3.6:</b></td>

                    <td>
                      <p class="docText">Explain how whitespace characters are handled in the <tt>string</tt> input operator and in the <tt>getline</tt> function.</p>

                      <p class="docText">解释 <tt>string</tt> 类型的输入操作符和 <tt>getline</tt> 函数分别如何处理空白字符。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a name="ch03lev2sec4"></a>

        <h4 class="docSection2Title">3.2.3. Operations on <tt>string</tt>s</h4>

        <h4 class="docSection2Title">3.2.3. <tt>string</tt> 对象的操作</h4>

        <p class="docText"><a class="docLink" href="ch03lev1sec2.html#ch03table02">Table 3.2</a> on the next page lists the most commonly used <tt>string</tt> operations.</p>

        <p class="docText"><a class="docLink" href="ch03lev1sec2.html#ch03table02">表 3.2</a> 列出了常用的 <tt>string</tt> 操作。</p><a name="ch03table02"></a>

        <h5 class="docTableTitle">Table 3.2. <tt>string</tt> Operations</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="375">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>s.empty()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns <tt>true</tt> if <tt>s</tt> is empty; otherwise returns <tt>false</tt></p>

              <p class="docText">如果 <tt>s</tt> 为空串，则返回 <tt>true</tt>，否则返回 <tt>false</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>s.size()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns number of characters in <tt>s</tt></p>

              <p class="docText">返回 <tt>s</tt> 中字符的个数</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>s[n]</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns the character at position <tt>n</tt> in <tt>s</tt>; positions start at 0.</p>

              <p class="docText">返回 <tt>s</tt> 中位置为 <tt>n</tt> 的字符，位置从 0 开始计数</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>s1 + s2</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns a <tt>string</tt> equal to the concatenation of <tt>s1</tt> and <tt>s2</tt></p>

              <p class="docText">把 <tt>s1</tt> 和<tt>s2</tt> 连接成一个新字符串，返回新生成的字符串</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>s1 = s2</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Replaces characters in <tt>s1</tt> by a copy of <tt>s2</tt></p>

              <p class="docText">把 <tt>s1</tt> 内容替换为 <tt>s2</tt> 的副本</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>v1 == v2</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns <tt>true</tt> if <tt>v1</tt> and <tt>v2</tt> are equal; <tt>false</tt> otherwise</p>

              <p class="docText">比较 <tt>v1</tt> 与 <tt>v2</tt>的内容，相等则返回 <tt>true</tt>，否则返回 <tt>false</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>!=, &lt;, &lt;=</tt>,
              <tt>&gt;, and &gt;=</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Have their normal meanings</p>

              <p class="docText">保持这些操作符惯有的含义</p>
            </td>
          </tr>
        </table>
        <a name="ch03lev3sec4"></a>

        <h5 class="docSection3Title">The <tt>string size</tt> and <tt>empty</tt> Operations</h5>

        <h5 class="docSection3Title"><tt>string</tt> 的 <tt>size</tt> 和 <tt>empty</tt> 操作</h5>

        <p class="docText">The length of a <tt>string</tt> is the number of characters in the <tt>string</tt>. It is returned by the <tt>size</tt> operation:</p>

        <p class="docText"><tt>string</tt> 对象的长度指的是 <tt>string</tt> 对象中字符的个数，可以通过 <tt>size</tt> 操作获取：</p>
        <pre>
     int main()
     {
         string st("The expense of spirit\n");
         cout &lt;&lt; "The size of " &lt;&lt; st &lt;&lt; "is " &lt;&lt; st.size()
              &lt;&lt; " characters, including the newline" &lt;&lt; endl;
         return 0;
     }
</pre>

        <p class="docText"><a name="idd1e16678"></a><a name="idd1e16682"></a><a name="idd1e16689"></a>If we compile and execute this program it yields</p>

        <p class="docText">编译并运行这个程序，得到的结果为：</p>
        <pre>
     <span class="docEmphStrong">The size of The expense of spirit</span>
     <span class="docEmphStrong">is 22 characters, including the newline</span>
</pre>

        <p class="docText">Often it is useful to know whether a <tt>string</tt> is empty. One way we could do so would be to compare <tt>size</tt> with 0:</p>

        <p class="docText">了解 <tt>string</tt> 对象是否空是有用的。一种方法是将 <tt>size</tt> 与 0 进行比较：</p>
        <pre>
     if (st.size() == 0)
          // <span class="docEmphItalicAlt">ok: empty</span>
</pre>

        <p class="docText">In this case, we don't really need to know how many characters are in the <tt>string</tt>; we are only interested in whether the <tt>size</tt> is zero. We can more directly answer this question by using the <tt>empty</tt> member:</p>

        <p class="docText">本例中，程序员并不需要知道 <tt>string</tt> 对象中有多少个字符，只想知道 <tt>size</tt> 是否为 0。用 <tt>string</tt> 的成员函数 <tt>empty</tt>() 可以更直接地回答这个问题：</p>
        <pre>
     if (st.empty())
          // <span class="docEmphItalicAlt">ok: empty</span>
</pre>

        <p class="docText">The <tt>empty</tt> function returns the <tt>bool</tt> (<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1" >Section 2.1</a>, p. <a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1" >34</a>) value <tt>true</tt> if the <tt>string</tt> contains no characters; otherwise, it returns <tt>false</tt>.</p>

        <p class="docText"><tt>empty</tt>() 成员函数将返回 <tt>bool</tt>（<a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1" >2.1 节</a>），如果 <tt>string</tt> 对象为空则返回 <tt>true</tt> 否则返回 <tt>false</tt>。</p><a name="ch03lev3sec5"></a>

        <h5 class="docSection3Title"><tt>string::size_type</tt></h5>

        <h5 class="docSection3Title"><tt>string::size_type</tt> 类型</h5>

        <p class="docText">It might be logical to expect that <tt>size</tt> returns an <tt>int</tt>, or, thinking back to the note on page <a class="docLink" href="ch02lev1sec2.html#ch02sb02" >38</a>, an <tt>unsigned</tt>. Instead, the <tt>size</tt> operation returns a value of type <tt>string::size_type</tt>. This type requires a bit of explanation.</p>

        <p class="docText">从逻辑上来讲，<tt>size</tt>() 成员函数似乎应该返回整形数值，或如 <a class="docLink" href="ch02lev1sec2.html#ch02sb02" >2.2 节</a>“建议”中所述的无符号整数。但事实上，<tt>size</tt> 操作返回的是 <tt>string::size_type</tt> 类型的值。我们需要对这种类型做一些解释。</p>

        <p class="docText"> </p>

        <p class="docText">The <tt>string</tt> classand many other library typesdefines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type <b><a name="ch03term19"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_19" ><span class="docEmphStrong"><tt>size_type</tt></span></a></b> is one of these companion types. It is defined as a synonym for an <tt>unsigned</tt> typeeither <tt>unsigned int</tt> or <tt>unsigned long</tt>that is guaranteed to be big enough to hold the size of any <a name="idd1e16821"></a><a name="idd1e16828"></a><a name="idd1e16836"></a><a name="idd1e16845"></a><a name="idd1e16850"></a><a name="idd1e16859"></a><a name="idd1e16872"></a><a name="idd1e16878"></a><a name="idd1e16886"></a><a name="idd1e16895"></a><tt>string</tt>. To use the <tt>size_type</tt> defined by <tt>string</tt>, we use the scope operator to say that the name <tt>size_type</tt> is defined in the <tt>string</tt> class.</p>

        <p class="docText"><tt>string</tt> 类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine-independent）。<b><a class="docLink" href="ch03lev1sec7.html#gloss03_19" ><span class="docEmphStrong"><tt>size_type</tt></span></a></b> 就是这些配套类型中的一种。它定义为与 <tt>unsigned</tt> 型（<tt>unsigned int</tt> 或 <tt>unsigned long</tt>）具有相同的含义，而且可以保证足够大能够存储任意 <tt>string</tt> 对象的长度。为了使用由 <tt>string</tt> 类型定义的 <tt>size_type</tt> 类型是由 <tt>string</tt> 类定义。</p><a name="ch03note05"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Any variable used to store the result from the <tt>string size</tt> operation ought to be of type <tt>string::size_type</tt>. It is particularly important <span class="docEmphasis">not</span> to assign the return from <tt>size</tt> to an <tt>int</tt>.</p>

                <p class="docText">任何存储 <tt>string</tt> 的 <tt>size</tt> 操作结果的变量必须为 <tt>string::size_type</tt> 类型。特别重要的是，还要把 <tt>size</tt> 的返回值赋给一个 <tt>int</tt> 变量。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">Although we don't know the precise type of <tt>string::size_type</tt>, wedo know that it is an <tt>unsigned</tt> type (<a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >Section 2.1.1</a>, p. <a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >34</a>). We also know that for a given type, the <tt>unsigned</tt> version can hold a positive value twice as large as the corresponding <tt>signed</tt> type can hold. This fact implies that the largest <tt>string</tt> could be twice as large as the size an <tt>int</tt> can hold.</p>

        <p class="docText">虽然我们不知道 <tt>string::size_type</tt> 的确切类型，但可以知道它是 <tt>unsigned</tt> 型（<a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >2.1.1 节</a>）。对于任意一种给定的数据类型，它的 <tt>unsigned</tt> 型所能表示的最大正数值比对应的 <tt>signed</tt> 型要大倍。这个事实表明 <tt>size_type</tt> 存储的 <tt>string</tt> 长度是 <tt>int</tt> 所能存储的两倍。</p>

        <p class="docText">Another problem with using an <tt>int</tt> is that on some machines the size of an <tt>int</tt> is too small to hold the size of even plausibly large <tt>string</tt>s. For example, if a machine has 16-bit <tt>int</tt>s, then the largest <tt>string</tt> an <tt>int</tt> could represent would have 32,767 characters. A <tt>string</tt> that held the contents of a file could easily exceed this size. The safest way to hold the <tt>size</tt> of a <tt>string</tt> is to use the type the library defines for this purpose, which is <tt>string::size_type</tt>.</p>

        <p class="docText">使用 <tt>int</tt> 变量的另一个问题是，有些机器上 <tt>int</tt> 变量的表示范围太小，甚至无法存储实际并不长的 <tt>string</tt> 对象。如在有 16 位 <tt>int</tt> 型的机器上，<tt>int</tt> 类型变量最大只能表示 32767 个字符的 <tt>string</tt> 个字符的 <tt>string</tt> 对象。而能容纳一个文件内容的 <tt>string</tt> 对象轻易就会超过这个数字。因此，为了避免溢出，保存一个 <tt>stirng</tt> 对象 <tt>size</tt> 的最安全的方法就是使用标准库类型 <tt>string::size_type</tt>。</p>

        <p class="docText"> </p><a name="ch03lev3sec6"></a>

        <h5 class="docSection3Title">The <tt>string</tt> Relational Operators</h5>

        <h5 class="docSection3Title"><tt>string</tt> 关系操作符</h5>

        <p class="docText">The <tt>string</tt> class defines several operators that compare two <tt>string</tt> values. Each of these operators works by comparing the characters from each <tt>string</tt>.</p>

        <p class="docText"><tt>string</tt> 类定义了几种关系操作符用来比较两个 <tt>string</tt> 值的大小。这些操作符实际上是比较每个 <tt>string</tt> </p><a name="ch03note06"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText"><tt>string</tt> comparisons are case-sensitivethe upper- and lowercase versions of a letter are different characters. On most computers, the uppercase letters come first: Every uppercase letter is less than any lowercase letter.</p>

                <p class="docText"><tt>string</tt> 对象比较操作是区分大小写的，即同一个字符的大小写形式被认为是两个不同的字符。在多数计算机上，大写的字母位于小写之前：任何一个大写之母都小于任意的小写字母。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">The equality operator compares two <tt>string</tt>s, returning <tt>true</tt> if they are equal. Two <tt>string</tt>s are equal if they are the same length and contain the same characters. The library also defines <tt>!=</tt> to test whether two <tt>string</tt>s are unequal.</p>

        <p class="docText"><tt>==</tt> 操作符比较两个 <tt>string</tt> 对象，如果它们相等，则返回 <tt>true</tt>。两个 <tt>string</tt> 对象相等是指它们的长度相同，且含有相同的字符。标准库还定义了 <tt>!=</tt> 操作符来测试两个 <tt>string</tt> 对象是否不等。</p>

        <p class="docText">The relational operators <tt>&lt;, &lt;=, &gt;, &gt;=</tt> test whether one <tt>string</tt> is less than, less than or equal, greater than, or greater than or equal to another:</p>

        <p class="docText">关系操作符 <tt>&lt;</tt>，<tt>&lt;=</tt>，<tt>&gt;</tt>，<tt>&gt;=</tt> 分别用于测试一个 <tt>string</tt> 对象是否小于、小于或等于、大于、大于或等于另一个 <tt>string</tt> 对象：</p>

        <p class="docText"> </p>
        <pre>
     string big = "big", small = "small";
     string s1 = big;    // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">is a copy of</span> <span class="docEmphasis">big</span>
     if (big == small)   // <span class="docEmphItalicAlt">false</span>
         // ...
     if (big &lt;= s1)      // <span class="docEmphItalicAlt">true, they're equal, so</span> <span class="docEmphasis">big</span> <span class="docEmphItalicAlt">is less than or equal to</span> <span class="docEmphItalicAlt">s1</span>
         // ...
</pre>

        <p class="docText">The relational operators compare <tt>string</tt>s using the same strategy as in a (case-sensitive) dictionary:</p>

        <p class="docText">关系操作符比较两个 <tt>string</tt> 对象时采用了和（大小写敏感的）字典排序相同的策略：</p>

        <ul>
          <li>
            <p class="docList">If two <tt>string</tt>s have different lengths and if every character in the shorter <tt>string</tt> is equal to the corresponding character of the longer <tt>string</tt>, then the shorter <tt>string</tt> is less than the longer one.</p>
          </li>

          <li>
            <p class="docList">如果两个 <tt>string</tt> 对象长度不同，且短的 <tt>string</tt> 对象与长的 <tt>string</tt> 对象的前面部分相匹配，则短的 <tt>string</tt> 对象小于长的 <tt>string</tt> 对象。</p>
          </li>

          <li>
            <p class="docList">If the characters in two <tt>string</tt>s differ, then we compare them by comparing the first character at which the <tt>string</tt>s differ.</p>
          </li>

          <li>
            <p class="docList">如果 <tt>string</tt> 对象的字符不同，则比较第一个不匹配的字符。<tt>string</tt></p>
          </li>
        </ul><a name="idd1e17130"></a><a name="idd1e17138"></a><a name="idd1e17146"></a><a name="idd1e17154"></a><a name="idd1e17163"></a><a name="idd1e17172"></a><a name="idd1e17178"></a><a name="idd1e17184"></a><a name="idd1e17195"></a><a name="idd1e17206"></a><a name="idd1e17217"></a><a name="idd1e17223"></a><a name="idd1e17232"></a><a name="idd1e17238"></a>

        <p class="docText">As an example, given the <tt>string</tt>s</p>

        <p class="docText">举例来说，给定 <tt>string</tt> 对象；</p>
        <pre>
     string substr = "Hello";
     string phrase = "Hello World";
     string slang  = "Hiya";
</pre>

        <p class="docText">then <tt>substr</tt> is less than <tt>phrase</tt>, and <tt>slang</tt> is greater than either <tt>substr</tt> or <tt>phrase</tt>.</p>

        <p class="docText">则 <tt>substr</tt> 小于 <tt>phrase</tt>，而 <tt>slang</tt> 则大于 <tt>substr</tt> 或 <tt>phrase</tt> </p><a name="ch03lev3sec7"></a>

        <h5 class="docSection3Title">Assignment for <tt>string</tt>s</h5>

        <h5 class="docSection3Title"><tt>string</tt> 对象的赋值</h5>

        <p class="docText">In general the library types strive to make it as easy to use a library type as it is to use a built-in type. To this end, most of the library types support assignment. In the case of <tt>string</tt>s, we can assign one <tt>string</tt> object to another:</p>

        <p class="docText">总体上说，标准库类型尽量设计得和基本数据类型一样方便易用。因此，大多数库类型支持赋值操作。对 <tt>string</tt> 对象来说，可以把一个 <tt>string</tt> 对象赋值给另一个 <tt>string</tt> 对象；</p>
        <pre>
     // <span class="docEmphasis">st1</span> <span class="docEmphItalicAlt">is an empty string,</span> <span class="docEmphasis">st2</span> <span class="docEmphItalicAlt">is a copy of the literal</span>
     string st1, st2 = "The expense of spirit";
     st1 = st2; // <span class="docEmphItalicAlt">replace</span> <span class="docEmphasis">st1</span> <span class="docEmphItalicAlt">by a copy of</span> <span class="docEmphasis">st2</span>
</pre>

        <p class="docText">After the assignment, <tt>st1</tt> contains a copy of the characters in <tt>st2</tt>.</p>

        <p class="docText">赋值操作后，<tt>st1</tt> 就包含了 <tt>st2</tt> 串所有字符的一个副本。</p>

        <p class="docText">Most <tt>string</tt> library implementations go to some trouble to provide efficient implementations of operations such as assignment, but it is worth noting that conceptually, assignment requires a fair bit of work. It must delete the storage containing the characters associated with <tt>st1</tt>, allocate the storage needed to contain a copy of the characters associated with <tt>st2</tt>, and then copy those characters from <tt>st2</tt> into this new storage.</p>

        <p class="docText">大多数 <tt>string</tt> 库类型的赋值等操作的实现都会遇到一些效率上的问题，但值得注意的是，从概念上讲，赋值操作确实需要做一些工作。它必须先把 <tt>st1</tt> 占用的相关内存释放掉，然后再分配给 <tt>st2</tt> 足够存放 <tt>st2</tt> 副本的内存空间，最后把 <tt>st2</tt> 中的所有字符复制到新分配的内存空间。</p>

        <p class="docText"> </p><a name="ch03lev3sec8"></a>

        <h5 class="docSection3Title">Adding Two <tt>string</tt>s</h5>

        <h5 class="docSection3Title">两个 <tt>string</tt> 对象相加</h5>

        <p class="docText">Addition on <tt>string</tt>s is defined as concatenation. That is, it is possible to concatenate two or more <tt>string</tt>s through the use of either the plus operator (<tt>+</tt>) or the compound assignment operator (<tt>+=</tt>) (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5" >Section 1.4.1</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5" >13</a>). Given the two <tt>string</tt>s</p>

        <p class="docText"><tt>string</tt> 对象的加法被定义为连接（concatenation）。也就是说，两个（或多个）<tt>string</tt> 对象可以通过使用加操作符 <tt>+</tt> 或者复合赋值操作符 <tt>+=</tt>（<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5" >1.4.1 节</a>）连接起来。给定两个 <tt>string</tt> 对象：</p>

        <p class="docText"> </p>
        <pre>
     string s1("hello, ");
     string s2("world\n");
</pre>

        <p class="docText">we can concatenate the two <tt>string</tt>s to create a third <tt>string</tt> as follows:</p>

        <p class="docText">下面把两个 <tt>string</tt> 对象连接起来产生第三个 <tt>string</tt> 对象：</p>
        <pre>
     string s3 = s1 + s2;   // <span class="docEmphasis">s3 is hello, world</span>\n
</pre>

        <p class="docText">If we wanted to append <tt>s2</tt> to <tt>s1</tt> directly, then we would use <tt>+=</tt>:</p>

        <p class="docText">如果要把 <tt>s2</tt> 直接追加到 <tt>s1</tt> 的末尾，可以使用 <tt>+=</tt> 操作符：</p>
        <pre>
     s1 += s2;   // <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">s1 = s1 + s2</span>
</pre>
        <a name="ch03lev3sec9"></a>

        <h5 class="docSection3Title">Adding Character String Literals and <tt>string</tt>s</h5>

        <h5 class="docSection3Title">和字符串字面值的连接</h5>

        <p class="docText">The <tt>string</tt>s <tt>s1</tt> and <tt>s2</tt> included punctuation directly. We could achieve the same result by mixing <tt>string</tt> objects and string literals as follows:</p>

        <p class="docText">上面的字符串对象 <tt>s1</tt> 和 <tt>s2</tt> 直接包含了标点符号。也可以通过将 <tt>string</tt> 对象和字符串字面值混合连接得到同样的结果：</p>
        <pre>
     string s1("hello");
     string s2("world");

     string s3 = s1 + ", " + s2 + "\n";
</pre>
        <a name="idd1e17458"></a><a name="idd1e17463"></a><a name="idd1e17471"></a><a name="idd1e17474"></a><a name="idd1e17488"></a><a name="idd1e17494"></a><a name="idd1e17500"></a><a name="idd1e17507"></a><a name="idd1e17513"></a>

        <p class="docText">When mixing <tt>string</tt>s and string literals, at least one operand to each <tt>+</tt> operator must be of <tt>string</tt> type:</p>

        <p class="docText">当进行 <tt>string</tt> 对象和字符串字面值混合连接操作时，<tt>+</tt> 操作符的左右操作数必须至少有一个是 <tt>string</tt> 类型的：</p>
        <pre>
     string s1 = "hello";   // <span class="docEmphItalicAlt">no punctuation</span>
     string s2 = "world";
     string s3 = s1 + ", ";           // <span class="docEmphItalicAlt">ok: adding a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">and a literal</span>
     string s4 = "hello" + ", ";      // <span class="docEmphItalicAlt">error: no</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
     string s5 = s1 + ", " + "world"; // <span class="docEmphItalicAlt">ok: each + has</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
     string s6 = "hello" + ", " + s2; // <span class="docEmphItalicAlt">error: can't add</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">literals</span>
</pre>

        <p class="docText">The initializations of <tt>s3</tt> and <tt>s4</tt> involve only a single operation. In these cases, it is easy to determine that the initialization of <tt>s3</tt> is legal: We initialize <tt>s3</tt> by adding a <tt>string</tt> and a string literal. The initialization of <tt>s4</tt> attempts to add two string literals and is illegal.</p>

        <p class="docText"><tt>s3</tt> 和 <tt>s4</tt> 的初始化只用了一个单独的操作。在这些例子中，很容易判断 <tt>s3</tt> 的初始化是合法的：把一个 <tt>string</tt> 对象和一个字符串字面值连接起来。而 <tt>s4</tt> 的初始化试图将两个字符串字面值相加，因此是非法的。</p>

        <p class="docText">The initialization of <tt>s5</tt> may appear surprising, but it works in much the same way as when we chain together input or output expressions (<a class="docLink" href="ch01lev1sec2.html#ch01lev1sec2" >Section 1.2</a>, p. <a class="docLink" href="ch01lev1sec2.html#ch01lev1sec2" >5</a>). In this case, the <tt>string</tt> library defines addition to return a <tt>string</tt>. Thus, when we initialize <tt>s5</tt>, the subexpression <tt>s1 + ", "</tt> returns a <tt>string</tt>, which can be concatenated with the literal <tt>"world\n"</tt>. It is as if we had written</p>

        <p class="docText"><tt>s5</tt> 的初始化方法显得有点不可思议，但这种用法和标准输入输出的串联效果是一样的（<a class="docLink" href="ch01lev1sec2.html#ch01lev1sec2" >1.2 节</a>）。本例中，<tt>string</tt> 标准库定义加操作返回一个 <tt>string</tt> 对象。这样，在对 <tt>s5</tt> 进行初始化时，子表达式 <tt>s1 + ", "</tt> 将返回一个新 <tt>string</tt> 对象，后者再和字面值 <tt>"world\n"</tt>连接。整个初始化过程可以改写为：</p>

        <p class="docText"> </p>
        <pre>
     string tmp = s1 + ", "; // <span class="docEmphItalicAlt">ok: + has a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
     s5 = tmp + "world";     // <span class="docEmphItalicAlt">ok: + has a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">operand</span>
</pre>

        <p class="docText">On the other hand, the initialization of <tt>s6</tt> is illegal. Looking at each subexpression in turn, we see that the first subexpression adds two string literals. There is no way to do so, and so the statement is in error.</p>

        <p class="docText">而 <tt>s6</tt> 的初始化是非法的。依次来看每个子表达式，则第一个子表达式试图把两个字符串字面值连接起来。这是不允许的，因此这个语句是错误的。</p><a name="ch03lev3sec10"></a>

        <h5 class="docSection3Title">Fetching a Character from a <tt>string</tt></h5>

        <h5 class="docSection3Title">从 <tt>string</tt> 对象获取字符</h5>

        <p class="docText">The <tt>string</tt> type uses the <span class="docEmphStrong">subscript</span> (<tt>[ ]</tt>) operator to access the individual characters in the <tt>string</tt>. The subscript operator takes a <tt>size_type</tt> value that denotes the character position we wish to fetch. The value in the subscript is often called "the subscript" or "an <b><a name="ch03term10"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_10" >index</a></b>."</p>

        <p class="docCNText"><tt>string</tt> 类型通过<span class="docCNEmphasis">下标</span>操作符（<tt>[ ]</tt>）来访问 <tt>string</tt> 对象中的单个字符。下标操作符需要取一个 <tt>size_type</tt> 类型的值，来标明要访问字符的位置。这个下标中的值通常被称为“下标”或“索引”<b>（<a name="ch03term10"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_10" >index</a>）</b></p>

        <p class="docText"> </p><a name="ch03note07"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Subscripts for <tt>string</tt>s start at zero; if <tt>s</tt> is a <tt>string</tt>, then if <tt>s</tt> isn't empty, <tt>s[0]</tt> is the first character in the <tt>string, s[1]</tt> is the second if there is one, and the last character is in <tt>s[s.size() - 1]</tt>.</p>

                <p class="docText"><tt>string</tt> 对象的下标从 0 开始。如果 <tt>s</tt> 是一个 <tt>string</tt> 对象且 <tt>s</tt> 不空，则 <tt>s[0]</tt> 就是字符串的第一个字符， <tt>s[1]</tt> 就表示第二个字符（如果有的话），而 <tt>s[s.size() - 1]</tt> 则表示 s 的最后一个字符。</p>
              </td>
            </tr>
          </table>

          <p class="docText"><span class="docEmphasis">It is an error to use an index outside this range.</span></p>

          <p class="docText"><span class="docCNEmphasis">引用下标时如果超出下标作用范围就会引起溢出错误。</span></p>
        </div>

        <p class="docText">We could use the subscript operator to print each character in a <tt>string</tt> on a separate line:</p>

        <p class="docText">可用下标操作符分别取出 <tt>string</tt> 对象的每个字符，分行输出：</p>
        <pre>
     string str("some string");
     for (string::size_type ix = 0; ix != str.size(); ++ix)
         cout &lt;&lt; str[ix] &lt;&lt; endl;
</pre>

        <p class="docText">On each trip through the loop we fetch the next character from <tt>str</tt>, printing it followed by a newline.</p>

        <p class="docText">每次通过循环，就从 <tt>str</tt> 对象中读取下一个字符，输出该字符并换行。</p><a name="ch03lev3sec11"></a>

        <h5 class="docSection3Title">Subscripting Yields an Lvalue</h5>

        <h5 class="docSection3Title">下标操作可用作左值</h5><a name="idd1e17748"></a><a name="idd1e17755"></a><a name="idd1e17762"></a><a name="idd1e17766"></a><a name="idd1e17772"></a><a name="idd1e17777"></a><a name="idd1e17783"></a><a name="idd1e17787"></a><a name="idd1e17791"></a><a name="idd1e17795"></a><a name="idd1e17799"></a><a name="idd1e17803"></a><a name="idd1e17807"></a><a name="idd1e17811"></a><a name="idd1e17815"></a><a name="idd1e17819"></a><a name="idd1e17823"></a><a name="idd1e17827"></a><a name="idd1e17832"></a><a name="idd1e17845"></a><a name="idd1e17858"></a><a name="idd1e17861"></a><a name="idd1e17869"></a><a name="idd1e17877"></a><a name="idd1e17883"></a><a name="idd1e17887"></a>

        <p class="docText">Recall that a variable is an lvalue (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10" >Section 2.3.1</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10" >45</a>), and that the left-hand side of an assignment must be an lvalue. Like a variable, the value returned by the subscript operator is an lvalue. Hence, a subscript can be used on either side of an assignment. The following loop sets each character in <tt>str</tt> to an asterisk:</p>

        <p class="docText">前面说过，变量是左值（<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10" >2.3.1 节</a>），且赋值操作的左操作的必须是左值。和变量一样，<tt>string</tt> 对象的下标操作返回值也是左值。因此，下标操作可以放于赋值操作符的左边或右边。通过下面循环把 <tt>str</tt> 对象的每一个字符置为 ‘*’：</p>
        <pre>
     for (string::size_type ix = 0; ix != str.size(); ++ix)
         str[ix] = '*';
</pre>
        <a name="ch03lev3sec12"></a>

        <h5 class="docSection3Title">Computing Subscript Values</h5>

        <h5 class="docSection3Title">计算下标值</h5>

        <p class="docText">Any expression that results in an integral value can be used as the index to the subscript operator. For example, assuming <tt>someval</tt> and <tt>someotherval</tt> are integral objects, we could write</p>

        <p class="docText">任何可产生整型值的表达式可用作下标操作符的索引。例如，假设 <tt>someval</tt> 和 <tt>someotherval</tt> 是两个整形对象，可以这样写：</p>
        <pre>
     str[someotherval * someval] = someval;
</pre>

        <p class="docText">Although any integral type can be used as an index, the actual type of the index is <tt>string::size_type</tt>, which is an <tt>unsigned</tt> type.</p>

        <p class="docText">虽然任何整型数值都可作为索引，但索引的实际数据类型却是类型 <tt>unsigned</tt> 类型 <tt>string::size_type</tt>。</p><a name="ch03note08"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The same reasons to use <tt>string::size_type</tt> as the type for a variable that holds the return from <tt>size</tt> apply when defining a variable to serve as an index. A variable used to index a <tt>string</tt> should have type <tt>string::size_type</tt>.</p>

                <p class="docText">前面讲过，应该用 <tt>string::size_type</tt> 类型的变量接受 <tt>size</tt> 函数的返回值。在定义用作索引的变量时，出于同样的道理，<tt>string</tt> 对象的索引变量最好也用 <tt>string::size_type</tt> 类型。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">When we subscript a <tt>string</tt>, we are responsible for ensuring that the index is "in range." By in range, we mean that the index is a number that, when assigned to a <tt>size_type</tt>, is a value in the range from 0 through the size of the <tt>string</tt> minus one. By using a <tt>string::size_type</tt> or another <tt>unsigned</tt> type as the index, we ensure that the subscript cannot be less than zero. As long as our index is an <tt>unsigned</tt> type, we need only check that it is less than the size of the <tt>string</tt>.</p>

        <p class="docText">在使用下标索引 <tt>string</tt> 对象时，必须保证索引值“在上下界范围内”。“在上下界范围内”就是指索引值是一个赋值为 <tt>size_type</tt> 类型的值，其取值范围在 0 到 <tt>string</tt> 对象长度减 1 之间。使用 <tt>string::size_type</tt> 类型或其他 <tt>unsigned</tt> 类型，就只需要检测它是否小于 <tt>string</tt> 对象的长度。</p><a name="ch03note09"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The library is not required to check the value of the index. Using an index that is out of range is undefined and usually results in a serious run-time error.</p>

                <p class="docText">标准库不要求检查索引值，所用索引的下标越界是没有定义的，这样往往会导致严重的运行时错误。</p>
              </td>
            </tr>
          </table>
        </div>
        <a name="ch03lev2sec5"></a>

        <h4 class="docSection2Title">3.2.4. Dealing with the Characters of a <tt>string</tt></h4>

        <h4 class="docSection2Title">3.2.4. <tt>string</tt> 对象中字符的处理</h4>

        <p class="docText">Often we want to process the individual characters of a <tt>string</tt>. For example, we might want to know if a particular character is a whitespace character or whether the character is alphabetic or numeric. <a class="docLink" href="ch03lev1sec2.html#ch03table03">Table 3.3</a> on the facing page lists the functions that can be used on the characters in a <tt>string</tt> (or on any other <tt>char</tt> value). These functions are defined in the <b><a name="ch03term3"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_03" ><span class="docEmphStrong"><tt>cctype</tt> header</span></a></b>.</p>

        <p class="docText">我们经常要对 <tt>string</tt> 对象中的单个字符进行处理，例如，通常需要知道某个特殊字符是否为空白字符、字母或数字。<a class="docLink" href="ch03lev1sec2.html#ch03table03">表 3.3</a> 列出了各种字符操作函数，适用于 <tt>string</tt> 对象的字符（或其他任何 <tt>char</tt> 值）。这些函数都在 <b><a name="ch03term3"></a><a class="docLink" href="ch03lev1sec7.html#gloss03_03" ><span class="docEmphStrong"><tt>cctype</tt> 头文件</span></a></b>中定义。</p><a name="ch03table03"></a>

        <h5 class="docTableTitle">Table 3.3. <tt>cctype</tt> Functions</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="175">
            <col width="325">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>isalnum(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>True</tt> if <tt>c</tt> is a letter or a digit.</p>

              <p class="docText">如果 <tt>c</tt> 是字母或数字，则为 <tt>True</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>isalpha(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt> if <tt>c</tt> is a letter.</p>

              <p class="docText">如果 <tt>c</tt> 是字母，则为 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>iscntrl(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt> if <tt>c</tt> is a control character.</p>

              <p class="docText">如果 <tt>c</tt> 是控制字符，则为 <tt>true</tt> </p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>isdigit(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt> if <tt>c</tt> is a digit.</p>

              <p class="docText">如果 <tt>c</tt> 是数字，则为 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>isgraph(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt> if <tt>c</tt> is not a space but is printable.</p>

              <p class="docText">如果 <tt>c</tt> 不是空格，但可打印，则为 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>islower(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt> if <tt>c</tt> is a lowercase letter.</p>

              <p class="docText">如果 <tt>c</tt> 是小写字母，则为 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>isprint(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>True</tt> if <tt>c</tt> is a printable character.</p>

              <p class="docText">如果 <tt>c</tt> 是可打印的字符，则为 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>ispunct(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>True</tt> if <tt>c</tt> is a punctuation character.</p>

              <p class="docText">如果 <tt>c</tt> 是标点符号，则 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>isspace(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt> if <tt>c</tt> is whitespace.</p>

              <p class="docText">如果 <tt>c</tt> 是空白字符，则为 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="center">
              <p class="docText"><tt>isupper(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>True</tt> if <tt>c</tt> is an uppercase letter.</p>

              <p class="docText">如果 <tt>c</tt> 是大写字母，则 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>isxdigit(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt> if <tt>c</tt> is a hexadecimal digit.</p>

              <p class="docText">如果是 <tt>c</tt> 十六进制数，则为 <tt>true</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>tolower(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">If <tt>c</tt> is an uppercase letter, returns its lowercase equivalent; otherwise returns <tt>c</tt> unchanged.</p>

              <p class="docText">如果 <tt>c</tt> 大写字母，返回其小写字母形式，否则直接返回 <tt>c</tt>。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>toupper(c)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">If <tt>c</tt> is a lowercase letter, returns its uppercase equivalent; otherwise returns <tt>c</tt> unchanged.</p>

              <p class="docText">如果 <tt>c</tt> 是小写字母，则返回其大写字母形式，否则直接返回 <tt>c</tt>。</p>
            </td>
          </tr>
        </table>

        <p class="docText">These functions mostly test the given character and return an <tt>int</tt>, which acts as a truth value. Each function returns zero if the test fails; otherwise, they return a (meaningless) nonzero value indicating that the character is of the requested kind.</p>

        <p class="docText">表中的大部分函数是测试一个给定的字符是否符合条件，并返回一个 <tt>int</tt> 作为真值。如果测试失败，则该函数返回 0 ，否则返回一个（无意义的）非 0 ，表示被测字符符合条件。</p>

        <p class="docText">For these functions, a printable character is a character with a visible representation; whitespace is one of space, tab, vertical tab, return, newline, and formfeed; and punctuation is a printable character that is not a digit, a letter, or (printable) whitespace character such as space.</p>

        <p class="docText">表中的这些函数，可打印的字符是指那些可以表示的字符，空白字符则是空格、制表符、垂直制表符、回车符、换行符和进纸符中的任意一种；标点符号则是除了数字、字母或（可打印的）空白字符（如空格）以外的其他可打印字符。</p>

        <p class="docText">As an example, we could use these functions to print the number of punctuation characters in a given <tt>string</tt>:</p>

        <p class="docText">这里给出一个例子，运用这些函数输出一给定 <tt>string</tt> 对象中标点符号的个数：</p>
        <pre>
     string s("Hello World!!!");
     string::size_type punct_cnt = 0;
     // <span class="docEmphItalicAlt">count number of punctuation characters in</span> <span class="docEmphasis">s</span>
     for (string::size_type index = 0; index != s.size(); ++index)
         if (ispunct(s[index]))
             ++punct_cnt;
     cout &lt;&lt; punct_cnt
          &lt;&lt; " punctuation characters in " &lt;&lt; s &lt;&lt; endl;
</pre>

        <p class="docText">The output of this program is</p>

        <p class="docText">这个程序的输出结果是：</p>
        <pre>
     <span class="docEmphStrong">3 punctuation characters in Hello World!!!</span>
</pre>

        <p class="docText">Rather than returning a truth value, the <tt>tolower</tt> and <tt>toupper</tt> functions return a charactereither the argument unchanged or the lower- or uppercase version of the character. We could use <tt>tolower</tt> to change <tt>s</tt> to lowercase as follows:</p>

        <p class="docText">和返回真值的函数不同的是，<tt>tolower</tt> 和 <tt>toupper</tt> 函数返回的是字符，返回实参字符本身或返回该字符相应的大小写字符。我们可以用 <tt>tolower</tt> 函数把 <tt>string</tt> 对象 <tt>s</tt> 中的字母改为小写字母，程序如下：</p>
        <pre>
     // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">to lowercase</span>
     for (string::size_type index = 0; index != s.size(); ++index)
         s[index] = tolower(s[index]);
     cout &lt;&lt; s &lt;&lt; endl;
</pre>

        <p class="docText">which generates</p>

        <p class="docText">得到的结果为：</p>
        <pre>
     <span class="docEmphStrong">hello world!!!</span>
</pre>
        <a name="ch03sb05"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Advice: Use the C++ Versions of C Library Headers</h2>

              <h2 class="docSidebarTitle">建议：采用 C 标准库头文件的 C++ 版本</h2><a name="idd1e18352"></a><a name="idd1e18355"></a><a name="idd1e18360"></a><a name="idd1e18365"></a><a name="idd1e18371"></a><a name="idd1e18376"></a><a name="idd1e18381"></a><a name="idd1e18386"></a><a name="idd1e18391"></a><a name="idd1e18395"></a>

              <p class="docText"><span class="docEmphStrong">In addition to facilities defined specifically for C++, the C++ library incorporates the C library. The <tt>cctype</tt> header makes available the C library functions defined in the C header file named <tt>ctype.h</tt>.</span></p>

              <p class="docText"><span class="docEmphStrong">C++ 标准库除了定义了一些选定于 C++ 的设施外，还包括 C 标准库。C++ 中的头文件 <tt>cctype</tt> 其实就是利用了 C 标准库函数，这些库函数就定义在 C 标准库的 <tt>ctype.h</tt> 头文件中。</span></p>

              <p class="docText"><span class="docEmphStrong">The standard C headers names use the form <span class="docEmphasis">name</span></span><span class="docEmphStrong"><tt>.h</tt>. The C++ versions of these headers are named <tt>c</tt></span><span class="docEmphBoldItalic">name</span><span class="docEmphStrong">the C++ versions remove the <tt>.h</tt> suffix and precede the <span class="docEmphasis">name</span> by the letter <tt>c</tt></span><span class="docEmphStrong">. The</span><span class="docEmphStrong"><tt>c</tt> indicates that the header originally comes from the C library. Hence, <tt>cctype</tt> has the same contents as <tt>ctype.h</tt>, but in a form that is appropriate for C++ programs. In particular, the names defined in the <tt>c</tt></span><span class="docEmphBoldItalic">name</span> <span class="docEmphStrong">headers are defined inside the <tt>std</tt> namespace, whereas those defined in the <tt>.h</tt> versions are not.</span></p>

              <p class="docText"><span class="docEmphStrong"><tt>C</tt></span> 标准库头文件命名形式为 <span class="docEmphBoldItalic">name</span> 而 C++ 版本则命名为 c<span class="docEmphasis">name</span> ，少了后缀，<span class="docEmphStrong"><tt>.h</tt> 而在头文件名前加了 c 表示这个头文件源自 <tt>C</tt> 标准库。因此，<tt>cctype</tt> 与 <tt>ctype.h</tt> 文件的内容是一样的，只是采用了更适合 <tt>C++</tt>程序的形式。特别地，c<span class="docEmphasis">name</span> 头文件中定义的名字都定义在命名空间 <tt>std</tt> 内，而 <tt>.h</tt> 版本中的名字却不是这样。</span></p>

              <p class="docText"><span class="docEmphStrong">Ordinarily, C++ programs should use the <tt>c</tt><span class="docEmphasis">name</span> versions of headers and not the <tt>name.h</tt> versions. That way names from the standard library are consistently found in the <tt>std</tt> namespace. Using the <tt>.h</tt> headers puts the burden on the programmer to remember which library names are inherited from C and which are unique to C++.</span></p>

              <p class="docText"><span class="docEmphStrong">通常，C++ 程序中应采用 <tt>c</tt><span class="docEmphasis">name</span> 这种头文件的版本，而不采用 <tt>name.h</tt> 版本，这样，标准库中的名字在命名空间 <tt>std</tt> 中保持一致。使用 <tt>.h</tt> 版本会给程序员带来负担，因为他们必须记得哪些标准库名字是从 <tt>C</tt> 继承来的，而哪些是 <tt>C++</tt> 所特有的。</span></p>
            </td>
          </tr>
        </table>
        <a name="ch03sb06"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 3.2.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa4q1"></a><b>Exercise 3.7:</b></td>

                    <td>
                      <p class="docText">Write a program to read two <tt>string</tt>s and report whether the <tt>string</tt>s are equal. If not, report which of the two is the larger. Now, change the program to report whether the <tt>string</tt>s have the same length and if not report which is longer.</p>

                      <p class="docText">编一个程序读入两个 <tt>string</tt> 对象，测试它们是否相等。若不相等，则指出两个中哪个较大。接着，改写程序测试它们的长度是否相等，若不相等指出哪个较长。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa4q2"></a><b>Exercise 3.8:</b></td>

                    <td>
                      <p class="docText">Write a program to read <tt>string</tt>s from the standard input, concatenating what is read into one large <tt>string</tt>. Print the concatenated <tt>string</tt>. Next, change the program to separate adjacent input <tt>string</tt>s by a space.</p>

                      <p class="docText">编一个程序，从标准输入读取多个 <tt>string</tt> 对象，把它们连接起来存放到一个更大的 <tt>string</tt> 对象中。并输出连接后的 <tt>string</tt> 对象。接着，改写程序，将连接后相邻 <tt>string</tt> 对象以空格隔开。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa4q3"></a><b>Exercise 3.9:</b></td>

                    <td>
                      <p class="docText">What does the following program do? Is it valid? If not, why not?</p>

                      <p class="docText">下列程序实现什么功能？实现合法？如果不合法，说明理由。</p>
                      <pre>
     string s;
     cout &lt;&lt; s[0] &lt;&lt; endl;
</pre>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch03qa4q4"></a><b>Exercise 3.10:</b></td>

                    <td>
                      <p class="docText">Write a program to strip the punctuation from a <tt>string</tt>. The input to the program should be a string of characters including punctuation; the output should be a <tt>string</tt> in which the punctuation is removed.</p>

                      <p class="docText">编一个程序，从 <tt>string</tt> 对象中去掉标点符号。要求输入到程序的字符串必须含有标点符号，输出结果则是去掉标点符号后的 <tt>string</tt> 对象。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table><br />

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch03lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch03lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
