<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 15.8.  Handle Classes and Inheritance</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch15lev1sec7.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch15lev1sec9.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch15lev1sec8"></a>

        <h3 class="docSection1Title">15.8. Handle Classes and Inheritance</h3>
        <h3 class="docSection1Title">15.8. 句柄类与继承</h3>

        <p class="docText">One of the ironies of object-oriented programming in C++ is that we cannot use objects to support it. Instead, we must use pointers and references, not objects. For example, in the following code fragment,</p>
        <p class="docText">C++ 中面向对象编程的一个颇具讽刺意味的地方是，不能使用对象支持面向对象编程，相反，必须使用指针或引用。例如，下面的代码段中：</p>
        <pre>
     void get_prices(Item_base object,
                     const Item_base *pointer,
                     const Item_base &amp;reference)
     {
         // <span class="docEmphItalicAlt">which version of</span> <span class="docEmphasis">net_price</span> <span class="docEmphItalicAlt">is called is determined at run time</span>
         cout &lt;&lt; pointer-&gt;net_price(1) &lt;&lt; endl;
         cout &lt;&lt; reference.net_price(1) &lt;&lt; endl;

         // <span class="docEmphItalicAlt">always invokes</span> <span class="docEmphasis">Item_base::net_price</span>
         cout &lt;&lt; object.net_price(1) &lt;&lt; endl;
     }
</pre><br>

        <p class="docText">the invocations through <tt>pointer</tt> and <tt>reference</tt> are resolved at run time based on the dynamic types of the object to which they are bound.</p>
	<p class="docText">通过 <tt>pointer</tt> 和 <tt>reference</tt> 进行的调用在运行时根据它们所绑定对象的动态类型而确定。</p>

        <p class="docText">Unfortunately, using pointers or references puts a burden on the users of our classes. We saw one such burden in the previous section that discussed the inter-actions between objects of inherited types and containers.</p>
	<p class="docText">但是，使用指针或引用会加重类用户的负担。在<a href="ch15lev1sec7.html" >前一节</a>中讨论继承类型对象与容器的相互作用时，已经碰到了一种这样的负担。</p>

	<a name="idd1e118953"></a><a name="idd1e118958"></a><a name="idd1e118965"></a><a name="idd1e118970"></a><a name="idd1e118975"></a><a name="idd1e118982"></a><a name="idd1e118985"></a><a name="idd1e118990"></a><a name="idd1e118995"></a><a name="idd1e119002"></a><a name="idd1e119009"></a><a name="idd1e119015"></a><a name="idd1e119023"></a>
	<a name="ch15term8"></a>
        <p class="docText">A common technique in C++ is to define a so-called cover or <b><a class="docLink" href="ch15lev1sec11.html#gloss15_08" >handle <span class="docEmphRoman">class</span></a></b>. The handle class stores and manages a pointer to the base class. The type of the object to which that pointer points will vary; it can point at either a base- or a derived-type object. Users access the operations of the inheritance hierarchy through the handle. Because the handle uses its pointer to execute those operations, the behavior of virtual members will vary at run time depending on the kind of object to which the handle is actually bound. Users of the handle thus obtain dynamic behavior but do not themselves have to worry about managing the pointer.</p>
        <p class="docText">C++ 中一个通用的技术是定义包装（cover）类或<b><a class="docLink" href="ch15lev1sec11.html#gloss15_08" >句柄<span class="docEmphRoman">类</span></a></b>。句柄类存储和管理基类指针。指针所指对象的类型可以变化，它既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承层次的操作。因为句柄类使用指针执行操作，虚成员的行为将在运行时根据句柄实际绑定的对象的类型而变化。因此，句柄的用户可以获得动态行为但无须操心指针的管理。</p>

        <p class="docText">Handles that cover an inheritance hierarchy have two important design considerations:</p>
        <p class="docText">包装了继承层次的句柄有两个重要的设计考虑因素：</p>

        <ul>
          <li>
            <p class="docList">As with any class that holds a pointer (<a class="docLink" href="ch13lev1sec5.html#ch13lev1sec5" >Section 13.5</a>, p. <a class="docLink" href="ch13lev1sec5.html#ch13lev1sec5" >492</a>), we must decide what to do about copy control. Handles that cover an inheritance hierarchy typically behave like either a smart pointer (<a class="docLink" href="ch13lev1sec5.html#ch13lev2sec25" >Section 13.5.1</a>, p. <a class="docLink" href="ch13lev1sec5.html#ch13lev2sec25" >495</a>) or a value (<a class="docLink" href="ch13lev1sec5.html#ch13lev2sec26" >Section 13.5.2</a>, p. <a class="docLink" href="ch13lev1sec5.html#ch13lev2sec26" >499</a>).</p>
            <p class="docList">像对任何保存指针（<a class="docLink" href="ch13lev1sec5.html#ch13lev1sec5" >第 13.5 节</a>）的类一样，必须确定对复制控制做些什么。包装了继承层次的句柄通常表现得像一个智能指针（<a class="docLink" href="ch13lev1sec5.html#ch13lev2sec25" >第 13.5.1 节</a>）或者像一个值（<a class="docLink" href="ch13lev1sec5.html#ch13lev2sec26" >第 13.5.2 节</a>）。</p>
          </li>

          <li>
            <p class="docList">The handle class determines whether the handle interface will hide the inheritance hierarchy or expose it. If the hierarchy is not hidden, users must know about and use objects in the underlying hierarchy.</p>
            <p class="docList">句柄类决定句柄接口屏蔽还是不屏蔽继承层次，如果不屏蔽继承层次，用户必须了解和使用基本层次中的对象。</p>
          </li>
        </ul>

        <p class="docText">There is no one right choice among these options; the decisions depend on the details of the hierarchy and how the class designer wants programmers to interact with those class(es). In the next two sections, we'll implement two different kinds of handles that address these design questions in different ways.</p>
        <p class="docText">对于这些选项没有正确的选择，决定取决于继承层次的细节，以及类设计者希望程序员如何与那些类相互作用。下面两节将实现两种不同的句柄，用不同的方式解决这些设计问题。</p>

	<a name="ch15lev2sec21"></a>
        <h4 class="docSection2Title">15.8.1. A Pointerlike Handle</h4>
        <h4 class="docSection2Title">15.8.1. 指针型句柄</h4>

        <p class="docText">As our first example, we'll define a pointerlike handle class, named <tt>Sales_item</tt>, to represent our <tt>Item_base</tt> hierarchy. Users of <tt>Sales_item</tt> will use it as if it were a pointer: Users will bind a <tt>Sales_item</tt> to an object of type <tt>Item_base</tt> and will then use the <tt>*</tt> and <tt>-&gt;</tt> operations to execute <tt>Item_base</tt> operations:</p>
        <p class="docText">像第一个例子一样，我们将定义一个名为 <tt>Sales_item</tt> 的指针型句柄类，表示 <tt>Item_base</tt> 层次。<tt>Sales_item</tt> 的用户将像使用指针一样使用它：用户将 <tt>Sales_item</tt> 绑定到 <tt>Item_base</tt> 类型的对象并使用 <tt>*</tt> 和 <tt>-&gt;</tt> 操作符执行 <tt>Item_base</tt> 的操作：</p>
        <pre>
     // <span class="docEmphItalicAlt">bind a handle to a</span> <span class="docEmphasis">Bulk_item</span> <span class="docEmphItalicAlt">object</span>
     Sales_item item(Bulk_item("0-201-82470-1", 35, 3, .20));

     item-&gt;net_price();   // <span class="docEmphasis">virtual</span> <span class="docEmphItalicAlt">call to</span> <span class="docEmphasis">net_price</span> <span class="docEmphItalicAlt">function</span>
</pre><br>

        <p class="docText">However, users won't have to manage the object to which the handle points; the <tt>Sales_item</tt> class will do that part of the job. When users call a function through a <tt>Sales_item</tt>, they'll get polymorphic behavior.</p>
        <p class="docText">但是，用户不必管理句柄指向的对象，<tt>Sales_item</tt> 类将完成这部分工作。当用户通过 <tt>Sales_item</tt> 类对象调用函数时，将获得多态行为。</p>

	<a name="ch15lev3sec33"></a>
        <h5 class="docSection3Title">Defining the Handle</h5>
        <h5 class="docSection3Title">定义句柄</h5>

        <p class="docText">We'll give our class three constructors: a default constructor, a copy constructor, and a constructor that takes an <tt>Item_base</tt>. This third constructor will copy the <tt>Item_base</tt> and ensure that the copy stays around as long as the <tt>Sales_item</tt> does. When we copy or assign a <tt>Sales_item</tt>, we'll copy the pointer rather than copying the object. As with our other pointerlike handle classes, we'll use a use count to manage the copies.</p>
	<p class="docText"><tt>Sales_item</tt> 类有三个构造函数：默认构造函数、复制构造函数和接受 <tt>Item_base</tt> 对象的构造函数。第三个构造函数将复制 <tt>Item_base</tt> 对象，并保证：只要 <tt>Sales_item</tt> 对象存在副本就存在。当复制 <tt>Sales_item</tt> 对象或给 <tt>Sales_item</tt> 对象赋值时，将复制指针而不是复制对象。像对其他指针型句柄类一样，将用使用计数来管理副本。</p>

	<a name="idd1e119164"></a><a name="idd1e119172"></a>
        <p class="docText">The use-counted classes we've used so far have used a companion class to store the pointer and associated use count. In this class, we'll use a different design, as illustrated in <a class="docLink" href="ch15lev1sec8.html#ch15fig02">Figure 15.2</a>. The <tt>Sales_item</tt> class will have two data members, both of which are pointers: One pointer will point to the <tt>Item_base</tt> object and the other will point to the use count. The <tt>Item_base</tt> pointer might point to an <tt>Item_base</tt> object or an object of a type derived from <tt>Item_base</tt>. By pointing to the use count, multiple <tt>Sales_item</tt> objects can share the same counter.</p>
	<p class="docText">迄今为止，我们已经使用过的使用计数式类，都使用一个伙伴类来存储指针和相关的使用计数。这个例子将使用不同的设计，如<a class="docLink" href="ch15lev1sec8.html#ch15fig02">图 15.2</a> 所示。<tt>Sales_item</tt> 类将有两个数据成员，都是指针：一个指针将指向 <tt>Item_base</tt> 对象，而另一个将指向使用计数。<tt>Item_base</tt> 指针可以指向 <tt>Item_base</tt> 对象也可以指向 <tt>Item_base</tt> 派生类型的对象。通过指向使用计数，多个 <tt>Sales_item</tt> 对象可以共享同一计数器。</p>

	<a name="ch15fig02"></a>
        <center>
          <h5 class="docFigureTitle">Figure 15.2. Use-Count Strategy for the <tt>Sales_item</tt> Handle Class</h5>
	  <h5 class="docFigureTitle">图 15.2. <tt>Sales_item</tt> 句柄类的使用计数策略</h5>

          <p class="docText"><img border="0" alt="" width="475" height="171" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/15fig02.gif;400478" ></p>
        </center><br>

        <p class="docText">In addition to managing the use count, the <tt>Sales_item</tt> class will define the dereference and arrow operators:</p>
        <p class="docText">除了管理使用计数之外，<tt>Sales_item</tt> 类还将定义解引用操作符和箭头操作符：</p>
        <pre>
     // <span class="docEmphItalicAlt">use counted handle class for the</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">hierarchy</span>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">default constructor: unbound handle</span>
         Sales_item(): p(0), use(new std::size_t(1)) { }
         // <span class="docEmphItalicAlt">attaches a handle to a copy of the</span> <span class="docEmphasis">Item_base</span> <span class="docEmphItalicAlt">object</span>
         Sales_item(const Item_base&amp;);
         // <span class="docEmphItalicAlt">copy control members to manage the use count and pointers</span>
         Sales_item(const Sales_item &amp;i):
                           p(i.p), use(i.use) { ++*use; }
         ~Sales_item() { decr_use(); }
         Sales_item&amp; operator=(const Sales_item&amp;);
         // <span class="docEmphItalicAlt">member access operators</span>
         const Item_base *operator-&gt;() const { if (p) return p;
             else throw std::logic_error("unbound Sales_item"); }
         const Item_base &amp;operator*() const { if (p) return *p;
             else throw std::logic_error("unbound Sales_item"); }
     private:
         Item_base *p;        // <span class="docEmphItalicAlt">pointer to shared item</span>
         std::size_t *use;    // <span class="docEmphItalicAlt">pointer to shared use count</span>
         // <span class="docEmphItalicAlt">called by both destructor and assignment operator to free pointers</span>
         void decr_use()
              { if (--*use == 0) { delete p; delete use; } }
     };
</pre><br>
        <a name="ch15lev3sec34"></a>

        <h5 class="docSection3Title">Use-Counted Copy Control</h5>
        <h5 class="docSection3Title">使用计数式复制控制</h5>

	<a name="idd1e119272"></a><a name="idd1e119277"></a><a name="idd1e119282"></a>
        <p class="docText">The copy-control members manipulate the use count and the <tt>Item_base</tt> pointer as appropriate. Copying a <tt>Sales_item</tt> involves copying the two pointers and incrementing the use count. The destructor decrements the use count and destroys the pointers if the count goes to zero. Because the assignment operator will need to do the same work, we implement the destructor's actions in a private utility function named <tt>decr_use</tt>.</p>
	<p class="docText">复制控制成员适当地操纵使用计数和 <tt>Item_base</tt> 指针。复制 <tt>Sales_item</tt> 对象包括复制两个指针和将使用计数加 1.析构函数将使用计数减 1，如果计数减至 0 就撤销指针。因为赋值操作符需要完成同样的工作，所以在一个名为 <tt>decr_use</tt> 的私有实用函数中实现析构函数的行为。</p>

        <p class="docText">The assignment operator is a bit more complicated than the copy constructor:</p>
        <p class="docText">赋值操作符比复制构造函数复杂一点：</p>
        <pre>
     // <span class="docEmphItalicAlt">use-counted assignment operator;</span> <span class="docEmphasis">use</span> <span class="docEmphItalicAlt">is a pointer to a shared use count</span>
     Sales_item&amp;
     Sales_item::operator=(const Sales_item &amp;rhs)
     {
         ++*rhs.use;
         decr_use();
         p = rhs.p;
         use = rhs.use;
         return *this;
     }
</pre><br>

        <p class="docText">The assignment operator acts like the copy constructor in that it increments the use count of the right-hand operand and copies the pointer. It also acts like the destructor in that we first have to decrement the use count of the left-hand operand and then delete the pointers if the use count goes to zero.</p>
        <p class="docText">赋值操作符像复制构造函数一样，将右操作数的使用计数加 1 并复制指针；它也像析构函数一样，首先必须将左操作数的使用计数减 1，如果使用计数减至 0 就删除指针。</p>

        <p class="docText">As usual with an assignment operator, we must protect against self-assignment. This operator handles self-assignment by first incrementing the use count in the right-hand operand. If the left- and right-hand operands are the same, the use count will be at least 2 when <tt>decr_use</tt> is called. That function decrements and checks the use count of the left-hand operand. If the use count goes to zero, then <tt>decr_use</tt> will free the <tt>Item_base</tt> and <tt>use</tt> objects currently in this object. What remains is to copy the pointers from the right-hand to the left-hand operand. As usual, our assignment operator returns a reference to the left-hand operand.</p>
	<p class="docText">像通常对赋值操作符一样，必须防止自身赋值。这个操作符通过首先将右操作数的使用计数减 1 来处理自身赋值。如果左右操作数相同，则调用 <tt>decr_use</tt> 时使用计数将至少为 2。该函数将左操作数的使用计数减 1 并进行检查，如果使用计数减至 0，则 <tt>decr_use</tt> 将释放该对象中的 <tt>Item_base</tt> 对象和 <tt>use</tt> 对象。剩下的是从右操作数向左操作数复制指针，像平常一样，我们的赋值操作符返回左操作数的引用。</p>

        <p class="docText">Aside from the copy-control members, the only other functions <tt>Sales_item</tt> defines are the operator functions, <tt>operator*</tt> and <tt>operator-&gt;</tt>. Users will access <tt>Item_base</tt> members through these operators. Because these operators return a pointer and reference, respectively, functions called through these operators will be dynamically bound.</p>
	<p class="docText">除了复制控制成员以外，<tt>Sales_item</tt> 定义的其他函数是是操作函数 <tt>operator*</tt> 和 <tt>operator-&gt;</tt>，用户将通过这些操作符访问 <tt>Item_base</tt> 成员。因为这两个操作符分别返回指针和引用，所以通过这些操作符调用的函数将进行动态绑定。</p>

        <p class="docText">We define only the <tt>const</tt> versions of these operators because the <tt>public</tt> members in the underlying <tt>Item_base</tt> hierarchy are all <tt>const</tt>.</p>
	<p class="docText">我们只定义了这些操作符的 <tt>const</tt> 版本，因为基础 <tt>Item_base</tt> 层次中的成员都是 <tt>const</tt> 成员。</p>

	<a name="ch15lev3sec35"></a>
        <h5 class="docSection3Title">Constructing the Handle</h5>
        <h5 class="docSection3Title">构造句柄</h5>

        <p class="docText">Our handle has two constructors: the default constructor, which creates an un-bound <tt>Sales_item</tt>, and a second constructor, which takes an object to which it attaches the handle.</p>
	<p class="docText">我们句柄有两个构造函数：默认构造函数创建未绑定的 <tt>Sales_item</tt> 对象，第二个构造函数接受一个对象，将句柄与其关联。</p>

        <p class="docText">The first constructor is easy: We set the <tt>Item_base</tt> pointer to 0 to indicate that this handle is not attached to any object. The constructor allocates a new use counter and initializes it to 1.</p>
	<p class="docText">第一个构造函数容易定义：将 <tt>Item_base</tt> 指针置 0 以指出该句柄没有关联任何对象上。构造函数分配一个新的计数器并将它初始化为 1。</p>

	<a name="idd1e119386"></a><a name="idd1e119391"></a><a name="idd1e119396"></a><a name="idd1e119406"></a><a name="idd1e119414"></a>
        <p class="docText">The second constructor is more difficult. We'd like users of our handle to create their own objects, to which they could attach a handle. The constructor will allocate a new object of the appropriate type and copy the parameter into that newly allocated object. That way the <tt>Sales_item</tt> class will own the object and can guarantee that the object is not deleted until the last <tt>Sales_item</tt> attached to the object goes away.</p>
	<p class="docText">第二个构造函数难一点，我们希望句柄的用户创建自己的对象，在这些对象上关联句柄。构造函数将分配适当类型的新对象并将形参复制到新分配的对象中，这样，<tt>Sales_item</tt> 类将拥有对象并能够保证在关联到该对象的最后一个 <tt>Sales_item</tt> 对象消失之前不会删除对象。</p>

	<a name="ch15lev2sec22"></a>
        <h4 class="docSection2Title">15.8.2. Cloning an Unknown Type</h4>
        <h4 class="docSection2Title">15.8.2. 复制未知类型</h4>

        <p class="docText">To implement the constructor that takes an <tt>Item_base</tt>, we must first solve a problem: We do not know the actual type of the object that the constructor is given. We know that it is an <tt>Item_base</tt> or an object of a type derived from <tt>Item_base</tt>. Handle classes often need to allocate a new copy of an existing object <span class="docEmphasis">without knowing the precise type</span> of the object. Our <tt>Sales_item</tt> constructor is a good example.</p>
	<p class="docText">要实现接受 <tt>Item_base</tt> 对象的构造函数，必须首先解决一个问题：我们不知道给予构造函数的对象的实际类型。我们知道它是一个 <tt>Item_base</tt> 对象或者是一个 <tt>Item_base</tt> 派生类型的对象。句柄类经常需要在不知道对象的确切类型时分配书籍对象的新副本。<tt>Sales_item</tt> 构造函数是个好例子。</p>

	<a name="ch15note29"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The common approach to solving this problem is to define a virtual operation to do the copy, which we'll name <tt>clone</tt>.</p>
		<p class="docText">解决这个问题的通用方法是定义虚操作进行复制，我们称将该操作命名为 <tt>clone</tt>。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">To support our handle class, we'll need to add <tt>clone</tt> to each of the types in the hierarchy, starting with the base class, which must define the function as virtual:</p>
	<p class="docText">为了句柄类，需要从基类开始，在继承层次的每个类型中增加 <tt>clone</tt>，基类必须将该函数定义为虚函数：</p>
        <pre>
     class Item_base {
     public:
         virtual Item_base* clone() const
                            { return new Item_base(*this); }
     };
</pre><br>

        <p class="docText">Each class must now redefine the virtual. Because the function exists to generate a new copy of an object of the class, we'll define the return type to reflect the type of the class itself:</p>
        <p class="docText">每个类必须重定义该虚函数。因为函数的存在是为了生成类对象的新副本，所以定义返回类型为类本身：</p>
        <pre>
     class Bulk_item : public Item_base {
     public:
         Bulk_item* clone() const
             { return new Bulk_item(*this); }
     };
</pre><br>

        <p class="docText">On page <a class="docLink" href="ch15lev1sec2.html#ch15lev3sec3" >564</a> we said there is one exception to the requirement that the return type of the derived class must match exactly that of the base class instance. That exception supports cases such as this one. If the base instance of a virtual function returns a reference or pointer to a class type, the derived version of the virtual may return a class <tt>public</tt>ly derived from the class returned by the base class instance (or a pointer or a reference to a class type).</p>
	<p class="docText"><a class="docLink" href="ch15lev1sec2.html#ch15lev3sec3" >第 15.2.3 节</a>介绍过，对于派生类的返回类型必须与基类实例的返回类型完全匹配的要求，但有一个例外。这个例外支持像这个类这样的情况。如果虚函数的基类实例返回类类型的引用或指针，则该虚函数的派生类实例可以返回基类实例返回的类型的派生类（或者是类类型的指针或引用）。</p>

	<a name="ch15lev3sec36"></a>
        <h5 class="docSection3Title">Defining the Handle Constructors</h5>
        <h5 class="docSection3Title">定义句柄构造函数</h5>

        <p class="docText">Once the <tt>clone</tt> function exists, we can write the <tt>Sales_item</tt> constructor:</p>
	<p class="docText">一旦有了 <tt>clone</tt> 函数，就可以这样编写 <tt>Sales_item</tt> 构造函数：</p>
        <pre>
     Sales_item::Sales_item(const Item_base &amp;item):
                 p(item.clone()), use(new std::size_t(1)) { }
</pre><br>

	<a name="idd1e119515"></a>
        <p class="docText">Like the default constructor, this constructor allocates and initializes its use count. It calls <tt>clone</tt> on its parameter to generate a (virtual) copy of that object. If the argument is an <tt>Item_base</tt>, then the <tt>clone</tt> function for <tt>Item_base</tt> is run; if the argument is a <tt>Bulk_item</tt>, then the <tt>Bulk_item clone</tt> is executed.</p>
	<p class="docText">像默认构造函数一样，这个构造函数分配并初始化使用计数，它调用形参的 <tt>clone</tt> 产生那个对象的（虚）副本。如果实参是 <tt>Item_base</tt> 对象，则运行 <tt>Item_base</tt> 的 <tt>clone</tt> 函数；如果实参是 <tt>Bulk_item</tt> 对象，则执行 <tt>Bulk_item</tt> 的 <tt>clone</tt> 函数。</p>

	<a name="ch15sb20"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 15.8.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa13q1"></a><b>Exercise 15.31:</b></td>

                    <td>
                      <p class="docText">Define and implement the <tt>clone</tt> operation for the limited discount class implemented in the exercises for <a class="docLink" href="ch15lev1sec2.html#ch15lev2sec5" >Section 15.2.3</a> (p. <a class="docLink" href="ch15lev1sec2.html#ch15lev2sec5" >567</a>).</p>
		      <p class="docText">为<a class="docLink" href="ch15lev1sec2.html#ch15lev2sec5" >第 15.2.3 节</a>的习题中实现的有限折扣类定义的实现 <tt>clone</tt> 操作。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa13q2"></a><b>Exercise 15.32:</b></td>

                    <td>
                      <p class="docText">In practice, our programs are unlikely to run correctly the first time we run them or the first time we run them against real data. It is often useful to incorporate a debugging strategy into the design of our classes. Implement a virtual <tt>debug</tt> function for our <tt>Item_base</tt> class hierarchy that displays the data members of the respective classes.</p>
		      <p class="docText">实际上，程序不太可能在第一次运行或第一次用真实数据运行时就能正确运行。在类的设计中包括调试策略经常是有用的。为 <tt>Item_base</tt> 类层次实现一个 <tt>debug</tt> 虚函数，显示各个类的数据成员。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa13q3"></a><b>Exercise 15.33:</b></td>

                    <td>
                      <p class="docText">Given the version of the <tt>Item_base</tt> hierarchy that includes the <tt>Disc_item</tt> abstract base class, indicate whether the <tt>Disc_item</tt> class should implement the <tt>clone</tt> function. If not, why not? If so, why?</p>
		      <p class="docText">对于 <tt>Item_base</tt> 层次的包括 <tt>Disc_item</tt> 抽象基类的版本，指出 <tt>Disc_item</tt> 类是否应实现 <tt>clone</tt> 函数，为什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa13q4"></a><b>Exercise 15.34:</b></td>

                    <td>
                      <p class="docText">Modify your debug function to let users turn debugging on or off. Implement the control two ways:</p>
                      <p class="docText">修改调试函数以允许用户打开或关闭调试。用两种方式实现控制：</p>

                      <div style="font-weight:bold">
                        <ol class="docList" type="a">
                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">By defining a parameter to the debug function</p>
			      <p class="docList">通过定义 <tt>debug</tt> 函数的形参。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">By defining a class data member that allows individual objects to turn on or turn off the display of debugging information</p>
                              <p class="docList">通过定义类数据成员。该成员允许个体对象打开或关闭调试信息的显示。</p>
                            </div>
                          </li>
                        </ol>
                      </div>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch15lev2sec23"></a>
        <h4 class="docSection2Title">15.8.3. Using the Handle</h4>
        <h4 class="docSection2Title">15.8.3. 句柄的使用</h4>

        <p class="docText">Using <tt>Sales_item</tt> objects, we could more easily write our bookstore application. Our code wouldn't need to manage pointers to the <tt>Item_base</tt> objects, yet the code would obtain virtual behavior on calls made through a <tt>Sales_item</tt>.</p>
	<p class="docText">使用 <tt>Sales_item</tt> 对象可以更容易地编写书店应用程序。代码将不必管理 <tt>Item_base</tt> 对象的指针，但仍然可以获得通过 <tt>Sales_item</tt> 对象进行的调用的虚行为。</p>

        <p class="docText">As an example, we could use <tt>Item_base</tt> objects to solve the problem proposed in <a class="docLink" href="ch15lev1sec7.html#ch15lev1sec7" >Section 15.7</a> (p. <a class="docLink" href="ch15lev1sec7.html#ch15lev1sec7" >597</a>). We could use <tt>Sales_items</tt> to keep track of the purchases a customer makes, storing a <tt>Sales_item</tt> representing each purchase in a <tt>multiset</tt>. When the customer was done shopping, we would total the sale.</p>
	<p class="docText">例如，可以使用 <tt>Item_base</tt> 对象解决<a class="docLink" href="ch15lev1sec7.html#ch15lev1sec7" >第 15.7 节</a>提出的问题。可以使用 <tt>Sales_item</tt> 对象跟踪顾客所做购买，在 <tt>multiset</tt> 中保存一个对象表示一次购买，当顾客完成购买时，可以计算销售总数。</p>
	
	<a name="ch15lev3sec37"></a>
        <h5 class="docSection3Title">Comparing Two <tt>Sales_items</tt></h5>
	<h5 class="docSection3Title">比较两个 <tt>Sales_item</tt> 对象</h5>

        <p class="docText">Before writing the function to total a sale, we need to define a way to compare <tt>Sales_items</tt>. To use <tt>Sales_item</tt> as the key in an associative container, we must be able to compare them (<a class="docLink" href="ch10lev1sec3.html#ch10lev2sec5" >Section 10.3.1</a>, p. <a class="docLink" href="ch10lev1sec3.html#ch10lev2sec5" >360</a>). By default, the associative containers use the less-than operator on the key type. However, for the same reasons discussed about our original <tt>Sales_item</tt> type in <a class="docLink" href="ch14lev1sec3.html#ch14lev2sec12" >Section 14.3.2</a> (p. <a class="docLink" href="ch14lev1sec3.html#ch14lev2sec12" >520</a>), defining <tt>operator&lt;</tt> for the <tt>Sales_item</tt> handle would be a bad idea: We want to take only the ISBN into account when we use <tt>Sales_item</tt> as a key, but want to consider all data members when determining equality.</p>
	<p class="docText">在编写函数计算销售总数之前，需要定义比较 <tt>Sales_item</tt> 对象的方法。要用 <tt>Sales_item</tt> 作为关联容器的关键字，必须能够比较它们（<a class="docLink" href="ch10lev1sec3.html#ch10lev2sec5" >第 10.3.1 节</a>）。关联容器默认使用关键字类型的小于操作符，但是，基于<a class="docLink" href="ch14lev1sec3.html#ch14lev2sec12" >第 14.3.2 节</a>讨论过的有关原始 <tt>Sales_item</tt> 类型的同样理由，为 <tt>Sales_item</tt> 句柄类定义 <tt>operator&gt;</tt> 可能是个坏主意：当使用 <tt>Sales_item</tt> 作关键字时，只想考虑 ISBN，但确定相等时又想要考虑所有数据成员。</p>

	<a name="idd1e119712"></a><a name="idd1e119717"></a><a name="idd1e119723"></a><a name="idd1e119729"></a><a name="idd1e119735"></a><a name="idd1e119743"></a>
        <p class="docText">Fortunately, the associative containers allow us to specify a function (or function object (<a class="docLink" href="ch14lev1sec8.html#ch14lev1sec8" >Section 14.8</a>, p. <a class="docLink" href="ch14lev1sec8.html#ch14lev1sec8" >530</a>)) to use as the comparison function. We do so similarly to the way we passed a separate function to the <tt>stable_sort</tt> algorithm in <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >Section 11.2.3</a> (p. <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >403</a>). In that case, we needed only to pass an additional argument to <tt>stable_sort</tt> to provide a comparison function to use in place of the <tt>&lt;</tt> operator. Overriding an associative container's comparison function is a bit more complicated because, as we shall see, we must supply the comparison function when we define the container object.</p>
	<p class="docText">幸好，关联容器使我们能够指定一个函数或函数对象（<a class="docLink" href="ch14lev1sec8.html#ch14lev1sec8" >第 14.8 节</a>）用作比较函数，这样做类似于<a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >第 11.2.3 节</a>中将单独函数传给 <tt>stable_sort</tt> 算法的方式。在那种情况下，只需要将附加的实参传给 <tt>stable_sort</tt> 以提供比较函数，代替 <tt>&lt;</tt> 操作符的。覆盖关联容器的比较函数有点复杂，因为，正如我们将看到的，在定义容器对象时必须提供比较函数。</p>

        <p class="docText">Let's start with the easy part, which is to define a function to use to compare <tt>Sales_item</tt> objects:</p>
	<p class="docText">让我们比较容易的部分开始，定义一个函数用于比较 <tt>Sales_item</tt> 对象：</p>
        <pre>
     // <span class="docEmphasis">compare</span> <span class="docEmphItalicAlt">defines item ordering for the</span> <span class="docEmphasis">multiset</span> <span class="docEmphItalicAlt">in</span> <span class="docEmphasis">Basket</span>
     inline bool
     compare(const Sales_item &amp;lhs, const Sales_item &amp;rhs)
     {
         return lhs-&gt;book() &lt; rhs-&gt;book();
     }
</pre><br>

        <p class="docText">Our <tt>compare</tt> function has the same interface as the less-than operator. It returns a <tt>bool</tt> and takes two <tt>const</tt> references to <tt>Sales_items</tt>. It compares the parameters by comparing their ISBNs. This function uses the <tt>Sales_item -&gt;</tt> operator, which returns a pointer to an <tt>Item_base</tt> object. That pointer is used to fetch and run the <tt>book</tt> member, which returns the ISBN.</p>
	<p class="docText">我们的 <tt>compare</tt> 函数与小于操作符有两样的接口，它接受两个 <tt>Sales_item</tt> 对象的 <tt>const</tt> 引用，通过比较 ISBN 而比较形参，返回一个 book 值。该函数使用 <tt>Sales_item</tt> 的 <tt>-&gt;</tt> 操作符，该操作符返回 <tt>Item_base</tt> 对象的指针，那个指针用于获取并运行成员 <tt>book</tt>，该成员返回 ISBN。</p>

	<a name="ch15lev3sec38"></a>
        <h5 class="docSection3Title">Using a Comparator with an Associative Container</h5>
        <h5 class="docSection3Title">使用带关联容器的比较器</h5>

        <p class="docText">If we think a bit about how the comparison function is used, we'll realize that it must be stored as part of the container. The comparison function is used by any operation that adds or finds an element in the container. In principle, each of these operations could take an optional extra argument that represented the comparison function. However, this strategy would be error-prone: If two operations used different comparison functions, then the ordering would be inconsistent. It's impossible to predict what would happen in practice.</p>
        <p class="docText">如果考虑一下如何使用比较函数，就会认识到，它必须作为容器的部分而存储。任何在容器中增加或查找元素的操作都要使用比较函数。原则上，每个这样的操作可以接受一个可选的附加实参，表示比较函数。但是，这种策略容易导致出错：如果两个操作使用不同的比较函数，顺序可能会不一致。不可能预测实际上会发生什么。</p>

        <p class="docText">To work effectively, an associative container needs to use the same comparison function for every operation. Yet, it is unreasonable to expect users to remember the comparison function every time, especially when there is no way to check that each call uses the same comparison function. Therefore, it makes sense for the container to remember the comparison function. By storing the comparator in the container object, we are assured that every operation that compares elements will do so consistently.</p>
        <p class="docText">要有效地工作，关联容器需要对每个操作使用同一比较函数。然而，期望用户每次记住比较函数是不合理的，尤其是，没有办法检查每个调用使用同一比较函数。因此，容器记住比较函数是有意义的。通过将比较器存储在容器对象中，可以保证比较元素的每个操作将一致地进行。</p>

	<a name="idd1e119845"></a><a name="idd1e119849"></a><a name="idd1e119857"></a>
        <p class="docText">For the same reasons that the container needs to know the element type, it needs to know the comparator type in order to store the comparator. In principle, the container could infer this type by assuming that the comparator is pointer to a function that returns a <tt>bool</tt> and takes references to two objects of the <tt>key_type</tt> of the container. Unfortunately, this inferred type would be overly restrictive. For one thing, we should allow the comparator to be a function object as well as a plain function. Even if we were willing to require that the comparator be a function, the inferred type would still be too restrictive. After all, the comparison function might return an <tt>int</tt> or any other type that can be used in a condition. Similarly, the parameter type need not exactly match the <tt>key_type</tt>. Any parameter type that is convertible to the <tt>key_type</tt> should also be allowed.</p>
	<p class="docText">基于同样的理由，容器需要知道元素类型，为了存储比较器，它需要知道比较器类型。原则上，通过假定比较器是一个函数指针，该函数接受两个容器的 <tt>key_type</tt> 类型的对象并返回 <tt>bool</tt> 值，容器可以推断出这个类型。不幸的是，这个推断出的类型可能限制太大。首先，应该允许比较器是函数对象或是普通函数。即使我们愿意要求比较器为函数，这个推断出的类型也可能仍然太受限制了，毕竟，比较函数可以返回 <tt>int</tt> 或者其他任意可用在条件中的类型。同样，形参类型也不需要与 <tt>key_type</tt> 完全匹配，应该允许可以转换为 <tt>key_type</tt> 的任意形参类型。</p>

        <p class="docText">So, to use our <tt>Sales_item</tt> comparison function, we must specify the comparator type when we define the <tt>multiset</tt>. In our case, that type is a function that returns a <tt>bool</tt> and takes two <tt>const Sales_item</tt> references.</p>
	<p class="docText">所以，要使用 <tt>Sales_item</tt> 的比较函数，在定义 <tt>multiset</tt> 时必须指定比较器类型。在我们的例子中，比较器类型是接受两个 <tt>const Sales_item</tt> 引用并返回 <tt>bool</tt> 值的函数。</p>

        <p class="docText">We'll start by defining a typedef that is a synonym for this type (<a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9" >Section 7.9</a>, p. <a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9" >276</a>):</p>
	<p class="docText">首先定义一个类型别名，作为该类型的同义词（<a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9" >第 7.9 节</a>）：</p>
        <pre>
     // <span class="docEmphItalicAlt">type of the comparison function used to order the</span> <span class="docEmphasis">multiset</span>
     typedef bool (*Comp)(const Sales_item&amp;, const Sales_item&amp;);
</pre><br>

        <p class="docText">This statement defines <tt>Comp</tt> as a synonym for the pointer to function type that matches the comparison function we wish to use to compare <tt>Sales_item</tt> objects.</p>
	<p class="docText">这个语句将 <tt>Comp</tt> 定义为函数类型指针的同义词，该函数类型与我们希望用来比较 <tt>Sales_item</tt> 对象的比较函数相匹配。</p>

        <p class="docText">Next we'll need to define a <tt>multiset</tt> that holds objects of type <tt>Sales_item</tt> and that uses this <tt>Comp</tt> type for its comparison function. Each constructor for the associative containers allows us to supply the name of the comparison function. We can define an empty <tt>multiset</tt> that uses our <tt>compare</tt> function as follows:</p>
	<p class="docText">接着需要定义 <tt>multiset</tt>，保存 <tt>Sales_item</tt> 类型的对象并在它的比较函数中使用这个 <tt>Comp</tt> 类型。关联容器的每个构造函数使我们能够提供比较函数的名字。可以这样定义使用 <tt>compare</tt> 函数的空 <tt>multiset</tt>：</p>
        <pre>
     std::multiset&lt;Sales_item, Comp&gt; items(compare);
</pre><br>

        <p class="docText">This definition says that <tt>items</tt> is a <tt>multiset</tt> that holds <tt>Sales_item</tt> objects and uses an object of type <tt>Comp</tt> to compare them. The <tt>multiset</tt> is emptywe supplied no elementsbut we did supply a comparison function named <tt>compare</tt>. When we add or look for elements in <tt>items</tt> our <tt>compare</tt> function will be used to order the <tt>multiset</tt>.</p>
	<p class="docText">这个定义是说，<tt>items</tt> 是一个 <tt>multiset</tt>，它保存 <tt>Sales_item</tt> 对象并使用 <tt>Comp</tt> 类型的对象比较它们。<tt>multiset</tt> 是空的——我们没有提供任何元素，但我们的确提供了一个名为 <tt>compare</tt> 的比较函数。当在 <tt>items</tt> 中增加或查找元素时，将用 <tt>compare</tt> 函数对 <tt>multiset</tt> 进行排序。</p>

	<a name="ch15lev3sec39"></a>
        <h5 class="docSection3Title">Containers and Handle Classes</h5>
        <h5 class="docSection3Title">容器与句柄类</h5>

        <p class="docText">Now that we know how to supply a comparison function, we'll define a class, named <tt>Basket</tt>, to keep track of a sale and calculate the purchase price:</p>
	<p class="docText">既然知道了怎样提供比较函数，我们将定义名为 <tt>Basker</tt> 的类，以跟踪销售并计算购买价格：</p>
        <pre>
     class Basket {
         // <span class="docEmphItalicAlt">type of the comparison function used to order the</span> <span class="docEmphasis">multiset</span>
         typedef bool (*Comp)(const Sales_item&amp;, const Sales_item&amp;);
     public:
         // <span class="docEmphItalicAlt">make it easier to type the type of our</span> <span class="docEmphasis">set</span>
         typedef std::multiset&lt;Sales_item, Comp&gt; set_type;
         // <span class="docEmphItalicAlt">typedefs modeled after corresponding container types</span>
         typedef set_type::size_type size_type;
         typedef set_type::const_iterator const_iter;
         Basket(): items(compare) { } // <span class="docEmphItalicAlt">initialze the comparator</span>
         void add_item(const Sales_item &amp;item)
                             { items.insert(item); }
         size_type size(const Sales_item &amp;i) const
                              { return items.count(i); }
         double total() const; // <span class="docEmphItalicAlt">sum of net prices for all items in the basket</span>
     private:
         std::multiset&lt;Sales_item, Comp&gt; items;
     };
</pre><br>

	<a name="idd1e120018"></a>
        <p class="docText">This class holds the customer's purchases in a <tt>multiset</tt> of <tt>Sales_item</tt> objects. We use a <tt>multiset</tt> to allow the customer to buy multiple copies of the same book.</p>
	<p class="docText">这个类在 <tt>Sales_item</tt> 对象的 <tt>multiple</tt> 中保存顾客购买的商品，用 <tt>multiple</tt> 使顾客能够购买同一本书的多个副本。</p>

        <p class="docText">The class defines a single constructor, the <tt>Basket</tt> default constructor. The class needs its own default constructor to pass <tt>compare</tt> to the <tt>multiset</tt> constructor that builds the <tt>items</tt> member.</p>
	<p class="docText">该类定义了一个构造函数，即 <tt>Basket</tt> 默认构造函数。该类需要自己的默认构造函数，以便将 <tt>compare</tt> 传给建立 <tt>items</tt> 成员的 <tt>multiset</tt> 构造函数。</p>

        <p class="docText">The operations that the <tt>Basket</tt> class defines are fairly simple: <tt>add_item</tt> takes a reference to a <tt>Sales_item</tt> and puts a copy of that item into the <tt>multiset</tt>; <tt>item_count</tt> returns the number of records for this ISBN in the basket for a given ISBN. In addition to the operations, <tt>Basket</tt> defines three typedefs to make it easier to use its <tt>multiset</tt> member.</p>
	<p class="docText"><tt>Basket</tt> 类定义的操作非常简单：<tt>add_item</tt> 操作接受 <tt>Sales_item</tt> 对象引用并将该项目的副本放入 <tt>multiset</tt>；对于给定 ISBN，<tt>size</tt> 操作返回购物篮中该 ISBN 的记录数。除了操作，<tt>Basket</tt> 还定义了三个类型别名，这样使用它的 <tt>multiset</tt> 成员就比较容易了。</p>

	<a name="ch15lev3sec40"></a>
        <h5 class="docSection3Title">Using the Handle to Execute a Virtual Function</h5>
        <h5 class="docSection3Title">使用句柄执行虚函数</h5>

        <p class="docText">The only complicated member of class <tt>Basket</tt> is the <tt>total</tt> function, which returns the price for all the items in the basket:</p>
	<p class="docText"><tt>Basket</tt> 类唯一的复杂成员是 <tt>total</tt> 函数，该函数返回购物篮中所有物品的价格：</p>
        <pre>
     double Basket::total() const
     {
         double sum = 0.0; // <span class="docEmphItalicAlt">holds the running total</span>

         /* <span class="docEmphItalicAlt">find each set of items with the same</span> <span class="docEmphasis">isbn</span> <span class="docEmphItalicAlt">and calculate</span>
          * <span class="docEmphItalicAlt">the net price for that quantity of items</span>
          * <span class="docEmphasis">iter</span> <span class="docEmphItalicAlt">refers to first copy of each book in the set</span>
          * <span class="docEmphasis">upper_bound</span> <span class="docEmphItalicAlt">refers to next element with a different</span> <span class="docEmphasis">isbn</span>
          */
          for (const_iter iter = items.begin();
                                 iter != items.end(); iter =
                                 items.upper_bound(*iter))
     {
              // <span class="docEmphItalicAlt">we know there's at least one element with this key in the</span> <span class="docEmphasis">Basket</span>
              // <span class="docEmphItalicAlt">virtual call to</span> <span class="docEmphasis">net_price</span> <span class="docEmphItalicAlt">applies appropriate discounts, if any</span>
              sum += (*iter)-&gt;net_price(items.count(*iter));
          }
          return sum;
     }
</pre><br>

        <p class="docText">The <tt>total</tt> function has two interesting parts: the call to the <tt>net_price</tt> function, and the structure of the <tt>for</tt> loop. We'll look at each in turn.</p>
	<p class="docText"><tt>total</tt> 函数有两个有趣的部分：对 <tt>net_price</tt> 函数的调用，以及 <tt>for</tt> 循环结构。我们逐一进行分析。</p>

        <p class="docText">When we call <tt>net_price</tt>, we need to tell it how many copies of a given book are being purchased. The <tt>net_price</tt> function uses this argument to determine whether the purchase qualifies for a discount. This requirement implies that we'd like to process the <tt>multiset</tt> in chunksprocessing all the records for a given title in one chunk and then the set of those for the next title and so on. Fortunately, <tt>multiset</tt> is well suited to this problem.</p>
	<p class="docText">调用 <tt>net_price</tt> 函数时，需要告诉它某本书已经购买了多少本，<tt>net_price</tt> 函数使用这个实参确定是否打折。这个要求暗示着我们希望成批处理 <tt>multiset</tt>——处理给定标题的所有记录，然后处理下一个标题的所有记录，以此类推。幸好，<tt>multiset</tt> 非常适合处理这个问题。</p>

        <p class="docText">Our <tt>for</tt> loop starts by defining and initializing <tt>iter</tt> to refer to the first element in the <tt>multiset</tt>. We use the <tt>multiset count</tt> member (<a class="docLink" href="ch10lev1sec3.html#ch10lev2sec10" >Section 10.3.6</a>, p. <a class="docLink" href="ch10lev1sec3.html#ch10lev2sec10" >367</a>) to determine how many elements in the <tt>multiset</tt> have the same key (e.g., same <tt>isbn</tt>) and use that number as the argument to the call to <tt>net_price</tt>.</p>
	<p class="docText"><tt>for</tt> 循环开始于定义 <tt>iter</tt> 并将 <tt>iter</tt> 初始化为指向 <tt>multiset</tt> 中的第一个元素。我们使用 <tt>multiset</tt> 的 <tt>count</tt> 成员（<a class="docLink" href="ch10lev1sec3.html#ch10lev2sec10" >第 10.3.6 节</a>）确定 <tt>multiset</tt> 中的多少成员具有相同的键（即，相同的 <tt>isbn</tt>），并且使用该数目作为实参调用 <tt>net_price</tt> 函数。</p>

	<a name="idd1e120208"></a><a name="idd1e120218"></a><a name="idd1e120226"></a><a name="idd1e120232"></a>
        <p class="docText">The interesting bit is the "increment" expression in the <tt>for</tt>. Rather than the usual loop that reads each element, we advance <tt>iter</tt> to refer to the next key. We skip over all the elements that match the current key by calling <tt>upper_bound</tt> (<a class="docLink" href="ch10lev1sec5.html#ch10lev2sec17" >Section 10.5.2</a>, p. <a class="docLink" href="ch10lev1sec5.html#ch10lev2sec17" >377</a>). The call to <tt>upper_bound</tt> returns the iterator that refers to the element just past the last one with the same key as in <tt>iter</tt>. That iterator we get back denotes either the end of the set or the next unique book. We test the new value of <tt>iter</tt>. If <tt>iter</tt> is equal to <tt>items.end()</tt>, we drop out of the <tt>for</tt>. Otherwise, we process the next book.</p>
	<p class="docText"><tt>for</tt> 循环中的“增量”表达式很有意思。与读每个元素的一般循环不同，我们推进 <tt>iter</tt> 指向下一个键。调用 <tt>upper_bound</tt> 函数以跳过与当前键匹配的所有元素，<tt>upper_bound</tt> 函数的调用返回一个迭代器，该迭代器指向与 <tt>iter</tt> 键相同的最后一个元素的下一元素，即，该迭代器指向集合的末尾或下一本书。测试 <tt>iter</tt> 的新值，如果与 <tt>items.end()</tt> 相等，则跳出 <tt>for</tt> 循环，否则，就处理下一本书。</p>

        <p class="docText">The body of the <tt>for</tt> calls the <tt>net_price</tt> function. That call can be a bit tricky to read:</p>
	<p class="docText"><tt>for</tt> 循环的循环体调用 <tt>net_price</tt> 函数，阅读这个调用需要一点技巧：</p>
        <pre>
     sum += (*iter)-&gt;net_price(items.count(*iter));
</pre><br>

        <p class="docText">We dereference <tt>iter</tt> to get the underlying <tt>Sales_item</tt> to which we apply the overloaded arrow operator from the <tt>Sales_item</tt> class. That operator returns the underlying <tt>Item_base</tt> object to which the handle is attached. From that object we call <tt>net_price</tt>, passing the <tt>count</tt> of items with the same <tt>isbn</tt>. The <tt>net_price</tt> function is virtual, so the version of the pricing function that is called depends on the type of the underlying <tt>Item_base</tt> object.</p>
	<p class="docText">对 <tt>iter</tt> 解引用获得基础 <tt>Sales_item</tt> 对象，对该对象应用 <tt>Sales_item</tt> 类重载的箭头操作符，该操作符返回句柄所关联的基础 <tt>Item_base</tt> 对象，用该 <tt>Item_base</tt> 对象调用 <tt>net_price</tt> 函数，传递具有相同 <tt>isbn</tt> 的图书的 <tt>count</tt> 作为实参。<tt>net_price</tt> 是虚函数，所以调用的定价函数的版本取决于基础 <tt>Item_base</tt> 对象的类型。</p>

	<a name="ch15sb21"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 15.8.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa14q1"></a><b>Exercise 15.35:</b></td>

                    <td>
                      <p class="docText">Write your own version of the <tt>compare</tt> function and <tt>Basket</tt> class and use them to manage a sale.</p>
		      <p class="docText">编写自己的 <tt>compare</tt> 函数和 <tt>Basket</tt> 类的版本并使用它们管理销售。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa14q2"></a><b>Exercise 15.36:</b></td>

                    <td>
                      <p class="docText">What is the underlying type of <tt>Basket::const_iter?</tt></p>
		      <p class="docText"><tt>Basket::const_iter</tt> 的基础类型是什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa14q3"></a><b>Exercise 15.37:</b></td>

                    <td>
                      <p class="docText">Why did we define the <tt>Comp</tt> typedef in the <tt>private</tt> part of <tt>Basket</tt>?</p>
		      <p class="docText">为什么在 <tt>Basket</tt> 的 <tt>private</tt> 部分定义 <tt>Comp</tt> 类型别名？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch15qa14q4"></a><b>Exercise 15.38:</b></td>

                    <td>
                      <p class="docText">Why did we define two <tt>private</tt> sections in <tt>Basket</tt>?</p>
		      <p class="docText">为什么在 <tt>Basket</tt> 中定义两个 <tt>private</tt> 部分？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch15lev1sec7.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch15lev1sec9.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
