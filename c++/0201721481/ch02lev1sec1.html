<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 2.1.  Primitive Built-in Types</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch02.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch02lev1sec2.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch02lev1sec1"></a>

        <h3 class="docSection1Title">2.1. Primitive Built-in Types</h3>
        <h3 class="docSection1Title">2.1. 基本内置类型</h3>

<a name="ch02term3"></a><a name="ch02term61"></a>
        <p class="docText">C++ defines a set of <b><a class="docLink" href="ch02lev1sec11.html#gloss02_03" >arithmetic types</a></b>, which represent integers, floating-point numbers, and individual characters and boolean values. In addition, there is a special type named <b><a class="docLink" href="ch02lev1sec11.html#gloss02_61" ><span class="docEmphStrong"><tt>void</tt></span></a></b>. The <tt>void</tt> type has no associated values and can be used in only a limited set of circumstances. The <tt>void</tt> type is most often used as the return type for a function that has no return value.</p>
	<p class="docText">C++ 定义了一组表示整数、浮点数、单个字符和布尔值的<b><a class="docLink" href="ch02lev1sec11.html#gloss02_03" >算术类型</a></b>，另外还定义了一种称为 <b><a class="docLink" href="ch02lev1sec11.html#gloss02_61" ><span class="docEmphStrong"><tt>void</tt></span></a></b> 的特殊类型。<tt>void</tt> 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。</p>

        <p class="docText">The size of the arithmetic types varies across machines. By size, we mean the number of bits used to represent the type. The standard guarantees a minimum size for each of the arithmetic types, but it does not prevent compilers from using larger sizes. Indeed, almost all compilers use a larger size for <tt>int</tt> than is strictly required. <a class="docLink" href="ch02lev1sec1.html#ch02table01">Table 2.1</a> (p. <a class="docLink" href="ch02lev1sec1.html#ch02table01">36</a>) lists the built-in arithmetic types and the associated minimum sizes.</p>
        <p class="docText">算术类型的存储空间依机器而定。这里的存储空间是指用来表示该类型的位（bit）数。C++标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间。事实上，对于int类型，几乎所有的编译器使用的存储空间都比所要求的大。<tt>int</tt><a class="docLink" href="ch02lev1sec1.html#ch02table01">表 2.1</a> 列出了内置算术类型及其对应的最小存储空间。</p>

<a name="ch02table01"></a>
        <h5 class="docTableTitle">Table 2.1. C++: Arithmetic Types</h5>
        <h5 class="docTableTitle">表 2.1. C++ 算术类型</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="groups" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="200">
            <col width="150">
          </colgroup>

          <thead>
            <tr>
              <th class="bottomBorder thead" scope="col" align="left" valign="top">
                <p class="docText">Type</p>
                <p class="docText">类型</p>
              </th>

              <th class="bottomBorder thead" scope="col" align="left" valign="top">
                <p class="docText">Meaning</p>
                <p class="docText">含义</p>
              </th>

              <th class="bottomBorder thead" scope="col" align="left" valign="top">
                <p class="docText">Minimum Size</p>
                <p class="docText">最小存储空间</p>
              </th>
            </tr>
          </thead>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bool</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">boolean</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">NA</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>char</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">character</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">8 bits</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>wchar_t</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">wide character</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">16 bits</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>short</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">short integer</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">16 bits</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>int</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">integer</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">16 bits</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>long</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">long integer</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">32 bits</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>float</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">single-precision floating-point</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">6 significant digits</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>double</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">double-precision floating-point</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">10 significant digits</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>long double</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">extended-precision floating-point</p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">10 significant digits</p>
            </td>
          </tr>
        </table><br>
        <a name="ch02note01"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Because the number of bits varies, the maximum (or minimum) values that these types can represent also vary by machine.</p>
                <p class="docText">因为位数的不同，这些类型所能表示的最大（最小）值也因机器的不同而有所不同。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch02lev2sec1"></a>
        <h4 class="docSection2Title">2.1.1. Integral Types</h4>
        <h4 class="docSection2Title">2.1.1. 整型</h4>

<a name="ch02term27"></a>
        <p class="docText">The arithmetic types that represent integers, characters, and boolean values are collectively referred to as the <b><a class="docLink" href="ch02lev1sec11.html#gloss02_27" >integral types</a></b>.</p>
        <p class="docText">表示整数、字符和布尔值的算术类型合称为<b><a class="docLink" href="ch02lev1sec11.html#gloss02_27" >整型</a></b>。</p>

        <p class="docText">There are two character types: <tt>char</tt> and <tt>wchar_t</tt>. The <tt>char</tt> type is guaranteed to be big enough to hold numeric values that correspond to any character in the machine's basic character set. As a result, <tt>char</tt>s are usually a single machine byte. The <tt>wchar_t</tt> type is used for extended character sets, such as those used for Chinese and Japanese, in which some characters cannot be represented within a single <tt>char</tt>.</p>
	<p class="docText">字符类型有两种：<tt>char</tt> 和 <tt>wchar_t</tt>。<tt>char</tt> 类型保证了有足够的空间，能够存储机器基本字符集中任何字符相应的数值，因此，<tt>char</tt> 类型通常是单个机器字节（byte）。<tt>wchar_t</tt> 类型用于扩展字符集，比如汉字和日语，这些字符集中的一些字符不能用单个 <tt>char</tt> 表示。</p>

<a name="ch02term62"></a><a name="idd1e6872"></a><a name="idd1e6875"></a><a name="idd1e6879"></a><a name="idd1e6882"></a><a name="idd1e6886"></a><a name="idd1e6890"></a>
        <p class="docText">The types <tt>short, int</tt>, and <tt>long</tt> represent integer values of potentially different sizes. Typically, <tt>short</tt>s are represented in half a machine <span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_62" >word</a></span>, <tt>int</tt>s in a machine word, and <tt>long</tt>s in either one or two machine words (on 32-bit machines, <tt>int</tt>s and <tt>longs</tt> are usually the same size).</p>
	<p class="docText"> <tt>short</tt>、<tt>int</tt> 和 <tt>long</tt> 类型都表示整型值，存储空间的大小不同。一般， <tt>short</tt> 类型为半个<span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_62" >机器字</a></span>长，<tt>int</tt> 类型为一个机器字长，而 <tt>long</tt> 类型为一个或两个机器字长（在 32 位机器中 <tt>int</tt> 类型和 <tt>long</tt> 类型通常字长是相同的）。</p>

<a name="ch02sb01"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Machine-Level Representation of The Built-in Types</h2>
              <h2 class="docSidebarTitle">内置类型的机器级表示 </h2>

              <p class="docText"><span class="docEmphStrong">The C++ built-in types are closely tied to their representation in the computer's memory. Computers store data as a sequence of bits, each of which holds either 0 or 1. A segment of memory might hold</span></p>
              <p class="docText"><span class="docEmphStrong">C++ 的内置类型与其在计算机的存储器中的表示方式紧密相关。计算机以位序列存储数据，每一位存储 0 或 1。一段内存可能存储着</span></p>
              <pre>
     00011011011100010110010000111011 ...
</pre><br>

              <p class="docText"><span class="docEmphStrong">At the bit level, memory has no structure and no meaning.</span></p>
              <p class="docText"><span class="docEmphStrong">在位这一级上，存储器是没有结构和意义的。</span></p>

              <p class="docText"><span class="docEmphStrong">The most primitive way we impose structure on memory is by processing it in chunks. Most computers deal with memory as chunks of bits of particular sizes, usually powers of 2. They usually make it easy to process 8, 16, or 32 bits at a time, and chunks of 64 and 128 bits are becoming more common. Although the exact sizes can vary from one machine to another, we usually refer to a chunk of 8 bits as a "byte" and 32 bits, or 4 bytes, as a "word."</span></p>
              <p class="docText"><span class="docEmphStrong">让存储具有结构的最基本方法是用块（chunk）处理存储。大部分计算机都使用特定位数的块来处理存储，块的位数一般是 2 的幂，因为这样可以一次处理 8、16 或 32 位。64 和 128 位的块如今也变得更为普遍。虽然确切的大小因机器不同而不同，但是通常将 8 位的块作为一个字节，32 位或 4 个字节作为一个“字（word）”。</span></p>

<a name="ch02term2"></a><a name="ch02term5"></a>
              <p class="docText"><span class="docEmphStrong">Most computers associate a numbercalled an <b><a class="docLink" href="ch02lev1sec11.html#gloss02_02" >address</a></b>with each <span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_05" >byte</a></span> in memory. Given a machine that has 8-bit bytes and 32-bit words, we might represent a word of memory as follows:</span></p>
              <p class="docText"><span class="docEmphStrong"><b>大多数计算机将存储器中的每一个字节和一个称为<a class="docLink" href="ch02lev1sec11.html#gloss02_02" >地址</a></b>的数关联起来。对于一个 8 位<span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_05" >字节</a></span>和 32 位字的机器，我们可以将存储器的字表示如下：</span></p>

              <table cellspacing="0" class="allBorders" border="1" rules="rows" cellpadding="4">
                <colgroup>
                  <col width="100">
                  <col width="50">
                  <col width="50">
                  <col width="50">
                  <col width="50">
                  <col width="50">
                  <col width="50">
                  <col width="50">
                  <col width="50">
                </colgroup>

                <tr>
                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText"><span class="docEmphStrong">736424</span></p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>
                </tr>

                <tr>
                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText"><span class="docEmphStrong">736425</span></p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>
                </tr>

                <tr>
                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText"><span class="docEmphStrong">736426</span></p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>
                </tr>

                <tr>
                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText"><span class="docEmphStrong">736427</span></p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">0</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>

                  <td class="docTableCell" align="left" valign="top">
                    <p class="docText">1</p>
                  </td>
                </tr>
              </table><br>

              <p class="docText"><span class="docEmphStrong">In this illustration, each byte's address is shown on the left, with the 8 bits of the byte following the address.</span></p>
              <p class="docText"><span class="docEmphStrong">在这个图中，左边是字节的地址，地址后面为字节的 8 位。</span></p>

              <p class="docText"><span class="docEmphStrong">We can use an address to refer to any of several variously sized collections of bits starting at that address. It is possible to speak of the word at address 736424 or the byte at address 736426. We can say, for example, that the byte at address 736425 is not equal to the byte at address 736427.</span></p>
              <p class="docText"><span class="docEmphStrong">可以用地址表示从该地址开始的任何几个不同大小的位集合。可以说地址为 736424 的字，也可以说地址为 736426 的字节。例如，可以说地址为736425的字节和地址为 736427 的字节不相等。</span></p>

              <p class="docText"><span class="docEmphStrong">To give meaning to the byte at address 736425, we must know the type of the value stored there. Once we know the type, we know how many bits are needed to represent a value of that type and how to interpret those bits.</span></p>
              <p class="docText"><span class="docEmphStrong">要让地址为 736425 的字节具有意义，必须要知道存储在该地址的值的类型。一旦知道了该地址的值的类型，就知道了表示该类型的值需要多少位和如何解释这些位。</span></p>

              <p class="docText"><span class="docEmphStrong">If we know that the byte at location 736425 has type "unsigned 8-bit integer," then we know that the byte represents the number 112. On the other hand, if that byte is a character in the ISO-Latin-1 character set, then it represents the lower-case letter q. The bits are the same in both cases, but by ascribing different types to them, we interpret them differently.</span></p>
              <p class="docText"><span class="docEmphStrong">如果知道地址为 736425 的字节的类型是8位无符号整数，那么就可以知道该字节表示整数 112。另外，如果这个字节是 ISO-Latin-1 字符集中的一个字符，那它就表示小写字母 q。虽然两种情况的位相同，但归属于不同类型，解释也就不同。</span></p>
            </td>
          </tr>
        </table><br>

        <p class="docText">The type <tt>bool</tt> represents the truth values, <tt>true</tt> and <tt>false</tt>. We can assign any of the arithmetic types to a <tt>bool</tt>. An arithmetic type with value 0 yields a <tt>bool</tt> that holds <tt>false</tt>. Any nonzero value is treated as <tt>true</tt>.</p>
	<p class="docText"><tt>bool</tt> 类型表示真值 <tt>true</tt> 和 <tt>false</tt>。可以将算术类型的任何值赋给 <tt>bool</tt> 对象。0 值算术类型代表 <tt>false</tt>，任何非 0 的值都代表 <tt>true</tt>。</p>

<a name="ch02lev3sec1"></a>
        <h5 class="docSection3Title">Signed and Unsigned Types</h5>
        <h5 class="docSection3Title">带符号和无符号类型</h5>

<a name="ch02term51"></a><a name="ch02term59"></a><a name="idd1e7178"></a><a name="idd1e7189"></a><a name="idd1e7198"></a><a name="idd1e7205"></a><a name="idd1e7213"></a><a name="idd1e7221"></a>
        <p class="docText">The integral types, except the boolean type, may be either <b><a class="docLink" href="ch02lev1sec11.html#gloss02_51" >signed</a></b> or <b><a class="docLink" href="ch02lev1sec11.html#gloss02_59" >unsigned</a></b>. As its name suggests, a signed type can represent both negative and positive numbers (including zero), whereas an <tt>unsigned</tt> type represents only values greater than or equal to zero.</p>
	<p class="docText">除 <tt>bool</tt> 类型外，整型可以是<b><a class="docLink" href="ch02lev1sec11.html#gloss02_51" >带符号的（signed）</a></b>也可以是<b><a class="docLink" href="ch02lev1sec11.html#gloss02_59" >无符号的（unsigned）</a></b>。顾名思义，带符号类型可以表示正数也可以表示负数（包括 0），而无符号型只能表示大于或等于 0 的数。</p>

        <p class="docText">The integers, <tt>int, short</tt>, and <tt>long</tt>, are all signed by default. To get an unsigned type, the type must be specified as <tt>unsigned</tt>, such as <tt>unsigned long</tt>. The <tt>unsigned int</tt> type may be abbreviated as <tt>unsigned</tt>. That is, <tt>unsigned</tt> with no other type implies <tt>unsigned int</tt>.</p>
	<p class="docText">整型 <tt>int</tt>、<tt>short</tt> 和 <tt>long</tt> 都默认为带符号型。要获得无符号型则必须指定该类型为 <tt>unsigned</tt>，比如 <tt>unsigned long</tt>。<tt>unsigned int</tt> 类型可以简写为 <tt>unsigned</tt>，也就是说，<tt>unsigned</tt> 后不加其他类型说明符意味着是 <tt>unsigned int</tt> 。</p>

        <p class="docText">Unlike the other integral types, there are three distinct types for <tt>char</tt>: plain <tt>char, signed char</tt>, and <tt>unsigned char</tt>. Although there are three distinct types, there are only two ways a <tt>char</tt> can be represented. The <tt>char</tt> type is respresented using either the <tt>signed char</tt> or <tt>unsigned char</tt> version. Which representation is used for <tt>char</tt> varies by compiler.</p>
	<p class="docText">和其他整型不同，<tt>char</tt> 有三种不同的类型：<tt>plain char</tt> 、<tt>unsigned char</tt> 和 <tt>signed char</tt>。虽然 <tt>char</tt> 有三种不同的类型，但只有两种表示方式。可以使用 <tt>unsigned char</tt> 或 </tt>signed char</tt> 表示 <tt>char</tt> 类型。使用哪种 <tt>char</tt> 表示方式由编译器而定。</p>

<a name="ch02lev3sec2"></a>
        <h5 class="docSection3Title">How Integral Values Are Represented</h5>
        <h5 class="docSection3Title">整型值的表示</h5>

        <p class="docText">In an <tt>unsigned</tt> type, all the bits represent the value. If a type is defined for a particular machine to use 8 bits, then the <tt>unsigned</tt> version of this type could hold the values 0 through 255.</p>
	<p class="docText">无符号型中，所有的位都表示数值。如果在某种机器中，定义一种类型使用 8 位表示，那么这种类型的 <tt>unsigned</tt> 型可以取值 0 到 255。</p>

        <p class="docText">The C++ standard does not define how <tt>signed</tt> types are represented at the bit level. Instead, each compiler is free to decide how it will represent <tt>signed</tt> types. These representations can affect the range of values that a <tt>signed</tt> type can hold. We are guaranteed that an 8-bit <tt>signed</tt> type will hold at least the values from 127 through 127; many implementations allow values from 128 through 127.</p>
	<p class="docText">C++ 标准并未定义 <tt>signed</tt> 类型如何用位来表示，而是由每个编译器自由决定如何表示 <tt>signed</tt> 类型。这些表示方式会影响 <tt>signed</tt> 类型的取值范围。8 位 <tt>signed</tt> 类型的取值肯定至少是从 -127 到 127，但也有许多实现允许取值从 -128 到 127。</p>

        <p class="docText">Under the most common strategy for representing <tt>signed</tt> integral types, we can view one of the bits as a sign bit. Whenever the sign bit is 1, the value is negative; when it is 0, the value is either 0 or a positive number. An 8-bit integral <tt>signed</tt> type represented using a sign-bit can hold values from 128 through 127.</p>
	<p class="docText">表示 <tt>signed</tt> 整型类型最常见的策略是用其中一个位作为符号位。符号位为 1，值就为负数；符号位为 0，值就为 0 或正数。一个 <tt>signed</tt> 整型取值是从 -128 到 127。</p>

<a name="ch02lev3sec3"></a>
        <h5 class="docSection3Title">Assignment to Integral Types</h5>
        <h5 class="docSection3Title">整型的赋值</h5>

<a name="idd1e7331"></a><a name="idd1e7340"></a><a name="idd1e7349"></a><a name="idd1e7359"></a><a name="idd1e7369"></a><a name="idd1e7373"></a><a name="idd1e7380"></a><a name="idd1e7384"></a><a name="idd1e7387"></a><a name="idd1e7390"></a><a name="idd1e7394"></a><a name="idd1e7401"></a><a name="idd1e7413"></a>
        <p class="docText">The type of an object determines the values that the object can hold. This fact raises the question of what happens when one tries to assign a value outside the allowable range to an object of a given type. The answer depends on whether the type is <tt>signed</tt> or <tt>unsigned</tt>.</p>
	<p class="docText">对象的类型决定对象的取值。这会引起一个疑问：当我们试着把一个超出其取值范围的值赋给一个指定类型的对象时，结果会怎样呢？答案取决于这种类型是 <tt>signed</tt> 还是 <tt>unsigned</tt> 的。</p>

        <p class="docText">For <tt>unsigned</tt> types, the compiler <span class="docEmphasis">must</span> adjust the out-of-range value so that it will fit. The compiler does so by taking the remainder of the value modulo the number of distinct values the <tt>unsigned</tt> target type can hold. An object that is an 8-bit <tt>unsigned char</tt>, for example, can hold values from 0 through 255 inclusive. If we assign a value outside this range, the compiler actually assigns the remainder of the value modulo 256. For example, we might attempt to assign the value 336 to an 8-bit <tt>signed char</tt>. If we try to store 336 in our 8-bit <tt>unsigned char</tt>, the actual value assigned will be 80, because 80 is equal to 336 modulo 256.</p>
	<p class="docText">对于 <tt>unsigned</tt> 类型来说，编译器必须调整越界值使其满足要求。编译器会将该值对 <tt>unsigned</tt> 类型的可能取值数目求模，然后取所得值。比如 8 位的 <tt>unsigned char</tt>，其取值范围从 0 到 255（包括 255）。如果赋给超出这个范围的值，那么编译器将会取该值对 256 求模后的值。例如，如果试图将 336 存储到 8 位的 <tt>unsigned char</tt> 中，则实际赋值为 80，因为 80 是 336 对 256 求模后的值。</p>

        <p class="docText">For the <tt>unsigned</tt> types, a negative value is always out of range. An object of <tt>unsigned</tt> type may never hold a negative value. Some languages make it illegal to assign a negative value to an <tt>unsigned</tt> type, but C++ does not.</p>
	<p class="docText">对于 <tt>unsigned</tt> 类型来说，负数总是超出其取值范围。<tt>unsigned</tt> 类型的对象可能永远不会保存负数。有些语言中将负数赋给 <tt>unsigned</tt> 类型是非法的，但在 C++ 中这是合法的。</p>

<a name="ch02note02"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">In C++ it is perfectly legal to assign a negative number to an object with <tt>unsigned</tt> type. The result is the negative value modulo the size of the type. So, if we assign 1 to an 8-bit <tt>unsigned char</tt>, the resulting value will be 255, which is 1 modulo 256.</p>
		<p class="docText">C++ 中，把负值赋给 <tt>unsigned</tt> 对象是完全合法的，其结果是该负数对该类型的取值个数求模后的值。所以，如果把 -1 赋给8位的 <tt>unsigned char</tt>，那么结果是 255，因为 255 是 -1 对 256 求模后的值。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">When assigning an out-of-range value to a <tt>signed</tt> type, it is up to the compiler to decide what value to assign. In practice, many compilers treat <tt>signed</tt> types similarly to how they are required to treat <tt>unsigned</tt> types. That is, they do the assignment as the remainder modulo the size of the type. However, we are not guaranteed that the compiler will do so for the <tt>signed</tt> types.</p>
	<p class="docText">当将超过取值范围的值赋给 <tt>signed</tt> 类型时，由编译器决定实际赋的值。在实际操作中，很多的编译器处理 <tt>signed</tt> 类型的方式和 <tt>unsigned</tt> 类型类似。也就是说，赋值时是取该值对该类型取值数目求模后的值。然而我们不能保证编译器都会这样处理 <tt>signed</tt> 类型。</p>

<a name="ch02lev2sec2"></a>
        <h4 class="docSection2Title">2.1.2. Floating-Point Types</h4>
        <h4 class="docSection2Title">2.1.2. 浮点型</h4>

        <p class="docText">The types <tt>float, double</tt>, and <tt>long double</tt> represent floating-point single-, double-, and extended-precision values. Typically, <tt>float</tt>s are represented in one word (32 bits), <tt>double</tt>s in two words (64 bits), and <tt>long double</tt> in either three or four words (96 or 128 bits). The size of the type determines the number of significant digits a floating-point value might contain.</p>
	<p class="docText">类型 <tt>float</tt>、 <tt>double</tt> 和 <tt>long double</tt> 分别表示单精度浮点数、双精度浮点数和扩展精度浮点数。一般 <tt>float</tt> 类型用一个字（32 位）来表示，<tt>double</tt> 类型用两个字（64 位）来表示，<tt>long double</tt> 类型用三个或四个字（96 或 128 位）来表示。类型的取值范围决定了浮点数所含的有效数字位数。</p>

<a name="ch02note03"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The <tt>float</tt> type is usually not precise enough for real programs<tt>float</tt> is guaranteed to offer only 6 significant digits. The <tt>double</tt> type guarantees at least 10 significant digits, which is sufficient for most calculations.</p>
		<p class="docText">对于实际的程序来说，<tt>float</tt> 类型精度通常是不够的——<tt>float</tt> 型只能保证 6 位有效数字，而 <tt>double</tt> 型至少可以保证 10 位有效数字，能满足大多数计算的需要。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
      </td>
    </tr>
  </table>

	<a name="ch02sb02"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
	    <h2 class="docSidebarTitle">Advice: Using the Built-in Arithmetic Types</h2>
	    <h2 class="docSidebarTitle">建议：使用内置算术类型</h2>

<a name="idd1e7573"></a><a name="idd1e7576"></a><a name="idd1e7588"></a><a name="idd1e7594"></a><a name="idd1e7599"></a><a name="idd1e7613"></a><a name="idd1e7619"></a><a name="idd1e7636"></a><a name="idd1e7646"></a><a name="idd1e7662"></a><a name="idd1e7671"></a><a name="idd1e7676"></a>
              <p class="docText"><span class="docEmphStrong">The number of integral types in C++ can be bewildering. C++, like C, is designed to let programs get close to the hardware when necessary, and the integral types are defined to cater to the peculiarities of various kinds of hardware. Most programmers can (and should) ignore these complexities by restricting the types they actually use.</span></p>
              <p class="docText"><span class="docEmphStrong">C++ 中整型数有点令人迷惑不解。就像 C 语言一样，C++ 被设计成允许程序在必要时直接处理硬件，因此整型被定义成满足各种各样硬件的特性。大多数程序员可以（应该）通过限制实际使用的类型来忽略这些复杂性。</span></p>

              <p class="docText"><span class="docEmphStrong">In practice, many uses of integers involve counting. For example, programs often count the number of elements in a data structure such as a <tt>vector</tt> or an array. We'll see in <a class="docLink" href="ch03.html#ch03" >Chapters 3</a> and <a class="docLink" href="ch04.html#ch04" >4</a> that the library defines a set of types to use when dealing with the size of an object. When counting such elements it is always right to use the library-defined type intended for this purpose. When counting in other circumstances, it is usually right to use an <tt>unsigned</tt> value. Doing so avoids the possibility that a value that is too large to fit results in a (seemingly) negative result.</span></p>
	      <p class="docText"><span class="docEmphStrong">实际上，许多人用整型进行计数。例如：程序经常计算像 <tt>vector</tt> 或数组这种数据结构的元素个数。在<a class="docLink" href="ch03.html#ch03" >第三章</a>和<a class="docLink" href="ch04.html#ch04" >第四章</a>中，我们将看到标准库定义了一组类型用于统计对象的大小。因此，当计数这些元素时使用标准库定义的类型总是正确的。其他情况下，使用 <tt>unsigned</tt> 类型比较明智，可以避免值越界导致结果为负数的可能性。</span></p>

              <p class="docText"><span class="docEmphStrong">When performing integer arithmetic, it is rarely right to use <tt>short</tt>s. In most programs, using <tt>short</tt>s leads to mysterious bugs when a value is assigned to a <tt>short</tt> that is bigger than the largest number it can hold. What happens depends on the machine, but typically the value "wraps around" so that a number too large to fit turns into a large negative number. For the same reason, even though <tt>char</tt> is an integral type, the <tt>char</tt> type should be used to hold characters and not for computation. The fact that <tt>char</tt> is <tt>signed</tt> on some implementations and <tt>unsigned</tt> on others makes it problematic to use it as a computational type.</span></p>
	      <p class="docText"><span class="docEmphStrong">当执行整型算术运算时，很少使用 <tt>short</tt> 类型。大多数程序中，使用 <tt>short</tt> 类型可能会隐含赋值越界的错误。这个错误会产生什么后果将取决于所使用的机器。比较典型的情况是值“截断（wrap around）”以至于因越界而变成很大的负数。同样的道理，虽然 <tt>char</tt> 类型是整型，但是 <tt>char</tt> 类型通常用来存储字符而不用于计算。事实上，在某些应用中 <tt>char</tt> 类型被当作 <tt>signed</tt> 类型，在另外一些应用中则被当作 <tt>unsigned</tt> 类型，因此把 <tt>char</tt> 类型作为计算类型使用时容易出问题。</span></p>

              <p class="docText"><span class="docEmphStrong">On most machines, integer calculations can safely use <tt>int</tt>. Technically speaking, an <tt>int</tt> can be as small as 16 bitstoo small for most purposes. In practice, almost all general-purpose machines use 32-bits for <tt>int</tt>s, which is often the same size used for <tt>long</tt>. The difficulty in deciding whether to use <tt>int</tt> or <tt>long</tt> occurs on machines that have 32-bit <tt>int</tt>s and 64-bit <tt>long</tt>s. On such machines, the <span class="docEmphasis">run-time</span> cost of doing arithmetic with <tt>long</tt>s can be considerably greater than doing the same calculation using a 32-bit <tt>int</tt>. Deciding whether to use <tt>int</tt> or <tt>long</tt> requires detailed understanding of the program and the actual run-time performance cost of using <tt>long</tt> versus <tt>int</tt></span>.</p>
	      <p class="docText"><span class="docEmphStrong">在大多数机器上，使用 <tt>int</tt> 类型进行整型计算不易出错。就技术上而言，<tt>int</tt> 类型用 16 位表示——这对大多数应用来说太小了。实际应用中，大多数通用机器都是使用和  <tt>long</tt>  类型一样长的 32 位来表示 <tt>int</tt> 类型。整型运算时，用 32 位表示 <tt>int</tt> 类型和用 64 位表示 <tt>long</tt> 类型的机器会出现应该选择 <tt>int</tt> 类型还是 <tt>long</tt> 类型的难题。在这些机器上，用 <tt>long</tt> 类型进行计算所付出的<span class="docEmphasis">运行时</span>代价远远高于用 <tt>int</tt> 类型进行同样计算的代价，所以选择类型前要先了解程序的细节并且比较 <tt>long</tt> 类型与 <tt>int</tt> 类型的实际运行时性能代价。</span></p>

              <p class="docText"><span class="docEmphStrong">Determining which floating-point type to use is easier: It is almost always right to use <tt>double</tt>. The loss of precision implicit in <tt>float</tt> is significant, whereas the cost of double precision calculations versus single precision is negligible. In fact, on some machines, double precision is faster than single. The precision offered by <tt>long double</tt> usually is unnecessary and often entails considerable extra run-time cost.</span></p>
	      <p class="docText"><span class="docEmphStrong">决定使用哪种浮点型就容易多了：使用 <tt>double</tt> 类型基本上不会有错。在 <tt>float</tt> 类型中隐式的精度损失是不能忽视的，而 <tt>double</tt> 类型精度代价相对于 <tt>float</tt> 类型精度代价可以忽略。事实上，有些机器上，<tt>double</tt> 类型比 <tt>float</tt> 类型的计算要快得多。<tt>long double</tt> 类型提供的精度通常没有必要，而且还需要承担额外的运行代价。</span></p>
            </td>
          </tr>
        </table><br>
  
	<a name="ch02sb03"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.1.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa1q1"></a><b>Exercise 2.1:</b></td>

                    <td>
                      <p class="docText">What is the difference between an <tt>int</tt>, a <tt>long</tt>, and a <tt>short</tt> value?</p>
		      <p class="docText"><tt>int</tt>、<tt>long</tt> 和 <tt>short</tt> 类型之间有什么差别？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa1q2"></a><b>Exercise 2.2:</b></td>

                    <td>
                      <p class="docText">What is the difference between an <tt>unsigned</tt> and a <tt>signed</tt> type?</p>
		      <p class="docText"><tt>unsigned</tt> 和 <tt>signed</tt> 类型有什么差别？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa1q3"></a><b>Exercise 2.3:</b></td>

                    <td>
                      <p class="docText">If a <tt>short</tt> on a given machine has 16 bits then what is the largest number that can be assigned to a <tt>short</tt>? To an <tt>unsigned short</tt>?</p>
		      <p class="docText">如果在某机器上 <tt>short</tt> 类型占 16 位，那么可以赋给 <tt>short</tt> 类型的最大数是什么？<tt>unsigned short</tt> 类型的最大数又是什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa1q4"></a><b>Exercise 2.4:</b></td>

                    <td>
                      <p class="docText">What value is assigned if we assign 100,000 to a 16-bit <tt>unsigned short</tt>? What value is assigned if we assign 100,000 to a plain 16-bit <tt>short</tt>?</p>
		      <p class="docText">当给 16 位的 <tt>unsigned short</tt> 对象赋值 100 000 时，赋的值是什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa1q5"></a><b>Exercise 2.5:</b></td>

                    <td>
                      <p class="docText">What is the difference between a <tt>float</tt> and a <tt>double</tt>?</p>
		      <p class="docText"><tt>float</tt> 类型和 <tt>double</tt> 类型有什么差别？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa1q6"></a><b>Exercise 2.6:</b></td>

                    <td>
                      <p class="docText">To calculate a mortgage payment, what types would you use for the rate, principal, and payment? Explain why you selected each type.</p>
                      <p class="docText">要计算抵押贷款的偿还金额，利率、本金和付款额应分别选用哪种类型？解释你选择的理由。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
       

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch02.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch02lev1sec2.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
