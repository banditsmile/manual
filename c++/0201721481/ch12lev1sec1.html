<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 12.1.  Class Definitions and Declarations</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch12.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch12lev1sec2.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch12lev1sec1"></a>

        <h3 class="docSection1Title">12.1. Class Definitions and Declarations</h3>
        <h3 class="docSection1Title">12.1. 类的定义和声明</h3>

        <p class="docText">Starting from <a class="docLink" href="ch01.html#ch01" >Chapter 1</a>, our programs have used classes. The library types we've used<tt>vector, istream, string</tt>are all class types. We've also defined some simple classes of our own, such as the <tt>Sales_item</tt> and <tt>TextQuery</tt> classes. To recap, let's look again at the <tt>Sales_item</tt> class:</p>
	<p class="docText">从第一章开始，程序中就已经使用了类。已经用过的标准库类型，比如 <tt>vector</tt>，<tt>istream</tt> 和 <tt>string</tt>，都是类类型。还定义了一些简单的类，如 <tt>Sales_item</tt> 和 <tt>TextQuery</tt> 类。为了扼要秣，再来看年 <tt>Sales_item</tt> 类：</p>
        <pre>
class Sales_item {
public:
    // <span class="docEmphItalicAlt">operations on</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">objects</span>
    double avg_price() const;
    bool same_isbn(const Sales_item &amp;rhs) const
        { return isbn == rhs.isbn; }
    // <span class="docEmphItalicAlt">default constructor needed to initialize members of built-in type</span>
    Sales_item(): units_sold(0), revenue(0.0) { }
private:
    std::string isbn;
    unsigned units_sold;
    double revenue;
};

double Sales_item::avg_price() const
{
    if (units_sold)
        return revenue/units_sold;
    else
        return 0;
}
</pre><br>
        <a name="ch12lev2sec1"></a>

        <h4 class="docSection2Title">12.1.1. Class Definitions: A Recap</h4>
        <h4 class="docSection2Title">12.1.1. 类定义：扼要重述</h4>

        <p class="docText">In writing this class in <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8" >Section 2.8</a> (p. <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8" >63</a>) and <a class="docLink" href="ch07lev1sec7.html#ch07lev1sec7" >Section 7.7</a> (p. <a class="docLink" href="ch07lev1sec7.html#ch07lev1sec7" >258</a>), we already learned a fair bit about classes.</p>
	<p class="docText">在<a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8" >第 2.8 节</a>和<a class="docLink" href="ch07lev1sec7.html#ch07lev1sec7" >第 7.7 节</a>中编写这个类时，已经学习了有关类的一些知识。</p>

<a name="ch12note01"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Most fundamentally, a class defines a new type and a new scope.</p>
                <p class="docText">最简单地说，类就是定义了一个新的类型和一个新作用域。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12lev3sec1"></a>

        <h5 class="docSection3Title">Class Members</h5>
        <h5 class="docSection3Title">类成员</h5>

        <p class="docText">Each class defines zero or more members. Members can be either data, functions, or type definitions.</p>
        <p class="docText">每个类可以没有成员，也可以定义多个成员，成员可以是数据、函数或类型别名。</p>

	<a name="idd1e91140"></a><a name="idd1e91147"></a><a name="idd1e91154"></a><a name="idd1e91159"></a><a name="idd1e91162"></a><a name="idd1e91165"></a><a name="idd1e91171"></a><a name="idd1e91174"></a><a name="idd1e91177"></a><a name="idd1e91182"></a>
        <p class="docText">A class may contain multiple <tt>public, private</tt>, and <tt>protected</tt> sections. We've already used the <tt>public</tt> and <tt>private</tt> access labels: Members defined in the <tt>public</tt> section are accessible to all code that uses the type; those defined in the <tt>private</tt> section are accessible to other class members. We'll have more to say about <tt>protected</tt> when we discuss inheritance in <a class="docLink" href="ch15.html#ch15" >Chapter 15</a>.</p>
	<p class="docText">一个类可以包含若干公有的、私有的和受保护的部分。我们已经使用过 <tt>public</tt> 和 <tt>private</tt> 访问标号：在 <tt>public</tt> 部分定义的成员可被使用该类型的所有代码访问；在 <tt>private</tt> 部分定义的成员可被其他类成员访问。在<a class="docLink" href="ch15.html#ch15" >第十五章</a>讨论继承时将进一步探讨 <tt>protected</tt>。</p>

        <p class="docText">All members must be declared inside the class; there is no way to add members once the class definition is complete.</p>
        <p class="docText">所有成员必须在类的内部声明，一旦类定义完成后，就没有任何方式可以增加成员了。</p>

	<a name="ch12lev3sec2"></a>
        <h5 class="docSection3Title">Constructors</h5>
        <h5 class="docSection3Title">构造函数</h5>

        <p class="docText">When we create an object of a class type, the compiler automatically uses a constructor (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >Section 2.3.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >49</a>) to initialize the object. A constructor is a special member function that has the same name as the class. Its purpose is to ensure that each data member is set to sensible initial values.</p>
        <p class="docText">创建一个类类型的对象时，编译器会自动使用一个构造函数（<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >第 2.3.3 节</a>）来初始化该对象。构造函数是一个特殊的、与类同名的成员函数，用于给每个数据成员设置适当的初始值。</p>

        <p class="docText">A constructor generally should use a <span class="docEmphRoman"><a name="ch12term9"></a><a class="docLink" href="ch12lev1sec8.html#gloss12_09" >constructor initializer list</a></span> (<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24" >Section 7.7.3</a>, p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24" >263</a>), to initialize the data members of the object:</p>
        <p class="docText">构造函数一般就使用一个构造函数初始化列表（<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24" >第 7.7.3 节</a>），来初始化对象的数据成员：</p>
        <pre>
// <span class="docEmphItalicAlt">default constructor needed to initialize members of built-in type</span>
Sales_item(): units_sold(0), revenue(0.0) { }
</pre><br>

        <p class="docText">The constructor initializer list is a list of member names and parenthesized initial values. It follows the constructor's parameter list and begins with a colon.</p>
        <p class="docText"></p>

	<a name="ch12lev3sec3"></a>
        <h5 class="docSection3Title">Member Functions</h5>
        <h5 class="docSection3Title">成员函数</h5>

        <p class="docText">Member functions must be declared, and optionally may be defined, inside the class; functions defined inside the class are <tt>inline</tt> (<a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6" >Section 7.6</a>, p. <a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6" >256</a>) by default.</p>
        <p class="docText">在类内部，声明成员函数是必需的，而定义成员函数则是可选的。在类内部定义的函数默认为 <tt>inline</tt>（<a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6" >第 7.6 节</a>）。</p>

        <p class="docText">Member functions defined outside the class must indicate that they are in the scope of the class. The definition of <tt>Sales_item::avg_price</tt> uses the scope operator (<a class="docLink" href="ch01lev1sec2.html#ch01lev2sec3" >Section 1.2.2</a>, p. <a class="docLink" href="ch01lev1sec2.html#ch01lev2sec3" >8</a>) to indicate that the definition is for the <tt>avg_price</tt> function of the <tt>Sales_item</tt> class.</p>
	<p class="docText">在类外部定义的成员函数必须指明它们是在类的作用域中。<tt>Sales_item::avg_price</tt> 的定义使用作用域操作符（<a class="docLink" href="ch01lev1sec2.html#ch01lev2sec3" >第 1.2.2 节</a>）来指明这是 <tt>Sales_item</tt> 类中 <tt>avg_price</tt> 函数的定义。</p>

        <p class="docText">Member functions take an extra implicit argument that binds the function to the object on behalf of which the function is calledwhen we write</p>
        <p class="docText">成员函数有一个附加的隐含实参，将函数绑定到调用函数的对象——当我们编写下面的函数时：</p>
        <pre>
trans.avg_price()
</pre><br>

        <p class="docText">we are calling the <tt>avg_price</tt> function on the object named <tt>trans</tt>. If <tt>trans</tt> is a <tt>Sales_item</tt> object, then references to a member of the <tt>Sales_item</tt> class inside the <tt>avg_price</tt> function are to the members in <tt>trans</tt>.</p>
	<p class="docText">就是在调用名 <tt>trans</tt> 的对象的 <tt>avg_price</tt> 函数。如果 <tt>trans</tt> 是一个 <tt>Sales_item</tt> 对象，则在 <tt>avg_price</tt> 函数内部对 <tt>Sales_item</tt> 类成员引用就是对 <tt>trans</tt> 成员的引用。</p>

        <p class="docText">Member functions may be declared <tt>const</tt> by putting the <tt>const</tt> keyword following the parameter list:</p>
	<p class="docText">将关键字 <tt>const</tt> 加在形参表之后，就可以将成员函数声明为常量：</p>
        <pre>
double avg_price() const;
</pre><br>

        <p class="docText">A <tt>const</tt> member may not change the data members of the object on which it operates. The <tt>const</tt> must appear in both the declaration and definition. It is a compile-time error for the <tt>const</tt> to be indicated on one but not the other.</p>
	<p class="docText"><tt>const</tt> 成员不能改变其所操作的对象的数据成员。<tt>const</tt> 必须同时出现在声明和定义中，若只出现在其中一处，就会出现一个编译时错误。</p>

	<a name="ch12sb01"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.1.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa1q1"></a><b>Exercise 12.1:</b></td>

                    <td>
			<a name="idd1e91373"></a><a name="idd1e91376"></a><a name="idd1e91379"></a><a name="idd1e91385"></a><a name="idd1e91391"></a><a name="idd1e91396"></a><a name="idd1e91399"></a><a name="idd1e91402"></a><a name="idd1e91405"></a><a name="idd1e91408"></a><a name="idd1e91413"></a><a name="idd1e91418"></a>
			<p class="docText">Write a class named <tt>Person</tt> that represents the name and address of a person. Use a <tt>string</tt> to hold each of these elements.</p>
			<p class="docText">编写一个名为 <tt>Person</tt> 的类，表示人的名字和地址。使用 <tt>string</tt> 来保存每个元素。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa1q2"></a><b>Exercise 12.2:</b></td>

                    <td>
			<p class="docText">Provide a constructor for <tt>Person</tt> that takes two <tt>string</tt>s.</p>
			<p class="docText">为 <tt>Person</tt> 提供一个接受两个 <tt>string</tt> 参数的构造函数。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa1q3"></a><b>Exercise 12.3:</b></td>

                    <td>
                      <p class="docText">Provide operations to return the name and address. Should these functions be <tt>const</tt>? Explain your choice.</p>
		      <p class="docText">提供返回名字和地址的操作。这些函数应为 <tt>const</tt> 吗？解释你的选择。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa1q4"></a><b>Exercise 12.4:</b></td>

                    <td>
                      <p class="docText">Indicate which members of <tt>Person</tt> you would declare as <tt>public</tt> and which you would declare as <tt>private</tt>. Explain your choice.</p>
		      <p class="docText">指明 <tt>Person</tt> 的哪个成员应声明为 <tt>public</tt>，哪个成员应声明为 <tt>private</tt>。解释你的选择。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev2sec2"></a>

        <h4 class="docSection2Title">12.1.2. Data Abstraction and Encapsulation</h4>
        <h4 class="docSection2Title">12.1.2. 数据抽象和封装</h4>

<a name="ch12term11"></a>
<a name="ch12term13"></a>
        <p class="docText">The fundamental ideas behind classes are <b><a class="docLink" href="ch12lev1sec8.html#gloss12_11" >data abstraction</a></b> and <b><a class="docLink" href="ch12lev1sec8.html#gloss12_13" >encapsulation</a></b>.</p>
        <p class="docText">类背后蕴涵的基本思想是<b><a class="docLink" href="ch12lev1sec8.html#gloss12_11" >数据抽象</a></b>和<b><a class="docLink" href="ch12lev1sec8.html#gloss12_13" >封装</a></b>。</p>

        <p class="docText">Data abstraction is a programming (and design) technique that relies on the separation of interface and implementation. The class designer must worry about how a class is implemented, but programmers that use the class need not know about these details. Instead, programmers who use a type need to know only the type's interface; they can think <span class="docEmphasis">abstractly</span> about what the type does rather than concretely about how the type works.</p>
        <p class="docText">数据抽象是一种依赖于接口和实现分离的编程（和设计）技术。类设计者必须关心类是如何实现的，但使用该类的程序员不必了解这些细节。相反，使用一个类型的程序员仅需了解类型的接口，他们可以抽象地考虑该类型做什么，而不必具体地考虑该类型如何工作。</p>

        <p class="docText">Encapsulation is a term that describes the technique of combining lower-level elements to form a new, higher-level entity. A function is one form of encapsulation: The detailed actions performed by the function are <span class="docEmphasis">encapsulated</span> in the larger entity that is the function itself. Encapsulated elements hide the details of their implementationwe may call a function but have no access to the statements that it executes. In the same way, a class is an encapsulated entity: It represents an aggregation of several members, and most (well-designed) class types hide the members that implement the type.</p>
	<p class="docText">封装是一项低层次的元素组合起来的形成新的、高层次实体珠技术。函数是封装的一种形式：函数所执行的细节行为被<span class="docEmphasis">封装</span>在函数本身这个更大的实体中。被封装的元素隐藏了它们的实现细节——可以调用一个函数但不能访问它所执行的语句。同样地，类也是一个封装的实体：它代表若干成员的聚焦，大多数（良好设计的）类类型隐藏了实现该类型的成员。</p>

        <p class="docText">If we think about the library <tt>vector</tt> type, it is an example of both data abstraction and encapsulation. It is abstract in that to use it, we think about its interfaceabout the operations that it can perform. It is encapsulated because we have no access to the details of how the type is representated nor to any of its implementation artifacts. An array, on the other hand, is similar in concept to a <tt>vector</tt> but is neither abstract nor encapsulated. We manipulate an array directly by accessing the memory in which the array is stored.</p>
	<p class="docText">标准库类型 <tt>vector</tt> 同时具备数据抽象和封装的特性。在使用方面它是抽象的，只需考虑它的接口，即它能执行的操作。它又是封装的，因为我们既无法了解该类型如何表示的细节，也无法访问其任意的实现制品。另一方面，数组在概念上类似于 <tt>vector</tt>，但既不是抽象的，也不是封装的。可以通过访问存放数组的内存来直接操纵数组。</p>

	<a name="ch12lev3sec4"></a>
        <h5 class="docSection3Title">Access Labels Enforce Abstraction and Encapsulation</h5>
        <h5 class="docSection3Title">访问标号实施抽象和封装</h5>

	<a name="ch12term2"></a>
        <p class="docText">In C++ we use <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_02" >access labels</a></span> (<a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8" >Section 2.8</a>, p. <a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8" >65</a>) to define the abstract interface to the class and to enforce encapsulation. A class may contain zero or more access labels:</p>
        <p class="docText">在 C++ 中，使用<span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_02" >访问标号</a></span>（<a class="docLink" href="ch02lev1sec8.html#ch02lev1sec8" >第 2.8 节</a>）来定义类的抽象接口和实施封装。一个类可以没有访问标号，也可以包含多个访问标号：</p>

        <ul>
          <li>
		<a name="ch12term22"></a>
		<p class="docList">Members defined after a <tt>public</tt> label are accessible to all parts of the program. The data-abstraction view of a type is defined by its <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_22" ><span class="docEmphRoman"><tt>public</tt> members</span></a></span>.</p>
		<p class="docList">程序的所有部分都可以访问带有 <tt>public</tt> 标号的成员。类型的数据抽象视图由其 <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_22" ><span class="docEmphRoman"><tt>public</tt> 成员</span></a></span>定义。</p>
          </li>

          <li>
            <p class="docList">Members defined after a <tt>private</tt> label are not accessible to code that uses the class. The <tt>private</tt> sections encapsulate (e.g., hide) the implementation from code that uses the type.</p>
	    <p class="docList">使用类的代码不可以访问带有 <tt>private</tt> 标号的成员。<tt>private</tt> 封装了类型的实现细节。</p>
          </li>
        </ul>

	<a name="idd1e91568"></a><a name="idd1e91573"></a><a name="idd1e91578"></a><a name="idd1e91583"></a><a name="idd1e91586"></a><a name="idd1e91591"></a>
        <p class="docText">There are no restrictions on how often an access label may appear. Each access label specifies the access level of the succeeding member definitions. The specified access level remains in effect until the next access label is encountered or the closing right brace of the class body is seen.</p>
        <p class="docText">一个访问标号可以出现的次数通常是没有限制的。每个访问标号指定了随后的成员定义的访问级别。这个指定的访问级别持续有效，直到遇到下一个访问标号或看到类定义体的右花括号为止。</p>

<a name="ch12term24"></a>
<a name="ch12term5"></a>
        <p class="docText">A class may define members before any access label is seen. The access level of members defined after the open curly of the class and before the first access label depend on how the class is defined. If the class is defined with the <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_24" ><span class="docEmphRoman"><tt>struct</tt> keyword</span></a></span>, then members defined before the first access label are <tt>public</tt>; if the class is defined using the <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_05" ><span class="docEmphRoman"><tt>class</tt> keyword</span></a></span>, then the members are <tt>private</tt>.</p>
	<p class="docText">可以在任意的访问标号出现之前定义类成员。在类的左花括号之后、第一个访问标号之前定义成员的访问级别，其值依赖于类是如何定义的。如果类是用 <tt>struct</tt> 关键字定义的，则在第一个访问标号之前的成员是公有的；如果类是用 <tt>class</tt> 关键字是定义的，则这些成员是私有的。</p>

	<a name="ch12sb02"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Advice: Concrete and Abstract Types</h2>
              <h2 class="docSidebarTitle">建议：具体类型和抽象类型</h2>

	<a name="ch12term7"></a>
              <p class="docText"><span class="docEmphStrong">Not all types need to be abstract. The library <tt>pair</tt> class is a good example of a useful, well-designed class that is concrete rather than abstract. A <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_07" >concrete class</a></span> is a class that exposes, rather than hides, its implementation.</span></p>
	      <p class="docText"><span class="docEmphStrong">并非所有类型都必须是抽象的。标准库中的 <tt>pair</tt> 类就是一个实用的、设计良好的具体类而不是抽象类。<span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_07" >具体类</a></span>会暴露而非隐藏其实现细节。</span></p>

              <p class="docText"><span class="docEmphStrong">Some classes, such as <tt>pair</tt>, really have no abstract interface. The <tt>pair</tt> type exists to bundle two data members into a single object. There is no need or advantage to hiding the data members. Hiding the members in a class like <tt>pair</tt> would only complicate the use of the type.</span></p>
	      <p class="docText"><span class="docEmphStrong">一些类，例如 <tt>pair</tt>，确实没有抽象接口。<tt>pair</tt> 类型只是将两个数据成员捆绑成单个对象。在这种情况下，隐藏数据成员没有必要也没有明显的好处。在像 <tt>pair</tt> 这样的类中隐藏数据成员只会造成类型使用的复杂化。</span></p>

              <p class="docText"><span class="docEmphStrong">Even so, such types often have member functions. In particular, it is a good idea for any class that has data members of built-in or compound type to define constructor(s) to initialize those members. The user of the class could initialize or assign to the data members but it is less error-prone for the class to do so.</span></p>
	      <p class="docText"><span class="docEmphStrong">尽管如此，这样的类型通常还是有成员函数。特别地，如果类具有内置类型或复合类型数据成员，那么定义构造函数来初始化这些成员就是一个好主意。类的使用都也可以初始化或赋值数据成员，但由类来做更不易出错。</span></p>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev3sec5"></a>

        <h5 class="docSection3Title">Different Kinds of Programming Roles</h5>
        <h5 class="docSection3Title">编程角色的不同类别</h5>

        <p class="docText">Programmers tend to think about the people who will run their applications as "users." Applications are designed for and evolve in response to feedback from those who ultimately "use" the applications. Classes are thought of in a similar way: A class designer designs and implements a class for "users" of that class. In this case, the "user" is a programmer, not the ultimate user of the application.</p>
              <p class="docText">程序员经常会将运行应用程序的人看作“用户”。应用程序为最终“使用”它的用户而设计，并响应用户的反馈而完善。类也类似：类的设计者为类的“用户”设计并实现类。在这种情况下，“用户”是程序员，而不是应用程序的最终用户。</p>

        <p class="docText">Authors of successful applications do a good job of understanding and implementing the needs of the application's users. Similarly, well-designed, useful classes are designed with a close attention to the needs of the users of the class.</p>
              <p class="docText">成功的应用程序的创建者会很好地理解和实现用户的需求。同样地，良好设计的、实用的类，其设计也要贴近类用户的需求。</p>

        <p class="docText">In another way, the division between class designer and class user reflects the division between users of an application and the designers and implementors of the application. Users care only if the application meets their needs in a cost-effective way. Similarly, users of a class care only about its interface. Good class designers define a class interface that is intuitive and easy to use. Users care about the implementation only in so far as the implementation affects their use of the class. If the implementation is too slow or puts burdens on users of the class, then the users must care. In well-designed classes, only the class designer worries about the implementation.</p>
              <p class="docText">另一方面，类的设计者与实现者之间的区别，也反映了应用程序的用户与设计和实现者之间的区分。用户只关心应用程序能否以合理的费用满足他们的需求。同样地，类的使用者只关心它的接口。好的类设计者会定义直观和易用的类接口，而使用者只关心类中影响他们使用的部分实现。如果类的实现速度太慢或给类的使用者加上负担，则必然引起使用者的关注。在良好设计的类中，只有类的设计者会关心实现。</p>

	<a name="idd1e91667"></a><a name="idd1e91672"></a><a name="idd1e91677"></a><a name="idd1e91680"></a>
        <p class="docText">In simple applications, the user of a class and the designer of the class might be one and the same person. Even in such cases, it is useful to keep the roles distinct. When designing the interface to a class, the class designer should think about how easy it will be to use the class. When using the class, the designer shouldn't think about how the class works.</p>
      <p class="docText">在简单的应用程序中，类的使用者和设计者也许是同一个人。即使在这种情况下，保持角色区分也是有益的。设计类的接口时，设计者应该考虑的是如何方便类的使用；使用类的时候，设计者就不应该考虑类如何工作。</p>

	<a name="ch12note02"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">C++ programmers tend to speak of "users" interchangably as users of the application or users of a class.</p>
                <p class="docText">注意，C++ 程序员经常会将应用程序的用户和类的使用者都称为“用户”。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">When referring to a "user," the context makes it clear which kind of user is meant. If we speak of "user code" or the "user" of the <tt>Sales_item</tt> class, we mean a programmer who is using a class in writing an application. If we speak of the "user" of the bookstore application, we mean the manager of the store who is running the application.</p>
	<p class="docText">提到“用户”时，应该由上下文清楚地标明所指的是哪类用户。如果提到“用户代码”或 <tt>Sales_item</tt> 类的”用户“，指的就是使用类编写应用程序的程序员。如果提到书店应用程序的”用户“，那么指的是运行应用程序的书店管理人员。</p>

<a name="ch12sb03"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Key Concept: Benefits of Data Abstraction and Encapsulation</h2>
              <h2 class="docSidebarTitle">关键概念：数据抽象和封装的好处</h2>

              <p class="docText"><span class="docEmphStrong">Data abstraction and encapsulation provide two important advantages:</span></p>
	      <p class="docText"><span class="docEmphStrong">数据抽象和封装提供了两个重要优点：</span></p>

              <ul>
                <li>
                  <p class="docList"><span class="docEmphStrong">Class internals are protected from inadvertent user-level errors, which might corrupt the state of the object.</span></p>
		  <p class="docText"><span class="docEmphStrong">避免类内部出现无意的、可能破坏对象状态的用户级错误。</span></p>
                </li>

                <li>
                  <p class="docList"><span class="docEmphStrong">The class implementation may evolve over time in response to changing requirements or bug reports without requiring change in user-level code.</span></p>
              <p class="docText"><span class="docEmphStrong">随时间推移可以根据需求改变或缺陷（bug）报告来完美类实现，而无须改变用户级代码。</span></p>
                </li>
              </ul>

              <p class="docText"><span class="docEmphStrong">By defining data members only in the <tt>private</tt> section of the class, the class author is free to make changes in the data. If the implementation changes, only the class code needs to be examined to see what affect the change may have. If data are <tt>public</tt>, then any function that directly accesses the data members of the old representation might be broken. It would be necessary to locate and rewrite all those portions of code that relied on the old representation before the program could be used again.</span></p>
              <p class="docText"><span class="docEmphStrong">仅在类的私有部分定义数据成员，类的设计者就可以自由地修改数据。如果实现改变了，那么只需检查类代码来了解此变化可能造成的影响。如果数据为仅有的，则任何直接访问原有数据成员的函数都可能遭到破坏。在程序可重新使用之前，有必要定位和重写依赖原有表示的那部分代码。</span></p>

              <p class="docText"><span class="docEmphStrong">Similarly, if the internal state of the class is <tt>private</tt>, then changes to the member data can happen in only a limited number of places. The data is protected from mistakes that users might introduce. If there is a bug that corrupts the object's state, the places to look for the bug are localized: When data are <tt>private</tt>, only a member function could be responsible for the error. The search for the mistake is limited, greatly easing the problems of maintenance and program correctness.</span></p>
              <p class="docText"><span class="docEmphStrong">同样地，如果类的内部状态是私有的，则数据成员的改变只可能在有限的地方发生。避免数据中出现用户可能引入的错误。如果有缺陷会破坏对象的状态，就在局部位置搜寻缺陷：如果数据是私有的，那么只有成员函数可能对该错误负责。对错误的搜寻是有限的，从而大大方便了程序的维护和修正。</span></p>

              <p class="docText"><span class="docEmphStrong">If the data are <tt>private</tt> and if the interface to the member functions does not change, then user functions that manipulate class objects require no change.</span></p>
              <p class="docText"><span class="docEmphStrong">如果数据是私有的并且没有改变成员函数的接口，则操纵类对象的用户函数无须改变。</span></p>

<a name="ch12note03"></a>
              <div class="docNote">
                <table width="90%" border="0" cellspacing="0" cellpadding="1">
                  <tr>
                    <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

                    <td valign="top">
                      <p class="docText"><span class="docEmphStrong">Because changing a class definition in a header file effectively changes the text of every source file that includes that header, code that uses a class must be recompiled when the class changes.</span></p>
                      <p class="docText"><span class="docEmphStrong">改变头文件中的类定义可有效地改变包含该头文件的每个源文件的程序文本，所以，当类发生改变时，使用该类的代码必须重新编译。</span></p>
                    </td>
                  </tr>
                </table><br>
              </div><br>
            </td>
          </tr>
        </table><br>

<a name="ch12sb04"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.1.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa2q1"></a><b>Exercise 12.5:</b></td>

                    <td>
			<a name="idd1e91790"></a><a name="idd1e91797"></a><a name="idd1e91802"></a><a name="idd1e91807"></a><a name="idd1e91811"></a>
                      <p class="docText">What are the access labels supported by C++ classes? What kinds of members should be defined after each access label? What, if any, are the constraints on where and how often an access label may appear inside a class definition?</p>
                      <p class="docText">C++ 类支持哪些访问标号？在每个访问标号之后应定义哪种成员？如果有的话，在类的定义中，一个访问标号可以出现在何处以及可出现多少次？约束条件是什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa2q2"></a><b>Exercise 12.6:</b></td>

                    <td>
                      <p class="docText">How do classes defined with the <tt>class</tt> keyword differ from those defined as <tt>struct</tt>?</p>
		      <p class="docText">有 <tt>class</tt> 关键字定义的类和用 <tt>struct</tt> 定义的类有什么不同？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa2q3"></a><b>Exercise 12.7:</b></td>

                    <td>
                      <p class="docText">What is encapsulation? Why it is useful?</p>
                      <p class="docText">什么是封装？为什么封装是有用的？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch12lev2sec3"></a>

        <h4 class="docSection2Title">12.1.3. More on Class Definitions</h4>
        <h4 class="docSection2Title">12.1.3. 关于类定义的更多内容</h4>

        <p class="docText">The classes we've defined so far have been simple; yet they have allowed us to explore quite a bit of the language support for classes. There remain a few more details about the basics of writing a class that we shall cover in the remainder of this section.</p>
                      <p class="docText">迄今为止，所定义的类都是简单的，然而通过这些类我们已经了解到 C++ 语言为类所提供的相当多的支持。本节的其余部分将阐述编写类的更多基础知识。</p>


        <a name="ch12lev3sec6"></a>

        <h5 class="docSection3Title">Multiple Data Members of the Same Type</h5>
        <h5 class="docSection3Title">同一类型的多个数据成员</h5>

        <p class="docText">As we've seen, class data members are declared similarly to how ordinary variables are declared. One way in which member declarations and ordinary declarations are the same is that if a class has multiple data members with the same type, these members can be named in a single member declaration.</p>
        <p class="docText">正如我们所见，类的数据成员的声明类似于普通变量的声明。如果一个类具有多个同一类型的数据成员，则这些成员可以在一个成员声明中指定，这种情况下，成员声明和普通变量声明是相同的。</p>

        <p class="docText">For example, we might define a type named <tt>Screen</tt> to represent a window on a computer. Each <tt>Screen</tt> would have a <tt>string</tt> member that holds the contents of the window, and three <tt>string::size_type</tt> members: one that specifies the character on which the cursor currently rests, and two others that specify the height and width of the window. We might define the members of this class as:</p>
	<p class="docText">例如，可以定义一个名为 <tt>Screen</tt> 的类型表示计算机上的窗口。每个 <tt>Screen</tt> 可以有一个保存窗口内容的 <tt>string</tt> 成员，以及三个 <tt>string::size_type</tt> 成员：一个指定光标当前停留的字符，另外两个指定窗口的高度和宽度。可以用如下方式这个类的成员：</p>
        <pre>
     class Screen {
     public:
         // <span class="docEmphItalicAlt">interface member functions</span>
     private:
         std::string contents;
         std::string::size_type cursor;
         std::string::size_type height, width;
     };
</pre><br>
        <a name="ch12lev3sec7"></a>

        <h5 class="docSection3Title">Using Typedefs to Streamline Classes</h5>
        <h5 class="docSection3Title">使用类型别名来简化类</h5>

        <p class="docText">In addition to defining data and function members, a class can also define its own local names for types. Our <tt>Screen</tt> will be a better abstraction if we provide a typedef for <tt>std::string::size_type:</tt></p>
	<p class="docText">除了定义数据和函数成员之外，类还可以定义自己的局部类型名字。如果为 <tt>std::string::size_type</tt> 提供一个类型别名，那么 <tt>Screen</tt> 类将是一个更好的抽象：</p>
        <pre>
     class Screen {
     public:
         // <span class="docEmphItalicAlt">interface member functions</span>
         typedef std::string::size_type index;
     private:
         std::string contents;
         index cursor;
         index height, width;
     };
</pre><br>

	<a name="idd1e91914"></a><a name="idd1e91919"></a><a name="idd1e91924"></a><a name="idd1e91927"></a>
        <p class="docText">Type names defined by a class obey the standard access controls of any other member. We put the definition of <tt>index</tt> in the <tt>public</tt> part of the class because we want users to use that name. Users of class <tt>Screen</tt> need not know that we use a <tt>string</tt> as the underlying implementation. By defining <tt>index</tt>, we hide this detail of how <tt>Screen</tt> is implemented. By making the type <tt>public</tt>, we let our users use this name.</p>
	<p class="docText">类所定义的类型名遵循任何其他成员的标准访问控制。将 <tt>index</tt> 的定义放在类的 <tt>public</tt> 部分，是因为希望用户使用这个名字。<tt>Screen</tt> 类的使用者不必了解用 <tt>string</tt> 实现的底层细节。定义 <tt>index</tt> 来隐藏 <tt>Screen</tt> 的实现细节。将这个类型设为 <tt>public</tt>，就允许用户使用这个名字。</p>

	<a name="ch12lev3sec8"></a>
        <h5 class="docSection3Title">Member Functions May Be Overloaded</h5>
        <h5 class="docSection3Title">成员函数可被重载</h5>

        <p class="docText">Another way our classes have been simple is that they have defined only a few member functions. In particular, none of our classes have needed to define over-loaded versions of any of their member functions. However, as with nonmember functions, a member function may be overloaded (<a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8" >Section 7.8</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8" >265</a>).</p>
        <p class="docText">这些类之所以简单，另一个方面也是因为它们只定义了几个成员函数。特别地，这些类都不需要定义其任意成员函数的重载版本。然而，像非成员函数一样，成员函数也可以被重载（<a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8" >第 7.8 节</a>）。</p>

        <p class="docText">With the exception of overloaded operators (<a class="docLink" href="ch14lev1sec9.html#ch14lev2sec34" >Section 14.9.5</a>, p. <a class="docLink" href="ch14lev1sec9.html#ch14lev2sec34" >547</a>)which have special rulesa member function overloads only other member functions of its own class. A class member function is unrelated to, and cannot overload, ordinary nonmember functions or functions declared in other classes. The same rules apply to overloaded member functions as apply to plain functions: Two overloaded members cannot have the same number and types of parameters. The function-matching (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >269</a>) process used for calls of nonmember overloaded functions also applies to calls of overloaded member functions.</p>
        <p class="docText">重载操作符（<a class="docLink" href="ch14lev1sec9.html#ch14lev2sec34" >第 14.9.5 节</a>）有特殊规则，是个例外，成员函数只能重载本类的其他成员函数。类的成员函数与普通的非成员函数以及在其他类中声明的函数不相关，也不能重载它们。重载的成员函数和普通函数应用相同的规则：两个重载成员的形参数量和类型不能完全相同。调用非成员重载函数所用到的函数匹配（<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >第 7.8.2 节</a>）过程也应用于重载成员函数的调用。</p>

	<a name="ch12lev3sec9"></a>
        <h5 class="docSection3Title">Defining Overloaded Member Functions</h5>
        <h5 class="docSection3Title">定义重载成员函数</h5>

        <p class="docText">To illustrate overloading, we might give our <tt>Screen</tt> class two overloaded members to return a given character from the window. One version will return the character currently denoted by the cursor and the other returns the character at a given row and column:</p>
	<p class="docText">为了举例说明重载，可以给出 <tt>Screen</tt> 类的两个重载成员，用于从窗口返回一个特定字符。两个重载成员中，一个版本返回由当前光标指示的字符，另一个返回指定行列处的字符：</p>
        <pre>
class Screen {
public:
    typedef std::string::size_type index;
    // <span class="docEmphItalicAlt">return character at the cursor or at a given position</span>
    char get() const { return contents[cursor]; }
    char get(index ht, index wd) const;
    // <span class="docEmphItalicAlt">remaining members</span>
private:
    std::string contents;
    index cursor;
    index height, width;
};
</pre><br>

        <p class="docText">As with any overloaded function, we select which version to run by supplying the appropriate number and/or types of arguments to a given call:</p>
        <p class="docText">与任意的重载函数一样，给指定的函数调用提供适当数目和／或类型的实参来选择运行哪个版本：</p>
        <pre>
     Screen myscreen;
     char ch = myscreen.get();// <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Screen::get()</span>
     ch = myscreen.get(0,0);  // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Screen::get(index, index)</span>
</pre><br>
        <a name="ch12lev3sec10"></a>

        <h5 class="docSection3Title">Explicitly Specifying <tt>inline</tt> Member Functions</h5>
	<h5 class="docSection3Title">显式指定 <tt>inline</tt> 成员函数</h5>

	<a name="idd1e92047"></a><a name="idd1e92054"></a><a name="idd1e92059"></a><a name="idd1e92066"></a><a name="idd1e92073"></a><a name="idd1e92082"></a><a name="idd1e92088"></a>
        <p class="docText">Member functions that are defined inside the class, such as the <tt>get</tt> member that takes no arguments, are automatically treated as <tt>inline</tt>. That is, when they are called, the compiler will attempt to expand the function inline (<a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6" >Section 7.6</a>, p. <a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6" >256</a>). We can also explicitly declare a member function as <tt>inline</tt>:</p>
	<p class="docText">在类内部定义的成员函数，例如不接受实参的 <tt>get</tt> 成员，将自动作为 <tt>inline</tt> 处理。也就是说，当它们被调用时，编译器将试图在同一行内扩展该函数（<a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6" >第 7.6 节</a>）。也可以显式地将成员函数声明为 <tt>inline</tt>：</p>
        <pre>
     class Screen {
     public:
         typedef std::string::size_type index;
         // <span class="docEmphItalicAlt">implicitly</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">when defined inside the class declaration</span>
         char get() const { return contents[cursor]; }
         // <span class="docEmphItalicAlt">explicitly declared as</span> <span class="docEmphasis">inline</span>; <span class="docEmphItalicAlt">will be defined outside the class declaration</span>
         inline char get(index ht, index wd) const;
         // <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">not specified in class declaration, but can be defined</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">later</span>
         index get_cursor() const;
         // ...
      };
     // <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">declared in the class declaration; no need to repeat on the definition</span>
     char Screen::get(index r, index c) const
     {
         index row = r * width;    // <span class="docEmphItalicAlt">compute the row location</span>
         return contents[row + c]; // <span class="docEmphItalicAlt">offset by</span> <span class="docEmphasis">c</span> <span class="docEmphItalicAlt">to fetch specified character</span>
     }
     // <span class="docEmphItalicAlt">not declared as</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">in the class declaration, but ok to make</span> <span class="docEmphasis">inline</span> <span class="docEmphItalicAlt">in definition</span>
     inline Screen::index Screen::get_cursor() const
     {
         return cursor;
     }
</pre><br>

        <p class="docText">We can specify that a member is <tt>inline</tt> as part of its declaration inside the class body. Alternatively, we can specify <tt>inline</tt> on the function definition that appears outside the class body. It is legal to specify <tt>inline</tt> both on the declaration and definition. One advantage of defining <tt>inline</tt> functions outside the class is that it can make the class easier to read.</p>
	<p class="docText">可以在类定义体内部指定一个成员为<tt>inline</tt>，作为其声明的一部分。或者，也可以在类定义外部的函数定义上指定 <tt>inline</tt>。在声明和定义处指定 <tt>inline</tt> 都是合法的。在类的外部定义 <tt>inline</tt> 的一个好处是可以使得类比较容易阅读。</p>

	<a name="ch12note04"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">As with other <tt>inline</tt>s, the definition of an <tt>inline</tt> member function must be visible in every source file that calls the function. The definition for an <tt>inline</tt> member function that is not defined within the class body ordinarily should be placed in the same header file in which the class definition appears.</p>
		<p class="docText">像其他 <tt>inline</tt> 一样，<tt>inline</tt> 成员函数的定义必须在调用该函数的每个源文件中是可见的。不在类定义体内定义的 <tt>inline</tt> 成员函数，其定义通常应放在有类定义的同一头文件中。</p>
              </td>
            </tr>
          </table><br>
        </div><br>


	<a name="ch12sb05"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.1.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa3q1"></a><b>Exercise 12.8:</b></td>

                    <td>
                      <p class="docText">Define <tt>Sales_item::avg_price</tt> as an inline function.</p>
		      <p class="docText">将 <tt>Sales_item::avg_price</tt> 定义为内联函数。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa3q2"></a><b>Exercise 12.9:</b></td>

                    <td>
                      <p class="docText">Write your own version of the <tt>Screen</tt> class presented in this section, giving it a constructor to create a <tt>Screen</tt> from values for height, width, and the contents of the screen.</p>
		      <p class="docText">修改本节中给出的 <tt>Screen</tt> 类，给出一个构造函数，根据屏幕的高度、宽度和内容的值来创建 <tt>Screen</tt>。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa3q3"></a><b>Exercise 12.10:</b></td>

                    <td>
                      <p class="docText">Explain each member in the following class:</p>
                      <p class="docText">解释下述类中的每个成员：</p>
                      <pre>
     class Record {
         typedef std::size_t size;
         Record(): byte_count(0) { }
         Record(size s): byte_count(s) { }
         Record(std::string s): name(s), byte_count(0) { }
         size byte_count;
         std::string name;
     public:
         size get_count() const { return byte_count; }
         std::string get_name() const { return name; }
     };
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>


        <a name="ch12lev2sec4"></a>
        <h4 class="docSection2Title">12.1.4. Class Declarations versus Definitions</h4>
        <h4 class="docSection2Title">12.1.4. 类声明与类定义</h4>

        <p class="docText">A class is completely defined once the closing curly brace appears. Once the class is defined, all the class members are known. The size required to store an object of the class is known as well. A class may be defined only once in a given source file. When a class is defined in multiple files, the definition in each file must be identical.</p>
        <p class="docText">一旦遇到右花括号，类的定义就结束了。并且一旦定义了类，那以我们就知道了所有的类成员，以及存储该类的对象所需的存储空间。在一个给定的源文件中，一个类只能被定义一次。如果在多个文件中定义一个类，那么每个文件中的定义必须是完全相同的。</p>

	<a name="idd1e92229"></a><a name="idd1e92236"></a><a name="idd1e92241"></a><a name="idd1e92244"></a><a name="idd1e92249"></a><a name="idd1e92254"></a><a name="idd1e92257"></a><a name="idd1e92260"></a><a name="idd1e92265"></a>
        <p class="docText">By putting class definitions in header files, we can ensure that a class is defined the same way in each file that uses it. By using header guards (<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >Section 2.9.2</a>, p. <a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >69</a>), we ensure that even if the header is included more than once in the same file, the class definition will be seen only once.</p>
        <p class="docText">将类定义在头文件中，可以保证在每个使用类的文件中以同样的方式定义类。使用头文件保护符（header guard）（<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >第 2.9.2 节</a>），来保证即使头文件在同一文件中被包含多次，类定义也只出现一次。</p>


        <p class="docText">It is possible to declare a class without defining it:</p>
        <p class="docText">可以声明一个类而不定义它：</p>
        <pre>
     class Screen; // <span class="docEmphItalicAlt">declaration of the Screen class</span>
</pre><br>

	<a name="ch12term15"></a>
        <p class="docText">This declaration, sometimes referred to as a <b><a class="docLink" href="ch12lev1sec8.html#gloss12_15" >forward declaration</a></b>, introduces the name <tt>Screen</tt> into the program and indicates that <tt>Screen</tt> refers to a class type. After a declaration and before a definition is seen, the type <tt>Screen</tt> is an <span class="docEmphStrong">incompete type</span>it's known that <tt>Screen</tt> is a type but not known what members that type contains.</p>
	<p class="docText">这个声明，有时称为<b><a class="docLink" href="ch12lev1sec8.html#gloss12_15" >前向声明（forward declaraton）</a></b>，在程序中引入了类类型的 <tt>Screen</tt>。在声明之后、定义之前，类 <tt>Screen</tt> 是一个<span class="docEmphStrong">不完全类型（incompete type）</span>，即已知 <tt>Screen</tt> 是一个类型，但不知道包含哪些成员。</p>

	<a name="ch12note05"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
		<a name="ch12term17"></a>
                <p class="docText">An <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_17" >incomplete type</a></span> can be used only in limited ways. Objects of the type may not be defined. An incomplete type may be used to define only pointers or references to the type or to declare (but not define) functions that use the type as a paremeter or return type.</p>
                <p class="docText"><span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_17" >不完全类型（incomplete type）</a></span>只能以有限方式使用。不能定义该类型的对象。不完全类型只能用于定义指向该类型的指针及引用，或者用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">A class must be fully defined before objects of that type are created. The class must be definedand not just declaredso that the compiler can know how much storage to reserve for an object of that class type. Similarly, the class must be defined before a reference or pointer is used to access a member of the type.</p>
        <p class="docText">在创建类的对象之前，必须完整地定义该类。必须定义类，而不只是声明类，这样，编译器就会给类的对象预定相应的存储空间。同样地，在使用引用或指针访问类的成员之前，必须已经定义类。</p>

	<a name="ch12lev3sec11"></a>
        <h5 class="docSection3Title">Using Class Declarations for Class Members</h5>
        <h5 class="docSection3Title">为类的成员使用类声明</h5>

        <p class="docText">A data member can be specified to be of a class type only if the definition for the class has already been seen. If the type is incomplete, a data member can be only a pointer or a reference to that class type.</p>
        <p class="docText">只有当类定义已经在前面出现过，数据成员才能被指定为该类类型。如果该类型是不完全类型，那么数据成员只能是指向该类类型的指针或引用。</p>

	<a name="idd1e92386"></a><a name="idd1e92391"></a>
        <p class="docText">Because a class is not defined until its class body is complete, a class cannot have data members of its own type. However, a class is considered declared as soon as its class name has been seen. Therefore, a class can have data members that are pointers or references to its own type:</p>
        <p class="docText">因为只有当类定义体完成后才能定义类，因此类不能具有自身类型的数据成员。然而，只要类名一出现就可以认为该类已声明。因此，类的数据成员可以是指向自身类型的指针或引用：</p>
        <pre>
     class LinkScreen {
         Screen window;
         LinkScreen *next;
         LinkScreen *prev;
     };
</pre><br>
        <a name="ch12note06"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A common use of class forward declarations is to write classes that are mutually dependent on one another. We'll see an example of such usage in <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4" >Section 13.4</a> (p. <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4" >486</a>).</p>
                <p class="docText">类的前身声明一般用来编写相互依赖的类。在第 13.4 节中，我们将看到用法的一个例子。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12sb06"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.1.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa4q1"></a><b>Exercise 12.11:</b></td>

                    <td>
                      <p class="docText">Define a pair of classes <tt>X</tt> and <tt>Y</tt>, in which <tt>X</tt> has a pointer to <tt>Y</tt>, and <tt>Y</tt> has an object of type <tt>X</tt>.</p>
		      <p class="docText">定义两个类 <tt>X</tt> 和 <tt>Y</tt>，<tt>X</tt> 中有一个指向 <tt>Y</tt> 的指针，<tt>Y</tt> 中有一个 <tt>X</tt> 类型的对象。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa4q2"></a><b>Exercise 12.12:</b></td>

                    <td>
                      <p class="docText">Explain the difference between a class declaration and definition. When would you use a class declaration? A class definition?</p>
                      <p class="docText">解释类声明与类定义之间的差异。何时使用类声明？何时使用类定义？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch12lev2sec5"></a>
        <h4 class="docSection2Title">12.1.5. Class Objects</h4>
        <h4 class="docSection2Title">12.1.5. 类对象</h4>

        <p class="docText">When we define a class, we are defining a type. Once a class is defined, we can define objects of that type. Storage is allocated when we define objects, but (ordinarily) not when we define types:</p>
        <p class="docText">定义一个类时，也就是定义了一个类型。一旦定义了类，就可以定义该类型的对象。定义对象时，将为其分配存储空间，但（一般而言）定义类型时不进行存储分配：</p>
        <pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">operations on</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">objects</span>
     private:
         std::string isbn;
         unsigned units_sold;
         double revenue;
     };
</pre><br>

        <p class="docText">defines a new type, but does not allocate any storage. When we define an object</p>
        <p class="docText">定义了一个新的类型，但没有进行存储分配。当我们定义一个对象</p>
        <pre>
     Sales_item item;
</pre><br>

        <p class="docText">the compiler allocates an area of storage sufficient to contain a <tt>Sales_item</tt> object. The name <tt>item</tt> refers to that area of storage. Each object has its own copy of the class data members. Modifying the data members of <tt>item</tt> does not change the data members of any other <tt>Sales_item</tt> object.</p>
	<p class="docText">时，编译器分配了足以容纳一个 <tt>Sales_item</tt> 对象的存储空间。<tt>item</tt> 指的就是那个存储空间。每个对象具有自己的类数据成员的副本。修改 <tt>item</tt> 的数据成员不会改变任何其他 <tt>Sales_item</tt> 对象的数据成员。</p>

	<a name="ch12lev3sec12"></a>
        <h5 class="docSection3Title">Defining Objects of Class Type</h5>
        <h5 class="docSection3Title">定义类类型的对象</h5>

	<a name="idd1e92525"></a><a name="idd1e92532"></a><a name="idd1e92539"></a><a name="idd1e92545"></a><a name="idd1e92550"></a><a name="idd1e92556"></a><a name="idd1e92563"></a>
        <p class="docText">After a class type has been defined, the type can be used in two ways:</p>
        <p class="docText">定义了一个类类型之后，可以按以下两种方式使用。</p>

        <ul>
          <li>
            <p class="docList">Using the class name directly as a type name</p>
            <p class="docList">将类的名字直接用作类型名。</p>
          </li>

          <li>
            <p class="docList">Specifying the keyword <tt>class</tt> or <tt>struct</tt>, followed by the class name:</p>
	    <p class="docList">指定关键字 <tt>class</tt> 或 <tt>struct</tt>，后面跟着类的名字：</p>
            <pre>
     Sales_item item1;       // <span class="docEmphItalicAlt">default initialized object of type</span> <span class="docEmphasis">Sales_item</span>
     class Sales_item item1; // <span class="docEmphItalicAlt">equivalent definition of</span> <span class="docEmphasis">item1</span>
</pre><br>
          </li>
        </ul>

        <p class="docText">Both methods of referring to a class type are equivalent. The second method is inherited from C and is also valid in C++. The first, more concise form was introduced by C++ to make class types easier to use.</p>
        <p class="docText">两种引用类类型方法是等价的。第二种方法是从 C 继承而来的，在 C++ 中仍然有效。第一种更为简练，由 C++ 语言引入，使得类类型更容易使用。</p>

	<a name="ch12lev3sec13"></a>
        <h5 class="docSection3Title">Why a Class Definition Ends in a Semicolon</h5>
        <h5 class="docSection3Title">为什么类的定义以分号结束</h5>

        <p class="docText">We noted on page <a class="docLink" href="ch02lev1sec8.html#ch02lev2sec26" >64</a> that a class definition ends with a semicolon. A semicolon is required because we can follow a class definition by a list of object definitions. As always, a definition must end in a semicolon:</p>
	<p class="docText">我们在<a class="docLink" href="ch02lev1sec8.html#ch02lev2sec26" >第 2.8 节</a>中指出，类的定义分号结束。分号是必需的，因为在类定义之后可以接一个对象定义列表。定义必须以分号结束：</p>
        <pre>
class Sales_item { /* ... */ };
class Sales_item { /* ... */ } accum, trans;
</pre><br>
        <a name="ch12note07"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Ordinarily, it is a bad idea to define an object as part of a class definition. Doing so obscures what's happening. It is confusing to readers to combine definitions of two different entitiesthe class and a variablein a single statement.</p>
                <p class="docText">通常，将对象定义成类定义的一部分是个坏主意。这样做，会使所发生的操作难以理解。对读者而言，将两个不同的实体（类和变量）组合在一个语句中，也会令人迷惑不解。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch12.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch12lev1sec2.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
