<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 16.4.  Class Template Members</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch16lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch16lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch16lev1sec4"></a>

        <h3 class="docSection1Title">16.4. Class Template Members</h3>
        <h3 class="docSection1Title">16.4. 类模板成员</h3>

        <p class="docText">So far we have seen only how to declare the interface members of our <tt>Queue</tt> class template. In this section, we'll look at how we might implement the class.</p>
	<p class="docText">到目前为止，我们只介绍了怎样声明 <tt>Queue</tt> 类模板的接口成员，本节将介绍怎样实现该类。</p>
	
	<a name="ch16note10"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The standard library implements <tt>queue</tt> as an adaptor (<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7" >Section 9.7</a>, p. <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7" >348</a>) on top of another container. To emphasize the programming points involved in using a lower-level data structure, we'll implement our <tt>Queue</tt> class as a linked list. In practice, using a library container in our implementation would probably be a better decision.</p>
                <p class="docText">标准库将 <tt>queue</tt> 实现为其他容器之上的适配器（<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7" >第 9.7 节</a>）。为了强调在使用低级数据结构中涉及的编程要点，我们将 <tt>Queue</tt> 实现为链表。实际上，在我们的实现中使用标准库容器可能是一个更好的决定。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16lev2sec14"></a>

        <h4 class="docSection2Title"><tt>Queue</tt> Implementation Strategy</h4>
        <h4 class="docSection2Title"><tt>Queue</tt> 的实现策略</h4>

        <p class="docText">Our implementation, shown in <a class="docLink" href="ch16lev1sec4.html#ch16fig01">Figure 16.1</a> on the next page, uses two classes:</p>
	<p class="docText">如<a class="docLink" href="ch16lev1sec4.html#ch16fig01">图 16.1</a> 所示，我们的实现使用两个类：</p>
	
	<a name="ch16fig01"></a>
        <center>
          <h5 class="docFigureTitle">Figure 16.1. <tt>Queue</tt> Implementation</h5>
          <h5 class="docFigureTitle"></h5>

          <p class="docText"><img border="0" alt="" width="461" height="116" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/16fig01.gif;400478" ></p>
        </center><br>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">Class <tt>QueueItem</tt> will represent a node in <tt>Queue</tt>'s linked list. This class has two data members: <tt>item</tt> and <tt>next</tt>:</p>
                <p class="docList"><tt>QueueItem</tt> 类表示 <tt>Queue</tt> 的链表中的节点，该类有两个数据成员 <tt>item</tt> 和 <tt>next</tt>：</p>

                <ul>
                  <li>
                    <p class="docList"><tt>item</tt> holds the value of the element in the <tt>Queue</tt>; its type varies with each instance of <tt>Queue</tt>.</p>
                <p class="docList"><tt>item</tt> 保存 <tt>Queue</tt> 中元素的值，它的类型随 <tt>Queue</tt> 的每个实例而变化。</p>
                  </li>

                  <li>
                    <p class="docList"><tt>next</tt> is a pointer to the next <tt>QueueItem</tt> object in the queue.</p>
                <p class="docList"><tt>next</tt> 是队列中指向下一 <tt>QueueItem</tt> 对象的指针。</p>
                  </li>
                </ul>

                <p class="docList">Each element in the <tt>Queue</tt> is stored in a <tt>QueueItem</tt> object.</p>
                <p class="docList"><tt>Queue</tt> 中的每个元素保存在一个 <tt>QueueItem</tt> 对象中。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Class <tt>Queue</tt> will provide the interface functions described in <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2" >Section 16.1.2</a> (p. <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2" >627</a>). The <tt>Queue</tt> class will also have two data members: <tt>head</tt> and <tt>tail</tt>. These members are pointers to <tt>QueueItem</tt>.</p>
                <p class="docList"><tt>Queue</tt> 类将提供<a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2" >第 16.1.2 节</a>描述的接口函数，<tt>Queue</tt> 类也有两个数据成员：<tt>head</tt> 和 <tt>tail</tt>，这些成员是 <tt>QueueItem</tt> 指针。</p>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">As do the standard containers, our <tt>Queue</tt> class will copy the values it's given.</p>
	<p class="docText">像标准容器一样，<tt>Queue</tt> 类将复制指定给它的值。</p>
	
	<a name="ch16lev2sec15"></a>
        <h4 class="docSection2Title">The <tt>QueueItem</tt> Class</h4>
        <h4 class="docSection2Title"><tt>QueueItem</tt> 类</h4>

	<a name="idd1e127863"></a><a name="idd1e127869"></a><a name="idd1e127875"></a>
        <p class="docText">We'll start our implementation by writing the <tt>QueueItem</tt> class:</p>
        <p class="docText">首先编写 <tt>QueueItem</tt> 类：</p>
        <pre>
     template &lt;class Type&gt; class QueueItem {
     // <span class="docEmphItalicAlt">private class: no public section</span>
         QueueItem(const Type &amp;t): item(t), next(0) { }
         Type item;           // <span class="docEmphItalicAlt">value stored in this element</span>
         QueueItem *next;     // <span class="docEmphItalicAlt">pointer to next element in the</span> <span class="docEmphasis">Queue</span>
     };
</pre><br>

        <p class="docText">As it stands, this class is already complete: It holds two data elements, which its constructor initializes. Like <tt>Queue, QueueItem</tt> is a class template. The class uses its template parameter to name the type of its <tt>item</tt> member. The value of each element in the <tt>Queue</tt> will be stored in <tt>item</tt>.</p>
        <p class="docText">这个类似乎已经差不多完整了：它保存由其构造函数初始化的两个数据成员。像 <tt>Queue</tt> 类一样，<tt>QueueItem</tt> 是一个类模板，该类使用模板形参指定 <tt>item</tt> 成员的类型，<tt>Queue</tt> 中每个元素的值将保存在 <tt>item</tt> 中。</p>

        <p class="docText">Each time we instantiate a <tt>Queue</tt> class, the same version of <tt>QueueItem</tt> will be instantiated as well. For example, if we create <tt>Queue&lt;int&gt;</tt>, then a companion class, <tt>QueueItem&lt;int&gt;</tt>, will be instantiated.</p>
        <p class="docText">每当实例化一个 <tt>Queue</tt> 类的时候，也将实例化 <tt>QueueItem</tt> 的相同版本。例如，如果创建 <tt>Queue&lt;int&gt;</tt>，则将实例化一个伙伴类 <tt>QueueItem&lt;int&gt;</tt>。</p>

        <p class="docText">Class <tt>QueueItem</tt> is a private classit has no public interface. We intend this class to be used to implement <tt>Queue</tt> and have not built it for general use. Hence, it has no public members. We'll need to make class <tt>Queue</tt> a friend of <tt>QueueItem</tt> so that its members can access the members of <tt>QueueItem</tt>. We'll see how to do so in <a class="docLink" href="ch16lev1sec4.html#ch16lev2sec21">Section 16.4.4</a> (p. <a class="docLink" href="ch16lev1sec4.html#ch16lev2sec21">658</a>).</p>
        <p class="docText"><tt>QueueItem</tt> 类为私有类——它没有公用接口。我们这个类只是为实现 <tt>Queue</tt>，并不想用于一般目的，因此，它没有公用成员。需要将 <tt>Queue</tt> 类设为 <tt>QueueItem</tt> 类的友元，以便 <tt>Queue</tt> 类成员能够访问 <tt>QueueItem</tt> 的成员。<a class="docLink" href="ch16lev1sec4.html#ch16lev2sec21">第 16.4.4 节</a>将介绍怎样做。</p>

<a name="ch16note11"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Inside the scope of a class template, we may refer to the class using its unqualified name.</p>
                <p class="docText">在类模板的作用域内部，可以用它的非限定名字引用该类。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16lev2sec16"></a>

        <h4 class="docSection2Title">The <tt>Queue</tt> Class</h4>
        <h4 class="docSection2Title"><tt>Queue</tt> 类</h4>

        <p class="docText">We can now flesh out our <tt>Queue</tt> class:</p>
        <p class="docText">现在充实 <tt>Queue</tt> 类：</p>
        <pre>
     template &lt;class Type&gt; class Queue {
     public:
         // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">Queue</span>
         Queue(): head(0), tail(0) { }
         // <span class="docEmphItalicAlt">copy control to manage pointers to</span> <span class="docEmphasis">QueueItem</span><span class="docEmphItalicAlt">s in the</span> <span class="docEmphasis">Queue</span>
         Queue(const Queue &amp;Q): head(0), tail(0)
                                       { copy_elems(Q); }
         Queue&amp; operator=(const Queue&amp;);
         ~Queue() { destroy(); }
              // <span class="docEmphItalicAlt">return element from head of</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">unchecked operation: front on an empty</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is undefined</span>
         Type&amp; front()             { return head-&gt;item; }
         const Type &amp;front() const { return head-&gt;item; }
         void push(const Type &amp;);       // <span class="docEmphItalicAlt">add element to back of</span> <span class="docEmphasis">Queue</span>
         void pop ();                    // <span class="docEmphItalicAlt">remove element from head of</span> <span class="docEmphasis">Queue</span>
         bool empty () const {           // <span class="docEmphItalicAlt">true if no elements in the</span> <span class="docEmphasis">Queue</span>
             return head == 0;
         }
     private:
         QueueItem&lt;Type&gt; *head;         // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
         QueueItem&lt;Type&gt; *tail;         // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">utility functions used by copy constructor, assignment, and destructor</span>
         void destroy();                // <span class="docEmphItalicAlt">delete all the elements</span>
         void copy_elems(const Queue&amp;); // <span class="docEmphItalicAlt">copy elements from parameter</span>
     };
</pre><br>

	<a name="idd1e128059"></a><a name="idd1e128064"></a>
        <p class="docText">In addition to the interface members, we have added the three copy-control members (<a class="docLink" href="ch13.html#ch13" >Chapter 13</a>) and associated utility functions used by those members. The <tt>private</tt> utility functions <tt>destroy</tt> and <tt>copy_elems</tt> will do the work of freeing the elements in the <tt>Queue</tt> and copying elements from another <tt>Queue</tt> into this one. The copy-control members are needed to manage the data members, <tt>head</tt> and <tt>tail</tt>, which are pointers to the first and last elements in the <tt>Queue</tt>. These elements are values of type <tt>QueueItem&lt;Type&gt;</tt>.</p>
	<p class="docText">除了接口成员之外，还增加了三个复制控制成员（<a class="docLink" href="ch13.html#ch13" >第十三章</a>）以及那些成员所用的相关实用函数。<tt>private</tt> 实用函数 <tt>destroy</tt> 和 <tt>copy_elems</tt> 将完成释放 <tt>Queue</tt> 中的元素以及从另一 <tt>Queue</tt> 复制元素到这个 <tt>Queue</tt> 的任务。复制控制成员用于管理数据成员 <tt>head</tt> 和 <tt>tail</tt>，<tt>head</tt> 和 <tt>tail</tt> 是指向 <tt>Queue</tt> 中首尾元素的指针，这些成员是 <tt>QueueItem&lt;Type&gt;</tt> 类型的值。</p>

        <p class="docText">The class implements several of its member functions:</p>
	<p class="docText"><tt>Queue</tt> 类实现了几个成员函数：</p>

        <ul>
          <li>
            <p class="docList">The default constructor sets both <tt>head</tt> and <tt>tail</tt> pointers to zero, indicating that the <tt>Queue</tt> is currently empty.</p>
	    <p class="docList">默认构造函数，将 <tt>head</tt> 和 <tt>tail</tt> 指针置 0,指明当前 <tt>Queue</tt> 为空。</p>
          </li>

          <li>
            <p class="docList">The copy constructor initializes <tt>head</tt> and <tt>tail</tt>, and calls <tt>copy_elems</tt> to copy the elements from its initializer.</p>
	    <p class="docList">复制构造函数，初始化 <tt>head</tt> 和 <tt>tail</tt>，并调用 <tt>copy_elems</tt> 从它的初始器复制元素。</p>
          </li>

          <li>
            <p class="docList">The <tt>front</tt> functions return the value at the head of the <tt>Queue</tt>. These functions do no checking: As with the analogous operations in the standard <tt>queue</tt>, users may not run <tt>front</tt> on an empty <tt>Queue</tt>.</p>
	    <p class="docList">几个 <tt>front</tt> 函数，返回头元素的值。这些函数不进行检查：像标准 <tt>queue</tt> 中的类似操作一样，用户不能在空 <tt>Queue</tt> 上运行 <tt>front</tt> 函数。</p>
          </li>

          <li>
            <p class="docList">The <tt>empty</tt> function returns the result of comparing <tt>head</tt> with zero. If <tt>head</tt> is zero, the <tt>Queue</tt> is empty; otherwise, it is not.</p>
	    <p class="docList"><tt>empty</tt> 函数，返回 <tt>head</tt> 与 0 的比较结果。如果 <tt>head</tt> 为 0，<tt>Queue</tt> 为空；否则，<tt>Queue</tt> 是非空的。</p>
          </li>
  </ul><a name="ch16lev2sec17"></a>

        <h4 class="docSection2Title">References to a Template Type in the Scope of the Template</h4>
        <h4 class="docSection2Title">模板作用域中模板类型的引用</h4>

        <p class="docText">For the most part, this class definition should be familiar. It differs little from other classes that we have defined. What is new is the use (or lack thereof) of the template type parameter in references to the <tt>Queue</tt> and <tt>QueueItem</tt> types.</p>
	<p class="docText">这个类的主要部分应该是我们熟悉的。它只与我们已经定义过的类有少许区别。新的内容是 <tt>Queue</tt> 类型和 <tt>QueueItem</tt> 类型的引用中对模板类型形参的使用（或缺少）。</p>

        <p class="docText">Ordinarily, when we use the name of a class template, we must specify the template parameters. There is one exception to this rule: Inside the scope of the class itself, we may use the unqualified name of the class template. For example, in the declarations of the default and copy constructor the name <tt>Queue</tt> is a shorthand notation that stands for <tt>Queue&lt;Type&gt;</tt>. Essentially the compiler infers that when we refer to the name of the class, we are referring to the same version. Hence, the copy constructor definition is really equivalent to writing:</p>
	<p class="docText">通常，当使用类模板的名字的时候，必须指定模板形参。这一规则有个例外：在类本身的作用域内部，可以使用类模板的非限定名。例如，在默认构造函数和复制构造函数的声明中，名字 <tt>Queue</tt> 是 <tt>Queue&lt;Type&gt;</tt> 缩写表示。实质上，编译器推断，当我们引用类的名字时，引用的是同一版本。因此，复制构造函数定义其实等价于：</p>
        <pre>
     Queue&lt;Type&gt;(const Queue&lt;Type&gt; &amp;Q): head(0), tail(0)
                 { copy_elems(Q); }
</pre><br>

        <p class="docText">The compiler performs no such inference for the template parameter(s) for other templates used within the class. Hence, we must specify the type parameter when declaring pointers to the companion <tt>QueueItem</tt> class:</p>
        <p class="docText">编译器不会为类中使用的其他模板的模板形参进行这样的推断，因此，在声明伙伴类 <tt>QueueItem</tt> 的指针时，必须指定类型形参：</p>
        <pre>
     QueueItem&lt;Type&gt; *head;    // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
     QueueItem&lt;Type&gt; *tail;    // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
</pre><br>

        <p class="docText">These declarations say that for a given instantiation of class <tt>Queue, head</tt> and <tt>tail</tt> point to an object of type <tt>QueueItem</tt> instantiated for the same template parameter. That is, the type of <tt>head</tt> and <tt>tail</tt> inside the <tt>Queue&lt;int&gt;</tt> instantiation is <tt>QueueItem&lt;int&gt;*</tt>. It would be an error to omit the template parameter in the definition of the <tt>head</tt> and <tt>tail</tt> members:</p>
        <p class="docText">这些声明指出，对于 <tt>Queue</tt> 类的给定实例化，<tt>head</tt> 和 <tt>tail</tt> 指向为同一模板形参实例化的 <tt>QueueItem</tt> 类型的对象，即，在 <tt>Queue&lt;int&gt;</tt> 实例化的内部，<tt>head</tt> 和 <tt>tail</tt> 的类型是 <tt>QueueItem&lt;int&gt;*</tt>。在 <tt>head</tt> 和 <tt>tail</tt> 成员的定义中省略模板形参将是错误的：</p>
        <pre>
     QueueItem *head;        // <span class="docEmphItalicAlt">error: which version of</span> <span class="docEmphasis">QueueItem?</span>
     QueueItem *tail;        // <span class="docEmphItalicAlt">error: which version of</span> <span class="docEmphasis">QueueItem?</span>
</pre><br>
        <a name="ch16sb12"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa10q1"></a><b>Exercise 16.30:</b></td>

                    <td>
                      <p class="docText">Identify which, if any, of the following class template declarations (or declaration pairs) are illegal.</p>
                      <p class="docText">如果有，指出下面类模板声明（或声明对）中哪些是非法的。</p>
                      <pre>
     (a) template &lt;class Type&gt; class C1;
         template &lt;class Type, int size&gt; class C1;
     (b) template &lt;class T, U, class V&gt; class C2;
     (c) template &lt;class C1, typename C2&gt; class C3 { };
     (d) template &lt;typename myT, class myT&gt; class C4 { };
     (e) template &lt;class Type, int *ptr&gt; class C5;
         template &lt;class T, int *pi&gt; class C5;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa10q2"></a><b>Exercise 16.31:</b></td>

                    <td>
                      <p class="docText">The following definition of <tt>List</tt> is incorrect. How would you fix it?</p>
                      <p class="docText">下面 <tt>List</tt> 的定义不正确，怎样改正？</p>
                      <pre>
     template &lt;class elemType&gt; class ListItem;
     template &lt;class elemType&gt; class List {
     public:
         List&lt;elemType&gt;();
         List&lt;elemType&gt;(const List&lt;elemType&gt; &amp;);
         List&lt;elemType&gt;&amp; operator=(const List&lt;elemType&gt; &amp;);
         ~List();
         void insert(ListItem *ptr, elemType value);
         ListItem *find(elemType value);
     private:
         ListItem *front;
         ListItem *end;
     };
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec18"></a>

        <h4 class="docSection2Title">16.4.1. Class-Template Member Functions</h4>
        <h4 class="docSection2Title">16.4.1. 类模板成员函数</h4>

	<a name="idd1e128329"></a><a name="idd1e128336"></a><a name="idd1e128343"></a><a name="idd1e128353"></a><a name="idd1e128363"></a><a name="idd1e128371"></a>
        <p class="docText">The definition of a member function of a class template has the following form:</p>
        <p class="docText">类模板成员函数的定义具有如下形式：</p>

        <ul>
          <li>
            <p class="docList">It must start with the keyword <tt>template</tt> followed by the template parameter list for the class.</p>
            <p class="docList">必须以关键字 <tt>template</tt> 开关，后接类的模板形参表。</p>
          </li>

          <li>
            <p class="docList">It must indicate the class of which it is a member.</p>
            <p class="docList">必须指出它是哪个类的成员。</p>
          </li>

          <li>
            <p class="docList">The class name must include its template parameters.</p>
            <p class="docList">类名必须包含其模板形参。</p>
          </li>
        </ul>

        <p class="docText">From these rules, we can see that a member function of class <tt>Queue</tt> defined outside the class will start as</p>
        <p class="docText">从这些规则可以看到，在类外定义的 <tt>Queue</tt> 类的成员函数的开关应该是：</p>
        <pre>
     template &lt;class T&gt; <span class="docEmphasis">ret-type</span> Queue&lt;T&gt;::<span class="docEmphasis">member-name</span>
</pre><br>
        <a name="ch16lev3sec19"></a>

        <h5 class="docSection3Title">The <tt>destroy</tt> Function</h5>
        <h5 class="docSection3Title"><tt>destroy</tt> 函数</h5>

        <p class="docText">To illustrate a class template member function defined outside its class, let's look at the <tt>destroy</tt> function:</p>
        <p class="docText">为了举例说明在类外定义的类模板成员函数，我们来看 <tt>destroy</tt> 函数：</p>
        <pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::destroy()
     {
         while (!empty())
             pop();
     }
</pre><br>

        <p class="docText">This definition can be read from left to right as:</p>
        <p class="docText">这个定义可以从左至右读作：</p>

        <ul>
          <li>
            <p class="docList">Defining a function template with a single type parameter named <tt>Type</tt></p>
            <p class="docList">用名为 <tt>Type</tt> 的类型形参定义一个函数模板；</p>
          </li>

          <li>
            <p class="docList">that returns <tt>void</tt>,</p>
            <p class="docList">它返回 <tt>void</tt>；</p>
          </li>

          <li>
            <p class="docList">which is in the scope of the <tt>Queue&lt;Type&gt;</tt> class template.</p>
            <p class="docList">它是在类模板 <tt>Queue&lt;Type&gt;</tt> 的作用域中。</p>
          </li>
        </ul>

        <p class="docText">The use of <tt>Queue&lt;Type&gt;</tt> preceding the scope operator (<tt>::</tt>) names the class to which the member function belongs.</p>
        <p class="docText">在作用域操作符（<tt>::</tt>）之前使用的 <tt>Queue&lt;Type&gt;</tt> 指定成员函数所属的类。</p>

        <p class="docText">Following the member-function name is the function definition. In the case of <tt>destroy</tt>, the function body looks very much like an ordinary nontemplate function definition. Its job is to walk the list of entries in this <tt>Queue</tt>, calling <tt>pop</tt> to remove each item.</p>
        <p class="docText">跟在成员函数名之后的是函数定义。在 <tt>destroy</tt> 的例子中，函数体看来很普通的非模板函数定义，它的工作是遍历这个 <tt>Queue</tt> 的每个分支，调用 <tt>pop</tt> 除去每一项。</p>

<a name="ch16lev3sec20"></a>
        <h5 class="docSection3Title">The <tt>pop</tt> Function</h5>
        <h5 class="docSection3Title"><tt>pop</tt> 函数</h5>

        <p class="docText">The <tt>pop</tt> member removes the value at the front of the <tt>Queue</tt>:</p>
        <p class="docText"><tt>pop</tt> 成员的作用是除去 <tt>Queue</tt> 的队头值：</p>
        <pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::pop()
     {
         // <span class="docEmphItalicAlt">pop is unchecked: Popping off an empty</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is undefined</span>
         QueueItem&lt;Type&gt;* p = head; // <span class="docEmphItalicAlt">keep pointer to</span> <span class="docEmphasis">head</span> <span class="docEmphItalicAlt">so we can delete it</span>
         head = head-&gt;next;         // <span class="docEmphasis">head</span> <span class="docEmphItalicAlt">now points to next element</span>
         delete p;                  // <span class="docEmphItalicAlt">delete old</span> <span class="docEmphasis">head</span> <span class="docEmphItalicAlt">element</span>
      }
</pre><br>

<a name="idd1e128548"></a><a name="idd1e128558"></a><a name="idd1e128568"></a><a name="idd1e128576"></a>
        <p class="docText">The <tt>pop</tt> function assumes that users do not call <tt>pop</tt> on an empty <tt>Queue</tt>. The job of <tt>pop</tt> is to remove the element at the start of the <tt>Queue</tt>. We must reset the <tt>head</tt> pointer to point to the next element in the <tt>Queue</tt>, and then delete the element that had been at the <tt>head</tt>. The only tricky part is remembering to keep a separate pointer to that element so we can delete it after resetting the <tt>head</tt> pointer.</p>
        <p class="docText"><tt>pop</tt> 函数假设用户不会在空 <tt>Queue</tt> 上调用 <tt>pop</tt>。<tt>pop</tt> 的工作是除去 <tt>Queue</tt> 的头元素。必须重置 <tt>head</tt> 指针以指向 <tt>Queue</tt> 中的下一元素，然后删除 <tt>head</tt> 位置的元素。唯一有技巧的部分是记得保持指向该元素的一个单独指针，以便在重置 <tt>head</tt> 指针之后可以删除元素。</p>

<a name="ch16lev3sec21"></a>
        <h5 class="docSection3Title">The <tt>push</tt> Function</h5>
        <h5 class="docSection3Title"><tt>push</tt> 函数</h5>

        <p class="docText">The <tt>push</tt> member places a new item at the back of the queue:</p>
        <p class="docText"><tt>push</tt> 成员将新项放在队列末尾：</p>
        <pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::push(const Type &amp;val)
     {
         // <span class="docEmphItalicAlt">allocate a new</span> <span class="docEmphasis">QueueItem</span> <span class="docEmphItalicAlt">object</span>
         QueueItem&lt;Type&gt; *pt = new QueueItem&lt;Type&gt;(val);
         // <span class="docEmphItalicAlt">put item onto existing queue</span>
         if (empty())
             head = tail = pt; // <span class="docEmphItalicAlt">the queue now has only one element</span>
         else {
             tail-&gt;next = pt; // <span class="docEmphItalicAlt">add new element to end of the queue</span>
             tail = pt;
         }
     }
</pre><br>

        <p class="docText">This function starts by allocating a new <tt>QueueItem</tt>, which is initialized from the value we were passed. There's actually a surprising bit of work going on in this statement:</p>
        <p class="docText">这个函数首先分配新的 <tt>QueueItem</tt> 对象，用传递的值初始化它。这里实际上有些令人惊讶的工作，陈述如下：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">The <tt>QueueItem</tt> constructor copies its argument into the <tt>QueueItem</tt>'s <tt>item</tt> member. As do the standard containers, our <tt>Queue</tt> class stores copies of the elements it is given.</p>
                <p class="docList"><tt>QueueItem</tt> 构造函数将实参复制到 <tt>QueueItem</tt> 对象的 <tt>item</tt> 成员。像标准容器所做的一样，<tt>Queue</tt> 类存储所给元素的副本。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">If <tt>item</tt> is a class type, the initialization of <tt>item</tt> uses the copy constructor of whatever type <tt>item</tt> has.</p>
                <p class="docList">如果 <tt>item</tt> 为类类型，<tt>item</tt> 的初始化使用 <tt>item</tt> 所具有任意类型的复制构造函数。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">The <tt>QueueItem</tt> constructor also initializes the <tt>next</tt> pointer to 0 to indicate that this element points to no other <tt>QueueItem</tt>.</p>
                <p class="docList"><tt>QueueItem</tt> 构造函数还将 <tt>next</tt> 指针初始化为 0，以指出该元素没有指向其他 <tt>QueueItem</tt> 对象。</p>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">Because we're adding the element at the end of the <tt>Queue</tt>, setting <tt>next</tt> to 0 is eactly what we want.</p>
        <p class="docText">因为将在 <tt>Queue</tt> 的末尾增加元素，将 <tt>next</tt> 置 0 正是我们所希望的。</p>

        <p class="docText">Having created and initialized a new element, we must next hook it into the <tt>Queue</tt>. If the <tt>Queue</tt> is empty, then both <tt>head</tt> and <tt>tail</tt> should point to this new element. If there are already other elements in the <tt>Queue</tt>, then we make the current <tt>tail</tt> element point to this new element. The old <tt>tail</tt> is no longer the last element, which we indicate by making <tt>tail</tt> point to the newly constructed element as well.</p>
        <p class="docText">创建和初始化新元素之后，必须将它链入 <tt>Queue</tt>。如果 <tt>Queue</tt> 为空，则 <tt>head</tt> 和 <tt>tail</tt> 都应该指向这个新元素。如果 <tt>Queue</tt> 中已经有元素了，则使当前 <tt>tail</tt> 元素指向这个新元素。旧的 <tt>tail</tt> 不再是最后一个元素了，这也是通过使 <tt>tail</tt> 指向新构造的元素指明的。</p>

<a name="ch16lev3sec22"></a>
        <h5 class="docSection3Title">The <tt>copy</tt> Function</h5>
        <h5 class="docSection3Title"><tt>copy_elems</tt> 函数</h5>

        <p class="docText">Aside from the assignment operator, which we leave as an exercise, the only remaining function to write is <tt>copy_elems</tt>. This function is designed to be used by the assignment operator and copy constructor. Its job is to copy the elements from its parameter into this <tt>Queue</tt>:</p>
        <p class="docText">我们将赋值操作符的实现留作习题，剩下要编写的函数只有 <tt>copy_elems</tt> 了。设计该函数的目的是供赋值操作符和复制构造函数使用，它的工作是从形参中复制元素到这个 <tt>Queue</tt>：</p>
        <pre>
     template &lt;class Type&gt;
     void Queue&lt;Type&gt;::copy_elems(const Queue &amp;orig)
     {
         // <span class="docEmphItalicAlt">copy elements from</span> <span class="docEmphasis">orig</span> <span class="docEmphItalicAlt">into this</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">loop stops when</span> <span class="docEmphasis">pt == 0,</span> <span class="docEmphItalicAlt">which happens when we reach</span> <span class="docEmphasis">orig.tail</span>
         for (QueueItem&lt;Type&gt; *pt = orig.head; pt; pt = pt-&gt;next)
             push(pt-&gt;item); // <span class="docEmphItalicAlt">copy the element</span>
      }
</pre><br>

	<a name="idd1e128794"></a><a name="idd1e128799"></a><a name="idd1e128806"></a><a name="idd1e128813"></a><a name="idd1e128818"></a><a name="idd1e128825"></a>
        <p class="docText">We copy the elements in a <tt>for</tt> loop that starts by setting <tt>pt</tt> equal to the parameter's <tt>head</tt> pointer. The <tt>for</tt> continues until <tt>pt</tt> is 0, which happens after we get to the element that is the last one in <tt>orig</tt>. For each element in <tt>orig</tt>, we <tt>push</tt> a copy of value in that element onto this <tt>Queue</tt> and advance <tt>pt</tt> to point to the next element in <tt>orig</tt>.</p>
        <p class="docText">在 <tt>for</tt> 循环中复制元素，<tt>for</tt> 循环始于将 <tt>pt</tt> 设为等于形参的 <tt>head</tt> 指针。循环进行直至获得 <tt>orig</tt> 中最后一个元素之后，<tt>pt</tt> 为 0。对于 <tt>orig</tt> 中的每个元素，将该元素值的副本 <tt>push</tt> 到这个 <tt>Queue</tt>，并推进 <tt>pt</tt> 以指向 <tt>orig</tt> 中的下一元素。</p>

	<a name="ch16lev3sec23"></a>
        <h5 class="docSection3Title">Instantiation of Class-Template Member Functions</h5>
        <h5 class="docSection3Title">类模板成员函数的实例化</h5>

        <p class="docText">Member functions of class templates are themselves function templates. Like any other function template, a member function of a class template is used to generate instantiations of that member. Unlike other function templates, the compiler does not perform template-argument deduction when instantiating class template member functions. Instead, the template parameters of a class template member function are determined by the type of the object on which the call is made. For example, when we call the <tt>push</tt> member of an object of type <tt>Queue&lt;int&gt;</tt>, the <tt>push</tt> function that is instantiated is</p>
        <p class="docText">类模板的成员函数本身也是函数模板。像任何其他函数模板一样，需要使用类模板的成员函数产生该成员的实例化。与其他函数模板不同的是，在实例化类模板成员函数的进修，编译器不执行模板实参推断，相反，类模板成员函数的模板形参由调用该函数的对象的类型确定。例如，当调用 <tt>Queue&lt;int&gt;</tt>　类型对象的 <tt>push</tt> 成员时，实例化的 <tt>push</tt> 函数为</p>
        <pre>
     void Queue&lt;int&gt;::push(const int &amp;val)
</pre><br>

        <p class="docText">The fact that member-function template parameters are fixed by the template arguments of the object means that calling a class template member function is more flexible than comparable calls to function templates. Normal conversions are allowed on arguments to function parameters that were defined using the template parameter:</p>
        <p class="docText">对象的模板实参能够确定成员函数模板形参，这一事实意味着，调用类模板成员函数比调用类似函数模板更灵活。用模板形参定义的函数形参的实参允许进行常规转换：</p>
        <pre>
     Queue&lt;int&gt; qi; // <span class="docEmphItalicAlt">instantiates class</span> <span class="docEmphasis">Queue&lt;int&gt;</span>
     short s = 42;
     int i = 42;
     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and passed to</span> <span class="docEmphasis">push</span>
     qi.push(s); // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::push(const int&amp;)</span>
     qi.push(i); // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">Queue&lt;int&gt;::push(const int&amp;)</span>
     f(s);       // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">f(const short&amp;)</span>
     f(i);       // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">f(const int&amp;)</span>
</pre><br>
        <a name="ch16lev3sec24"></a>

        <h5 class="docSection3Title">When Classes and Members Are Instantiated</h5>
        <h5 class="docSection3Title">何时实例化类和成员</h5>

        <p class="docText">Member functions of a class template are instantiated only for functions that are used by the program. If a function is never used, then that member function is never instantiated. This behavior implies that types used to instantiate a template need to meet only the requirements of the operations that are actually used. As an example, recall the sequential container constructor (<a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1" >Section 9.1.1</a>, p. <a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1" >309</a>) that takes <a name="idd1e128961"></a>only a size parameter. That constructor uses the default constructor for the element type. If we have a type that does not define the default constructor, we may still define a container to hold this type. However, we may not use the constructor that takes only a size.</p>
        <p class="docText">类模板的成员函数只有为程序所用才进行实例化。如果某函数从未使用，则不会实例化该成员函数。这一行为意味着，用于实例化模板的类型只需满足实际使用的操作的要求。<a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1" >第 9.1.1 节</a>中只接受一个容量形参的顺序容器构造函数就是这样的例子，该构造函数使用元素类型的默认构造函数。如果有一个没有定义默认构造函数的类型，仍然可以定义容器来保存该类型，但是，不能使用只接受一个容量的构造函数。</p>

        <p class="docText">When we define an object of a template type, that definition causes the class template to be instantiated. Defining an object also instantiates whichever constructor was used to initialize the object, along with any members called by that constructor:</p>
        <p class="docText">定义模板类型的对象时，该定义导致实例化类模板。定义对象也会实例化用于初始化该对象的任一构造函数，以及该构造函数调用的任意成员：</p>
        <pre>
     // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;</span> <span class="docEmphItalicAlt">class and</span> <span class="docEmphasis">Queue&lt;int&gt;::Queue()</span>
     Queue&lt;string&gt; qs;
     qs.push("hello"); // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::push</span>
</pre><br>

        <p class="docText">The first statement instantiates the <tt>Queue&lt;string&gt;</tt> class and its default constructor. The next statement instantiates the <tt>push</tt> member function.</p>
        <p class="docText">第一个语句实例化 Queue<string> 类及其默认构造函数，第二个语句实例化 push 成员函数。</p>

        <p class="docText">The instantiation of the <tt>push</tt> member:</p>
        <p class="docText">push 成员的实例化：</p>
        <pre>
     template &lt;class Type&gt; void Queue&lt;Type&gt;::push(const Type &amp;val)
     {
          // <span class="docEmphItalicAlt">allocate a new</span> <span class="docEmphasis">QueueItem</span> <span class="docEmphItalicAlt">object</span>
          QueueItem&lt;Type&gt; *pt = new QueueItem&lt;Type&gt;(val);
          // <span class="docEmphasis">put item onto existing queue</span>
          if (empty())
              head = tail = pt;    // <span class="docEmphItalicAlt">the queue now has only one element</span>
          else {
              tail-&gt;next = pt;     // <span class="docEmphItalicAlt">add new element to end of the queue</span>
              tail = pt;
          }
     }
</pre><br>

        <p class="docText">in turn instantiates the companion <tt>QueueItem&lt;string&gt;</tt> class and its constructor.</p>
        <p class="docText">将依次实例化伙伴类 <tt>QueueItem&lt;string&gt;</tt> 及其构造函数。</p>

        <p class="docText">The <tt>QueueItem</tt> members in <tt>Queue</tt> are pointers. Defining a pointer to a class template doesn't instantiate the class; the class is instantiated only when we use such a pointer. Thus, <tt>QueueItem</tt> is not instantiated when we create a <tt>Queue</tt> object. Instead, the <tt>QueueItem</tt> class is instanatiated when a <tt>Queue</tt> member such as <tt>front, push</tt>, or <tt>pop</tt> is used.</p>
	<p class="docText"><tt>Queue</tt> 类中的 <tt>QueueItem</tt> 成员是指针。类模板的指针定义不会对类进行实例化，只有用到这样的指针时才会对类进行实例化。因此，在创建 <tt>Queue</tt> 对象进不会实例化 <tt>QueueItem</tt> 类，相反，在使用诸如 <tt>front</tt>、<tt>push</tt> 或 <tt>pop</tt> 这样的 <tt>Queue</tt> 成员时才实例化 <tt>QueueItem</tt> 类。</p>

<a name="ch16sb13"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.4.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa11q1"></a><b>Exercise 16.32:</b></td>

                    <td>
                      <p class="docText">Implement the assignment operator for class <tt>Queue</tt>.</p>
                      <p class="docText">为 <tt>Queue</tt> 类实现赋值操作符。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa11q2"></a><b>Exercise 16.33:</b></td>

                    <td>
                      <p class="docText">Explain how the <tt>next</tt> pointers in the newly created <tt>Queue</tt> get set during the <tt>copy_elems</tt> function.</p>
                      <p class="docText">解释在 <tt>copy_elems</tt> 函数中新创建的 <tt>Queue</tt> 对象中的 <tt>next</tt> 指针怎样设置。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa11q3"></a><b>Exercise 16.34:</b></td>

                    <td>
                      <p class="docText">Write the member function definitions of the <tt>List</tt> class that you defined for the exercises in <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2" >Section 16.1.2</a> (p. <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2" >628</a>).</p>
                      <p class="docText">编写<a class="docLink" href="ch16lev1sec1.html#ch16lev2sec2" >第 16.1.2 节</a>习题中定义的 <tt>List</tt> 类的成员函数定义。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa11q4"></a><b>Exercise 16.35:</b></td>

                    <td>
                      <p class="docText">Write a generic version of the <tt>CheckedPtr</tt> class described in <a class="docLink" href="ch14lev1sec7.html#ch14lev1sec7" >Section 14.7</a> (p. <a class="docLink" href="ch14lev1sec7.html#ch14lev1sec7" >526</a>).</p>
                      <p class="docText">编写<a class="docLink" href="ch14lev1sec7.html#ch14lev1sec7" >第 14.7 节</a>中描述的 <tt>CheckedPtr</tt> 类的泛型版本。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec19"></a>

        <h4 class="docSection2Title">16.4.2. Template Arguments for Nontype Parameters</h4>
        <h4 class="docSection2Title">16.4.2. 非类型形参的模板实参</h4>

	<a name="idd1e129159"></a><a name="idd1e129164"></a><a name="idd1e129171"></a><a name="idd1e129176"></a><a name="idd1e129183"></a><a name="idd1e129189"></a>
        <p class="docText">Now that we've seen more about how class templates are implemented, we can look at nontype parameters for class templates. We'll do so by defining a new version of the <tt>Screen</tt> class first introduced in <a class="docLink" href="ch12.html#ch12" >Chapter 12</a>. In this case, we'll redefine <tt>Screen</tt> to be a template, parameterized by its height and width:</p>
        <p class="docText">我们已经了解了如何实现类模板，现在来看看类模板的非类型形参。我们将为<a class="docLink" href="ch12.html#ch12" >第十二章</a>引入的 <tt>Screen</tt> 类定义一个新版本，借引介绍类模板的非类型形参。在这个例子中，将 <tt>Screen</tt> 类重新定义为模板，以高度和宽度为形参。</p>
        <pre>
     template &lt;int hi, int wid&gt;
     class Screen {
     public:
         // <span class="docEmphItalicAlt">template nontype parameters used to initialize data members</span>
         Screen(): screen(hi * wid, '#'), cursor (0),
                   height(hi), width(wid) { }
         // ...
     private:
         std::string            screen;
         std::string::size_type cursor;
         std::string::size_type height, width;
     };
</pre><br>

        <p class="docText">This template has two parameters, both of which are nontype parameters. When users define <tt>Screen</tt> objects, they must provide a constant expression to use for each of these parameters. The class uses these parameters in the default constructor to set the size of the default <tt>Screen</tt>.</p>
        <p class="docText">这个模板有两个形参，均为非类型形参。当用户定义 <tt>Screen</tt> 对象时，必须为每个形参提供常量表达式以供使用。类在默认构造函数中使用这些形参设置默认 <tt>Screen</tt> 的尺寸。</p>

        <p class="docText">As with any class template, the parameter values must be explicitly stated whenever we use the <tt>Screen</tt> type:</p>
        <p class="docText">像任意类模板一样，使用 <tt>Screen</tt> 类型时必须显式声明形参值：</p>
        <pre>
     Screen&lt;24,80&gt; hp2621; // <span class="docEmphItalicAlt">screen 24 lines by 80 characters</span>
</pre><br>

        <p class="docText">The object <tt>hp2621</tt> uses the template instantiation <tt>Screen&lt;24, 80&gt;</tt>. The template argument for <tt>hi</tt> is 24, and the argument for <tt>wid</tt> is 80. In both cases, the template argument is a constant expression.</p>
        <p class="docText">对象 <tt>hp2621</tt> 使用模板实例化 <tt>Screen&lt;24, 80&gt;</tt>。<tt>hi</tt> 的模板实参是 24，而 <tt>wid</tt> 的模板实参是 80，两种情况下，模板实参都是常量表达式。</p>

<a name="ch16note12"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Nontype template arguments must be compile-time constant expressions.</p>
                <p class="docText">非类型模板实参必须是编译时常量表达式。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

  <a name="ch16sb14"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.4.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa12q1"></a><b>Exercise 16.36:</b></td>

                    <td>
			<a name="idd1e129307"></a><a name="idd1e129314"></a><a name="idd1e129321"></a><a name="idd1e129328"></a>
                      <p class="docText">Explain what instantiations, if any, are caused by each labeled statement.</p>
                      <p class="docText">每个带标号的语句，会导致实例化吗？如果会，解释为什么。</p>
                      <pre>
     template &lt;class T&gt; class Stack { };
     void f1(Stack&lt;char&gt;);                   // <span class="docEmphItalicAlt">(a)</span>
     class Exercise {
         Stack&lt;double&gt; &amp;rsd;                 // <span class="docEmphItalicAlt">(b)</span>
         Stack&lt;int&gt; si;                      // <span class="docEmphItalicAlt">(c)</span>
     };
     int main() {
         Stack&lt;char&gt; *sc;                    // <span class="docEmphItalicAlt">(d)</span>
         f1(*sc);                            // <span class="docEmphItalicAlt">(e)</span>
         int iObj = sizeof(Stack&lt; string &gt;); // <span class="docEmphItalicAlt">(f)</span>
     }
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa12q2"></a><b>Exercise 16.37:</b></td>

                    <td>
                      <p class="docText">Identify which, if any, of the following template instantiations are valid. Explain why the instantiation isn't valid.</p>
                      <p class="docText">下面哪些模板实例化是有效的？解释为什么实例化无效。</p>
                      <pre>
     template &lt;class T, int size&gt; class Array { /* . . . */ };
     template &lt;int hi, int wid&gt; class Screen { /* . . . */ };
     (a) const int hi = 40, wi = 80; Screen&lt;hi, wi+32&gt; sObj;
     (b) const int arr_size = 1024; Array&lt;string, arr_size&gt; a1;
     (c) unsigned int asize = 255; Array&lt;int, asize&gt; a2;
     (e) const double db = 3.1415; Array&lt;double, db&gt; a3;
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>


        <a name="ch16lev2sec20"></a>
        <h4 class="docSection2Title">16.4.3. Friend Declarations in Class Templates</h4>
        <h4 class="docSection2Title">16.4.3. 类模板中的友元声明</h4>

        <p class="docText">There are three kinds of friend declarations that may appear in a class template. Each kind of declaration declares friendship to one or more entities:</p>
                <p class="docText">在类模板中可以出现三种友元声明，每一种都声明了与一个或多个实体友元关系：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">A friend declaration for an ordinary nontemplate class or function, which grants friendship to the specific named class or function.</p>
                <p class="docList">普通非模板类或函数的友元声明，将友元关系授予明确指定的类或函数。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">A friend declaration for a class template or function template, which grants access to all instances of the friend.</p>
                <p class="docList">类模板或函数模板的友元声明，授予对友元所有实例的访问权。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">A friend declaration that grants access only to a specific instance of a class or function template.</p>
                <p class="docList">只授予对类模板或函数模板的特定实例的访问权的友元声明。</p>
              </div>
            </li>
          </ol>
  </div>
  
        <a name="ch16lev3sec25"></a>

        <h5 class="docSection3Title">Ordinary Friends</h5>
        <h5 class="docSection3Title">普通友元</h5>

        <p class="docText">A nontemplate class or function can be a friend to a class template:</p>
        <p class="docText">非模板类或非模板函数可以是类模板的友元：</p>
        <pre>
     template &lt;class Type&gt; class Bar {
         // <span class="docEmphItalicAlt">grants access to ordinary, nontemplate class and function</span>
         friend class FooBar;
         friend void fcn();
         // ...
     };
</pre><br>

        <p class="docText">This declaration says that the members of <tt>FooBar</tt> and the function <tt>fcn</tt> may access the <tt>private</tt> and <tt>protected</tt> members of any instantiation of class <tt>Bar</tt>.</p><a name="ch16lev3sec26"></a>
        <p class="docText">这个声明是说，<tt>FooBar</tt> 的成员和 <tt>fcn</tt> 函数可以访问 <tt>Bar</tt> 类的任意实例的 <tt>private</tt> 成员和 <tt>protected</tt> 成员。</a>

        <h5 class="docSection3Title">General Template Friendship</h5>
        <h5 class="docSection3Title">一般模板友元关系</h5>

        <p class="docText">A friend can be a class or function template:</p>
        <p class="docText">友元可以是类模板或函数模板：</p>
        <pre>
     template &lt;class Type&gt; class Bar {
         // <span class="docEmphItalicAlt">grants access to</span> <span class="docEmphasis">Foo1</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">templ_fcn1 parameterized</span> <span class="docEmphItalicAlt">by any type</span>
         template &lt;class T&gt; friend class Foo1;
         template &lt;class T&gt; friend void templ_fcn1(const T&amp;);
         // ...
     };
</pre><br>

<a name="idd1e129448"></a><a name="idd1e129455"></a>
        <p class="docText">These friend declarations use a different type parameter than does the class itself. That type parameter refers to the type parameter of <tt>Foo1</tt> and <tt>templ_fcn1</tt>. In both these cases, an unlimited number of classes and functions are made friends to <tt>Bar</tt>. The friend declaration for <tt>Foo1</tt> says that any instance of <tt>Foo1</tt> may access the private elements of any instance of <tt>Bar</tt>. Similarly, any instance of <tt>templ_fcn1</tt> may access any instance of <tt>Bar</tt>.</p>
        <p class="docText">这些友元声明使用与类本身不同的类型形参，该类型形参指的是 <tt>Foo1</tt> 和 <tt>temp1_fcn1</tt> 的类型形参。在这两种情况下，都将没有数目限制的类和函数设为 <tt>Bar</tt> 的友元。<tt>Foo1</tt> 的友元声明是说，<tt>Foo1</tt> 的友元声明是说，<tt>Foo1</tt> 的任意实例都可以访问 <tt>Bar</tt> 的任意实例的私有元素，类似地，<tt>temp_fcn1</tt> 的任意实例可以访问 <tt>Bar</tt> 的任意实例。</p>

        <p class="docText">This friend declaration establishes a one-to-many mapping between each instantiation of <tt>Bar</tt> and its friends, <tt>Foo1</tt> and <tt>templ_fcn1</tt>. For each instantiation of <tt>Bar</tt>, all instantiations of <tt>Foo1</tt> or <tt>templ_fcn1</tt> are friends.</p>
        <p class="docText">这个友元声明在 <tt>Bar</tt> 与其友元 <tt>Foo1</tt> 和 <tt>temp1_fcn1</tt> 的每个实例之间建立了一对多的映射。对 <tt>Bar</tt> 的每个实例而言，<tt>Foo1</tt> 或 <tt>temp1_fcn1</tt> 的所有实例都是友元。</p>

<a name="ch16lev3sec27"></a>
        <h5 class="docSection3Title">Specific Template Friendship</h5>
        <h5 class="docSection3Title">特定的模板友元关系</h5>

        <p class="docText">Rather than making all instances of a template a friend, a class can grant access to only a specific instance:</p>
        <p class="docText">除了将一个模板的所有实例设为友元，类也可以只授予对特定实例的访问权：</p>
        <pre>
     template &lt;class T&gt; class Foo2;
     template &lt;class T&gt; void templ_fcn2(const T&amp;);
     template &lt;class Type&gt; class Bar {
          // <span class="docEmphItalicAlt">grants access to a single specific instance parameterized by</span> <span class="docEmphasis">char*</span>
          friend class Foo2&lt;char*&gt;;
          friend void templ_fcn2&lt;char*&gt;(char* const &amp;);
          // ...
     };
</pre><br>

        <p class="docText">Even though <tt>Foo2</tt> itself is a class template, friendship is extended only to the specific instance of <tt>Foo2</tt> that is parameterized by <tt>char*</tt>. Similarly, the friend declaration for <tt>templ_fcn2</tt> says that only the instance of that function parameterized by <tt>char*</tt> is a friend to class <tt>Bar</tt>. The specific instantiations of <tt>Foo2</tt> and <tt>templ_fcn2</tt> parameterized by <tt>char*</tt> can access every instantiation of <tt>Bar</tt>.</p>
        <p class="docText">即使 <tt>Foo2</tt> 本身是类模板，友元关系也只扩展到 <tt>Foo2</tt> 的形参类型为 <tt>char*</tt> 的特定实例。类似地，<tt>temp1_fcn2</tt> 的友元声明是说，只有形参类型为 <tt>char*</tt> 的函数实例是 <tt>Bar</tt> 类的友元。形参类型为 <tt>char*</tt> 的 <tt>Foo2</tt> 和 <tt>temp1_fcn2</tt> 的特定实例可以访问 <tt>Bar</tt> 的每个实例。</p>

        <p class="docText">More common are friend declarations of the following form:</p>
        <p class="docText">下面形式的友元声明更为常见：</p>
        <pre>
     template &lt;class T&gt; class Foo3;
     template &lt;class T&gt; void templ_fcn3(const T&amp;);
     template &lt;class Type&gt; class Bar {
         // <span class="docEmphItalicAlt">each instantiation of</span> <span class="docEmphasis">Bar</span> <span class="docEmphItalicAlt">grants access to the</span>
         // <span class="docEmphItalicAlt">version of</span> <span class="docEmphasis">Foo3</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">templ_fcn3 instantiated</span> <span class="docEmphItalicAlt">with the same type</span>
         friend class Foo3&lt;Type&gt;;
         friend void templ_fcn3&lt;Type&gt;(const Type&amp;);
         // ...
     };
</pre><br>

        <p class="docText">These friends define friendship between a particular instantiation of <tt>Bar</tt> and the instantiation of <tt>Foo3</tt> or <tt>templ_fcn3</tt> that uses the same template argument. Each instantiation of <tt>Bar</tt> has a single associated <tt>Foo3</tt> and <tt>templ_fcn3</tt> friend:</p>
        <p class="docText">这些友元定义了 <tt>Bar</tt> 的特定实例与使用同一模板实参的 <tt>Foo3</tt> 或 <tt>temp1_fcn3</tt> 的实例之间的友元关系。每个 <tt>Bar</tt> 实例有一个相关的 <tt>Foo3</tt> 和 <tt>temp1_fcn3</tt> 友元：</p>
        <pre>
     Bar&lt;int&gt; bi;    // <span class="docEmphasis">Foo3&lt;int&gt;</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">templ_fcn3&lt;int&gt;</span> <span class="docEmphItalicAlt">are friends</span>
     Bar&lt;string&gt; bs; // <span class="docEmphasis">Foo3&lt;string&gt;, templ_fcn3&lt;string&gt;</span> <span class="docEmphItalicAlt">are friends</span>
</pre><br>

        <p class="docText">Only those versions of <tt>Foo3</tt> or <tt>templ_fcn3</tt> that have the same template argument as a given instantiation of <tt>Bar</tt> are friends. Thus, <tt>Foo3&lt;int&gt;</tt> may access the private parts of <tt>Bar&lt;int&gt;</tt> but not of <tt>Bar&lt;string&gt;</tt> or any other instantiation of <tt>Bar</tt>.</p>
        <p class="docText">只有与给定 <tt>Bar</tt> 实例有相同模板实参的那些 <tt>Foo3</tt> 或 <tt>temp1_fcn3</tt> 版本是友元。因此，<tt>Foo3&lt;int&gt;</tt> 可以访问 <tt>Bar&lt;int&gt;</tt> 的私有部分，但不能访问 <tt>Bar&lt;string&gt;</tt> 或者任意其他 <tt>Bar</tt> 实例的私有部分。</p>

<a name="ch16lev3sec28"></a>
        <h5 class="docSection3Title">Declaration Dependencies</h5>
        <h5 class="docSection3Title">声明依赖性</h5>

<a name="idd1e129672"></a><a name="idd1e129679"></a><a name="idd1e129684"></a><a name="idd1e129689"></a>
        <p class="docText">When we grant access to all instances of a given template, there need not be a declaration for that class or function template in scope. Essentially, the compiler treats the friend declaration as a declaration of the class or function as well.</p>
        <p class="docText">当授予对给定模板的实例的访问权时候，在作用域中不需要存在该类模板或函数模板的声明。实质上，编译器将友元声明也当作类或函数的声明对待。</p>

        <p class="docText">When we want to restrict friendship to a specific instantiation, then the class or function must have been declared before it can be used in a friend declaration:</p>
        <p class="docText">想要限制对特定实例化的友元关系时，必须在可以用于友元声明之前声明类或函数：</p>
        <pre>
     template &lt;class T&gt; class A;
     template &lt;class T&gt; class B {
     public:
         friend class A&lt;T&gt;;      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">A</span> <span class="docEmphItalicAlt">is known to be a template</span>
         friend class C;         // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">C</span> <span class="docEmphItalicAlt">must be an ordinary, nontemplate class</span>
         template &lt;class S&gt; friend class D; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">D</span> <span class="docEmphItalicAlt">is a template</span>
         friend class E&lt;T&gt;;      // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">E</span> <span class="docEmphItalicAlt">wasn't declared as a template</span>
         friend class F&lt;int&gt;;    // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">F</span> <span class="docEmphItalicAlt">wasn't declared as a template</span>
      };
</pre><br>

        <p class="docText">If we have not previously told the compiler that the friend is a template, then the compiler will infer that the friend is an ordinary nontemplate class or function.</p><a name="ch16lev2sec21"></a>
        <p class="docText">如果没有事先告诉编译器该友元是一个模板，则编译器将认为该友元是一个普通非模板类或非模板函数。</p>

        <h4 class="docSection2Title">16.4.4. <tt>Queue</tt> and <tt>QueueItem</tt> Friend Declarations</h4>
        <h4 class="docSection2Title">16.4.4. <tt>Queue</tt> 和 <tt>QueueItem</tt> 的友元声明</h4>

        <p class="docText">Our <tt>QueueItem</tt> class is not intended to be used by the general program: All its members are private. In order for <tt>Queue</tt> to use <tt>QueueItem, QueueItem</tt> must make <tt>Queue</tt> a friend.</p>
	<p class="docText"><tt>QueueItem</tt> 类不打算为一般程序所用：它的所有成员都是私有的。为了让 <tt>Queue</tt> 类使用 <tt>QueueItem</tt> 灰，<tt>QueueItem</tt> 类必须将 <tt>Queue</tt> 类设为友元。</p>
	
	<a name="ch16lev3sec29"></a>
        <h5 class="docSection3Title">Making a Class Template a Friend</h5>
        <h5 class="docSection3Title">将类模板设为友元</h5>

        <p class="docText">As we have just seen, when making a class template a friend, the class designer must decide how wide to make that friendship. In the case of <tt>QueueItem</tt>, we need to decide whether <tt>QueueItem</tt> should grant friendship to all <tt>Queue</tt> instances or only to a specific instance.</p>
        <p class="docText">像我们已经看到的，将类模板设为友元的进修，类设计者必须决定友元关系应设置多广。在 <tt>QueueItem</tt> 类的例子中，需要决定 <tt>QueueItem</tt> 类应该将友元关系授予所有的 <tt>Queue</tt> 类实例，还是只授予特定实例。</p>

        <p class="docText">Making every <tt>Queue</tt> a friend of each <tt>QueueItem</tt> is too broad. It makes no sense to allow a <tt>Queue</tt> instantiated with the type <tt>string</tt> to access members of a <tt>QueueItem</tt> instantiated with type <tt>double</tt>. The <tt>Queue&lt;string&gt;</tt> instantiation should be a friend only to the instantiation of the <tt>QueueItem</tt> for <tt>string</tt>s. That is, we want a one-to-one mapping between a <tt>Queue</tt> and <tt>QueueItem</tt> for each type of <tt>Queue</tt> that is instantiated:</p>
        <p class="docText">将每个 <tt>Queue</tt> 类设为每个 <tt>QueueItem</tt> 类的友元太宽泛了，允许用 <tt>string</tt> 类型实例化的 <tt>Queue</tt> 类去访问用 <tt>double</tt> 类型实例化的 <tt>QueueItem</tt> 类的成员是没有意义的。<tt>Queue&lt;string&gt;</tt> 实例只应该是用 <tt>string</tt> 实例化的 <tt>QueueItem</tt> 类的友元，即，对于实例化的 <tt>Queue</tt> 类的每种类型，我们想要 <tt>Queue</tt> 类和 <tt>QueueItem</tt> 类之间的一对一映射：</p>
        <pre>
     // <span class="docEmphItalicAlt">declaration that</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is a template needed for friend declaration in</span> <span class="docEmphasis">QueueItem</span>
     template &lt;class Type&gt; class Queue;
     template &lt;class Type&gt; class QueueItem {
         friend class Queue&lt;Type&gt;;
         // ...
      };
</pre><br>

        <p class="docText">This declaration establishes the desired one-to-one mapping; only the <tt>Queue</tt> class that is instantiated with the same type as <tt>QueueItem</tt> is made a friend.</p>
        <p class="docText">这个声明建立了想要一对一映射，只将与 <tt>QueueItem</tt> 类用同样类型实例化的 <tt>Queue</tt> 类设为友元。</p><a name="ch16lev3sec30"></a>

        <h5 class="docSection3Title">The <tt>Queue</tt> Output Operator</h5>
        <h5 class="docSection3Title"><tt>Queue</tt> 输出操作符</h5>

	<a name="idd1e129874"></a><a name="idd1e129879"></a><a name="idd1e129884"></a>
        <p class="docText">One operation that might be useful to add to our <tt>Queue</tt> interface is the ability to print the contents of a <tt>Queue</tt> object. We'll do so by providing an overloaded instance of the output operator. This operator will walk the list of elements in the <tt>Queue</tt> and print the value in each element. We'll print the elements inside a pair of brackets.</p>
        <p class="docText"><tt>Queue</tt> 类接口中可能增加的一个有用操作，是输出 <tt>Queue</tt> 对象的内容的能力。提供输出操作符的重载实例，可以做到这一点。这个操作符将遍历 <tt>Queue</tt> 中的元素链表并输出每个元素的值，将在一对尖括号内输出元素。</p>

        <p class="docText">Because we want to be able to print the contents of <tt>Queues</tt> of any type, we need to make the output operator a template as well:</p>
        <p class="docText">因为希望能够输出任意类型 <tt>Queue</tt> 的内容，所以需要将输出操作符也设为模板：</p>
        <pre>
     template &lt;class Type&gt;
     ostream&amp; operator&lt;&lt;(ostream &amp;os, const Queue&lt;Type&gt; &amp;q)
     {
         os &lt;&lt; "&lt; ";
         QueueItem&lt;Type&gt; *p;
         for (p = q.head; p; p = p-&gt;next)
                 os &lt;&lt; p-&gt;item &lt;&lt; " ";
         os &lt;&lt;"&gt;";
         return os;
     }
</pre><br>

        <p class="docText">If a <tt>Queue</tt> of type <tt>int</tt> contains the values 3, 5, 8, and 13, the output of this <tt>Queue</tt> displays as follows:</p>
        <p class="docText">如果 <tt>int</tt> 类型的 <tt>Queue</tt> 包含值 3、5、8 和 13，这个 <tt>Queue</tt> 的输出显示如下：</p>
        <pre>
     <span class="docEmphStrong"><tt>&lt;3 5 8 13 &gt;</tt></span>
</pre><br>

        <p class="docText">If the <tt>Queue</tt> is empty, the <tt>for</tt> loop body is never executed. The effect will be to print an empty pair of brackets if the <tt>Queue</tt> is empty.</p>
        <p class="docText">如果 <tt>Queue</tt> 为空，<tt>for</tt> 循环不执行。结果是输出一对空的尖括号。</p> <a name="ch16lev3sec31"></a>

        <h5 class="docSection3Title">Making a Function Template a Friend</h5>
        <h5 class="docSection3Title">将函数模板设为友元</h5>

        <p class="docText">The output operator needs to be a friend of both the <tt>Queue</tt> and <tt>QueueItem</tt> classes. It uses the <tt>head</tt> member of class <tt>Queue</tt> and the <tt>next</tt> and <tt>item</tt> members of class <tt>QueueItem</tt>. Our classes grant friendship to the specific instance of the output operator instantiated with the same type:</p>
        <p class="docText">输出操作符需要成为 <tt>Queue</tt> 类和 <tt>QueueItem</tt> 类的友元。它使用 <tt>Queue</tt> 类的 <tt>head</tt> 成员和 <tt>QueueItem</tt> 类的 <tt>next</tt> 和 <tt>item</tt> 成员。我们的类将友元关系授予用同样类型实例化的输出操作符的特定实例：</p>
        <pre>
     // <span class="docEmphItalicAlt">function template declaration must precede friend declaration in</span> QueueItem
     template &lt;class T&gt;
     std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Queue&lt;T&gt;&amp;);
     template &lt;class Type&gt; class QueueItem {
         friend class Queue&lt;Type&gt;;
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">item</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">next</span>
         friend std::ostream&amp;
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
         // ...
     };
     template &lt;class Type&gt; class Queue {
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">head</span>
         friend std::ostream&amp;
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
     };
</pre><br>

	<a name="idd1e130007"></a><a name="idd1e130014"></a><a name="idd1e130021"></a><a name="idd1e130028"></a><a name="idd1e130031"></a><a name="idd1e130036"></a>
        <p class="docText">Each friend declaration grants access to the corresponding instantiation of the <tt>operator&lt;&lt;</tt>. That is, the output operator that prints a <tt>Queue&lt;int&gt;</tt> is a friend to class <tt>Queue&lt;int&gt;</tt> (and <tt>QueueItem&lt;int&gt;)</tt>. It is not a friend to any other <tt>Queue</tt> type.</p>
        <p class="docText">每个友元声明授予对对应 <tt>operator&lt;&lt;</tt> 实例的访问权，即输出 <tt>Queue&lt;int&gt;</tt> 的输出操作符是 <tt>Queue&lt;int&gt;</tt> 类（以及 <tt>QueueItem&lt;int&gt;)</tt> 类）的友元，它不是任意其他 <tt>Queue</tt> 类型的友元。</p>

	<a name="ch16lev3sec32"></a>
        <h5 class="docSection3Title">Type Dependencies and the Output Operator</h5>
        <h5 class="docSection3Title">类型依赖性与输出操作符</h5>

        <p class="docText">The <tt>Queue</tt> output <tt>operator&lt;&lt;</tt> relies on the <tt>operator&lt;&lt;</tt> of <tt>item</tt> to actually print each element:</p>
        <p class="docText"><tt>Queue</tt> 类的输出 <tt>operator&lt;&lt;</tt> 依赖于 <tt>item</tt> 对象的 <tt>operator&lt;&lt;</tt> 实际输出每个元素：</p>
        <pre>
     os &lt;&lt; p-&gt;item &lt;&lt; " ";
</pre><br>

        <p class="docText">When we use <tt>p-&gt;item</tt> as an operand of the <tt>&lt;&lt;</tt> operator, we are using the <tt>&lt;&lt;</tt> defined for whatever type <tt>item</tt> has.</p>
        <p class="docText">当使用 <tt>p-&gt;item</tt> 作为 <tt>&lt;&lt;</tt> 操作符的操作数的时候，使用的是为 item 所属的任意类型而定义的 <tt>&lt;&lt;</tt>。</p>

        <p class="docText">This code is an example of a type dependency between <tt>Queue</tt> and the element type that <tt>Queue</tt> holds. In effect, each type bound to <tt>Queue</tt> that uses the <tt>Queue</tt> output operator must itself have an output operator. There is no language mechanism to specify or enforce that dependency in the definition of <tt>Queue</tt> itself. It is legal to create a <tt>Queue</tt> for a class that does not define the output operator but it is a compile-time (or link-time) error to print a <tt>Queue</tt> holding such a type.</p><a name="ch16sb15"></a>
        <p class="docText">此代码是 <tt>Queue</tt> 和 <tt>Queue</tt> 保存的元素之间的类型依赖性的例子。实际上，绑定到 <tt>Queue</tt> 且使用 <tt>Queue</tt> 输出操作符的每种类型本身必须有输出操作符。没有语言机制指定或强制 <tt>Queue</tt> 自身定义中的依赖性。为没有定义输出操作符的类创建 <tt>Queue</tt> 对象是合法的，但输出保存这种类型的 <tt>Queue</tt> 对象会发生编译时（或链接时）错误。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.4.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa13q1"></a><b>Exercise 16.38:</b></td>

                    <td>
                      <p class="docText">Write a <tt>Screen</tt> class template that uses nontype parameters to define the height and width of the <tt>Screen</tt>.</p>
        <p class="docText">编写 <tt>Screen</tt> 类模板，使用非类型形参定义 <tt>Screen</tt> 的高度和宽度。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa13q2"></a><b>Exercise 16.39:</b></td>

                    <td>
                      <p class="docText">Implement input and output operators for the template <tt>Screen</tt> class.</p>
        <p class="docText">为 <tt>Screen</tt> 模板类实现输入和输出操作符。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa13q3"></a><b>Exercise 16.40:</b></td>

                    <td>
                      <p class="docText">Which, if any, friends are necessary in class <tt>Screen</tt> to make the input and output operators work? Explain why each friend declaration, if any, was needed.</p>
        <p class="docText">要使输入和输出操作符能够工作，<tt>Screen</tt> 类需要友元吗？如果需要，要哪些友元解释为什么需要每个友元声明。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa13q4"></a><b>Exercise 16.41:</b></td>

                    <td>
                      <p class="docText">The friend declaration for <tt>operator&lt;&lt;</tt> in class <tt>Queue</tt> was</p>
        <p class="docText"><tt>Queue</tt> 类中的 <tt>operator&lt;&lt;</tt> 的友元声明是：</p>
                      <pre>
     friend std::ostream&amp;
     operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
</pre><br>

                      <p class="docText">What would be the effect of writing the <tt>Queue</tt> parameter as <tt>const Queue&amp;</tt> rather than <tt>const Queue&lt;Type&gt;&amp;?</tt></p>
        <p class="docText">将 <tt>Queue</tt> 形参写为 <tt>const Queue&amp;</tt> 而不是 <tt>const Queue&lt;Type&gt;&amp;</tt>，会有什么结果？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa13q5"></a><b>Exercise 16.42:</b></td>

                    <td>
                      <p class="docText">Write an input operator that reads an <tt>istream</tt> and puts the values it reads into a <tt>Queue</tt>.</p>
        <p class="docText">编写一个输入操作符，读一个 <tt>istream</tt> 对象并将读到的值放入一个 <tt>Queue</tt> 对象中。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec22"></a>

        <h4 class="docSection2Title">16.4.5. Member Templates</h4>
        <h4 class="docSection2Title">16.4.5. 成员模板</h4>

<a name="ch16term7"></a>
        <p class="docText">Any class (template or otherwise) may have a member that is itself a class or function template. Such members are referred to as <b><a class="docLink" href="ch16lev1sec9.html#gloss16_07" >member templates</a></b>. Member templates may not be virtual.</p>
        <p class="docText">任意类（模板或非模板）可以拥有本身为类模板或函数模板的成员，这种成员称为<b><a class="docLink" href="ch16lev1sec9.html#gloss16_07" >成员模板</a></b>，成员模板不能为虚。</p>

<a name="idd1e130257"></a><a name="idd1e130262"></a><a name="idd1e130267"></a>
        <p class="docText">One example of a member template is the <tt>assign</tt> (<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec13" >Section 9.3.8</a>, p. <a class="docLink" href="ch09lev1sec3.html#ch09lev2sec13" >328</a>) member of the standard containers. The version <tt>assign</tt> that takes two iterators uses a template parameter to represent the type of its iterator parameters. Another member template example is the container constructor that takes two iterators (<a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1" >Section 9.1.1</a>, p. <a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1" >307</a>). This constructor and the <tt>assign</tt> member allow containers to be built from sequences of different but compatible element types and/or different container types. Having implemented our own <tt>Queue</tt> class, we now can understand the design of these standard container members a bit better.</p>
        <p class="docText">成员模板的一个例子是标准容器的 <tt>assign</tt> 成员（<a class="docLink" href="ch09lev1sec3.html#ch09lev2sec13" >第 9.3.8 节</a>），接受两个迭代器的 <tt>assign</tt> 版本使用模板形参表示其迭代器形参的类型。另一个成员模板例子是接受两个迭代器的容器构造函数（<a class="docLink" href="ch09lev1sec1.html#ch09lev2sec1" >第 9.1.1 节</a>）。该构造函数和 <tt>assign</tt> 成员使我们能够从不同但兼容的元素类型序列和／或不同容器类型建立容器。实现了自己的 <tt>Queue</tt> 类之后，我们现在能够更好地理解这些标准容器成员的设计了。</p>

        <p class="docText">Consider the <tt>Queue</tt> copy constructor: It takes a single parameter that is a reference to a <tt>Queue&lt;Type&gt;</tt>. If we wanted to create a <tt>Queue</tt> by copying elements from a <tt>vector</tt>, we could not do so; there is no conversion from <tt>vector</tt> to <tt>Queue</tt>. Similarly, if we wanted to copy elements from a <tt>Queue&lt;short&gt;</tt> into a <tt>Queue&lt;int&gt;</tt>, we could not do so. Again, even though we can convert a <tt>short</tt> to an <tt>int</tt>, there is no conversion from <tt>Queue&lt;short&gt;</tt> to <tt>Queue&lt;int&gt;</tt>. The same logic applies to the <tt>Queue</tt> assignment operator, which also takes a parameter of type <tt>Queue&lt;Type&gt;&amp;</tt>.</p>
        <p class="docText">考虑 <tt>Queue</tt> 类的复制构造函数：它接受一个形参，是 <tt>Queue&lt;Type&gt;</tt> 的引用。想要通过从 <tt>vector</tt> 对象中复制元素而创建 <tt>Queue</tt> 对象，是办不到的，因为没有从 vector 到 <tt>Queue</tt> 的转换。类似地，想要从 <tt>Queue&lt;short&gt;</tt> 复制元素到 <tt>Queue&lt;int&gt;</tt>，也办不到。同样的逻辑应用于赋值操作符，它也接受一个 <tt>Queue&lt;Type&gt;&amp;</tt> 类型的形参。</p>

        <p class="docText">The problem is that the copy constructor and assignment operator fix both the container and element type. We'd like to define a constructor and an <tt>assign</tt> member that allow both the container and element type to vary. When we need a parameter type to vary, we need to define a function template. In this case, we'll define the constructor and <tt>assign</tt> member to take a pair of iterators that denote a range in some other sequence. These functions will have a single template type parameter that represents an iterator type.</p>
        <p class="docText">问题在于，复制构造函数和赋值操作符固定了容器和元素的类型。我们希望定义一个构造函数和一个 <tt>assign</tt> 成员，使容器类型和元素类型都能变化。需要形参类型变化的时候，就需要定义函数模板。在这个例子中，我们将定义构造函数和 <tt>assign</tt> 成员接受一对在其他序列指明范围的迭代器，这些函数将有一个表示迭代器类型的模板类型形参。</p>

<a name="ch16note13"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The standard <tt>queue</tt> class does not define these members: <tt>queue</tt> doesn't support building or assigning a <tt>queue</tt> from another container. We define these members here for illustration purposes only.</p>
                <p class="docText">标准 <tt>queue</tt> 类没有定义这些成员：不支持从其他容器建立 <tt>queue</tt> 对象或给 <tt>queue</tt> 对象赋值。我们在这里定义这些成员只是为了举例说明。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16lev3sec33"></a>

        <h5 class="docSection3Title">Defining a Member Template</h5>
        <h5 class="docSection3Title">定义成员模板</h5>

        <p class="docText">A template member declaration looks like the declaration of any template:</p>
                <p class="docText">模板成员声明看起来像任意模板的声明一样：</p>
        <pre>
     template &lt;class Type&gt; class Queue {
     public:
         // <span class="docEmphItalicAlt">construct a</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">from a pair of iterators on some sequence</span>
         template &lt;class It&gt;
         Queue(It beg, It end):
               head(0), tail(0) { copy_elems(beg, end); }
         // <span class="docEmphItalicAlt">replace current</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">by contents delimited by a pair of iterators</span>
         template &lt;class Iter&gt; void assign(Iter, Iter);
         // <span class="docEmphItalicAlt">rest of</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">class as before</span>
     private:
         // <span class="docEmphItalicAlt">version of copy to be used by</span> <span class="docEmphasis">assign</span> <span class="docEmphItalicAlt">to copy elements from iterator range</span>
         template &lt;class Iter&gt; void copy_elems(Iter, Iter);
     };
</pre><br>

        <p class="docText">The member declaration starts with its own template parameter list. The constructor and <tt>assign</tt> member each have a single template type parameter. These functions use that type parameter as the type for their function parameters, which are iterators denoting a range of elements to copy.</p>
	<p class="docText">成员声明的开关是自己的模板形参表。构造函数和 assign 成员各有一个模板类型形参，这些函数使用该类型形参作为其函数形参的类型，它们的函数形参是指明要复制元素范围的迭代器。</p>
	
	<a name="ch16lev3sec34"></a>
        <h5 class="docSection3Title">Defining a Member Template Outside the Class</h5>
        <h5 class="docSection3Title">在类外部定义成员模板</h5>

<a name="idd1e130423"></a><a name="idd1e130428"></a><a name="idd1e130435"></a>
        <p class="docText">Like nontemplate members, a member template can be defined inside or outside of its enclosing class or class template definition. We have defined the constructor inside the class body. Its job is to copy the elements from the iterator range formed by its iterator arguments. It does so by calling the iterator version of <tt>copy_elems</tt> to do the actual copy.</p>
        <p class="docText">像非模板成员一样，成员模板可以定义在包含它的类或类模板定义的内部或外部。我们已经在类定义体内部定义了构造函数，它的工作是从迭代器实参形成的迭代器范围复制元素，实际复制工作是通过调用 <tt>copy_elems</tt> 的迭代器版本完成的。</p>

        <p class="docText">When we define a member template outside the scope of a class template, we must include both template parameter lists:</p>
        <p class="docText"></p>
        <pre>
     template &lt;class T&gt; template &lt;class Iter&gt;
     void Queue&lt;T&gt;::assign(Iter beg, Iter end)
     {
         destroy();            // <span class="docEmphItalicAlt">remove existing elements in this</span> <span class="docEmphasis">Queue</span>
         copy_elems(beg, end); // <span class="docEmphItalicAlt">copy elements from the input range</span>
     }
</pre><br>

        <p class="docText">When a member template is a member of a class template, then its definition must include the class-template parameters as well as its own template parameters. The class-template parameter list comes first, followed by the member's own template parameter list. The definition of <tt>assign</tt> starts with</p>
        <p class="docText">当成员模板是类模板的成员时，它的定义必须包含类模板形参以及自己的模板形参。首先是类模板形参表，后面接着成员自己的模板形参表。<tt>assign</tt> 函数定义的开头为</p>
        <pre>
     template &lt;class T&gt; template &lt;class Iter&gt;
</pre><br>

        <p class="docText">The first template parameter list <tt>template&lt;class T&gt;</tt>is that of the class template. The second template parameter list <tt>template&lt;class Iter&gt;</tt>is that of the member template.</p>
        <p class="docText">第一个模板形参表 <tt>template&lt;class T&gt;</tt> 是类模板的，第二个模板形参表 <tt>template&lt;class Iter&gt;</tt> 是成员模板的。</p>

        <p class="docText">The actions of our <tt>assign</tt> function are quite simple: It first calls <tt>destroy</tt>, which, as we've seen, frees the existing members of this <tt>Queue</tt>. The <tt>assign</tt> member then calls a new utility function named <tt>copy_elems</tt> to do the work of copying elements from the input range. That function is also a member template:</p>
        <p class="docText"><tt>assign</tt> 函数的行为非常简单：它首先调用 <tt>destroy</tt> 函数，<tt>destroy</tt> 函数释放这个 <tt>Queue</tt> 的现在成员，然后 <tt>assign</tt> 成员调用名为 <tt>copy_elems</tt> 的新实用函数，完成从输入范围复制元素的工作。<tt>copy_elems</tt> 函数也是一个成员模板：</p>
        <pre>
     template &lt;class Type&gt; template &lt;class It&gt;
     void Queue&lt;Type&gt;::copy_elems(It beg, It end)
     {
         while (beg != end) {
            push(*beg);
            ++beg;
         }
     }
</pre><br>

        <p class="docText">The iterator version of <tt>copy_elems</tt> walks through an input range denoted by a pair of iterators. It calls <tt>push</tt> on each element in that range, which actually adds the element to the <tt>Queue</tt>.</p>
        <p class="docText"><tt>copy_elems</tt> 的迭代器版本遍历由一对迭代器指定的输入范围，它对范围内的每个元素调用<tt> push</tt> 函数，实际上由 <tt>push</tt> 函数将元素加入 <tt>Queue</tt>。</p>

<a name="ch16note14"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Because <tt>assign</tt> erases elements in the existing container, it is essential that the iterators passed to <tt>assign</tt> refer to elements in a different container. The standard container <tt>assign</tt> members and iterator constructors have the same restrictions.</p>
        <p class="docText">因为 <tt>assign</tt> 函数删除现在容器中的成员，所以传给 <tt>assign</tt> 函数的迭代器有必要引用不同容器中的元素。标准容器的 <tt>assign</tt> 成员和迭代器构造函数有相同的限制。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16lev3sec35"></a>

        <h5 class="docSection3Title">Member Templates Obey Normal Access Control</h5>
        <h5 class="docSection3Title">成员模板遵循常规访问控制</h5>

<a name="idd1e130548"></a><a name="idd1e130553"></a><a name="idd1e130558"></a><a name="idd1e130563"></a>
        <p class="docText">A member template follows the same access rules as any other class members. If the member template is private, then only member functions and friends of the class can use that member template. Because the function member template <tt>assign</tt> is a public member, it can be used by the entire program; <tt>copy_elems</tt> is private, so it can be accessed only by the friends and members of <tt>Queue</tt>.</p>
        <p class="docText">成员模板遵循与任意其他类成员一样的访问规则。如果成员模板为私有的，则只有该类的成员函数和友元可以使用该成员模板。因为函数成员模板 <tt>assign</tt> 是公有的，所以整个程序都可以使用它：<tt>copy_elems</tt> 是私有的，所以只有 <tt>Queue</tt> 的友元和成员可以访问它。</p>

<a name="ch16lev3sec36"></a>
        <h5 class="docSection3Title">Member Templates and Instantiation</h5>
        <h5 class="docSection3Title">成员模板和实例化</h5>

        <p class="docText">Like any other member, a member template is instantiated only when it is used in a program. The instantiation of member templates of class templates is a bit more complicated than the instantiation of plain member functions of class templates. Member templates have two kinds of template parameters: Those that are defined by the class and those defined by the member template itself. The class template parameters are fixed by the type of the object through which the function is called. The template parameters defined by the member act like parameters of ordinary function templates. These parameters are resolved through normal template argument deduction (<a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10" >Section 16.2.1</a>, p. <a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10" >637</a>).</p>
        <p class="docText">与其他成员一样，成员模板只有在程序中使用时才实例化。类模板的成员模板的实例化比类模板的普通成员函数的实例化要复杂一点。成员模板有两种模板形参：由类定义的和由成员模板本身定义的。类模板形参由调用函数的对象的类型确定，成员定义的模板形参的行为与普通函数模板一样。这些形参都通过常规模板实参推断（<a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10" >第 16.2.1 节</a>）而确定。</p>

        <p class="docText">To understand how instantiation works, let's look at uses of these members to copy and assign elements from an array of <tt>short</tt>s or a <tt>vector&lt;int&gt;:</tt></p>
        <p class="docText">要理解实例化的原理，我们来看看使用这些成员从 <tt>short</tt> 数组或 <tt>vector&lt;int&gt;:</tt> 复制和赋值元素：</p>
        <pre>
     short a[4] = { 0, 3, 6, 9 };
     // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::Queue(short *, short *)</span>
     Queue&lt;int&gt; qi(a, a + 4); // <span class="docEmphItalicAlt">copies elements from</span> <span class="docEmphasis">a</span> <span class="docEmphItalicAlt">into</span> <span class="docEmphasis">qi</span>
     vector&lt;int&gt; vi(a, a + 4);
     // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;::assign(vector&lt;int&gt;::iterator,</span>
     //                                 vector&lt;int&gt;::iterator)
     qi.assign(vi.begin(), vi.end());
</pre><br>

        <p class="docText">Because we are constructing an object of type <tt>Queue&lt;int&gt;</tt>, we know that the compiler will instantiate the iterator-based constructor for <tt>Queue&lt;int&gt;</tt>. The type of the constructor's own template parameter is deduced by the compiler from the type of <tt>a</tt> and <tt>a +4</tt>. That type is pointer to <tt>short</tt>. Thus, the definition of <tt>qi</tt> instantiates</p>
        <p class="docText">因为所构造的是 <tt>Queue&lt;int&gt;</tt> 类型的对象，我们知道编译器将为 <tt>Queue&lt;int&gt;</tt> 实例化基于迭代器的构造函数。该构造函数本身模板形参的类型由编译器根据 <tt>a</tt> 和 <tt>a+4</tt> 的类型推断，而该类型为 <tt>short</tt> 指针。因此，<tt>qi</tt> 的定义将实例化</p>
        <pre>
     void Queue&lt;int&gt;::Queue(short *, short *);
</pre><br>

        <p class="docText">The effect of this constructor is to copy the elements of type <tt>short</tt> from the array named <tt>a</tt> into <tt>qi</tt>.</p>
        <p class="docText">这个构造函数的效果是，从名为 <tt>a</tt> 的数组中复制 <tt>short</tt> 类型的元素到 <tt>qi</tt>。</p>

        <p class="docText">The call to <tt>assign</tt> instantiates a member of <tt>qi</tt>, which has type <tt>Queue&lt;int&gt;</tt>. Thus, this call instantiates the <tt>Queue&lt;int&gt;</tt> member named <tt>assign</tt>. That function is itself a function template. As with any other function template, the compiler deduces the template argument for <tt>assign</tt> from the arguments to the call. The type deduced is <tt>vector&lt;int&gt;::iterator</tt>, meaning that this call instantiates</p>
        <p class="docText">对 <tt>assign</tt> 的调用将实例化 <tt>qi</tt> 的成员。<tt>qi</tt> 具有 <tt>Queue&lt;int&gt;</tt> 类型，因此，这个调用将实例化名为 <tt>assign</tt> 的 <tt>Queue&lt;int&gt;</tt> 成员。该函数本身是函数模板，像对任意其他函数模板一样，编译器从传给调用的实参推断 <tt>assign</tt> 的模板实参，推断得到的类型是 <tt>vector&lt;int&gt;::iterator</tt>，即，这个调用将实例化</p>
        <pre>
     void Queue&lt;int&gt;::assign(vector&lt;int&gt;::iterator,
                             vector&lt;int&gt;::iterator);
</pre><br>
        <a name="ch16lev2sec23"></a>

        <h4 class="docSection2Title">16.4.6. The Complete <tt>Queue</tt> Class</h4>
	<h4 class="docSection2Title">16.4.6. 完整的 <tt>Queue</tt> 类</h4>

        <p class="docText"><a name="idd1e130713"></a>For completeness, here is the final definition of our <tt>Queue</tt> class:</p>
        <p class="docText">为了完整起见，在这里给出 <tt>Queue</tt> 类的最终定义：</p>
        <pre>
     // <span class="docEmphItalicAlt">declaration that</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is a template needed for friend declaration in</span> <span class="docEmphasis">QueueItem</span>
     template &lt;class Type&gt; class Queue;
     // <span class="docEmphItalicAlt">function template declaration must precede friend declaration in</span> <span class="docEmphasis">QueueItem</span>
     template &lt;class T&gt;
     std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Queue&lt;T&gt;&amp;);
     template &lt;class Type&gt; class QueueItem {
         friend class Queue&lt;Type&gt;;
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">item</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">next</span>
         friend std::ostream&amp;     // <span class="docEmphItalicAlt">defined on page 659</span>
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
     // <span class="docEmphItalicAlt">private class: no public section</span>
         QueueItem(const Type &amp;t): item(t), next(0) { }
         Type item;           // <span class="docEmphItalicAlt">value stored in this element</span>
         QueueItem *next;     // <span class="docEmphItalicAlt">pointer to next element in the</span> <span class="docEmphasis">Queue</span>
     };
     template &lt;class Type&gt; class Queue {
         // <span class="docEmphItalicAlt">needs access to</span> <span class="docEmphasis">head</span>
         friend std::ostream&amp; // <span class="docEmphItalicAlt">defined on page 659</span>
         operator&lt;&lt; &lt;Type&gt; (std::ostream&amp;, const Queue&lt;Type&gt;&amp;);
     public:
         // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">Queue</span>
         Queue(): head(0), tail(0) { }
         // <span class="docEmphItalicAlt">construct a</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">from a pair of iterators on some sequence</span>
         template &lt;class It&gt;
         Queue(It beg, It end):
               head(0), tail(0) { copy_elems(beg, end); }
         // <span class="docEmphItalicAlt">copy control to manage pointers to</span> <span class="docEmphasis">QueueItem</span><span class="docEmphItalicAlt">s in the</span> <span class="docEmphasis">Queue</span>
         Queue(const Queue &amp;Q): head(0), tail(0)
                                       { copy_elems(Q); }
         Queue&amp; operator=(const Queue&amp;); // <span class="docEmphItalicAlt">left as exercise for the reader</span>
         ~Queue() { destroy(); }
         // <span class="docEmphItalicAlt">replace current</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">by contents delimited by a pair of iterators</span>
         template &lt;class Iter&gt; void assign(Iter, Iter);
         // <span class="docEmphItalicAlt">return element from head of</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">unchecked operation: front on an empty</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is undefined</span>
         Type&amp; front()             { return head-&gt;item; }
         const Type &amp;front() const { return head-&gt;item; }
         void push(const Type &amp;);// <span class="docEmphItalicAlt">defined on page 652</span>
         void pop();             // <span class="docEmphItalicAlt">defined on page 651</span>
         bool empty() const {           // <span class="docEmphItalicAlt">true if no elements in the</span> <span class="docEmphasis">Queue</span>
             return head == 0;
     }
     private:
         QueueItem&lt;Type&gt; *head;   // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
         QueueItem&lt;Type&gt; *tail;   // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
     // <span class="docEmphItalicAlt">utility functions used by copy constructor, assignment, and destructor</span>
     void destroy();                // <span class="docEmphItalicAlt">defined on page 651</span>
     void copy_elems(const Queue&amp;); // <span class="docEmphItalicAlt">defined on page 652</span>
     // <span class="docEmphItalicAlt">version of copy to be used by</span> <span class="docEmphasis">assign</span> <span class="docEmphItalicAlt">to copy elements from iterator range</span>
     // <span class="docEmphItalicAlt">defined on page 662</span>
     template &lt;class Iter&gt; void copy_elems(Iter, Iter);
     };
     // <span class="docEmphItalicAlt">Inclusion Compilation Model: include member function definitions as well</span>
     #include "Queue.cc"
</pre><br>

	<a name="idd1e130886"></a><a name="idd1e130893"></a><a name="idd1e130900"></a>
        <p class="docText">Members that are not defined in the class itself can be found in earlier sections of this chapter; the comment following such members indicates the page on which the definition can be found.</p>
        <p class="docText">未在类本身中定义的成员可在本章前面几节中找到，跟在这些成员后面的注释指出了可以在哪一节找到它们。</p>

<a name="ch16sb16"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.4.6</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa14q1"></a><b>Exercise 16.43:</b></td>

                    <td>
                      <p class="docText">Add the <tt>assign</tt> member and a constructor that takes a pair of iterators to your <tt>List</tt> class.</p>
                      <p class="docText">为你的 <tt>List</tt> 类增加 <tt>assign</tt> 成员和一个参数为一对迭代器的构造函数。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa14q2"></a><b>Exercise 16.44:</b></td>

                    <td>
                      <p class="docText">We implemented our own <tt>Queue</tt> class in order to illustrate how class templates are implemented. One way in which our implementation could be simplified would be to define <tt>Queue</tt> on top of one of the existing library container types. That way, we could avoid having to manage the allocation and deallocation of the <tt>Queue</tt> elements. Reimplement <tt>Queue</tt> using <tt>std::list</tt> to hold the actual <tt>Queue</tt> elements.</p>
                      <p class="docText">为了举例说明怎样实现类模板，我们实现了自己的 <tt>Queue</tt> 类。可以简化实现的一种方式可能是将 <tt>Queue</tt> 定义在一个现存的标准库容器类型之上，用这种方法，可以避免必须管理 <tt>Queue</tt> 元素的分配和回收。用 <tt>std::List</tt> 保存实际 <tt>Queue</tt> 元素，重新实现 <tt>Queue</tt> 类。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec24"></a>

        <h4 class="docSection2Title">16.4.7. <tt>static</tt> Members of Class Templates</h4>
        <h4 class="docSection2Title">16.4.7. 类模板的 static 成员</h4>

        <p class="docText">A class template can declare <tt>static</tt> members (<a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6" >Section 12.6</a>, p. <a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6" >467</a>) in the same way as any other class:</p>
                      <p class="docText">类模板可以像任意其他类一样声明 <tt>static</tt> 成员（<a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6" >第 12.6 节</a>）。以下代码：</p>
        <pre>
     template &lt;class T&gt; class Foo {
     public:
        static std::size_t count() { return ctr; }
        // <span class="docEmphItalicAlt">other interface members</span>
     private:
        static std::size_t ctr;
        // <span class="docEmphItalicAlt">other implementation members</span>
     };
</pre><br>

        <p class="docText">defines a class template named <tt>Foo</tt> that among other members has a <tt>public static</tt> member function named <tt>count</tt> and a <tt>private static</tt> data member named <tt>ctr</tt>.</p>
        <p class="docText">定义了名为 <tt>Foo</tt> 的类模板，它有一个名为 <tt>count</tt> 的 <tt>public static</tt> 成员函数和一个名为 <tt>ctr</tt> 的 <tt>private static</tt> 数据成员。</p>

        <p class="docText">Each instantiation of class <tt>Foo</tt> has its own <tt>static</tt> member:</p>
        <p class="docText"><tt>Foo</tt> 类的每个实例化有自己的 <tt>static</tt> 成员：</p>
        <pre>
     // <span class="docEmphItalicAlt">Each object shares the same</span> <span class="docEmphasis">Foo&lt;int&gt;::ctrand Foo&lt;int&gt;::count</span> <span class="docEmphItalicAlt">members</span>
     Foo&lt;int&gt; fi, fi2, fi3;
     // <span class="docEmphItalicAlt">has</span> <span class="docEmphasis">static</span> <span class="docEmphItalicAlt">members</span> <span class="docEmphasis">Foo&lt;string&gt;::ctrand Foo&lt;string&gt;::count</span>
     Foo&lt;string&gt; fs;
</pre><br>

	<a name="idd1e131053"></a><a name="idd1e131062"></a><a name="idd1e131071"></a><a name="idd1e131080"></a><a name="idd1e131089"></a>
        <p class="docText">Each instantiation represents a distinct type, so there is one <tt>static</tt> shared among the objects of any given instantiation. Hence, any objects of type <tt>Foo&lt;int&gt;</tt> share the same <tt>static</tt> member <tt>ctr</tt>. Objects of type <tt>Foo&lt;string&gt;</tt> share a different <tt>ctr</tt> member.</p>
        <p class="docText">每个实例化表示截然不同的类型，所以给定实例外星人所有对象都共享一个 <tt>static</tt> 成员。因此，<tt>Foo&lt;int&gt;</tt> 类型的任意对象共享同一 <tt>static</tt> 成员 <tt>ctr</tt>，<tt>Foo&lt;string&gt;</tt> 类型的对象共享另一个不同的 <tt>ctr</tt> 成员。</p>

<a name="ch16lev3sec37"></a>
        <h5 class="docSection3Title">Using a <tt>static</tt> Member of a Class Template</h5>
        <h5 class="docSection3Title">使用类模板的 <tt>static</tt> 成员</h5>

        <p class="docText">As usual, we can access a <tt>static</tt> member of a class template through an object of the class type or by using the scope operator to access the member directly. Of course, when we attempt to use the <tt>static</tt> member through the class, we must refer to an actual instantiation:</p>
        <p class="docText">通常，可以通过类类型的对象访问类模板的 <tt>static</tt> 成员，或者通过使用作用域操作符直接访问成员。当然，当试图通过类使用 <tt>static</tt> 成员的时候，必须引用实际的实例化：</p>
        <pre>
     Foo&lt;int&gt; fi, fi2;              // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Foo&lt;int&gt;</span> <span class="docEmphItalicAlt">class</span>
     size_t ct = Foo&lt;int&gt;::count(); // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Foo&lt;int&gt;::count</span>
     ct = fi.count();               // <span class="docEmphItalicAlt">ok: uses</span> <span class="docEmphasis">Foo&lt;int&gt;::count</span>
     ct = fi2.count();              // <span class="docEmphItalicAlt">ok: uses</span> <span class="docEmphasis">Foo&lt;int&gt;::count</span>
     ct = Foo::count();             // <span class="docEmphItalicAlt">error: which template instantiation?</span>
</pre><br>

        <p class="docText">Like any other member function, a <tt>static</tt> member function is instantiated only if it is used in a program.</p>
        <p class="docText">与任意其他成员函数一样，<tt>static</tt> 成员函数只有在程序中使用时才进行实例化。</p>

	<a name="ch16lev3sec38"></a>
        <h5 class="docSection3Title">Defining a <tt>static</tt> Member</h5>
        <h5 class="docSection3Title">定义 <tt>static</tt> 成员</h5>

        <p class="docText">As with any other <tt>static</tt> data member, there must be a definition for the data member that appears outside the class. In the case of a class template <tt>static</tt>, the member definition must inidicate that it is for a class template:</p>
        <p class="docText">像使用任意其他 <tt>static</tt> 数据成员一样，必须在类外部出现数据成员的定义。在类模板含有 <tt>static</tt> 成员的情况下，成员定义必须指出它是类模板的成员：</p>
        <pre>
     template &lt;class T&gt;
     size_t Foo&lt;T&gt;::ctr = 0; // <span class="docEmphItalicAlt">define and initialize</span> <span class="docEmphasis">ctr</span>
</pre><br>

        <p class="docText">A <tt>static</tt> data member is defined like any other member of a class template that is defined outside the class. It begins with the keyword <tt>template</tt> followed by the class template parameter list and the class name. In this case, the name of the <tt>static</tt> data member is prefixed by <tt>Foo&lt;T&gt;::</tt>, which indicates that the member belongs to the class template <tt>Foo</tt>.</p>
        <p class="docText">static 数据成员像定义在类外部的任意其他类成员一样定义，它用关键字 <tt>template</tt> 开头，后面接着类模板形参表和类名。在这个例子中，<tt>static</tt> 数据成员的名字以 <tt>Foo&lt;T&gt;::</tt> 为前缀，表示成员属于类模板 Foo。</p>
<a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch16lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch16lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
