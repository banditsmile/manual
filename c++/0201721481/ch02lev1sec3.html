<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 2.3.  Variables</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch02lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch02lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch02lev1sec3"></a>

        <h3 class="docSection1Title">2.3. Variables</h3>
        <h3 class="docSection1Title">2.3. 变量</h3>

        <p class="docText">Imagine that we are given the problem of computing 2 to the power of 10. Our first attempt might be something like</p>
        <p class="docText">如果要计算 2 的 10 次方，我们首先想到的可能是：</p>
        <pre>
      #include &lt;iostream&gt;
      int main()
      {
          // <span class="docEmphItalicAlt">a first, not very good, solution</span>
          std::cout &lt;&lt; "2 raised to the power of 10: ";
          std::cout &lt;&lt; 2*2*2*2*2*2*2*2*2*2;
          std::cout &lt;&lt; std::endl;
          return 0;
      }
</pre>

        <p class="docText">This program solves the problem, although we might double- or triple-check to make sure that exactly 10 literal instances of 2 are being multiplied. Otherwise, we're satisfied. Our program correctly generates the answer 1,024.</p>
        <p class="docText">这个程序确实解决了问题，尽管我们可能要一而再、再而三地检查确保恰好有 10 个字面值常量 2 相乘。这个程序产生正确的答案 1024。</p>

        <p class="docText">We're next asked to compute 2 raised to the power of 17 and then to the power of 23. Changing our program each time is a nuisance. Worse, it proves to be remarkably error-prone. Too often, the modified program produces an answer with one too few or too many instances of 2.</p>
        <p class="docText">接下来要计算 2 的 17 次方，然后是 23 次方。而每次都要改变程序是很麻烦的事。更糟的是,这样做还容易引起错误。修改后的程序常常会产生多乘或少乘 2 的结果。</p>

        <p class="docText">An alternative to the explicit brute force power-of-2 computation is twofold:</p>
        <p class="docText">替代这种蛮力型计算的方法包括两部分内容：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">Use named objects to perform and print each computation.</p>
                <p class="docList">使用已命名对象执行运算并输出每次计算。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Use flow-of-control constructs to provide for the repeated execution of a sequence of program statements while a condition is true.</p>
                <p class="docList">使用控制流结构，当某个条件为真时重复执行一系列程序语句。</p>
              </div>
            </li>
          </ol>
        </div>

<a name="idd1e9178"></a><a name="idd1e9181"></a><a name="idd1e9184"></a>
        <p class="docText">Here, then, is an alternative way to compute 2 raised to the power of 10:</p>
        <p class="docText">以下是计算 2 的 10 次方的替代方法：</p>
        <pre>
      #include &lt;iostream&gt;
      int main()
      {
          // <span class="docEmphItalicAlt">local objects of type</span> <span class="docEmphasis">int</span>
          int value = 2;
          int pow = 10;
          int result = 1;
          // <span class="docEmphItalicAlt">repeat calculation of</span> <span class="docEmphasis">result</span> <span class="docEmphItalicAlt">until</span> <span class="docEmphasis">cnt</span> <span class="docEmphItalicAlt">is equal to</span> <span class="docEmphasis">pow</span>
          for (int cnt = 0; cnt != pow; ++cnt)
              result *= value;   // <span class="docEmphasis">result = result * value;</span>
          std::cout &lt;&lt; value
                    &lt;&lt; " raised to the power of "
                    &lt;&lt; pow &lt;&lt; ": \t"
                    &lt;&lt; result &lt;&lt; std::endl;
          return 0;
      }
</pre>

        <p class="docText"><tt>value, pow, result</tt>, and <tt>cnt</tt> are variables that allow for the storage, modification, and retrieval of values. The <tt>for</tt> loop allows for the repeated execution of our calculation until it's been executed <tt>pow</tt> times.</p>
	<p class="docText"><tt>value</tt>、<tt>pow</tt>、<tt>result</tt> 和 <tt>cnt</tt> 都是变量，可以对数值进行存储、修改和查询。<tt>for</tt> 循环使得计算过程重复执行 <tt>pow</tt> 次。</p>

<a name="ch02sb06"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa3q1"></a><b>Exercise 2.11:</b></td>

                    <td>
                      <p class="docText">Write a program that prompts the user to input two numbers, the base and exponent. Print the result of raising the base to the power of the exponent.</p>
                      <p class="docText">编写程序，要求用户输入两个数——底数（base）和指数（exponent），输出底数的指数次方的结果。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a name="ch02sb07"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Key Concept: Strong Static Typing</h2>
              <h2 class="docSidebarTitle">关键概念：强静态类型</h2>

              <p class="docText"><span class="docEmphStrong">C++ is a statically typed language, which means that types are checked at compile time. The process by which types are checked is referred to as type-checking.</span></p>
              <p class="docText"><span class="docEmphStrong">C++ 是一门静态类型语言，在编译时会作类型检查。</span></p>

              <p class="docText"><span class="docEmphStrong">In most languages, the type of an object constrains the operations that the object can perform. If the type does not support a given operation, then an object of that type cannot perform that operation.</span></p>
              <p class="docText"><span class="docEmphStrong">在大多数语言中，对象的类型限制了对象可以执行的操作。如果某种类型不支持某种操作，那么这种类型的对象也就不能执行该操作。</span></p>

              <p class="docText"><span class="docEmphStrong">In C++, whether an operation is legal or not is checked at compile time. When we write an expression, the compiler checks that the objects used in the expression are used in ways that are defined by the type of the objects. If not, the compiler generates an error message; an executable file is not produced.</span></p>
              <p class="docText"><span class="docEmphStrong">在 C++ 中，操作是否合法是在编译时检查的。当编写表达式时，编译器检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不是的话，那么编译器会提示错误，而不产生可执行文件。</span></p>

              <p class="docText"><span class="docEmphStrong">As our programs, and the types we use, get more complicated, we'll see that static <b><a name="ch02term54"></a><a class="docLink" href="ch02lev1sec11.html#gloss02_54" >type checking</a></b> helps find bugs in our programs earlier. A consequence of static checking is that the type of every entity used in our programs must be known to the compiler. Hence, we must define the type of a variable before we can use that variable in our programs.</span></p>
              <p class="docText"><span class="docEmphStrong">随着程序和使用的类型变得越来越复杂，我们将看到静态类型检查能帮助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的每个实体的类型。因此，程序中使用变量前必须先定义变量的类型</span></p>
            </td>
          </tr>
        </table><br>
        <a name="ch02lev2sec10"></a>

        <h4 class="docSection2Title">2.3.1. What Is a Variable?</h4>
        <h4 class="docSection2Title">2.3.1. 什么是变量</h4>

<a name="idd1e9291"></a><a name="idd1e9294"></a>
        <p class="docText">A variable provides us with named storage that our programs can manipulate. Each variable in C++ has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable. C++ programmers tend to refer to variables as "variables" or as "objects" interchangeably.</p>
        <p class="docText">变量提供了程序可以操作的有名字的存储区。C++ 中的每一个变量都有特定的类型，该类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。C++ 程序员常常把变量称为“变量”或“对象（object）”。</p>

<a name="ch02lev3sec4"></a>
        <h5 class="docSection3Title">Lvalues and Rvalues</h5>
        <h5 class="docSection3Title">左值和右值</h5>

        <p class="docText">We'll have more to say about expressions in <a class="docLink" href="ch05.html#ch05" >Chapter 5</a>, but for now it is useful to know that there are two kinds of expressions in C++:</p>
        <p class="docText">我们在<a class="docLink" href="ch05.html#ch05" >第五章</a>再详细探讨表达式，现在先介绍 C++ 的两种表达式：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
<a name="ch02term32"></a>
                <p class="docList"><b><a class="docLink" href="ch02lev1sec11.html#gloss02_32" >lvalue</a></b> (pronounced "ell-value"): An expression that is an lvalue may appear as either the left-hand or right-hand side of an assignment.</p>
                <p class="docList"><b><a class="docLink" href="ch02lev1sec11.html#gloss02_32" >左值</a></b>（发音为 ell-value）：左值可以出现在赋值语句的左边或右边。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
<a name="ch02term42"></a>
                <p class="docList"><b><a class="docLink" href="ch02lev1sec11.html#gloss02_42" >rvalue</a></b> (pronounced "are-value"): An expression that is an rvalue may appear on the right- but not left-hand side of an assignment.</p>
                <p class="docList"><b><a class="docLink" href="ch02lev1sec11.html#gloss02_42" >右值</a></b>（发音为 are-value）：右值只能出现在赋值的右边，不能出现在赋值语句的左边。</p>

                <p class="docList">Variables are lvalues and so may appear on the left-hand side of an assignment. Numeric literals are rvalues and so may not be assigned. Given the variables:</p>
                <p class="docList">变量是左值，因此可以出现在赋值语句的左边。数字字面值是右值，因此不能被赋值。给定以下变量：</p>
                <pre>
      int units_sold = 0;
      double sales_price = 0, total_revenue = 0;
</pre><br>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">it is a compile-time error to write either of the following:</p>
        <p class="docText">下列两条语句都会产生编译错误：</p>
        <pre>
      // <span class="docEmphItalicAlt">error: arithmetic expression is not an lvalue</span>
      units_sold * sales_price = total_revenue;
      // <span class="docEmphItalicAlt">error: literal constant is not an lvalue</span>
      0 = 1;
</pre><br>

        <p class="docText">Some operators, such as assignment, require that one of their operands be an lvalue. As a result, lvalues can be used in more contexts than can rvalues. The context in which an lvalue appears determines how it is used. For example, in the expression</p>
        <p class="docText">有些操作符，比如赋值，要求其中的一个操作数必须是左值。结果，可以使用左值的上下文比右值更广。左值出现的上下文决定了左值是如何使用的。例如，表达式</p>
        <pre>
      units_sold = units_sold + 1;
</pre>

        <p class="docText">the variable <tt>units_sold</tt> is used as the operand to two different operators. The <tt>+</tt> operator cares only about the values of its operands. The value of a variable is the value currently stored in the memory associated with that variable. The effect of the addition is to fetch that value and add one to it.</p>
	<p class="docText">中，<tt>units_sold</tt> 变量被用作两种不同操作符的操作数。<tt>+</tt> 操作符仅关心其操作数的值。变量的值是当前存储在和该变量相关联的内存中的值。加法操作符的作用是取得变量的值并加 1。</p>

        <p class="docText">The variable <tt>units_sold</tt> is also used as the left-hand side of the <tt>=</tt> operator. The <tt>=</tt> operator reads its right-hand side and writes to its left-hand side. In this expression, the result of the addition is stored in the storage associated with <tt>units_sold;</tt> the previous value in <tt>units_sold</tt> is overwritten.</p>
	<p class="docText">变量 <tt>units_sold</tt> 也被用作 <tt>=</tt> 操作符的左操作数。<tt>=</tt> 操作符读取右操作数并写到左操作数。在这个表达式中，加法运算的结果被保存到与 <tt>units_sold</tt> 相关联的存储单元中，而 <tt>units_sold</tt> 之前的值则被覆盖。</p>

<a name="ch02note05"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">In the course of the text, we'll see a number of situations in which the use of an rvalue or lvalue impacts the behavior and/or the performance of our programsin particular when passing and returning values from a function.</p>
                <p class="docText">在本书中，我们将看到在许多情形中左值或右值的使用影响程序的操作和/或性能——特别是在向函数传递值或从函数中返回值的时候。</p>
              </td>
            </tr>
          </table>
        </div>
        <a name="ch02sb08"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.3.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
<a name="ch02qa4q1"></a>
                    <td align="right" class="docText" width="50"><b>Exercise 2.12:</b></td>

                    <td>
<a name="idd1e9412"></a><a name="idd1e9415"></a><a name="idd1e9418"></a><a name="idd1e9421"></a><a name="idd1e9424"></a>
                      <p class="docText">Distinguish between an lvalue and an rvalue; show examples of each.</p>
                      <p class="docText">区分左值和右值，并举例说明。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa4q2"></a><b>Exercise 2.13:</b></td>

                    <td>
                      <p class="docText">Name one case where an lvalue is required.</p>
                      <p class="docText">举出一个需要左值的例子。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a name="ch02sb09"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Terminology: What Is an object?</h2>
              <h2 class="docSidebarTitle">术语：什么是对象？</h2>

              <p class="docText"><span class="docEmphStrong">C++ programmers tend to be cavalier in their use of the term <span class="docEmphasis">object</span>. Most generally, an object is a region of memory that has a type. More specifically, evaluating an expression that is an lvalue yields an object.</span></p>
              <p class="docText"><span class="docEmphStrong">C++ 程序员经常随意地使用术语对象。一般而言，对象就是内存中具有类型的区域。说得更具体一些，计算左值表达式就会产生对象。</span></p>

              <p class="docText"><span class="docEmphStrong">Strictly speaking, some might reserve the term <span class="docEmphasis">object</span> to describe only variables or values of class types. Others might distinguish between named and unnamed objects, always referring to variables when discussing named objects. Still others distinguish between objects and values, using the term <span class="docEmphasis">object</span> for data that can be changed by the program and using the term <span class="docEmphasis">value</span> for those that are read-only.</span></p>
              <p class="docText"><span class="docEmphStrong">严格地说，有些人只把术语对象用于描述变量或类类型的值。有些人还区别有名字的对象和没名字的对象，当谈到有名字的对象时一般指变量。还有一些人区分对象和值，用术语对象描述可被程序改变的数据，用术语值描述只读数据。</span></p>

              <p class="docText"><span class="docEmphStrong">In this book, we'll follow the more colloquial usage that an object is a region of memory that has a type. We will freely use <span class="docEmphasis">object</span> to refer to most of the data manipulated by our programs regardless of whether those data have built-in or class type, are named or unnamed, or are data that can be read or written.</span></p>
              <p class="docText"><span class="docEmphStrong">在本书中，我们遵循更为通用的用法，即对象是内存中具有类型的区域。我们可以自由地使用对象描述程序中可操作的大部分数据，而不管这些数据是内置类型还是类类型，是有名字的还是没名字的，是可读的还是可写的。</span></p>
            </td>
          </tr>
        </table>
        <a name="ch02lev2sec11"></a>

        <h4 class="docSection2Title">2.3.2. The Name of a Variable</h4>
        <h4 class="docSection2Title">2.3.2. 变量名</h4>

<a name="ch02term24"></a>
        <p class="docText">The name of a variable, its <b><a class="docLink" href="ch02lev1sec11.html#gloss02_24" >identifier</a></b>, can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper- and lowercase letters are distinct: Identifiers in C++ are case-sensitive. The following defines four distinct identifiers:</p>
        <p class="docText">变量名，即变量的<b><a class="docLink" href="ch02lev1sec11.html#gloss02_24" >标识符</a></b>，可以由字母、数字和下划线组成。变量名必须以字母或下划线开头，并且区分大小写字母：C++ 中的标识符都是大小写敏感的。下面定义了 4 个不同的标识符：</p>
        <pre>
      // <span class="docEmphasis">declares four different</span> int <span class="docEmphasis">variables</span>
      int somename, someName, SomeName, SOMENAME;
</pre><br>
        <a name="ch02note06"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">There is no language-imposed limit on the permissible length of a name, but out of consideration for others that will read and/or modify our code, it should not be too long.</p>
                <p class="docText">语言本身并没有限制变量名的长度，但考虑到将会阅读和/或修改我们的代码的其他人，变量名不应太长。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">For example,</p>
        <p class="docText">例如：</p>
        <pre>
      gosh_this_is_an_impossibly_long_name_to_type
</pre>

        <p class="docText">is a really bad identifier name.</p>
        <p class="docText">就是一个糟糕的标识符名。</p>

<a name="ch02lev3sec5"></a>
        <h5 class="docSection3Title">C++ Keywords</h5>
        <h5 class="docSection3Title">C++ 关键字</h5>

        <p class="docText">C++ reserves a set of words for use within the language as keywords. Keywords may not be used as program identifiers. <a class="docLink" href="ch02lev1sec3.html#ch02table02">Table 2.2</a> on the next page lists the complete set of C++ keywords.</p>
        <p class="docText">C++ 保留了一组词用作该语言的关键字。关键字不能用作程序的标识符。<a class="docLink" href="ch02lev1sec3.html#ch02table02">表 2.2</a> 列出了 C++ 所有的关键字。</p>

<a name="ch02table02"></a>
        <h5 class="docTableTitle">Table 2.2. C++ Keywords</h5>
        <h5 class="docTableTitle">表 2.2. C++ 关键字</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="100">
            <col width="100">
            <col width="100">
            <col width="100">
            <col width="100">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>asm</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>do</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>if</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>return</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>try</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>auto</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>double</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>inline</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>short</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>typedef</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bool</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>dynamic_cast</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>int</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>signed</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>typeid</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>break</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>else</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>long</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>sizeof</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>typename</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>case</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>enum</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>mutable</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>static</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>union</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>catch</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>explicit</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>namespace</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>static_cast</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>unsigned</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>char</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>export</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>new</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>struct</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>using</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>class</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>extern</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>operator</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>switch</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>virtual</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>const</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>false</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>private</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>template</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>void</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>const_cast</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>float</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>protected</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>this</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>volatile</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>continue</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>for</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>public</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>throw</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>wchar_t</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>default</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>friend</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>register</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>true</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>while</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>delete</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>goto</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>reinterpret_cast</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top"> </td>

            <td class="docTableCell" align="left" valign="top"> </td>
          </tr>
        </table><br>

<a name="idd1e9917"></a><a name="idd1e9922"></a><a name="idd1e9927"></a>
        <p class="docText">C++ also reserves a number of words that can be used as alternative names for various operators. These alternative names are provided to support character sets that do not support the standard set of C++ operator symbols. These names, listed in <a class="docLink" href="ch02lev1sec3.html#ch02table03">Table 2.3</a>, also may not be used as identifiers:</p>
        <p class="docText">C++ 还保留了一些词用作各种操作符的替代名。这些替代名用于支持某些不支持标准C++操作符号集的字符集。它们也不能用作标识符。<a class="docLink" href="ch02lev1sec3.html#ch02table03">表 2.3</a>列出了这些替代名。</p>

<a name="ch02table03"></a>
        <h5 class="docTableTitle">Table 2.3. C++ Operator Alternative Names</h5>
        <h5 class="docTableTitle">表 2.3. C++ 操作符替代名</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="100">
            <col width="100">
            <col width="100">
            <col width="100">
            <col width="50">
            <col width="50">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>and</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bitand</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>compl</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>not_eq</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>or_eq</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>xor_eq</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>and_eq</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bitor</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>not</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>or</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>xor</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top"> </td>
          </tr>
        </table><br>

        <p class="docText">In addition to the keywords, the standard also reserves a set of identifiers for use in the library. Identifiers cannot contain two consecutive underscores, nor can an identifier begin with an underscore followed immediately by an upper-case letter. Certain identifiersthose that are defined outside a functionmay not begin with an underscore.</p>
        <p class="docText">除了关键字，C++ 标准还保留了一组标识符用于标准库。标识符不能包含两个连续的下划线，也不能以下划线开头后面紧跟一个大写字母。有些标识符（在函数外定义的标识符）不能以下划线开头。</p>

<a name="ch02lev3sec6"></a>
        <h5 class="docSection3Title">Conventions for Variable Names</h5>
        <h5 class="docSection3Title">变量命名习惯</h5>

        <p class="docText">There are a number of generally accepted conventions for naming variables. Following these conventions can improve the readability of a program.</p>
        <p class="docText">变量命名有许多被普遍接受的习惯，遵循这些习惯可以提高程序的可读性。</p>

        <ul>
          <li>
            <p class="docList">A variable name is normally written in lowercase letters. For example, one writes <tt>index</tt>, not <tt>Index</tt> or <tt>INDEX</tt>.</p>
	    <p class="docList">变量名一般用小写字母。例如，通常会写成 <tt>index</tt>，而不写成 <tt>Index</tt> 或 <tt>INDEX</tt>。</p>
          </li>

          <li>
            <p class="docList">An identifier is given a mnemonic namethat is, a name that gives some indication of its use in a program, such as <tt>on_loan</tt> or <tt>salary</tt>.</p>
	    <p class="docList">标识符应使用能帮助记忆的名字，也就是说，能够提示其在程序中的用法的名字，如 <tt>on_loan</tt> 或 <tt>salary</tt>。</p>
          </li>

          <li>
            <p class="docList">An identifier containing multiple words is written either with an underscore between each word or by capitalizing the first letter of each embedded word. For example, one generally writes <tt>student_loan</tt> or <tt>studentLoan</tt>, not <tt>studentloan</tt>.</p>
	    <p class="docList">包含多个词的标识符书写为在每个词之间添加一个下划线，或者每个内嵌的词的第一个字母都大写。例如通常会写成 <tt>student_loan</tt> 或 <tt>studentLoan</tt>，而不写成 <tt>studentloan</tt>。</p>
          </li>
        </ul><a name="ch02note07"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
<a name="idd1e10080"></a><a name="idd1e10083"></a><a name="idd1e10088"></a><a name="idd1e10091"></a><a name="idd1e10096"></a><a name="idd1e10099"></a><a name="idd1e10102"></a><a name="idd1e10105"></a><a name="idd1e10110"></a>
                <p class="docText">The most important aspect of a naming convention is that it be applied consistently.</p>
                <p class="docText">命名习惯最重要的是保持一致。</p>
              </td>
            </tr>
          </table>
        </div>
        <a name="ch02sb10"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.3.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa5q1"></a><b>Exercise 2.14:</b></td>

                    <td>
                      <p class="docText">Which, if any, of the following names are invalid? Correct each identified invalid name.</p>
                      <p class="docText">下面哪些（如果有）名字是非法的？更正每个非法的标识符名字。</p>
                      <pre>
      (a) int double = 3.14159;        (b) char _;
      (c) bool catch-22;               (d) char 1_or_2 ='1';
      (e) float Float = 3.14f;
</pre>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a name="ch02lev2sec12"></a>

        <h4 class="docSection2Title">2.3.3. Defining Objects</h4>
        <h4 class="docSection2Title">2.3.3. 定义对象</h4>

        <p class="docText">The following statements define five variables:</p>
        <p class="docText">下列语句定义了 5 个变量：</p>
        <pre>
      int units_sold;
      double sales_price, avg_price;
      std::string title;
      Sales_item curr_book;
</pre>

<a name="ch02term55"></a>
        <p class="docText">Each definition starts with a <b><a class="docLink" href="ch02lev1sec11.html#gloss02_55" >type specifier</a></b>, followed by a comma-separated list of one or more names. A semicolon terminates the definition. The type specifier names the type associated with the object: <tt>int, double, std::string</tt>, and <tt>Sales_item</tt> are all names of types. The types <tt>int</tt> and <tt>double</tt> are built-in types, <tt>std::string</tt> is a type defined by the library, and <tt>Sales_item</tt> is a type that we used in <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5" >Section 1.5</a> (p. <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5" >20</a>)and will define in subsequent chapters. The type determines the amount of storage that is allocated for the variable and the set of operations that can be performed on it.</p>
	<p class="docText">每个定义都是以<b><a class="docLink" href="ch02lev1sec11.html#gloss02_55" >类型说明符</a></b>开始，后面紧跟着以逗号分开的含有一个或多个说明符的列表。分号结束定义。类型说明符指定与对象相关联的类型：<tt>int</tt> 、<tt>double</tt>、<tt>std::string</tt> 和 <tt>Sales_item</tt> 都是类型名。其中 <tt>int</tt> 和 <tt>double</tt> 是内置类型，<tt>std::string</tt> 是标准库定义的类型，<tt>Sales_item</tt> 是我们在<a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5" >第 1.5 节</a>使用的类型，将会在后面章节定义。类型决定了分配给变量的存储空间的大小和可以在其上执行的操作。</p>

        <p class="docText">Multiple variables may be defined in a single statement:</p>
        <p class="docText">多个变量可以定义在同一条语句中：</p>
        <pre>
      double salary, wage;    // <span class="docEmphasis">defines two variables of type</span> double
      int month,
          day, year;          // <span class="docEmphasis">defines three variables of type</span> int
      std::string address;    // <span class="docEmphasis">defines one variable of type</span> std::string
</pre><br>
        <a name="ch02lev3sec7"></a>

        <h5 class="docSection3Title">Initialization</h5>
        <h5 class="docSection3Title">初始化</h5>

<a name="ch02term26"></a><a name="ch02term60"></a><a name="ch02term12"></a><a name="ch02term17"></a>
        <p class="docText">A definition specifies a variable's type and identifier. A definition may also provide an initial value for the object. An object defined with a specified first value is spoken of as <b><a class="docLink" href="ch02lev1sec11.html#gloss02_26" >initialized</a></b>. C++ supports two forms of <span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_60" >variable initialization</a></span>: <b><a class="docLink" href="ch02lev1sec11.html#gloss02_12" >copy-initialization</a></b> and <b><a class="docLink" href="ch02lev1sec11.html#gloss02_17" >direct-initialization</a></b>. The copy-initialization syntax uses the equal (<tt>=</tt>) symbol; direct-initialization places the initializer in parentheses:</p>
	<p class="docText">变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时指定了初始值的对象被称为是<b><a class="docLink" href="ch02lev1sec11.html#gloss02_26" >已初始化的</a></b>。C++ 支持两种<span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_60" >初始化变量</a>的形式：<b><a class="docLink" href="ch02lev1sec11.html#gloss02_12" >复制初始化</a></b>和<b><a class="docLink" href="ch02lev1sec11.html#gloss02_17" >直接初始化</a></b>。复制初始化语法用等号（<tt>=</tt>），直接初始化则是把初始化式放在括号中：</p>
        <pre>
      int ival(1024);     // <span class="docEmphasis">direct-initialization</span>
      int ival = 1024;    // <span class="docEmphasis">copy-initialization</span>
</pre><br>

<a name="idd1e10248"></a><a name="idd1e10253"></a><a name="idd1e10256"></a>
        <p class="docText">In both cases, <tt>ival</tt> is initialized to <tt>1024</tt>.</p>
	<p class="docText">这两种情形中，<tt>ival</tt> 都被初始化为 <tt>1024</tt>。</p>

<a name="ch02note08"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Although, at this point in the book, it may seem obscure to the reader, in C++ it is essential to understand that initialization is not assignment. Initialization happens when a variable is created and gives that variable its initial value. Assignment involves obliterating an object's current value and replacing that value with a new one.</p>
                <p class="docText">虽然在本书到目前为止还没有清楚说明，但是在 C++ 中理解“初始化不是赋值”是必要的。初始化指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">Many new C++ programmers are confused by the use of the <tt>=</tt> symbol to initialize a variable. It is tempting to think of initialization as a form of assignment. But initialization and assignment are different operations in C++. This concept is particularly confusing because in many other languages the distinction is irrelevant and can be ignored. Moreover, even in C++ the distinction rarely matters until one attempts to write fairly complex classes. Nonetheless, it is a crucial concept and one that we will reiterate throughout the text.</p>
	<p class="docText">使用 <tt>=</tt> 来初始化变量使得许多 C++ 编程新手感到迷惑，他们很容易把初始化当成是赋值的一种形式。但是在 C++ 中初始化和赋值是两种不同的操作。这个概念特别容易误导人，因为在许多其他的语言中这两者的差别不过是枝节问题因而可以被忽略。即使在 C++ 中也只有在编写非常复杂的类时才会凸显这两者之间的区别。无论如何，这是一个关键的概念，也是我们将会在整本书中反复强调的概念。</p>

<a name="ch02note09"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">There are subtle differences between copy- and direct-initialization when initializing objects of a class type. We won't completely explain these differences until <a class="docLink" href="ch13.html#ch13" >Chapter 13</a>. For now, it's worth knowing that the direct syntax is more flexible and can be slightly more efficient.</p>
                <p class="docText">当初始化类类型对象时，复制初始化和直接初始化之间的差别是很微妙的。我们在<a class="docLink" href="ch13.html#ch13" >第十三章</a>再详细解释它们之间的差别。现在我们只需知道，直接初始化语法更灵活且效率更高。</p>
              </td>
            </tr>
          </table>
        </div>
        <a name="ch02lev3sec8"></a>

        <h5 class="docSection3Title">Using Multiple Initializers</h5>
        <h5 class="docSection3Title">使用多个初始化式</h5>

<a name="ch02term36"></a>
        <p class="docText">When we initialize an <span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_36" >object</a></span> of a built-in type, there is only one way to do so: We supply a value, and that value is copied into the newly defined object. For built-in types, there is little difference between the direct and the copy forms of initialization.</p>
        <p class="docText">初始化内置类型的<span class="docEmphRoman"><a class="docLink" href="ch02lev1sec11.html#gloss02_36" >对象</a></span>只有一种方法：提供一个值，并且把这个值复制到新定义的对象中。对内置类型来说，复制初始化和直接初始化几乎没有差别。</p>

        <p class="docText">For objects of a class type, there are initializations that can be done only using direct-initialization. To understand why, we need to know a bit about how classes control initialization.</p>
        <p class="docText">对类类型的对象来说，有些初始化仅能用直接初始化完成。要想理解其中缘由，需要初步了解类是如何控制初始化的。</p>

<a name="ch02term11"></a>
        <p class="docText">Each class may define one or more special member functions (<a class="docLink" href="ch01lev1sec5.html#ch01lev2sec10" >Section 1.5.2</a>, p. <a class="docLink" href="ch01lev1sec5.html#ch01lev2sec10" >24</a>) that say how we can initialize variables of the class type. The member functions that define how initialization works are known as <b><a class="docLink" href="ch02lev1sec11.html#gloss02_11" >constructors</a></b>. Like any function, a constructor can take multiple arguments. A class may define several constructors, each of which must take a different number or type of arguments.</p>
        <p class="docText">每个类都可能会定义一个或几个特殊的成员函数（<a class="docLink" href="ch01lev1sec5.html#ch01lev2sec10" >第 1.5.2 节</a>）来告诉我们如何初始化类类型的变量。定义如何进行初始化的成员函数称为<b><a class="docLink" href="ch02lev1sec11.html#gloss02_11" >构造函数</a></b>。和其他函数一样，构造函数能接受多个参数。一个类可以定义几个构造函数，每个构造函数必须接受不同数目或者不同类型的参数。</p>

        <p class="docText">As an example, we'll look a bit at the <tt>string</tt> class, which we'll cover in more detail in <a class="docLink" href="ch03.html#ch03" >Chapter 3</a>. The <tt>string</tt> type is defined by the library and holds character strings of varying sizes. To use <tt>string</tt>s, we must include the <tt>string</tt> header. Like the IO types, <tt>string</tt> is defined in the <tt>std</tt> namespace.</p>
	<p class="docText">我们以 <tt>string</tt> 类为例（<tt>string</tt> 类将在<a class="docLink" href="ch03.html#ch03" >第三章</a>详细讨论）。<tt>string</tt> 类型在标准库中定义，用于存储不同长度的字符串。使用 <tt>string</tt> 时必须包含 <tt>string</tt> 头文件。和 IO 类型一样，<tt>string</tt> 定义在 <tt>std</tt> 命名空间中。</p>

        <p class="docText">The <tt>string</tt> class defines several constructors, giving us various ways to initialize a <tt>string</tt>. One way we can initialize a <tt>string</tt> is as a copy of a character string literal:</p>
	<p class="docText"><tt>string</tt> 类定义了几个构造函数，使得我们可以用不同的方式初始化 <tt>string</tt> 对象。其中一种初始化 <tt>string</tt> 对象的方式是作为字符串字面值的副本：</p>
        <pre>
      #include &lt;string&gt;
      // <span class="docEmphItalicAlt">alternative ways to initialize</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">from a character string literal</span>
      std::string titleA = "C++ Primer, 4th Ed.";
      std::string titleB("C++ Primer, 4th Ed.");
</pre>

<a name="idd1e10378"></a><a name="idd1e10383"></a>
        <p class="docText">In this case, either initialization form can be used. Both definitions create a <tt>string</tt> object whose initial value is a copy of the specified string literal.</p>
	<p class="docText">本例中，两种初始化方式都可以使用。两种定义都创建了一个 <tt>string</tt> 对象，其初始值都是指定的字符串字面值的副本。</p>

        <p class="docText">However, we can also initialize a <tt>string</tt> from a count and a character. Doing so creates a <tt>string</tt> containing the specified character repeated as many times as indicated by the count:</p>
        <p class="docText">也可以通过一个计数器和一个字符初始化string对象。这样创建的对象包含重复多次的指定字符，重复次数由计数器指定：</p>
        <pre>
      std::string all_nines(10, '9');   // all_nines= <span class="docEmphasis">"9999999999"</span>
</pre>

        <p class="docText">In this case, the only way to initialize <tt>all_nines</tt> is by using the direct form of initialization. It is not possible to use copy-initialization with multiple initializers.</p>
	<p class="docText">本例中，初始化 <tt>all_nines</tt> 的唯一方法是直接初始化。有多个初始化式时不能使用复制初始化。</p>

<a name="ch02lev3sec9"></a>
        <h5 class="docSection3Title">Initializing Multiple Variables</h5>
        <h5 class="docSection3Title">初始化多个变量</h5>

        <p class="docText">When a definition defines two or more variables, each variable may have its own initializer. The name of an object becomes visible immediately, and so it is possible to initialize a subsequent variable to the value of one defined earlier in the same definition. Initialized and uninitialized variables may be defined in the same definition. Both forms of initialization syntax may be intermixed:</p>
        <p class="docText">当一个定义中定义了两个以上变量的时候，每个变量都可能有自己的初始化式。 对象的名字立即变成可见，所以可以用同一个定义中前面已定义变量的值初始化后面的变量。已初始化变量和未初始化变量可以在同一个定义中定义。两种形式的初始化文法可以相互混合。</p>
        <pre>
      #include &lt;string&gt;
      // <span class="docEmphasis">ok:</span> salary <span class="docEmphasis">defined and initialized before it is used to initialize</span> wage
      double salary = 9999.99,
            wage(salary + 0.01);
      // <span class="docEmphasis">ok: mix of initialized and uninitialized</span>
      int interval,
          month = 8, day = 7, year = 1955;
      // <span class="docEmphasis">ok: both forms of initialization syntax used</span>
      std::string title("C++ Primer, 4th Ed."),
                  publisher = "A-W";
</pre><br>

        <p class="docText">An object can be initialized with an arbitrarily complex expression, including the return value of a function:</p>
        <p class="docText">对象可以用任意复杂的表达式（包括函数的返回值）来初始化：</p>
        <pre>
      double price = 109.99, discount = 0.16;
      double sale_price = apply_discount(price, discount);
</pre>

        <p class="docText">In this example, <tt>apply_discount</tt> is a function that takes two values of type <tt>double</tt> and returns a value of type <tt>double</tt>. We pass the variables <tt>price</tt> and <tt>discount</tt> to that function and use its return value to initialize <tt>sale_price</tt>.</p>
	<p class="docText">本例中，函数 <tt>apply_discount</tt> 接受两个 <tt>double</tt> 类型的值并返回一个 <tt>double</tt> 类型的值。将变量 <tt>price</tt> 和 <tt>discount</tt> 传递给函数，并且用它的返回值来初始化 <tt>sale_price</tt>。</p>

<a name="ch02sb11"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.3.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa6q1"></a><b>Exercise 2.15:</b></td>

                    <td>
                      <p class="docText">What, if any, are the differences between the following definitions:</p>
                      <p class="docText">下面两个定义是否不同？有何不同？</p>
                      <pre>
      int month = 9, day = 7;

      int month = 09, day = 07;
</pre><br>

                      <p class="docText">If either definition contains an error, how might you correct the problem?</p>
                      <p class="docText">如果上述定义有错的话，那么应该怎样改正呢?</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa6q3"></a><b>Exercise 2.16:</b></td>

                    <td>
                      <p class="docText">Assuming <tt>calc</tt> is a function that returns a <tt>double</tt>, which, if any, of the following are illegal definitions? Correct any that are identified as illegal.</p>
		      <p class="docText">假设 <tt>calc</tt> 是一个返回 <tt>double</tt> 对象的函数。下面哪些是非法定义?改正所有的非法定义。</p>
                      <pre>
     (a) int car = 1024, auto = 2048;
     (b) int ival = ival;
     (c) std::cin &gt;&gt; int input_value;
     (d) double salary = wage = 9999.99;
     (e) double calc = calc();
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>

<a name="ch02lev2sec13"></a>
        <h4 class="docSection2Title">2.3.4. Variable Initialization Rules</h4>
        <h4 class="docSection2Title">2.3.4. 变量初始化规则</h4>

        <p class="docText">When we define a variable without an initializer, the system sometimes initializes the variable for us. What value, if any, is supplied depends on the type of the variable and may depend on where it is defined.</p>
        <p class="docText">当定义没有初始化式的变量时，系统有时候会帮我们初始化变量。这时，系统提供什么样的值取决于变量的类型，也取决于变量定义的位置。</p>

<a name="ch02lev3sec10"></a>
        <h5 class="docSection3Title">Initialization of Variables of Built-in Type</h5>
        <h5 class="docSection3Title">内置类型变量的初始化</h5>

<a name="idd1e10489"></a><a name="idd1e10494"></a><a name="idd1e10499"></a><a name="idd1e10504"></a>
<a name="ch02term58"></a>
        <p class="docText">Whether a variable of built-in type is automatically initialized depends on where it is defined. Variables defined outside any function body are initialized to zero. Variables of built-in type defined inside the body of a function are <b><a class="docLink" href="ch02lev1sec11.html#gloss02_58" >uninitialized</a></b>. Using an uninitialized variable for anything other than as the left-hand operand of an assignment is undefined. Bugs due to uninitialized variables can be hard to find. As we cautioned on page <a class="docLink" href="ch02lev1sec2.html#ch02sb04" >42</a>, you should never rely on undefined behavior.</p>
        <p class="docText">内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数，<b><a class="docLink" href="ch02lev1sec11.html#gloss02_58" >未初始化</a></b>变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难于发现。正如我们在<a class="docLink" href="ch02lev1sec2.html#ch02sb04" >第 2.2 节</a>劝告的，永远不要依赖未定义行为。</p>

        <a name="ch02sb12"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Caution: Uninitialized Variables Cause Run-Time Problems</h2>
              <h2 class="docSidebarTitle">警告：未初始化的变量引起运行问题</h2>

              <p class="docText"><span class="docEmphStrong">Using an uninitialized object is a common program error, and one that is often difficult to uncover. The compiler is not required to detect a use of an uninitialized variable, although many will warn about at least some uses of uninitialized variables. However, no compiler can detect all uses of uninitialized variables.</span></p>
              <p class="docText"><span class="docEmphStrong">使用未初始化的变量是常见的程序错误，通常也是难以发现的错误。虽然许多编译器都至少会提醒不要使用未初始化变量，但是编译器并未被要求去检测未初始化变量的使用。而且，没有一个编译器能检测出所有未初始化变量的使用。</span></p>

              <p class="docText"><span class="docEmphStrong">Sometimes, we're lucky and using an uninitialized variable results in an immediate crash at run time. Once we track down the location of the crash, it is usually pretty easy to see that the variable was not properly initialized.</span></p>
              <p class="docText"><span class="docEmphStrong">有时我们很幸运，使用未初始化的变量导致程序在运行时突然崩溃。一旦跟踪到程序崩溃的位置，就可以轻易地发现没有正确地初始化变量。</span></p>

              <p class="docText"><span class="docEmphStrong">Other times, the program completes but produces erroneous results. Even worse, the results can appear correct when we run our program on one machine but fail on another. Adding code to the program in an unrelated location can cause what we thought was a correct program to suddenly start to produce incorrect results.</span></p>
              <p class="docText"><span class="docEmphStrong">但有时，程序运行完毕却产生错误的结果。更糟糕的是，程序运行在一部机器上时能产生正确的结果，但在另外一部机器上却不能得到正确的结果。添加代码到程序的一些不相关的位置，会导致我们认为是正确的程序产生错误的结果。</span></p>

              <p class="docText"><span class="docEmphStrong">The problem is that uninitialized variables actually do have a value. The compiler puts the variable somewhere in memory and treats whatever bit pattern was in that memory as the variable's initial state. When interpreted as an integral value, any bit pattern is a legitimate valuealthough the value is unlikely to be one that the programmer intended. Because the value is legal, using it is unlikely to lead to a crash. What it is likely to do is lead to incorrect execution and/or incorrect calculation.</span></p>
              <p class="docText"><span class="docEmphStrong">问题出在未初始化的变量事实上都有一个值。编译器把该变量放到内存中的某个位置，而把这个位置的无论哪种位模式都当成是变量初始的状态。当被解释成整型值时，任何位模式都是合法的值——虽然这个值不可能是程序员想要的。因为这个值合法，所以使用它也不可能会导致程序崩溃。可能的结果是导致程序错误执行和/或错误计算。</span></p>
            </td>
          </tr>
        </table>

        <a name="ch02note10"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">We recommend that every object of built-in type be initialized. It is not always necessary to initialize such variables, but it is easier and safer to do so until you can be certain it is safe to omit an initializer.</p>
                <p class="docText">建议每个内置类型的对象都要初始化。虽然这样做并不总是必需的，但是会更加容易和安全，除非你确定忽略初始化式不会带来风险。</p>
              </td>
            </tr>
          </table>
        </div>

        <a name="ch02lev3sec11"></a>
        <h5 class="docSection3Title">Initialization of Variables of Class Type</h5>
        <h5 class="docSection3Title">类类型变量的初始化</h5>

<a name="idd1e10606"></a><a name="idd1e10611"></a><a name="idd1e10616"></a><a name="idd1e10619"></a><a name="idd1e10622"></a><a name="idd1e10628"></a><a name="idd1e10631"></a><a name="idd1e10636"></a>
        <p class="docText">Each class defines how objects of its type can be initialized. Classes control object initialization by defining one or more constructors (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">Section 2.3.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">49</a>). As an example, we know that the <tt>string</tt> class provides at least two constructors. One of these constructors lets us initialize a <tt>string</tt> from a character string literal and another lets us initialize a <tt>string</tt> from a character and a count.</p>
	<p class="docText">每个类都定义了该类型的对象可以怎样初始化。类通过定义一个或多个构造函数来控制类对象的初始化（<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12">第 2.3.3 节</a>）。例如：我们知道 <tt>string</tt> 类至少提供了两个构造函数，其中一个允许我们通过字符串字面值初始化 <tt>string</tt> 对象，另外一个允许我们通过字符和计数器初始化 <tt>string</tt> 对象。</p>

<a name="ch02term15"></a>
        <p class="docText">Each class may also define what happens if a variable of the type is defined but an initializer is not provided. A class does so by defining a special constructor, known as the <b><a class="docLink" href="ch02lev1sec11.html#gloss02_15" >default constructor</a></b>. This constructor is called the default constructor because it is run "by default;" if there is no initializer, then this constructor is used. The default constructor is used regardless of where a variable is defined.</p>
        <p class="docText">如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即<b><a class="docLink" href="ch02lev1sec11.html#gloss02_15" >默认构造函数</a></b>来实现的。这个构造函数之所以被称作默认构造函数，是因为它是“默认”运行的。如果没有提供初始化式，那么就会使用默认构造函数。不管变量在哪里定义，默认构造函数都会被使用。</p>

        <p class="docText">Most classes provide a default constructor. If the class has a default constructor, then we can define variables of that class without explicitly initializing them. For example, the <tt>string</tt> type defines its default constructor to initialize the <tt>string</tt> as an empty stringthat is, a string with no characters:</p>
	<p class="docText">大多数类都提供了默认构造函数。如果类具有默认构造函数，那么就可以在定义该类的变量时不用显式地初始化变量。例如，<tt>string</tt> 类定义了默认构造函数来初始化 <tt>string</tt> 变量为空字符串，即没有字符的字符串：</p>
        <pre>
      std::string empty;  // <span class="docEmphasis">empty</span> <span class="docEmphItalicAlt">is the empty string;</span> <span class="docEmphasis">empty =""</span>
</pre>

        <p class="docText">Some class types do not have a default constructor. For these types, every definition must provide explicit initializer(s). It is not possible to define variables of such types without giving an initial value.</p>
        <p class="docText">有些类类型没有默认构造函数。对于这些类型来说，每个定义都必须提供显式的初始化式。没有初始值是根本不可能定义这种类型的变量的。</p>

<a name="ch02sb13"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.3.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa7q1"></a><b>Exercise 2.17:</b></td>

                    <td>
                      <p class="docText">What are the initial values, if any, of each of the following variables?</p>
                      <p class="docText">下列变量的初始值（如果有）是什么？</p>
                      <pre>
      std::string global_str;
      int global_int;
      int main()
      {
          int local_int;
          std::string local_str;
          // ...
          return 0;
      }
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a name="ch02lev2sec14"></a>

        <h4 class="docSection2Title">2.3.5. Declarations and Definitions</h4>
        <h4 class="docSection2Title">2.3.5. 声明和定义</h4>

        <p class="docText">As we'll see in <a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9" >Section 2.9</a> (p. <a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9" >67</a>), C++ programs typically are composed of many files. In order for multiple files to access the same variable, C++ distinguishes between declarations and definitions.</p>
        <p class="docText">正如将在<a class="docLink" href="ch02lev1sec9.html#ch02lev1sec9" >第 2.9 节</a>所看到的那样，C++ 程序通常由许多文件组成。为了让多个文件访问相同的变量，C++ 区分了声明和定义。</p>

<a name="ch02term16"></a>
        <p class="docText">A <b><a class="docLink" href="ch02lev1sec11.html#gloss02_16" >definition</a></b> of a variable allocates storage for the variable and may also specify an initial value for the variable. There must be one and only one definition of a variable in a program.</p>
        <p class="docText">变量的<b><a class="docLink" href="ch02lev1sec11.html#gloss02_16" >定义</a></b>用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。</p>

<a name="ch02term14"></a>
<a name="idd1e10749"></a>
        <p class="docText">A <b><a class="docLink" href="ch02lev1sec11.html#gloss02_14" >declaration</a></b> makes known the type and name of the variable to the program. A definition is also a declaration: When we define a variable, we declare its name and type. We can declare a name without defining it by using the <tt>extern</tt> keyword. A declaration that is not also a definition consists of the object's name and its type preceded by the keyword <tt>extern</tt>:</p>
        <p class="docText"><b><a class="docLink" href="ch02lev1sec11.html#gloss02_14" >声明</a></b>用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用extern关键字声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern：</p>
        <pre>
      extern int i;   // <span class="docEmphItalicAlt">declares but does not define</span> <span class="docEmphasis">i</span>
      int i;          //  <span class="docEmphItalicAlt">declares and defines</span> <span class="docEmphasis">i</span>
</pre><br>

        <p class="docText">An <tt>extern</tt> declaration is <span class="docEmphasis">not</span> a definition and does not allocate storage. In effect, it claims that a definition of the variable exists elsewhere in the program. A variable can be declared multiple times in a program, but it must be defined only once.</p>
        <p class="docText"><tt>extern</tt> 声明不是定义，也<span class="docEmphasis">不</span>分配存储空间。事实上，它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次。</p>

        <p class="docText">A declaration may have an initializer only if it is also a definition because only a definition allocates storage. The initializer must have storage to initialize. If an initializer is present, the declaration is treated as a definition even if the declaration is labeled <tt>extern</tt>:</p>
	<p class="docText">只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有存储空间来进行初始化。如果声明有初始化式，那么它可被当作是定义，即使声明标记为 <tt>extern</tt>：</p>
        <pre>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">definition</span>
</pre>

        <p class="docText">Despite the use of <tt>extern</tt>, this statement defines <tt>pi</tt>. Storage is allocated and initialized. An <tt>extern</tt> declaration may include an initializer only if it appears outside a function.</p>
	<p class="docText">虽然使用了 <tt>extern</tt> ，但是这条语句还是定义了 <tt>pi</tt>，分配并初始化了存储空间。只有当 <tt>extern</tt> 声明位于函数外部时，才可以含有初始化式。</p>

        <p class="docText">Because an <tt>extern</tt> that is initialized is treated as a definition, any subseqent definition of that variable is an error:</p>
	<p class="docText">因为已初始化的 <tt>extern</tt> 声明被当作是定义，所以该变量任何随后的定义都是错误的：</p>
        <pre>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">definition</span>
      double pi;                 // <span class="docEmphItalicAlt">error: redefinition of</span> <span class="docEmphasis">pi</span>
</pre>

        <p class="docText">Similarly, a subsequent <tt>extern</tt> declaration that has an initializer is also an error:</p>
	<p class="docText">同样，随后的含有初始化式的 <tt>extern</tt> 声明也是错误的：</p>
        <pre>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">definition</span>
      extern double pi;          // <span class="docEmphItalicAlt">ok: declaration not definition</span>
      extern double pi = 3.1416; // <span class="docEmphItalicAlt">error: redefinition of</span> <span class="docEmphasis">pi</span>
</pre>

        <p class="docText">The distinction between a declaration and a definition may seem pedantic but in fact is quite important.</p>
        <p class="docText">声明和定义之间的区别可能看起来微不足道，但事实上却是举足轻重的。</p>

<a name="ch02note11"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">In C++ a variable must be defined exactly once and must be defined or declared before it is used.</p>
                <p class="docText">在 C++ 语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或声明变量。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">Any variable that is used in more than one file requires declarations that are separate from the variable's definition. In such cases, one file will contain the definition for the variable. Other files that use that same variable will contain declarations forbut not a definition ofthat same variable.</p>
        <p class="docText">任何在多个文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，使用该变量的其他文件则包含该变量的声明（而不是定义）。</p>

<a name="ch02sb14"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.3.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa8q1"></a><b>Exercise 2.18:</b></td>

                    <td>
                      <p class="docText">Explain the meaning of each of these instances of <tt>name</tt>:</p>
		      <p class="docText">解释下列例子中 <tt>name</tt> 的意义</p>
                      <pre>
      extern std::string name;
      std::string name("exercise 3.5a");
      extern std::string name("exercise 3.5a");
</pre>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>

        <a name="ch02lev2sec15"></a>
        <h4 class="docSection2Title">2.3.6. Scope of a Name</h4>
        <h4 class="docSection2Title">2.3.6. 名字的作用域</h4>

<a name="idd1e10913"></a><a name="idd1e10916"></a><a name="idd1e10919"></a><a name="idd1e10922"></a><a name="idd1e10927"></a>
<a name="ch02term43"></a>
        <p class="docText">Every name in a C++ program must refer to a unique entity (such as a variable, function, type, etc.). Despite this requirement, names can be used more than once in a program: A name can be reused as long as it is used in different contexts, from which the different meanings of the name can be distinguished. The context used to distinguish the meanings of names is a <b><a class="docLink" href="ch02lev1sec11.html#gloss02_43" >scope</a></b>. A scope is a region of the program. A name can refer to different entities in different scopes.</p>
        <p class="docText">C++程序中，每个名字都与唯一的实体（比如变量、函数和类型等）相关联。尽管有这样的要求，还是可以在程序中多次使用同一个名字，只要它用在不同的上下文中，且通过这些上下文可以区分该名字的不同意义。用来区分名字的不同意义的上下文称为<b><a class="docLink" href="ch02lev1sec11.html#gloss02_43" >作用域</a></b>。作用域是程序的一段区域。一个名称可以和不同作用域中的不同实体相关联。</p>

        <p class="docText">Most scopes in C++ are delimited by curly braces. Generally, names are visible from their point of declaration until the end the scope in which the declaration appears. As an example, consider this program, which we first encountered in <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >Section 1.4.2</a> (p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >14</a>):</p>
        <p class="docText">C++ 语言中，大多数作用域是用花括号来界定的。一般来说，名字从其声明点开始直到其声明所在的作用域结束处都是可见的。例如，思考<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >第 1.4.2 节</a>中的程序：</p>
        <pre>
      #include &lt;iostream&gt;
      int main()
      {
          int sum = 0;
          //  <span class="docEmphItalicAlt">sum values from 1 up to 10 inclusive</span>
          for (int val = 1; val &lt;= 10; ++val)
              sum += val;   // <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">sum = sum + val</span>

          std::cout &lt;&lt; "Sum of 1 to 10 inclusive is "
                    &lt;&lt; sum &lt;&lt; std::endl;
          return 0;
      }
</pre>

<a name="ch02term21"></a>
<a name="ch02term31"></a>
        <p class="docText">This program defines three names and uses two names from the standard library. It defines a function named <tt>main</tt> and two variables named <tt>sum</tt> and <tt>val</tt>. The name <tt>main</tt> is defined outside any curly braces and is visible throughout the program. Names defined outside any function have <b><a class="docLink" href="ch02lev1sec11.html#gloss02_21" >global scope</a></b>; they are accessible from anywhere in the program. The name <tt>sum</tt> is defined within the scope of the <tt>main</tt> function. It is accessible throughout the <tt>main</tt> function but not outside of it. The variable <tt>sum</tt> has <b><a class="docLink" href="ch02lev1sec11.html#gloss02_31" >local scope</a></b>. The name <tt>val</tt> is more interesting. It is defined in the scope of the <tt>for</tt> statement (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >Section 1.4.2</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >14</a>). It can be used in that statement but not elsewhere in <tt>main</tt>. It has <span class="docEmphStrong">statement scope</span>.</p><a name="ch02lev3sec12"></a>
	<p class="docText">这个程序定义了三个名字，使用了两个标准库的名字。程序定义了一个名为 <tt>main</tt> 的函数，以及两个名为 <tt>sum</tt> 和 <tt>val</tt> 的变量。名字 <tt>main</tt> 定义在所有花括号之外，在整个程序都可见。定义在所有函数外部的名字具有<b><a class="docLink" href="ch02lev1sec11.html#gloss02_21" >全局作用域</a></b>，可以在程序中的任何地方访问。名字 <tt>sum</tt> 定义在 <tt>main</tt> 函数的作用域中，在整个 <tt>main</tt> 函数中都可以访问，但在 <tt>main</tt> 函数外则不能。变量 <tt>sum</tt> 有<b><a class="docLink" href="ch02lev1sec11.html#gloss02_31" >局部作用域</a></b>。名字 <tt>val</tt> 更有意思，它定义在 <tt>for</tt> 语句的作用域中，只能在 <tt>for</tt> 语句中使用，而不能用在 <tt>main</tt> 函数的其他地方。它具有<span class="docEmphStrong">语句作用域</span>。</p>

        <h5 class="docSection3Title">Scopes in C++ Nest</h5>
        <h5 class="docSection3Title">C++ 中作用域可嵌套</h5>

        <p class="docText">Names defined in the global scope can be used in a local scope; global names and those defined local to a function can be used inside a statement scope, and so on. Names can also be redefined in an inner scope. Understanding what entity a name refers to requires unwinding the scopes in which the names are defined:</p>
        <p class="docText">定义在全局作用域中的名字可以在局部作用域中使用，定义在全局作用域中的名字和定义在函数的局部作用域中的名字可以在语句作用域中使用，等等。名字还可以在内部作用域中重新定义。理解和名字相关联的实体需要明白定义名字的作用域：</p>
        <pre>
      #include &lt;iostream&gt;
      #include &lt;string&gt;
      /*  <span class="docEmphItalicAlt">Program for illustration purposes only:</span>
       *  <span class="docEmphItalicAlt">It is bad style for a function to use a global variable and then</span>
       *  <span class="docEmphItalicAlt">define a local variable with the same name</span>
       */
      std::string s1 = "hello";  // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">has global scope</span>
      int main()
      {
          std::string s2 = "world"; // <span class="docEmphasis">s2</span> <span class="docEmphItalicAlt">has local scope</span>
          // <span class="docEmphItalicAlt">uses global</span> <span class="docEmphasis">s1;</span> <span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">"hello world"</span>
          std::cout &lt;&lt; s1 &lt;&lt; " " &lt;&lt; s2 &lt;&lt; std::endl;
          int s1 = 42; // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">is local and hides global</span> <span class="docEmphasis">s1</span>
          // <span class="docEmphItalicAlt">uses local</span> <span class="docEmphasis">s1</span>;<span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">"42 world"</span>
          std::cout &lt;&lt; s1 &lt;&lt; " " &lt;&lt; s2 &lt;&lt; std::endl;
          return 0;
      }
</pre>

<a name="idd1e11083"></a>
        <p class="docText">This program defines three variables: a global <tt>string</tt> named <tt>s1</tt>, a local <tt>string</tt> named <tt>s2</tt>, and a local <tt>int</tt> named <tt>s1</tt>. The definition of the local <tt>s1</tt> <span class="docEmphasis">hides</span> the global <tt>s1</tt>.</p>
	<p class="docText">这个程序中定义了三个变量：<tt>string</tt> 类型的全局变量 <tt>s1</tt>、<tt>string</tt> 类型的局部变量 <tt>s2</tt> 和 <tt>int</tt> 类型的局部变量 <tt>s1</tt>。局部变量 <tt>s1</tt> 的定义<span class="docEmphasis">屏蔽</span>了全局变量 <tt>s1</tt>。</p>

        <p class="docText">Variables are visible from their point of declaration. Thus, the local definition of <tt>s1</tt> is not visible when the first output is performed. The name <tt>s1</tt> in that output expression refers to the global <tt>s1</tt>. The output printed is <tt>hello world</tt>. The second statement that does output follows the local definition of <tt>s1</tt>. The local <tt>s1</tt> is now in scope. The second output uses the local rather than the global <tt>s1</tt>. It writes <tt>42 world</tt>.</p>
	<p class="docText">变量从声明开始才可见，因此执行第一次输出时局部变量 <tt>s1</tt> 不可见，输出表达式中的 <tt>s1</tt> 是全局变量 <tt>s1</tt>，输出“<tt>hello world</tt>”。第二条输出语句跟在 <tt>s1</tt> 的局部定义后，现在局部变量 <tt>s1</tt> 在作用域中。第二条输出语句使用的是局部变量 <tt>s1</tt> 而不是全局变量 <tt>s1</tt>，输出“<tt>42 world</tt>”。</p>

<a name="ch02note12"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Programs such as the preceeding are likely to be confusing. It is almost always a bad idea to define a local variable with the same name as a global variable that the function uses or might use. It is much better to use a distinct name for the local.</p>
                <p class="docText">像上面这样的程序很可能让人大惑不解。在函数内定义一个与函数可能会用到的全局变量同名的局部变量总是不好的。局部变量最好使用不同的名字。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">We'll have more to say about local and global scope in <a class="docLink" href="ch07.html#ch07" >Chapter 7</a> and about statement scope in <a class="docLink" href="ch06.html#ch06" >Chapter 6</a>. C++ has two other levels of scope: <span class="docEmphStrong">class scope</span>, which we'll cover in <a class="docLink" href="ch12.html#ch12" >Chapter 12</a> and <span class="docEmphStrong">namespace scope</span>, which we'll see in <a class="docLink" href="ch17lev1sec2.html#ch17lev1sec2" >Section 17.2</a>.</p>
        <p class="docText"><a class="docLink" href="ch07.html#ch07" >第七章</a>将详细讨论局部作用域和全局作用域，<a class="docLink" href="ch06.html#ch06" >第六章</a>将讨论语句作用域。C++ 还有另外两种不同级别的作用域：<span class="docEmphStrong">类作用域</span>（<a class="docLink" href="ch12.html#ch12" >第十二章</a>将介绍）和<span class="docEmphStrong">命名空间作用域</span>（<a class="docLink" href="ch17lev1sec2.html#ch17lev1sec2" >第 17.2 节</a>将介绍）。</p>

<a name="ch02lev2sec16"></a>
        <h4 class="docSection2Title">2.3.7. Define Variables Where They Are Used</h4>
        <h4 class="docSection2Title">2.3.7. 在变量使用处定义变量</h4>

        <p class="docText">In general, variable definitions or declarations can be placed anywhere within the program that a statement is allowed. A variable must be declared or defined before it is used.</p>
        <p class="docText">一般来说，变量的定义或声明可以放在程序中能摆放语句的任何位置。变量在使用前必须先声明或定义。</p>

<a name="ch02note13"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">It is usually a good idea to define an object near the point at which the object is first used.</p>
                <p class="docText">通常把一个对象定义在它首次使用的地方是一个很好的办法。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">Defining an object where the object is first used improves readability. The reader does not have to go back to the beginning of a section of code to find the definition of a particular variable. Moreover, it is often easier to give the variable a useful initial value when the variable is defined close to where it is first used.</p>
        <p class="docText">在对象第一次被使用的地方定义对象可以提高程序的可读性。读者不需要返回到代码段的开始位置去寻找某一特殊变量的定义，而且，在此处定义变量，更容易给它赋以有意义的初始值。</p>

        <p class="docText">One constraint on placing declarations is that variables are accessible from the point of their definition until the end of the enclosing block. A variable must be defined in or before the outermost scope in which the variable will be used.</p>
        <p class="docText">放置声明的一个约束是，变量只在从其定义处开始到该声明所在的作用域的结束处才可以访问。必须在使用该变量的最外层作用域里面或之前定义变量。</p>

<a name="ch02sb15"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 2.3.6</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa9q1"></a><b>Exercise 2.19:</b></td>

                    <td>
<a name="idd1e11218"></a><a name="idd1e11221"></a>
                      <p class="docText">What is the value of <tt>j</tt> in the following program?</p>
                      <p class="docText">下列程序中 <tt>j</tt> 的值是多少？</p>
                      <pre>
      int i = 42;
      int main()
      {
          int i = 100;
          int j = i;
          // ...
      }
</pre>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa9q2"></a><b>Exercise 2.20:</b></td>

                    <td>
                      <p class="docText">Given the following program fragment, what values are printed?</p>
                      <p class="docText">下列程序段将会输出什么？</p>
                      <pre>
      int i = 100, sum = 0;
      for (int i = 0; i != 10; ++i)
           sum += i;
      std::cout &lt;&lt; i &lt;&lt; " " &lt;&lt; sum &lt;&lt; std::endl;
</pre>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch02qa9q3"></a><b>Exercise 2.21:</b></td>

                    <td>
                      <p class="docText">Is the following program legal?</p>
                      <p class="docText">下列程序合法吗？</p>
                      <pre>
      int sum = 0;
      for (int i = 0; i != 10; ++i)
          sum += i;
      std::cout &lt;&lt; "Sum from 0 to " &lt;&lt; i
                &lt;&lt; " is " &lt;&lt; sum &lt;&lt; std::endl;
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch02lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch02lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
