<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 13.5.  Managing Pointer Members</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch13lev1sec4.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch13lev1sec6.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch13lev1sec5"></a>

        <h3 class="docSection1Title">13.5. Managing Pointer Members</h3>
        <h3 class="docSection1Title">13.5. 管理指针成员</h3>

        <p class="docText">This book generally advocates the use of the standard library. One reason we do so is that using the standard library greatly reduces the need for pointers in modern C++ programs. However, many applications still require the use of pointers, particularly in the implementation of classes. Classes that contain pointers require careful attention to copy control. The reason they must do so is that copying a pointer copies only the address in the pointer. Copying a pointer does not copy the object to which the pointer points.</p>
        <p class="docText">本书始终提倡使用标准库。这样做的一个原因是，使用标准库能够大大减少现代 C++ 程序中对指针的需要。然而，许多应用程序仍需要使用指针，特别是在类的实现中。包含指针的类需要特别注意复制控制，原因是复制指针时只复制指针中的地址，而不会复制指针指向的对象。</p>

        <p class="docText">When designing a class with a pointer member, the first decision a class author must make is what behavior that pointer should provide. When we copy one pointer to another, the two pointers point to the same object. When two pointers point to the same object, it is possible to use either pointer to change the underlying object. Similarly, it is possible for one pointer to <tt>delete</tt> the object even though the user of the other pointer still thinks the underlying object exists.</p>
        <p class="docText">设计具有指针成员的类时，类设计者必须首先需要决定的是该指针应提供什么行为。将一个指针复制到另一个指针时，两个指针指向同一对象。当两个指针指向同一对象时，可能使用任一指针改变基础对象。类似地，很可能一个指针删除了一对象时，另一指针的用户还认为基础对象仍然存在。</p>

        <p class="docText">By default, a pointer member has the same behavior as a pointer object. However, through different copy-control strategies we can implement different behavior for pointer members. Most C++ classes take one of three approaches to managing pointer members:</p>
        <p class="docText">指针成员默认具有与指针对象同样的行为。然而，通过不同的复制控制策略，可以为指针成员实现不同的行为。大多数 C++ 类采用以下三种方法之一管理指针成员：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">The pointer member can be given normal pointerlike behavior. Such classes will have all the pitfalls of pointers but will require no special copy control.</p>
                <p class="docList">指针成员采取常规指针型行为。这样的类具有指针的所有缺陷但无需特殊的复制控制。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">The class can implement so-called "smart pointer" behavior. The object to which the pointer points is shared, but the class prevents dangling pointers.</p>
                <p class="docList">类可以实现所谓的“智能指针”行为。指针所指向的对象是共享的，但类能够防止悬垂指针。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">The class can be given valuelike behavior. The object to which the pointer points will be unique to and managed separately by each class object.</p>
                <p class="docList">类采取值型行为。指针所指向的对象是唯一的，由每个类对象独立管理。</p>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">In this section we look at three classes that implement each of these different approaches to managing their pointer members.</p>
        <p class="docText">本节中介绍三个类，分别实现管理指针成员的三种不同方法。</p>

	<a name="ch13lev2sec21"></a>
        <h4 class="docSection2Title">A Simple Class with a Pointer Member</h4>
        <h4 class="docSection2Title">一个带指针成员的简单类</h4>

	<a name="idd1e101863"></a><a name="idd1e101870"></a><a name="idd1e101876"></a><a name="idd1e101884"></a><a name="idd1e101889"></a>
        <p class="docText">To illustrate the issues involved, we'll implement a simple class that contains an <tt>int</tt> and a pointer:</p>
        <p class="docText">为了阐明所涉及的问题，我们将实现一个简单类，该类包含一个 <tt>int</tt> 值和一个指针：</p>
        <pre>
     // <span class="docEmphItalicAlt">class that has a pointer member that behaves like a plain pointer</span>
     class HasPtr {
     public:
         // <span class="docEmphItalicAlt">copy of the values we're given</span>
         HasPtr(int *p, int i): ptr(p), val(i) { }

         // <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">members to return the value of the indicated data member</span>
         int *get_ptr() const { return ptr; }
         int get_int() const { return val; }

         // <span class="docEmphItalicAlt">non</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">members to change the indicated data member</span>
         void set_ptr(int *p) { ptr = p; }
         void set_int(int i) { val = i; }

         // <span class="docEmphItalicAlt">return or change the value pointed to, so ok for</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">objects</span>
         int get_ptr_val() const { return *ptr; }
         void set_ptr_val(int val) const { *ptr = val; }

     private:
         int *ptr;
         int val;
     };
</pre><br>

        <p class="docText">The <tt>HasPtr</tt> constructor takes two parameters, which it copies into <tt>HasPtr</tt>'s data members. The class provides simple accessor functions: The <tt>const</tt> functions <tt>get_int</tt> and <tt>get_ptr</tt> return the value of the <tt>int</tt> and pointer members, respectively; the <tt>set_int</tt> and <tt>set_ptr</tt> members let us change these members, giving a new value to the <tt>int</tt> or making the pointer point to a different object. We also define the <tt>get_ptr_val</tt> and <tt>set_ptr_val</tt> members. These members get and set the underlying value to which the pointer points.</p>
        <p class="docText"><tt>HasPtr</tt> 构造函数接受两个形参，将它们复制到 <tt>HasPtr</tt> 的数据成员。<tt>HasPtr</tt> 类提供简单的访问函数：函数 <tt>get_int</tt> 和 <tt>get_ptr</tt> 分别返回 <tt>int</tt> 成员和指针成员的值：<tt>set_int</tt> 和 <tt>set_ptr</tt> 成员则使我们能够改变这些成员，给 <tt>int</tt> 成员一个新值或使指针成员指向不同的对象。还定义了 <tt>get_ptr_val</tt> 和 <tt>set_ptr_val</tt> 成员，它们能够获取和设置指针所指向的基础值。</p>

	<a name="ch13lev2sec22"></a>
        <h4 class="docSection2Title">Default Copy/Assignment and Pointer Members</h4>
        <h4 class="docSection2Title">默认复制／赋值与指针成员</h4>

        <p class="docText">Because the class does not define a copy constructor, copying one <tt>HasPtr</tt> object to another copies both members:</p>
	<p class="docText">因为 <tt>HasPtr</tt> 类没有定义复制构造函数，所以复制一个 <tt>HasPtr</tt> 对象将复制两个成员：</p>
        <pre>
     int obj = 0;
     HasPtr ptr1(&amp;obj, 42); // <span class="docEmphasis">int*</span> <span class="docEmphItalicAlt">member points to</span> <span class="docEmphasis">obj, val</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">42</span>
     HasPtr ptr2(ptr1);     // <span class="docEmphasis">int*</span> <span class="docEmphItalicAlt">member points to</span> <span class="docEmphasis">obj, val</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">42</span>
</pre><br>

        <p class="docText">After the copy, the pointers in <tt>ptr1</tt> and <tt>ptr1</tt> both address the same object and the <tt>int</tt> values in each object are the same. However, the behavior of these two members appears quite different, because the value of a pointer is distinct from the value of the object to which it points. After the copy, the <tt>int</tt> values are distinct and independent, whereas the pointers are intertwined.</p>
        <p class="docText">复制之后，<tt>ptr1</tt> 和 <tt>ptr2</tt> 中的指针指向同一对象且两个对象中的 <tt>int</tt> 值相同。但是，因为指针的值不同于它所指对象的值，这两个成员的行为看来非常不同。复制之后，<tt>int</tt> 值是清楚和独立的，而指针则纠缠在一起。</p>

	<a name="ch13note12"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Classes that have pointer members and use default synthesized copy control have all the pitfalls of ordinary pointers. In particular, the class itself has no way to avoid dangling pointers.</p>
                <p class="docText">具有指针成员且使用默认合成复制构造函数的类具有普通指针的所有缺陷。尤其是，类本身无法避免悬垂指针。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch13lev2sec23"></a>
        <h4 class="docSection2Title">Pointers Share the Same Object</h4>
        <h4 class="docSection2Title">指针共享同一对象</h4>

	<a name="idd1e102050"></a><a name="idd1e102055"></a><a name="idd1e102062"></a>
        <p class="docText">When we copy an arithmetic value, the copy is independent from the original. We can change one copy without changing the other:</p>
        <p class="docText">复制一个算术值时，副本独立于原版，可以改变一个副本而不改变另一个：</p>
        <pre>
     ptr1.set_int(0); // <span class="docEmphItalicAlt">changes</span> <span class="docEmphasis">val</span> <span class="docEmphItalicAlt">member only in</span> <span class="docEmphasis">ptr1</span>
     ptr2.get_int();  // <span class="docEmphasis">returns 42</span>
     ptr1.get_int();  // <span class="docEmphasis">returns 0</span>
</pre><br>

        <p class="docText">When we copy a pointer, the address values are distinct, but the pointers point to the same underlying object. If we call <tt>set_ptr_val</tt> on either object, the underlying object is changed for both:</p>
        <p class="docText">复制指针时，地址值是可区分的，但指针指向同一基础对象。如果在任一对象上调用 <tt>set_ptr_val</tt>，则二者的基础对象都会改变：</p>
        <pre>
     ptr1.set_ptr_val(42); // <span class="docEmphItalicAlt">sets object to which both</span> <span class="docEmphasis">ptr1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ptr2</span> <span class="docEmphItalicAlt">point</span>
     ptr2.get_ptr_val();   // <span class="docEmphasis">returns 42</span>
</pre><br>

        <p class="docText">When two pointers point to the same object, either one can change the value of the shared object.</p>
        <p class="docText">两个指针指向同一对象时，其中任意一个都可以改变共享对象的值。</p>

	<a name="ch13lev2sec24"></a>
        <h4 class="docSection2Title">Dangling Pointers Are Possible</h4>
        <h4 class="docSection2Title">可能出现悬垂指针</h4>

        <p class="docText">Because our class copies the pointers directly, it presents our users with a potential problem: <tt>HasPtr</tt> stores the pointer it was given. It is up to the user to guarantee that the object to which that pointer points stays around as long as the <tt>HasPtr</tt> object does:</p>
        <p class="docText">因为类直接复制指针，会使用户面临潜在的问题：<tt>HasPtr</tt> 保存着给定指针。用户必须保证只要 <tt>HasPtr</tt> 对象存在，该指针指向的对象就存在：</p>
        <pre>
     int *ip = new int(42); // <span class="docEmphItalicAlt">dynamically allocated</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">initialized to</span> <span class="docEmphasis">42</span>
     HasPtr ptr(ip, 10);    // <span class="docEmphasis">Has Ptr</span> <span class="docEmphItalicAlt">points to same object as</span> <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">does</span>
     delete ip;             // <span class="docEmphItalicAlt">object pointed to by</span> <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">is freed</span>
     ptr.set_ptr_val(0); // <span class="docEmphItalicAlt">disaster: The object to which</span> <span class="docEmphasis">Has Ptr</span> <span class="docEmphItalicAlt">points was freed!</span>
</pre><br>

        <p class="docText">The problem here is that <tt>ip</tt> and the pointer inside <tt>ptr</tt> both point to the same object. When that object is deleted, the pointer inside <tt>HasPtr</tt> no longer points to a valid object. However, there is no way to know that the object is gone.</p>
	<p class="docText">这里的问题是 <tt>ip</tt> 和 <tt>ptr</tt> 中的指针指向同一对象。删除了该对象时，<tt>ptr</tt> 中的指针不再指向有效对象。然而，没有办法得知对象已经不存在了。</p>

	<a name="ch13sb06"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 13.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa6q1"></a><b>Exercise 13.20:</b></td>

                    <td>
                      <p class="docText">Given the original version of the <tt>HasPtr</tt> class that relies on the default definitions for copy-control, describe what happens in the following code:</p>
                      <p class="docText">对于 <tt>HasPtr</tt> 类的原始版本（依赖于复制控制的默认定义），描述下面代码中会发生什么：</p>
                      <pre>
     int i = 42;
     HasPtr p1(&amp;i, 42);
     HasPtr p2 = p1;
     cout &lt;&lt; p2.get_ptr_val() &lt;&lt; endl;
     p1.set_ptr_val(0);
     cout &lt;&lt; p2.get_ptr_val() &lt;&lt; endl;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa6q2"></a><b>Exercise 13.21:</b></td>

                    <td>
                      <p class="docText">What would happen if we gave our <tt>HasPtr</tt> class a destructor that <tt>delete</tt>d its pointer member?</p>
                      <p class="docText">如果给 <tt>HasPtr</tt> 类添加一个析构函数，用来删除指针成员，会发生什么？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch13lev2sec25"></a>
        <h4 class="docSection2Title">13.5.1. Defining Smart Pointer Classes</h4>
        <h4 class="docSection2Title">13.5.1. 定义智能指针类</h4>

	<a name="idd1e102257"></a><a name="idd1e102266"></a><a name="idd1e102274"></a><a name="idd1e102279"></a><a name="idd1e102282"></a><a name="idd1e102287"></a><a name="idd1e102292"></a><a name="idd1e102298"></a><a name="idd1e102307"></a><a name="idd1e102312"></a><a name="idd1e102317"></a><a name="idd1e102320"></a><a name="idd1e102323"></a>
        <p class="docText">In the previous section we defined a simple class that held a pointer and an <tt>int</tt>. The pointer member behaved in all ways like any other pointer. Any changes made to the object to which the pointer pointed were made to a single, shared object. If the user deleted that object, then our class had a dangling pointer. Its pointer member pointed at an object that no longer existed.</p>
        <p class="docText">上节中我们定义了一个简单类，保存一个指针和一个 <tt>int</tt> 值。其中指针成员的行为与其他任意指针完全相同。对该指针指向的对象所做的任意改变都将作用于共享对象。如果用户删除该对象，则类就有一个悬垂指针，指向一个不复存在的对象。</p>

	<a name="ch13term10"></a>
        <p class="docText">An alternative to having a pointer member behave exactly like a pointer is to define what is sometimes referred to as a <b><a class="docLink" href="ch13lev1sec7.html#gloss13_10" >smart pointer</a></b> class. A smart pointer behaves like an ordinary pointer except that it adds functionality. In this case, we'll give our smart pointer the responsibility for deleting the shared object. Users will dynamically allocate an object and pass the address of that object to our new <tt>HasPtr</tt> class. The user may still access the object through a plain pointer but must not <tt>delete</tt> the pointer. The <tt>HasPtr</tt> class will ensure that the object is deleted when the last <tt>HasPtr</tt> that points to it is destroyed.</p>
        <p class="docText">除了使指针成员与指针完全相同之外，另一种方法是定义所谓的<b><a class="docLink" href="ch13lev1sec7.html#gloss13_10" >智能指针</a></b>类。智能指针除了增加功能外，其行为像普通指针一样。本例中让智能指针负责删除共享对象。用户将动态分配一个对象并将该对象的地址传给新的 <tt>HasPtr</tt> 类。用户仍然可以通过普通指针访问对象，但绝不能删除指针。<tt>HasPtr</tt> 类将保证在撤销指向对象的最后一个 <tt>HasPtr</tt> 对象时删除对象。</p>

        <p class="docText">In other ways, our <tt>HasPtr</tt> will behave like a plain pointer. In particular, when we copy a <tt>HasPtr</tt> object, the copy and the original will point to the same underlying object. If we change that object through one copy, the value will be changed when accessed through the other.</p>
        <p class="docText"><tt>HasPtr</tt> 在其他方面的行为与普通指针一样。具体而言，复制对象时，副本和原对象将指向同一基础对象，如果通过一个副本改变基础对象，则通过另一对象访问的值也会改变。</p>

        <p class="docText">Our new <tt>HasPtr</tt> class will need a destructor to delete the pointer. However, the destructor cannot delete the pointer unconditionally. If two <tt>HasPtr</tt> objects point to the same underlying object, we don't want to delete the object until both objects are destroyed. To write the destructor, we need to know whether this <tt>HasPtr</tt> is the last one pointing to a given object.</p>
        <p class="docText">新的 <tt>HasPtr</tt> 类需要一个析构函数来删除指针，但是，析构函数不能无条件地删除指针。如果两个 <tt>HasPtr</tt> 对象指向同一基础对象，那么，在两个对象都撤销之前，我们并不希望删除基础对象。为了编写析构函数，需要知道这个 <tt>HasPtr</tt> 对象是否为指向给定对象的最后一个。</p>

	<a name="ch13lev3sec2"></a>
        <h5 class="docSection3Title">Introducing Use Counts</h5>
        <h5 class="docSection3Title">引入使用计数</h5>

	<a name="ch13term13"></a><a name="ch13term8"></a>
        <p class="docText">A common technique used in defining smart pointers is to use a <b><a class="docLink" href="ch13lev1sec7.html#gloss13_13" >use count</a></b>. The pointerlike class associates a counter with the object to which the class points. The use count keeps track of how many objects of the class share the same pointer. When the use count goes to zero, then the object is deleted. A use count is sometimes also referred to as a <b><a class="docLink" href="ch13lev1sec7.html#gloss13_08" >reference count</a></b>.</p>
        <p class="docText">定义智能指针的通用技术是采用一个<b><a class="docLink" href="ch13lev1sec7.html#gloss13_13" >使用计数</a></b>。智能指针类将一个计数器与类指向的对象相关联。使用计数跟踪该类有多少个对象共享同一指针。使用计数为 0 时，删除对象。使用计数有时也称为<b><a class="docLink" href="ch13lev1sec7.html#gloss13_08" >引用计数</a></b>。</p>

        <p class="docText">Each time a new object of the class is created, the pointer is initialized and the use count is set to 1. When an object is created as a copy of another, the copy constructor copies the pointer and increments the associated use count. When an object is assigned to, the assignment operator decrements the use count of the object to which the left-hand operand points (and deletes that object if the use count goes to zero) and increments the use count of the object pointed to by the right-hand operand. Finally, when the destructor is called, it decrements the use count and deletes the underlying object if the count goes to zero.</p>
        <p class="docText">每次创建类的新对象时，初始化指针并将使用计数置为 1。当对象作为另一对象的副本而创建时，复制构造函数复制指针并增加与之相应的使用计数的值。对一个对象进行赋值时，赋值操作符减少左操作数所指对象的使用计数的值（如果使用计数减至 0，则删除对象），并增加右操作数所指对象的使用计数的值。最后，调用析构函数时，析构函数减少使用计数的值，如果计数减至 0，则删除基础对象。</p>

        <p class="docText">The only wrinkle is deciding where to put the use count. The counter cannot go directly into our <tt>HasPtr</tt> object. To see why, consider what happens in the following case:</p>
        <p class="docText">唯一的创新在于决定将使用计数放在哪里。计数器不能直接放在 <tt>HasPtr</tt> 对象中，为什么呢？考虑下面的情况：</p>
        <pre>
     int obj;
     HasPtr p1(&amp;obj, 42);
     HasPtr p2(p1);  // <span class="docEmphasis">p1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">p2</span> <span class="docEmphItalicAlt">both point to same</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">object</span>
     HasPtr p3(p1);  // <span class="docEmphasis">p1, p2,</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">p3</span> <span class="docEmphItalicAlt">all point to same</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">object</span>
</pre><br>

	<a name="idd1e102438"></a><a name="idd1e102443"></a><a name="idd1e102447"></a>
        <p class="docText">If the use count is stored in a <tt>HasPtr</tt> object, how can we update it correctly when <tt>p3</tt> is created? We could increment the count in <tt>p1</tt> and copy that count into <tt>p3</tt>, but how would we update the counter in <tt>p2?</tt></p>
        <p class="docText">如果使用计数保存在 <tt>HasPtr</tt> 对象中，创建 <tt>p3</tt> 时怎样更新它？可以在 <tt>p1</tt> 中将计数增量并复制到 <tt>p3</tt>，但怎样更新 <tt>p2</tt> 中的计数？</p>

	<a name="ch13lev3sec3"></a>
        <h5 class="docSection3Title">The Use-Count Class</h5>
        <h5 class="docSection3Title">使用计数类</h5>

        <p class="docText">There are two classic strategies for implementing a use count, one of which we will use here; the other approach is described in <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec21" >Section 15.8.1</a> (p. <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec21" >599</a>). In the approach we use here, we'll define a separate concrete class to encapsulate the use count and the associated pointer:</p>
        <p class="docText">实现使用计数有两种经典策略，在这里将使用其中一种，另一种方法在<a class="docLink" href="ch15lev1sec8.html#ch15lev2sec21" >第 15.8.1 节</a>中讲述。这里所用的方法中，需要定义一个单独的具体类用以封闭使用计数和相关指针：</p>
        <pre>
     // <span class="docEmphItalicAlt">private class for use by HasPtr only</span>
     class U_Ptr {
         friend class HasPtr;
         int *ip;
         size_t use;
         U_Ptr(int *p): ip(p), use(1) { }
         ~U_Ptr() { delete ip; }
     };
</pre><br>

        <p class="docText">All the members of this class are <tt>private</tt>. We don't intend ordinary users to use the <tt>U_Ptr</tt> class, so we do not give it any <tt>public</tt> members. The <tt>HasPtr</tt> class is made a friend so that its members will have access to the members of <tt>U_Ptr</tt>.</p>
        <p class="docText">这个类的所有成员均为 <tt>private</tt>。我们不希望用户使用 <tt>U_Ptr</tt> 类，所以它没有任何 <tt>public</tt> 成员。将 <tt>HasPtr</tt> 类设置为友元，使其成员可以访问 <tt>U_Ptr</tt> 的成员。</p>

        <p class="docText">The class is pretty simple, although the concept of how it works can be slippery. The <tt>U_Ptr</tt> class holds the pointer and the use count. Each <tt>HasPtr</tt> will point to a <tt>U_Ptr</tt>. The use count will keep track of how many <tt>HasPtr</tt> objects point to each <tt>U_Ptr</tt> object. The only functions <tt>U_Ptr</tt> defines are its constructor and destructor. The constructor copies the pointer, which the destructor deletes. The constructor also sets the use count to 1, indicating that a <tt>HasPtr</tt> object points to this <tt>U_Ptr</tt>.</p>
	<p class="docText">尽管该类的工作原理比较难，但这个类相当简单。<tt>U_Ptr</tt> 类保存指针和使用计数，每个 <tt>HasPtr</tt> 对象将指向一个 <tt>U_Ptr</tt> 对象，使用计数将跟踪指向每个 <tt>U_Ptr</tt> 对象的 <tt>HasPtr</tt> 对象的数目。<tt>U_Ptr</tt> 定义的仅有函数是构造函数和析构函数，构造函数复制指针，而析构函数删除它。构造函数还将使用计数置为 1，表示一个 <tt>HasPtr</tt> 对象指向这个 <tt>U_Ptr</tt> 对象。</p>

        <p class="docText">Assuming we just created a <tt>HasPtr</tt> object from a pointer that pointed to an <tt>int</tt> value of 42, we might picture the objects as follows:</p>
        <p class="docText">假定刚从指向 <tt>int</tt> 值 42 的指针创建一个 <tt>HasPtr</tt> 对象，可以画出这些对象，如下图：</p>

        <p class="docText"><img border="0" alt="" width="385" height="146" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/496fig01.gif;400478" ></p>

        <p class="docText">If we copy this object, then the objects will be as shown on the next page.</p>
        <p class="docText">如果复制这个对象，则对象如下图所示。</p>

	<a name="ch13lev3sec4"></a>
        <h5 class="docSection3Title">Using the Use-Counted Class</h5>
        <h5 class="docSection3Title">使用计数类的使用</h5>

        <p class="docText">Our new <tt>HasPtr</tt> class holds a pointer to a <tt>U_Ptr</tt>, which in turn points to the actual underlying <tt>int</tt> object. Each member must be changed to reflect the fact that the class points to a <tt>U_Ptr</tt> rather than an <tt>int*</tt>.</p>
	<p class="docText">新的 <tt>HasPtr</tt> 类保存一个指向 <tt>U_Ptr</tt> 对象的指针，<tt>U_Ptr</tt> 对象指向实际的 <tt>int</tt> 基础对象。必须改变每个成员以说明的 <tt>HasPtr</tt> 类指向一个 <tt>U_Ptr</tt> 对象而不是一个 <tt>int</tt></p>

        <p class="docText"><img border="0" alt="" width="425" height="180" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/497fig01.gif;400478" ></p>

	<a name="idd1e102589"></a><a name="idd1e102594"></a>
        <p class="docText">We'll look first at the constructors and copy-control members:</p>
        <p class="docText">先看看构造函数和复制控制成员：</p>
        <pre>
     /* <span class="docEmphItalicAlt">smart pointer class: takes ownership of the dynamically allocated</span>
      *          <span class="docEmphItalicAlt">object to which it is bound</span>
      * <span class="docEmphItalicAlt">User code must dynamically allocate an object to initialize a</span> <span class="docEmphasis">HasPtr</span>
      * <span class="docEmphItalicAlt">and must not delete that object; the</span> <span class="docEmphasis">HasPtr</span> <span class="docEmphItalicAlt">class will delete it</span>
      */
     class HasPtr {
     public:
         // <span class="docEmphasis">HasPtr</span> <span class="docEmphItalicAlt">owns the pointer; pmust have been dynamically allocated</span>
         HasPtr(int *p, int i): ptr(new U_Ptr(p)), val(i) { }

         // <span class="docEmphItalicAlt">copy members and increment the use count</span>
         HasPtr(const HasPtr &amp;orig):
            ptr(orig.ptr), val(orig.val) { ++ptr-&gt;use; }
         HasPtr&amp; operator=(const HasPtr&amp;);

         // <span class="docEmphItalicAlt">if use count goes to zero, delete the</span> <span class="docEmphasis">U_Ptr</span> <span class="docEmphItalicAlt">object</span>
         ~HasPtr() { if (--ptr-&gt;use == 0) delete ptr; }
     private:
         U_Ptr *ptr;        // <span class="docEmphItalicAlt">points to use-counted</span> <span class="docEmphasis">U_Ptr</span> <span class="docEmphItalicAlt">class</span>
         int val;
     };
</pre><br>

        <p class="docText">The <tt>HasPtr</tt> constructor that takes a pointer and an <tt>int</tt> uses its pointer parameter to create a new <tt>U_Ptr</tt> object. After the <tt>HasPtr</tt> constructor completes, the <tt>HasPtr</tt> object points to a newly allocated <tt>U_Ptr</tt> object. That <tt>U_Ptr</tt> object stores the pointer we were given. The use count in that new <tt>U_Ptr</tt> is 1, indicating that only one <tt>HasPtr</tt> object points to it.</p>
        <p class="docText">接受一个指针和一个 <tt>int</tt> 值的 <tt>HasPtr</tt> 构造函数使用其指针形参创建一个新的 <tt>U_Ptr</tt> 对象。<tt>HasPtr</tt> 构造函数执行完毕后，<tt>HasPtr</tt> 对象指向一个新分配的 <tt>U_Ptr</tt> 对象，该 <tt>U_Ptr</tt> 对象存储给定指针。新 <tt>U_Ptr</tt> 中的使用计数为 1，表示只有一个 <tt>HasPtr</tt> 对象指向它。</p>

        <p class="docText">The copy constructor copies the members from its parameter and increments the use count. After the constructor completes, the newly created object points to the same <tt>U_Ptr</tt> object as the original and the use count of that <tt>U_Ptr</tt> object is incremented by one.</p>
        <p class="docText">复制构造函数从形参复制成员并增加使用计数的值。复制构造函数执行完毕后，新创建对象与原有对象指向同一 <tt>U_Ptr</tt> 对象，该 <tt>U_Ptr</tt> 对象的使用计数加 1。</p>

        <p class="docText">The destructor checks the use count in the underlying <tt>U_Ptr</tt> object. If the use count goes to 0, then this is the last <tt>HasPtr</tt> object that points to this <tt>U_Ptr</tt>. In this case, the <tt>HasPtr</tt> destructor deletes its <tt>U_Ptr</tt> pointer. Deleting that pointer has the effect of calling the <tt>U_Ptr</tt> destructor, which in turn deletes the underlying <tt>int</tt> object.</p>
        <p class="docText">析构函数将检查 <tt>U_Ptr</tt> 基础对象的使用计数。如果使用计数为 0，则这是最后一个指向该 <tt>U_Ptr</tt> 对象的 <tt>HasPtr</tt> 对象，在这种情况下，<tt>HasPtr</tt> 析构函数删除其 <tt>U_Ptr</tt> 指针。删除该指针将引起对 <tt>U_Ptr</tt> 析构函数的调用，<tt>U_Ptr</tt> 析构函数删除 <tt>int</tt> 基础对象。</p>

	<a name="ch13lev3sec5"></a>
        <h5 class="docSection3Title">Assignment and Use Counts</h5>
        <h5 class="docSection3Title">赋值与使用计数</h5>

	<a name="idd1e102725"></a><a name="idd1e102734"></a><a name="idd1e102742"></a><a name="idd1e102751"></a><a name="idd1e102756"></a>
        <p class="docText">The assignment operator is a bit more complicated than the copy constructor:</p>
        <p class="docText">赋值操作符比复制构造函数复杂一点：</p>
        <pre>
     HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)
     {
         ++rhs.ptr-&gt;use;     // <span class="docEmphItalicAlt">increment use count on rhs first</span>
         if (--ptr-&gt;use == 0)
              delete ptr;    // <span class="docEmphItalicAlt">if use count goes to 0 on this object, delete it</span>
         ptr = rhs.ptr;      // <span class="docEmphItalicAlt">copy the</span> <span class="docEmphasis">U_Ptr</span> <span class="docEmphItalicAlt">object</span>
         val = rhs.val;      // <span class="docEmphItalicAlt">copy the</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">member</span>
         return *this;
     }
</pre><br>

        <p class="docText">Here we start by incrementing the use count in the right-hand operand. Then we decrement and check the use count on this object. As with the destructor, if this is the last object pointing to the <tt>U_Ptr</tt>, we delete the object, which in turn destroys the underlying <tt>int</tt>. Having decremented (and possibly destroyed) the existing value in the left-hand operand, we then copy the pointer from <tt>rhs</tt> into this object. As usual, assignment returns a reference to this object.</p>
        <p class="docText">在这里，首先将右操作数中的使用计数加 1，然后将左操作数对象的使用计数减 1 并检查这个使用计数。像析构函数中那样，如果这是指向 <tt>U_Ptr</tt> 对象的最后一个对象，就删除该对象，这会依次撤销 <tt>int</tt> 基础对象。将左操作数中的当前值减 1（可能撤销该对象）之后，再将指针从 <tt>rhs</tt> 复制到这个对象。赋值照常返回对这个对象的引用。</p>

	<a name="ch13note13"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">This assignment operator guards against self-assignment by incrementing the use count of <tt>rhs</tt> before decrementing the use count of the left-hand operand.</p>
                <p class="docText">这个赋值操作符在减少左操作数的使用计数之前使 <tt>rhs</tt> 的使用计数加 1，从而防止自身赋值。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">If the left and right operands are the same, the effect of this assignment operator will be to increment and then immediately decrement the use count in the underlying <tt>U_Ptr</tt> object.</p>
        <p class="docText">如果左右操作数相同，赋值操作符的效果将是 <tt>U_Ptr</tt> 基础对象的使用计数加 1 之后立即减 1。</p>

	<a name="ch13lev3sec6"></a>
        <h5 class="docSection3Title">Changing Other Members</h5>
        <h5 class="docSection3Title">改变其他成员</h5>

        <p class="docText">The other members that access the <tt>int*</tt> now need to change to get to the <tt>int</tt> indirectly through the <tt>U_Ptr</tt> pointer:</p>
        <p class="docText">现在需要改变访问 <tt>int*</tt> 的其他成员，以便通过 <tt>U_Ptr</tt> 指针间接获取 <tt>int</tt>：</p>
        <pre>
     class HasPtr {
     public:
         // <span class="docEmphItalicAlt">copy control and constructors as before</span>
         // <span class="docEmphItalicAlt">accessors must change to fetch value from</span> <span class="docEmphasis">U_Ptr</span> <span class="docEmphItalicAlt">object</span>
         int *get_ptr() const { return ptr-&gt;ip; }
         int get_int() const { return val; }

         // <span class="docEmphItalicAlt">change the appropriate data member</span>
         void set_ptr(int *p) { ptr-&gt;ip = p; }
         void set_int(int i) { val = i; }

         // <span class="docEmphItalicAlt">return or change the value pointed to, so ok for</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">objects</span>
         // <span class="docEmphItalicAlt">Note:</span> <span class="docEmphasis">*ptr-&gt;ip</span> <span class="docEmphItalicAlt">is equivalent to</span> <span class="docEmphasis">*(ptr-&gt;ip)</span>
         int get_ptr_val() const { return *ptr-&gt;ip; }
         void set_ptr_val(int i) { *ptr-&gt;ip = i; }
     private:
         U_Ptr *ptr;        // <span class="docEmphItalicAlt">points to use-counted</span> <span class="docEmphasis">U_Ptr</span> <span class="docEmphItalicAlt">class</span>
         int val;
     };
</pre><br>

	<a name="idd1e102893"></a><a name="idd1e102900"></a><a name="idd1e102905"></a><a name="idd1e102911"></a><a name="idd1e102918"></a><a name="idd1e102921"></a>
        <p class="docText">The functions that get and set the <tt>int</tt> member are unchanged. Those that operate on the pointer have to dereference the <tt>U_Ptr</tt> to get to the underlying <tt>int*</tt>.</p>
        <p class="docText">获取和设置 <tt>int</tt> 成员的函数不变。那些使用指针操作的函数必须对 <tt>U_Ptr</tt> 解引用，以便获取 <tt>int*</tt> 基础对象。</p>

        <p class="docText">When we copy <tt>HasPtr</tt> objects, the <tt>int</tt> member behaves the same as in our first class. Its value is copied; the members are independent. The pointer members in the copy and the original still point to the same underlying object. A change made to that object will affect the value as seen by either <tt>HasPtr</tt> object. However, users of <tt>HasPtr</tt> do not need to worry about dangling pointers. As long as they let the <tt>HasPtr</tt> class take care of freeing the object, the class will ensure that the object stays around as long as there are <tt>HasPtr</tt> objects that point to it.</p>
	<p class="docText">复制 <tt>HasPtr</tt> 对象时，<tt>int</tt> 成员的行为与第一个类中一样。所复制的是 <tt>int</tt> 成员的值，各成员是独立的，副本和原对象中的指针仍指向同一基础对象，对基础对象的改变将影响通过任一 <tt>HasPtr</tt> 对象所看到的值。然而，<tt>HasPtr</tt> 的用户无须担心悬垂指针。只要他们让 <tt>HasPtr</tt> 类负责释放对象，<tt>HasPtr</tt> 类将保证只要有指向基础对象的 <tt>HasPtr</tt> 对象存在，基础对象就存在。</p>

	<a name="ch13sb07"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Advice: Managing Pointer Members</h2>
              <h2 class="docSidebarTitle">建议：管理指针成员</h2>

              <p class="docText"><span class="docEmphStrong">Objects with pointer members often need to define the copy-control members. If we rely on the synthesized versions, then the class puts a burden on its users. Users must ensure that the object to which the member points stays around for at least as long as the object that points to it does.</span></p>
              <p class="docText"><span class="docEmphStrong">具有指针成员的对象一般需要定义复制控制成员。如果依赖合成版本，会给类的用户增加负担。用户必须保证成员所指向的对象存在，只要还有对象指向该对象。</span></p>

              <p class="docText"><span class="docEmphStrong">To manage a class with pointer members, we must define all three copy-control members: the copy constructor, assignment operator, and the destructor. These members can define either pointerlike or valuelike behavior for the pointer member.</span></p>
              <p class="docText"><span class="docEmphStrong">为了管理具有指针成员的类，必须定义三个复制控制成员：复制构造函数、赋值操作符和析构函数。这些成员可以定义指针成员的指针型行为或值型行为。</span></p>

              <p class="docText"><span class="docEmphStrong">Valuelike classes give each object its own copy of the underlying values pointed to by pointer members. The copy constructor allocates a new element and copies the value from the object it is copying. The assignment operator destroys the existing object it holds and copies the value from its right-hand operand into its left-hand operand. The destructor destroys the object.</span></p>
              <p class="docText"><span class="docEmphStrong">值型类将指针成员所指基础值的副本给每个对象。复制构造函数分配新元素并从被复制对象处复制值，赋值操作符撤销所保存的原对象并从右操作数向左操作数复制值，析构函数撤销对象。</span></p>

              <p class="docText"><span class="docEmphStrong">As an alternative to defining either valuelike behavior or pointerlike behavior some classes are so-called "smart pointers." These classes share the same underlying value between objects, thus providing pointerlike behavior. But they use copy-control techniques to avoid some of the pitfalls of regular pointers. To implement smart pointer behavior, a class needs to ensure that the underlying object stays around until the last copy goes away. Use counting (<a class="docLink" href="ch13lev1sec5.html#ch13lev2sec25">Section 13.5.1</a>, p. <a class="docLink" href="ch13lev1sec5.html#ch13lev2sec25">495</a>), is a common technique for managing smart pointer classes. Each copy of the same underlying value is given a use count. The copy constructor copies the pointer from the old object into the new one and increments the use count. The assignment operator decrements the use count of the left-hand operand and increments the count of the right-hand operand. If the use count of the left-hand operand goes to zero, the assignment operator must delete the object to which it points. Finally, the assignment operator copies the pointer from the right-hand operand into its left-hand operand. The destructor decrements the use count and deletes the underlying object if the count goes to zero.</span></p>
              <p class="docText"><span class="docEmphStrong">作为定义值型行为或指针型行为的另一选择，是使用称为“智能指针”的一些类。这些类在对象间共享同一基础值，从而提供了指针型行为。但它们使用复制控制技术以避免常规指针的一些缺陷。为了实现智能指针行为，类需要保证基础对象一直存在，直到最后一个副本消失。使用计数（<a class="docLink" href="ch13lev1sec5.html#ch13lev2sec25">第 13.5.1 节</a>）是管理智能指针类的通用技术。同一基础值的每个副本都有一个使用计数。复制构造函数将指针从旧对象复制到新对象时，会将使用计数加 1。赋值操作符将左操作数的使用计数减 1 并将右操作数的使用计数加 1，如果左操作数的使用计数减至 0，赋值操作符必须删除它所指向的对象，最后，赋值操作符将指针从右操作数复制到左操作数。析构函数将使用计数减 1，并且，如果使用计数减至 0，就删除基础对象。</span></p>

<a name="ch13note14"></a>
              <div class="docNote">
                <table width="90%" border="0" cellspacing="0" cellpadding="1">
                  <tr>
                    <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

                    <td valign="top">
                      <p class="docText"><span class="docEmphStrong">These approaches to managing pointers occur so frequently that programmers who use classes with pointer members must be thoroughly familiar with these programming techniques.</span></p>
                      <p class="docText"><span class="docEmphStrong">管理指针的这些方法用得非常频繁，因此使用带指针成员类的程序员必须充分熟悉这些编程技术。</span></p>
                    </td>
                  </tr>
                </table><br>
              </div><br>
            </td>
          </tr>
        </table><br>

	<a name="ch13sb08"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 13.5.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa7q1"></a><b>Exercise 13.22:</b></td>

                    <td>
                      <p class="docText">What is a use count?</p>
                      <p class="docText">什么是使用计数？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa7q2"></a><b>Exercise 13.23:</b></td>

                    <td>
                      <p class="docText">What is a smart pointer? How does a smart pointer class differ from one that implements plain pointer behavior?</p>
                      <p class="docText">什么是智能指针？智能指针类如何与实现普通指针行为的类相区别？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa7q3"></a><b>Exercise 13.24:</b></td>

                    <td>
                      <p class="docText">Implement your own version of the use-counted <tt>HasPtr</tt> class.</p>
                      <p class="docText">实现你自己的使用计数的 <tt>HasPtr</tt> 类的版本。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch13lev2sec26"></a>
        <h4 class="docSection2Title">13.5.2. Defining Valuelike Classes</h4>
        <h4 class="docSection2Title">13.5.2. 定义值型类</h4>

	<a name="ch13term14"></a><a name="idd1e103008"></a><a name="idd1e103013"></a>
        <p class="docText">A completely different approach to the problem of managing pointer members is to give them <b><a class="docLink" href="ch13lev1sec7.html#gloss13_14" >value semantics</a></b>. Simply put, classes with value semantics define objects that behave like the arithmetic types: When we copy a valuelike object, we get a new, distinct copy. Changes made to the copy are not reflected in the original, and vice versa. The <tt>string</tt> class is an example of a valuelike class.</p>
        <p class="docText">处理指针成员的另一个完全不同的方法，是给指针成员提供<b><a class="docLink" href="ch13lev1sec7.html#gloss13_14" >值语义</a></b>。具有值语义的类所定义的对象，其行为很像算术类型的对象：复制值型对象时，会得到一个不同的新副本。对副本所做的改变不会反映在原有对象上，反之亦然。<tt>string</tt> 类是值型类的一个例子。</p>

        <p class="docText">To make our pointer member behave like a value, we must copy the object to which the pointer points whenever we copy the <tt>HasPtr</tt> object:</p>
        <p class="docText">要使指针成员表现得像一个值，复制 <tt>HasPtr</tt> 对象时必须复制指针所指向的对象：</p>
        <pre>
     /*
      * <span class="docEmphItalicAlt">Valuelike behavior even though</span> <span class="docEmphasis">HasPtr</span> <span class="docEmphItalicAlt">has a pointer member:</span>
      * <span class="docEmphItalicAlt">Each time we copy a</span> <span class="docEmphasis">HasPtr</span> <span class="docEmphItalicAlt">object, we make a new copy of the</span>
      * <span class="docEmphItalicAlt">underlying</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">object to which</span> <span class="docEmphasis">ptr</span> <span class="docEmphItalicAlt">points</span>.
      */
     class HasPtr {
     public:
         // <span class="docEmphItalicAlt">no point to passing a pointer if we're going to copy it anyway</span>
         // <span class="docEmphItalicAlt">store pointer to a copy of the object we're given</span>
         HasPtr(const int &amp;p, int i): ptr(new int(p)), val(i) {}

         // <span class="docEmphItalicAlt">copy members and increment the use count</span>
         HasPtr(const HasPtr &amp;orig):
            ptr(new int (*orig.ptr)), val(orig.val) { }

         HasPtr&amp; operator=(const HasPtr&amp;);
         ~HasPtr() { delete ptr; }
         // <span class="docEmphItalicAlt">accessors must change to fetch value from Ptr object</span>
         int get_ptr_val() const { return *ptr; }
         int get_int() const { return val; }

         // <span class="docEmphItalicAlt">change the appropriate data member</span>
         void set_ptr(int *p) { ptr = p; }
         void set_int(int i) { val = i; }

         // <span class="docEmphItalicAlt">return or change the value pointed to, so ok for const objects</span>
         int *get_ptr() const { return ptr; }
         void set_ptr_val(int p) const { *ptr = p; }
     private:
         int *ptr;        // <span class="docEmphItalicAlt">points to an</span> <span class="docEmphasis">int</span>
         int val;
     };
</pre><br>

        <p class="docText">The copy constructor no longer copies the pointer. It now allocates a new <tt>int</tt> object and initializes that object to hold the same value as the object of which it is a copy. Each object always holds its own, distinct copy of its <tt>int</tt> value. Because each object holds its own copy, the destructor unconditionally deletes the pointer.</p>
        <p class="docText">复制构造函数不再复制指针，它将分配一个新的 <tt>int</tt> 对象，并初始化该对象以保存与被复制对象相同的值。每个对象都保存属于自己的 <tt>int</tt> 值的不同副本。因为每个对象保存自己的副本，所以析构函数将无条件删除指针。</p>

	<a name="idd1e103147"></a><a name="idd1e103156"></a><a name="idd1e103164"></a>
        <p class="docText">The assignment operator doesn't need to allocate a new object. It just has to remember to assign a new value to the object to which its <tt>int</tt> pointer points rather than assigning to the pointer itself:</p>
        <p class="docText">赋值操作符不需要分配新对象，它只是必须记得给其指针所指向的对象赋新值，而不是给指针本身赋值：</p>
        <pre>
     HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)
     {
         // <span class="docEmphItalicAlt">Note: Every</span> <span class="docEmphasis">HasPtr</span> <span class="docEmphItalicAlt">is guaranteed to point at an actual</span> <span class="docEmphasis">int;</span>
         //    <span class="docEmphItalicAlt">We know that</span> <span class="docEmphasis">ptr</span> <span class="docEmphasis">cannot be a zero pointer</span>
         *ptr = *rhs.ptr;       // <span class="docEmphItalicAlt">copy the value pointed to</span>
         val = rhs.val;         // <span class="docEmphItalicAlt">copy the</span> <span class="docEmphasis">int</span>
         return *this;
     }
</pre><br>

        <p class="docText">In other words, we change the value pointed to but not the pointer.</p>
        <p class="docText">换句话说，改变的是指针所指向的值，而不是指针。</p>

	<a name="ch13note15"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">As always, the assignment operator must be correct even if we're assigning an object to itself. In this case, the operations are inherently safe even if the left- and right-hand objects are the same. Thus, there is no need to explicitly check for self-assignment.</p>
                <p class="docText">即使要将一个对象赋值给它本身，赋值操作符也必须总是保证正确。本例中，即使左右操作数相同，操作本质上也是安全的，因此，不需要显式检查自身赋值。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch13sb09"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 13.5.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa8q1"></a><b>Exercise 13.25:</b></td>

                    <td>
                      <p class="docText">What is a valuelike class?</p>
                      <p class="docText">什么是值型类？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa8q2"></a><b>Exercise 13.26:</b></td>

                    <td>
                      <p class="docText">Implement your own version of a valuelike <tt>HasPtr</tt> class.</p>
                      <p class="docText">实现你自己的值型 <tt>HasPtr</tt> 类版本？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa8q3"></a><b>Exercise 13.27:</b></td>

                    <td>
                      <p class="docText">The valuelike <tt>HasPtr</tt> class defines each of the copy-control members. Describe what would happen if the class defined</p>
                      <p class="docText">值型 <tt>HasPtr</tt> 类定义了所有复制控制成员。描述将会发生什么，如果该类：</p>

                      <div style="font-weight:bold">
                        <ol class="docList" type="a">
                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">The copy constructor and destructor but no assignment operator.</p>
                              <p class="docList">定义了复制构造函数和析构函数但没有定义赋值操作符。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">The copy constructor and assignment operator but no destructor.</p>
                              <p class="docList">定义了复制构造函数和赋值操作符但没有定义析构函数。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">The destructor but neither the copy constructor nor assignment operator.</p>
                              <p class="docList">定义了析构函数但没有定义复制构造函数和赋值操作符。</p>
                            </div>
                          </li>
                        </ol>
                      </div>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch13qa8q4"></a><b>Exercise 13.28:</b></td>

                    <td>
                      <p class="docText">Given the following classes, implement a default constructor and the necessary copy-control members.</p>
                      <p class="docText">对于如下的类，实现默认构造函数和必要的复制控制成员。</p>
                      <pre>
     (a) class TreeNode {        (b) class BinStrTree {
         public:                         public:
             // ...                         //...
         private:                        private:
             std::string value;               TreeNode *root;
             int         count;          };
             TreeNode    *left;
             TreeNode    *right;
         };
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch13lev1sec4.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch13lev1sec6.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
