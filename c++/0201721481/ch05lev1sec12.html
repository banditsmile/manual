<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 5.12.  Type Conversions</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch05lev1sec11.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch05lev1sec13.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch05lev1sec12"></a>

        <h3 class="docSection1Title">5.12. Type Conversions</h3>
        <h3 class="docSection1Title">5.12. 类型转换</h3>

	<a name="ch05term7"></a>
        <p class="docText">The type of the operand(s) determine whether an expression is legal and, if the expression is legal, determines the meaning of the expression. However, in C++ some types are related to one another. When two types are related, we can use an object or value of one type where an operand of the related type is expected. Two types are related if there is a <b><a class="docLink" href="ch05lev1sec14.html#gloss05_07" >conversion</a></b> between them.</p>
        <p class="docText">表达式是否合法取决于操作数的类型，而且合法的表达式其含义也由其操作数类型决定。但是，在 C++ 中，某些类型之间存在相关的依赖关系。若两种类型相关，则可在需要某种类型的操作数位置上，使用该类型的相关类型对象或值。如果两个类型之间可以相互<b><a class="docLink" href="ch05lev1sec14.html#gloss05_07" >转换</a></b>，则称这两个类型相关。</p>

        <p class="docText">As an example, consider</p>
        <p class="docText">考虑下列例子：</p>
        <pre>
     int ival = 0;
     ival = 3.541 + 3; // <span class="docEmphItalicAlt">typically compiles with a warning</span>
</pre>

        <p class="docText">which assigns 6 to <tt>ival</tt>.</p>
	<p class="docText"><tt>ival</tt>  的值为 6。</p>

        <p class="docText">The operands to the addition operator are values of two different types: <tt>3.541</tt> is a literal of type <tt>double</tt>, and <tt>3</tt> is a literal of type <tt>int</tt>. Rather than attempt to add values of the two different types, C++ defines a set of conversions to transform the operands to a common type before performing the arithmetic. These conversions are carried out automatically by the compiler without programmer interventionand sometimes without programmer knowledge. For that reason, they are referred to as <span class="docEmphStrong">implicit type conversions</span>.</p>
	<p class="docText">首先做加法操作，其操作数是两个不同类型的值：<tt>3.541</tt> 是 <tt>double</tt> 型的字面值常量，而 3 则是 <tt>int</tt> 型的字面值常量。C++ 并不是把两个不同类型的值直接加在一起，而是提供了一组转换规则，以便在执行算术操作之前，将两个操作数转换为同一种数据类型。这些转换规则由编译器自动执行，无需程序员介入——有时甚至不需要程序员了解。因此，它们也被称为<span class="docEmphStrong">隐式类型转换</span>。</p>

	<a name="idd1e38829"></a><a name="idd1e38836"></a><a name="idd1e38844"></a><a name="idd1e38849"></a><a name="idd1e38854"></a><a name="idd1e38859"></a>
        <p class="docText">The built-in conversions among the arithmetic types are defined to preserve precision, if possible. Most often, if an expression has both integral and floating-point values, the integer is converted to floating-point. In this addition, the integer value <tt>3</tt> is converted to <tt>double</tt>. Floating-point addition is performed and the result, <tt>6.541</tt>, is of type <tt>double</tt>.</p>
	<p class="docText">C++ 定义了算术类型之间的内置转换以尽可能防止精度损失。通常，如果表达式的操作数分别为整型和浮点型，则整型的操作数被转换为浮点型。本例中，整数3被转换为 <tt>double</tt> 类型，然后执行浮点类型的加法操作，得 <tt>double</tt> 类型的结果 <tt>6.541</tt>。</p>

        <p class="docText">The next step is to assign that <tt>double</tt> value to <tt>ival</tt>, which is an <tt>int</tt>. In the case of assignment, the type of the left-hand operand dominates, because it is not possible to change the type of the object on the left-hand side. When the left- and right-hand types of an assignment differ, the right-hand side is converted to the type of the left-hand side. Here the <tt>double</tt> is converted to <tt>int</tt>. Converting a <tt>double</tt> to an <tt>int</tt> TRuncates the value; the decimal portion is discarded. 6.541 becomes 6, which is the value assigned to <tt>ival</tt>. Because the conversion of a <tt>double</tt> to <tt>int</tt> may result in a loss of precision, most compilers issue a warning. For example, the compiler we used to check the examples in this book warns us:</p>
	<p class="docText">下一步是将 <tt>double</tt> 类型的值赋给 <tt>int</tt> 型变量 <tt>ival</tt>。在赋值操作中，因为不可能更改左操作数对象的类型，因此左操作数的类型占主导地位。如果赋值操作的左右操作数类型不相同，则右操作数会被转换为左边的类型。本例中，<tt>double</tt> 型的加法结果转换为 <tt>int</tt> 型。<tt>double</tt> 向 <tt>int</tt> 的转换自动按截尾形式进行，小数部分被舍弃。于是 6.541 变成 6，然后赋给 <tt>ival</tt>。因为从 <tt>double</tt> 到 <tt>int</tt> 的转换会导致精度损失，因此大多数编译器会给出警告。例如，本书所用的测试例程的编译器给出如下警告：</p>
        <pre>
     warning: assignment to 'int' from 'double'
</pre>

	<a name="ch05term12"></a>
        <p class="docText">To understand <span class="docEmphRoman"><a class="docLink" href="ch05lev1sec14.html#gloss05_12" >implicit conversions</a></span>, we need to know when they occur and what conversions are possible.</p>
        <p class="docText">为了理解<span class="docEmphRoman"><a class="docLink" href="ch05lev1sec14.html#gloss05_12" >隐式类型转换</a></span>，我们需要知道它们在什么时候发生，以及可能出现什么类型的转换。</p>

	<a name="ch05lev2sec25"></a>
	<h4 class="docSection2Title">5.12.1. When Implicit Type Conversions Occur</h4>
        <h4 class="docSection2Title">5.12.1. 何时发生隐式类型转换</h4>	

        <p class="docText">The compiler applies conversions for both built-in and class type objects as necessary. Implicit type conversions take place in the following situations:</p>
        <p class="docText">编译器在必要时将类型转换规则应用到内置类型和类类型的对象上。在下列情况下，将发生隐式类型转换：</p>

        <ul>
          <li>
            <p class="docList">In expressions with operands of mixed types, the types are converted to a common type:</p>
            <p class="docList">在混合类型的表达式中，其操作数被转换为相同的类型：</p>
            <pre>
     int ival;
     double dval;
     ival &gt;= dval // <span class="docEmphasis">ival</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">double</span>
</pre>
          </li>

          <li>
            <p class="docList">An expression used as a condition is converted to <tt>bool</tt>:</p>
	    <p class="docList">用作条件的表达式被转换为 <tt>bool</tt> 类型：</p>
            <pre>
     int ival;
     if (ival)   // <span class="docEmphasis">ival</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">bool</span>
     while (cin) // <span class="docEmphasis">cin</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">bool</span>
</pre>

            <p class="docList">Conditions occur as the first operand of the conditional (<tt>?:</tt>) operator and as the operand(s) to the logical NOT (<tt>!</tt>), logical AND (<tt>&amp;&amp;</tt>), and logical OR (<tt>||</tt>) operators. Conditions also appear in the <tt>if, while, for</tt>, and <tt>do while</tt> statements. (We cover the <tt>do while</tt> in <a class="docLink" href="ch06.html#ch06" >Chapter 6</a>)</p>
	    <p class="docList">条件操作符（<tt>?:</tt>）中的第一个操作数以及逻辑非（<tt>!</tt>）、逻辑与（<tt>&amp;&amp;</tt>）和逻辑或（<tt>||</tt>）的操作数都是条件表达式。出现在 <tt>if</tt>、<tt>while</tt>、<tt>for</tt> 和 <tt>do while</tt> 语句中的同样也是条件表达式（其中 <tt>do while</tt>将在<a class="docLink" href="ch06.html#ch06" >第六章</a>中学习）。</p>
          </li>

          <li>
            <p class="docList">An expression used to initialize or assign to a variable is converted to the type of the variable:</p>
            <p class="docList">用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量的类型：</p>
            <pre>
     int ival = 3.14; // <span class="docEmphasis">3.14</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span>
     int *ip;
     ip = 0; // <span class="docEmphasis">the</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">0 converted to a null pointer of type</span> <span class="docEmphasis">int *</span>
</pre>
          </li>
        </ul>

        <p class="docText">In addition, as we'll see in <a class="docLink" href="ch07.html#ch07" >Chapter 7</a>, implicit conversions also occur during function calls.</p>
        <p class="docText">另外，在函数调用中也可能发生隐式类型转换，我们将在<a class="docLink" href="ch07.html#ch07" >第七章</a>学习这方面的内容。</p>

	<a name="ch05lev2sec26"></a>
        <h4 class="docSection2Title">5.12.2. The Arithmetic Conversions</h4>
        <h4 class="docSection2Title">5.12.2. 算术转换</h4>

	<a name="idd1e39065"></a><a name="idd1e39070"></a><a name="idd1e39075"></a><a name="idd1e39080"></a><a name="idd1e39087"></a><a name="idd1e39090"></a><a name="idd1e39093"></a><a name="idd1e39101"></a>
	<a name="ch05term1"></a>
        <p class="docText">The language defines a set of conversions among the built-in types. Among these, the most common are the <b><a class="docLink" href="ch05lev1sec14.html#gloss05_01" >arithmetic conversions</a></b>, which ensure that the two operands of a binary operator, such as an arithmetic or logical operator, are converted to a common type before the operator is evaluated. That common type is also the result type of the expression.</p>
        <p class="docText">C++ 语言为内置类型提供了一组转换规则，其中最常用的是<b><a class="docLink" href="ch05lev1sec14.html#gloss05_01" >算术转换</a></b>。算术转换保证在执行操作之前，将二元操作符（如算术或逻辑操作符）的两个操作数转换为同一类型，并使表达式的值也具有相同的类型。</p>

        <p class="docText">The rules define a hierarchy of type conversions in which operands are converted to the widest type in the expression. The conversion rules are defined so as to preserve the precision of the values involved in a multi-type expression. For example, if one operand is of type <tt>long double</tt>, then the other is converted to type <tt>long double</tt> regardless of what the second type is.</p>
	<p class="docText">算术转换规则定义了一个类型转换层次，该层次规定了操作数应按什么次序转换为表达式中最宽的类型。在包含多种类型的表达式中，转换规则要确保计算值的精度。例如，如果一个操作数的类型是 <tt>long double</tt>，则无论另一个操作数是什么类型，都将被转换为 <tt>long double</tt>。</p>

	<a name="ch05term13"></a>
        <p class="docText">The simplest kinds of conversion are <b><a class="docLink" href="ch05lev1sec14.html#gloss05_13" >integral promotions</a></b>. Each of the integral types that are smaller than <tt>int</tt> <tt>char, signed char, unsigned char, short</tt>, and <tt>unsigned short</tt>is promoted to <tt>int</tt> if all possible values of that type fit in an <tt>int</tt>. Otherwise, the value is promoted to <tt>unsigned int</tt>. When <tt>bool</tt> values are promoted to <tt>int</tt>, a <tt>false</tt> value promotes to zero and <tt>true</tt> to one.</p>
	<p class="docText">最简单的转换为<b><a class="docLink" href="ch05lev1sec14.html#gloss05_13" >整型提升</a></b>：对于所有比 <tt>int</tt> 小的整型，包括 <tt>char</tt>、<tt>signed char</tt>、<tt>unsigned char</tt>、<tt>short</tt> 和 <tt>unsigned short</tt>，如果该类型的所有可能的值都能包容在 <tt>int</tt> 内，它们就会被提升为 <tt>int</tt> 型，否则，它们将被提升为 <tt>unsigned int</tt>。如果将 <tt>bool</tt> 值提升为 <tt>int</tt> ，则 <tt>false</tt> 转换为 0，而 <tt>true</tt> 则转换为 1。</p>

	<a name="ch05lev3sec4"></a>
        <h5 class="docSection3Title">Conversions between Signed and Unsigned Types</h5>
        <h5 class="docSection3Title">有符号与无符号类型之间的转换</h5>

        <p class="docText">When an <tt>unsigned</tt> value is involved in an expression, the conversion rules are defined to preserve the value of the operands. Conversions involving <tt>unsigned</tt> operands depend on the relative sizes of the integral types on the machine. Hence, such conversions are inherently machine dependent.</p>
	<p class="docText">若表达式中使用了无符号（ <tt>unsigned</tt> ）数值，所定义的转换规则需保护操作数的精度。<tt>unsigned</tt> 操作数的转换依赖于机器中整型的相对大小，因此，这类转换本质上依赖于机器。</p>

        <p class="docText">In expressions involving <tt>short</tt>s and <tt>ints</tt>, values of type <tt>short</tt> are converted to <tt>int</tt>. Expressions involving <tt>unsigned short</tt> are converted to <tt>int</tt> if the <tt>int</tt> type is large enough to represent all the values of an <tt>unsigned short</tt>. Otherwise, both operands are converted to <tt>unsigned int</tt>. For example, if <tt>short</tt>s are a half word and <tt>int</tt>s a word, then any <tt>unsigned</tt> value will fit inside an <tt>int</tt>. On such a machine, <tt>unsigned shorts</tt> are converted to <tt>int</tt>.</p>
	<p class="docText">包含 <tt>short</tt> 和 <tt>int</tt> 类型的表达式， <tt>short</tt> 类型的值转换为 <tt>int</tt> 。如果 <tt>int</tt> 型足够表示所有 <tt>unsigned short</tt> 型的值，则将 <tt>unsigned short</tt> 转换为 <tt>int</tt>，否则，将两个操作数均转换为 <tt>unsigned int</tt> 。例如，如果 <tt>short</tt> 用半字表示而 <tt>int</tt> 用一个字表示，则所有 <tt>unsigned</tt> 值都能包容在 <tt>int</tt> 内，在这种机器上， <tt>unsigned short</tt> 转换为 <tt>int</tt>。</p>

        <p class="docText">The same conversion happens among operands of type <tt>long</tt> and <tt>unsigned int</tt>. The <tt>unsigned int</tt> operand is converted to <tt>long</tt> if type <tt>long</tt> on the machine is large enough to represent all the values of the <tt>unsigned int</tt>. Otherwise, both operands are converted to <tt>unsigned long</tt>.</p>
	<p class="docText"><tt>long</tt> 和 <tt>unsigned int</tt> 的转换也是一样的。只要机器上的 <tt>long</tt> 型足够表示 <tt>unsigned int</tt> 型的所有值，就将 <tt>unsigned int</tt> 转换为 <tt>long</tt> 型，否则，将两个操作数均转换为 <tt>unsigned long</tt> 。</p>

        <p class="docText">On a 32-bit machine, <tt>long</tt> and <tt>int</tt> are typically represented in a word. On such machines, expressions involving <tt>unsigned int</tt>s and <tt>longs</tt> are converted to <tt>unsigned long</tt>.</p>
	<p class="docText">在 32 位的机器上，<tt>long</tt> 和 <tt>int</tt> 型通常用一个字长表示，因此当表达式包含 <tt>unsigned int</tt> 和 <tt>long</tt> 两种类型，其操作数都应转换为 <tt>unsigned long</tt> 型。</p>

        <p class="docText">Conversions for expressions involving signed and <tt>unsigned int</tt> can be surprising. In these expressions the signed value is converted to <tt>unsigned</tt>. For example, if we compare a plain <tt>int</tt> and an <tt>unsigned int</tt>, the <tt>int</tt> is first converted to <tt>unsigned</tt>. If the <tt>int</tt> happens to hold a negative value, the result will be converted as described in <a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >Section 2.1.1</a> (p. <a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >36</a>), with all the attendant problems discussed there.</p>
	<p class="docText">对于包含 <tt>signed</tt> 和 <tt>unsigned int</tt> 型的表达式，其转换可能出乎我们的意料。表达式中的 <tt>signed</tt> 型数值会被转换为 <tt>unsigned</tt> 型。例如，比较 <tt>int</tt> 型和 <tt>unsigned int</tt> 型的简单变量，系统首先将 <tt>int</tt> 型数值转换为 <tt>unsigned int</tt> 型，如果 <tt>int</tt> 型的值恰好为负数，其结果将以<a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >第 2.1.1 节</a>介绍的方法转换，并带来该节描述的所有副作用。</p>

	<a name="ch05lev3sec5"></a>
        <h5 class="docSection3Title">Understanding the Arithmetic Conversions</h5>
        <h5 class="docSection3Title">理解算术转换</h5>

	<a name="idd1e39302"></a><a name="idd1e39307"></a>
        <p class="docText">The best way to understand the arithmetic conversions is to study lots of examples. In most of the following examples, either the operands are converted to the largest type involved in the expression or, in the case of assignment expressions, the right-hand operand is converted to the type of the left-hand operand:</p>
        <p class="docText">研究大量例题是帮助理解算术转换的最好方法。下面大部分例题中，要么是将操作数转换为表达式中的最大类型，要么是在赋值表达式中将右操作数转换为左操作数的类型。</p>
        <pre>
     bool      flag;         char           cval;
     short     sval;         unsigned short usval;
     int       ival;         unsigned int   uival;
     long      lval;         unsigned long  ulval;
     float     fval;         double         dval;
     3.14159L + 'a'; // <span class="docEmphItalicAlt">promote 'a' to</span> <span class="docEmphasis">int</span>, <span class="docEmphItalicAlt">then convert to</span> <span class="docEmphasis">long double</span>
     dval + ival;    // <span class="docEmphasis">ival</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">double</span>
     dval + fval;    // <span class="docEmphasis">fval</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">double</span>
     ival = dval;    // <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">converted (by truncation) to</span> <span class="docEmphasis">int</span>
     flag = dval;    // <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">is 0, then</span> <span class="docEmphasis">flag</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">false</span>, <span class="docEmphItalicAlt">otherwise</span> <span class="docEmphasis">true</span>
     cval + fval;    // <span class="docEmphasis">cval</span> <span class="docEmphItalicAlt">promoted to</span> <span class="docEmphasis">int</span>, <span class="docEmphItalicAlt">that</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">float</span>
     sval + cval;    // <span class="docEmphasis">sval</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">cval</span> <span class="docEmphItalicAlt">promoted to</span> <span class="docEmphasis">int</span>
     cval + lval;    // <span class="docEmphasis">cval</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">long</span>
     ival + ulval;   // <span class="docEmphasis">ival</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">unsigned long</span>
     usval + ival;   // <span class="docEmphItalicAlt">promotion depends on size of</span> <span class="docEmphasis">unsigned short</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">int</span>
     uival + lval;   // <span class="docEmphItalicAlt">conversion depends on size of</span> <span class="docEmphasis">unsigned int</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">long</span>
</pre>

        <p class="docText">In the first addition, the character constant lowercase <tt>'a'</tt> has type <tt>char</tt>, which as we know from <a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >Section 2.1.1</a> (p. <a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >34</a>) is a numeric value. The numeric value that <tt>'a'</tt> represents depends on the machine's character set. On our ASCII machine, <tt>'a'</tt> represents the number 97. When we add <tt>'a'</tt> to a <tt>long double</tt>, the <tt>char</tt> value is promoted to <tt>int</tt> and then that <tt>int</tt> value is converted to a <tt>long double</tt>. That converted value is added to the <tt>long double</tt> literal. The other interesting cases are the last two expressions involving <tt>unsigned</tt> values.</p><a name="ch05lev2sec27"></a>
	<p class="docText">第一个加法操作的小写字母 <tt>'a'</tt> 是一个 <tt>char</tt> 类型的字符常量，正如我们在<a class="docLink" href="ch02lev1sec1.html#ch02lev2sec1" >第 2.1.1 节</a>介绍的，它是一个数值。字母 <tt>'a'</tt> 表示的数值取决于机器字符集。在 ASCII 机器中，字母 <tt>'a'</tt> 的值为 97。将 <tt>'a'</tt> 与 <tt>long double</tt> 型数据相加时，<tt>char</tt> 型的值被提升为 <tt>int</tt> 型，然后将 <tt>int</tt> 型转换为 <tt>long double</tt> 型，转换后的值再与 <tt>long double</tt> 型字面值相加。另一个有趣的现象是最后两个表达式都包含 <tt>unsigned</tt> 数值。</p>

        <h4 class="docSection2Title">5.12.3. Other Implicit Conversions</h4>
        <h4 class="docSection2Title">5.12.3. 其他隐式转换</h4>

	<a name="ch05lev3sec6"></a>
        <h5 class="docSection3Title">Pointer Conversions</h5>
        <h5 class="docSection3Title">指针转换</h5>

        <p class="docText">In most cases when we use an array, the array is automatically converted to a pointer to the first element:</p>
        <p class="docText">在使用数组时，大多数情况下数组都会自动转换为指向第一个元素的指针：</p>
        <pre>
     int ia[10];    // <span class="docEmphItalicAlt">array of 10</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">s</span>
     int* ip = ia;  // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">ia</span> <span class="docEmphItalicAlt">to pointer to first element</span>
</pre>

        <p class="docText">The exceptions when an array is not converted to a pointer are: as the operand of the address-of (<tt>&amp;</tt>) operator or of <tt>sizeof</tt>, or when using the array to initialize a reference to the array. We'll see how to define a reference (or pointer) to an array in <a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >Section 7.2.4</a> (p. <a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >240</a>).</p>
	<p class="docText">不将数组转换为指针的例外情况有：数组用作取地址（<tt>&amp;</tt>）操作符的操作数或 <tt>sizeof</tt> 操作符的操作数时，或用数组对数组的引用进行初始化时，不会将数组转换为指针。我们将在<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >第 7.2.4 节</a>学习如何定义指向数组的引用（或指针）。</p>

        <p class="docText">There are two other pointer conversions: A pointer to any data type can be converted to a <tt>void*</tt>, and a constant integral value of 0 can be converted to any pointer type.</p>
	<p class="docText">C++ 还提供了另外两种指针转换：指向任意数据类型的指针都可转换为 <tt>void*</tt> 类型；整型数值常量 0 可转换为任意指针类型。</p>

	<a name="ch05lev3sec7"></a>
        <h5 class="docSection3Title">Conversions to <tt>bool</tt></h5>
	<h5 class="docSection3Title">转换为 <tt>bool</tt> 类型</h5>

	<a name="idd1e39580"></a><a name="idd1e39589"></a><a name="idd1e39596"></a><a name="idd1e39602"></a><a name="idd1e39608"></a><a name="idd1e39617"></a><a name="idd1e39626"></a><a name="idd1e39631"></a><a name="idd1e39638"></a><a name="idd1e39643"></a><a name="idd1e39648"></a>
        <p class="docText">Arithmetic and pointer values can be converted to <tt>bool</tt>. If the pointer or arithmetic value is zero, then the <tt>bool</tt> is <tt>false</tt>; any other value converts to <tt>true</tt>:</p>
	<p class="docText">算术值和指针值都可以转换为 <tt>bool</tt> 类型。如果指针或算术值为 0，则其 <tt>bool</tt> 值为 <tt>false</tt> ，而其他值则为 <tt>true</tt>：</p>
        <pre>
     if (cp) /* ... */     // true <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">cp</span> <span class="docEmphItalicAlt">is not zero</span>
     while (*cp) /* ... */ // <span class="docEmphItalicAlt">dereference</span> <span class="docEmphasis">cp</span> <span class="docEmphItalicAlt">and convert resulting</span> <span class="docEmphasis">char</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">bool</span>
</pre>

        <p class="docText">Here, the <tt>if</tt> converts any nonzero value of <tt>cp</tt> to <tt>TRue</tt>. The <tt>while</tt> dereferences <tt>cp</tt>, which yields a <tt>char</tt>. The null character has value zero and converts to <tt>false</tt>. All other <tt>char</tt> values convert to <tt>true</tt>.</p>
	<p class="docText">这里，<tt>if</tt> 语句将 <tt>cp</tt> 的非零值转换为 <tt>true</tt>。 <tt>while</tt> 语句则对 <tt>cp</tt> 进行解引用，操作结果产生一个 <tt>char</tt> 型的值。空字符（ <tt>null</tt> ）具有 <tt>0</tt> 值，被转换为 <tt>false</tt>，而其他字符值则转换为 <tt>true</tt>。</p>

<a name="ch05lev3sec8"></a>
        <h5 class="docSection3Title">Arithmetic Type and <tt>bool</tt> Conversions</h5>
	<h5 class="docSection3Title">算术类型与 <tt>bool</tt> 类型的转换</h5>

        <p class="docText">Arithmetic objects can be converted to <tt>bool</tt> and <tt>bool</tt> objects can be converted to <tt>int</tt>. When an arithmetic type is converted to <tt>bool</tt>, zero converts as <tt>false</tt> and any other value converts as <tt>true</tt>. When a <tt>bool</tt> is converted to an arithmetic type, <tt>true</tt> becomes one and <tt>false</tt> becomes zero:</p>
	<p class="docText">可将算术对象转换为 <tt>bool</tt> 类型，<tt>bool</tt> 对象也可转换为 <tt>int</tt> 型。将算术类型转换为 <tt>bool</tt> 型时，零转换为 <tt>false</tt> ，而其他值则转换为 <tt>true</tt> 。将 <tt>bool</tt> 对象转换为算术类型时，<tt>true</tt> 变成 1，而 <tt>false</tt> 则为 0：</p>
        <pre>
     bool b = true;
     int ival = b;   // <span class="docEmphasis">ival == 1</span>
     double pi = 3.14;
     bool b2 = pi;   // <span class="docEmphasis">b2</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">true</span>
     pi = false;     // <span class="docEmphasis">pi == 0</span>
</pre>

        <a name="ch05lev3sec9"></a>
        <h5 class="docSection3Title">Conversions and Enumeration Types</h5>
        <h5 class="docSection3Title">转换与枚举类型</h5>

        <p class="docText">Objects of an enumeration type (<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >Section 2.7</a>, p. <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >62</a>) or an enumerator can be automatically converted to an integral type. As a result, they can be used where an integral value is requiredfor example, in an arithmetic expression:</p>
	<p class="docText">C++ 自动将枚举类型（<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >第 2.7 节</a>）的对象或枚举成员（ <tt>enumerator</tt> ）转换为整型，其转换结果可用于任何要求使用整数值的地方。例如，用于算术表达式：</p>
        <pre>
     // <span class="docEmphasis">point2d</span> <span class="docEmphItalicAlt">is 2,</span> <span class="docEmphasis">point2w</span> <span class="docEmphItalicAlt">is 3,</span> <span class="docEmphasis">point3d</span> <span class="docEmphItalicAlt">is 3,</span> <span class="docEmphasis">point3w</span> <span class="docEmphasis">is 4</span>
     enum Points { point2d = 2, point2w,
                   point3d = 3, point3w };
     const size_t array_size = 1024;
     // <span class="docEmphItalicAlt">ok: pt2w promoted to int</span>
     int chunk_size = array_size * pt2w;
     int array_3d = array_size * point3d;
</pre>

        <p class="docText">The type to which an <tt>enum</tt> object or enumerator is promoted is machine-defined and depends on the value of the largest enumerator. Regardless of that value, an <tt>enum</tt> or enumerator is always promoted at least to <tt>int</tt>. If the largest enumerator does not fit in an <tt>int</tt>, then the promotion is to the smallest type larger than <tt>int</tt> (<tt>unsigned int, long</tt> or <tt>unsigned long</tt>) that can hold the enumerator value.</p>
	<p class="docText">将 <tt>enum</tt> 对象或枚举成员提升为什么类型由机器定义，并且依赖于枚举成员的最大值。无论其最大值是什么， <tt>enum</tt> 对象或枚举成员至少提升为 <tt>int</tt> 型。如果 <tt>int</tt> 型无法表示枚举成员的最大值，则提升到能表示所有枚举成员值的、大于 <tt>int</tt> 型的最小类型（ <tt>unsigned int</tt>、<tt>long</tt> 或 <tt>unsigned long</tt>）。</p>

	<a name="ch05lev3sec10"></a>
        <h5 class="docSection3Title">Conversion to <tt>const</tt></h5>
	<h5 class="docSection3Title">转换为 <tt>const</tt> 对象</h5>

        <p class="docText">A non<tt>const</tt> object can be converted to a <tt>const</tt> object, which happens when we use a non<tt>const</tt> object to initialize a reference to <tt>const</tt> object. We can also convert the address of a non<tt>const</tt> object (or convert a non<tt>const</tt> pointer) to a pointer to the related <tt>const</tt> type:</p>
	<p class="docText">当使用非 <tt>const</tt> 对象初始化 <tt>const</tt> 对象的引用时，系统将非 <tt>const</tt> 对象转换为 <tt>const</tt> 对象。此外，还可以将非 <tt>const</tt> 对象的地址（或非 <tt>const</tt> 指针）转换为指向相关 <tt>const</tt> 类型的指针：</p>
        <pre>
     int i;
     const int ci = 0;
     const int &amp;j = i;   // <span class="docEmphItalicAlt">ok: convert non-</span><span class="docEmphasis">const</span> <span class="docEmphItalicAlt">to reference to</span> <span class="docEmphasis">const int</span>
     const int *p = &amp;ci; // <span class="docEmphItalicAlt">ok: convert address of non-</span><span class="docEmphasis">const</span> <span class="docEmphItalicAlt">to address of a</span> <span class="docEmphasis">const</span>
</pre>

        <a name="ch05lev3sec11"></a>
        <h5 class="docSection3Title">Conversions Defined by the Library Types</h5>
        <h5 class="docSection3Title">由标准库类型定义的转换</h5>

	<a name="idd1e39932"></a><a name="idd1e39935"></a><a name="idd1e39943"></a><a name="idd1e39949"></a><a name="idd1e39954"></a><a name="idd1e39959"></a><a name="idd1e39963"></a><a name="idd1e39966"></a><a name="idd1e39973"></a><a name="idd1e39977"></a><a name="idd1e39982"></a>
        <p class="docText">Class types can define conversions that the compiler will apply automatically. Of the library types we've used so far, there is one important conversion that we have used. When we read from an <tt>istream</tt> as a condition</p>
	<p class="docText">类类型可以定义由编译器自动执行的类型转换。迄今为止，我们使用过的标准库类型中，有一个重要的类型转换。从 <tt>istream</tt> 中读取数据，并将此表达式作为 <tt>while</tt> 循环条件：</p>
        <pre>
     string s;
     while (cin &gt;&gt; s)
</pre>

        <p class="docText">we are implicitly using a conversion defined by the IO library. In a condition such as this one, the expression <tt>cin &gt;&gt; s</tt> is evaluated, meaning <tt>cin</tt> is read. Whether the read succeeds or fails, the result of the expression is <tt>cin</tt>.</p>
	<p class="docText">这里隐式使用了 IO 标准库定义的类型转换。在与此类似的条件中，求解表达式  <tt>cin &gt;&gt; s</tt>，即读 <tt>cin</tt>。无论读入是否成功，该表达式的结果都是 <tt>cin</tt>。</p>

        <p class="docText">The condition in the <tt>while</tt> expects a value of type <tt>bool</tt>, but it is given a value of type <tt>istream</tt>. That <tt>istream</tt> value is converted to <tt>bool</tt>. The effect of converting an <tt>istream</tt> to <tt>bool</tt> is to test the state of the stream. If the last attempt to read from <tt>cin</tt> succeeded, then the state of the stream will cause the conversion to <tt>bool</tt> to be <tt>true</tt>the <tt>while</tt> test will succeed. If the last attempt failedsay because we hit end-of-filethen the conversion to <tt>bool</tt> will yield <tt>false</tt> and the <tt>while</tt> condition will fail.</p>
	<p class="docText"><tt>while</tt> 循环条件应为 <tt>bool</tt> 类型的值，但此时给出的却是 <tt>istream</tt> 类类型的值，于是 <tt>istream</tt> 类型的值应转换为 <tt>bool</tt> 类型。将 <tt>istream</tt> 类型转换为 <tt>bool</tt> 类型意味着要检验流的状态。如果最后一次读 <tt>cin</tt> 的尝试是成功的，则流的状态将导致上述类型转换为 <tt>bool</tt> 类型后获得 <tt>true</tt> 值——<tt>while</tt> 循环条件成立。如果最后一次尝试失败，比如说已经读到文件尾了，此时将 <tt>istream</tt> 类型转换为 <tt>bool</tt> 类型后得 <tt>false</tt>，<tt>while</tt> 循环条件不成立。</p>

	<a name="ch05sb19"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 5.12.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch05qa14q1"></a><b>Exercise 5.31:</b></td>

                    <td>
                      <p class="docText">Given the variable definitions on page <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec26">180</a>, explain what conversions take place when evaluating the following expressions:</p>
                      <p class="docText">记住，你可能需要考虑操作符的结合性，以便在表达式含有多个操作符的情况下确定答案。</p>
                      <pre>
     (a) if (fval)
     (b) dval = fval + ival;
     (c) dval + ival + cval;
</pre>
                    </td>
                  </tr>
                </table>
              </blockquote>

              <p class="docText">Remember that you may need to consider associativity of the operators in order to determine the answer in the case of expressions involving more than one operator.</p>
              <p class="docText">记住，你可能需要考虑操作符的结合性，以便 在表达式含有多个操作符的情况下确定答案。</p>
            </td>
          </tr>
        </table>
        <a name="ch05lev2sec28"></a>

        <h4 class="docSection2Title">5.12.4. Explicit Conversions</h4>
        <h4 class="docSection2Title">5.12.4. 显式转换</h4>

	<a name="ch05term4"></a><a name="ch05term22"></a><a name="ch05term10"></a><a name="ch05term6"></a><a name="ch05term20"></a>
		<p class="docText">An explicit conversion is spoken of as a <b><a class="docLink" href="ch05lev1sec14.html#gloss05_04" >cast</a></b> and is supported by the following set of named cast operators: <b><a class="docLink" href="ch05lev1sec14.html#gloss05_22" ><span class="docEmphStrong"><tt>static_cast</tt></span></a></b>, <b><a class="docLink" href="ch05lev1sec14.html#gloss05_10" ><span class="docEmphStrong"><tt>dynamic_cast</tt></span></a></b>, <b><a class="docLink" href="ch05lev1sec14.html#gloss05_06" ><span class="docEmphStrong"><tt>const_cast</tt></span></a></b>, and <b><a class="docLink" href="ch05lev1sec14.html#gloss05_20" ><span class="docEmphStrong"><tt>reinterpret_cast</tt>.</span></a></b></p>
        <p class="docText">显式转换也称为强制类型转换（<b><a class="docLink" href="ch05lev1sec14.html#gloss05_04" >cast</a></b>），包括以下列名字命名的强制类型转换操作符：<b><a class="docLink" href="ch05lev1sec14.html#gloss05_22" ><span class="docEmphStrong"><tt>static_cast</tt></span></a></b>、<b><a class="docLink" href="ch05lev1sec14.html#gloss05_10" ><span class="docEmphStrong"><tt>dynamic_cast</tt></span></a></b>、<b><a class="docLink" href="ch05lev1sec14.html#gloss05_06" ><span class="docEmphStrong"><tt>const_cast</tt></span></a></b> 和 <b><a class="docLink" href="ch05lev1sec14.html#gloss05_20" ><span class="docEmphStrong"><tt>reinterpret_cast</tt></span></a></b>。</p>

	<a name="ch05note16"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Although necessary at times, casts are inherently dangerous constructs.</p>
                <p class="docText">虽然有时候确实需要强制类型转换，但是它们本质上是非常危险的。</p>
              </td>
            </tr>
          </table>
        </div>
        <a name="ch05lev2sec29"></a>

        <h4 class="docSection2Title">5.12.5. When Casts Might Be Useful</h4>
        <h4 class="docSection2Title">5.12.5. 何时需要强制类型转换</h4>

	<a name="idd1e40137"></a>
        <p class="docText">One reason to perform an explicit cast is to override the usual standard conversions. The following compound assignment</p>
        <p class="docText">因为要覆盖通常的标准转换，所以需显式使用强制类型转换。下面的复合赋值：</p>
        <pre>
     double dval;
     int ival;
     ival *= dval; // <span class="docEmphasis">ival = ival * dval</span>
</pre>

        <p class="docText">converts <tt>ival</tt> to <tt>double</tt> in order to multiply it by <tt>dval</tt>. That double result is then truncated to <tt>int</tt> in order to assign it to <tt>ival</tt>. We can eliminate the unnecessary conversion of <tt>ival</tt> to <tt>double</tt> by explicitly casting <tt>dval</tt> to <tt>int</tt>:</p>
	<p class="docText">为了与 <tt>dval</tt> 做乘法操作，需将 <tt>ival</tt> 转换为 <tt>double</tt> 型，然后将乘法操作的 <tt>double</tt> 型结果截尾为 <tt>int</tt> 型，再赋值给 <tt>ival</tt>。为了去掉将 <tt>ival</tt> 转换为 <tt>double</tt> 型这个不必要的转换，可通过如下强制将 <tt>dval</tt> 转换为 <tt>int</tt> 型：</p>
        <pre>
     ival *= static_cast&lt;int&gt;(dval); // <span class="docEmphItalicAlt">converts</span> <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphItalicAlt">int</span>
</pre>

        <p class="docText">Another reason for an explicit cast is to select a specific conversion when more than one conversion is possible. We will look at this case more closely in <a class="docLink" href="ch14.html#ch14" >Chapter 14</a>.</p>
        <p class="docText">显式使用强制类型转换的另一个原因是：可能存在多种转换时，需要选择一种特定的类型转换。我们将在<a class="docLink" href="ch14.html#ch14" >第 14 章</a>中详细讨论这种情况。</p>

	<a name="ch05lev2sec30"></a>
        <h4 class="docSection2Title">5.12.6. Named Casts</h4>
        <h4 class="docSection2Title">5.12.6. 命名的强制类型转换</h4>

        <p class="docText">The general form for the named cast notation is the following:</p>
        <p class="docText">命名的强制类型转换符号的一般形式如下：</p>
        <pre>
     <span class="docEmphasis">cast-name&lt;type&gt;(expression);</span>
</pre><br>

        <p class="docText"><tt>cast-name</tt> may be one of <tt>static_cast, const_cast, dynamic_cast</tt>, or <tt>reinterpret_cast</tt>. <span class="docEmphasis">type</span> is the target type of the conversion, and <span class="docEmphasis">expression</span> is the value to be cast. The type of cast determines the specific kind of conversion that is performed on the <span class="docEmphasis">expression</span>.</p>
	<p class="docText">其中 <tt>cast-name</tt> 为 <tt>static_cast</tt>、<tt>dynamic_cast</tt>、<tt>const_cast</tt> 和<tt>reinterpret_cast</tt> 之一，<tt>type</tt> 为转换的目标类型，而 <tt>expression</tt> 则是被强制转换的值。强制转换的类型指定了在 <tt>expression</tt> 上执行某种特定类型的转换。</p>

	<a name="ch05lev3sec12"></a>
        <h5 class="docSection3Title"><tt>dynamic_cast</tt></h5>

        <p class="docText">A <tt>dynamic_cast</tt> supports the run-time identification of objects addressed either by a pointer or reference. We cover <tt>dynamic_cast</tt> in <a class="docLink" href="ch18lev1sec2.html#ch18lev1sec2" >Section 18.2</a> (p. <a class="docLink" href="ch18lev1sec2.html#ch18lev1sec2" >772</a>).</p>
	<p class="docText"><tt>dynamic_cast</tt> 支持运行时识别指针或引用所指向的对象。对 <tt>dynamic_cast</tt> 的讨论将在<a class="docLink" href="ch18lev1sec2.html#ch18lev1sec2" >第 18.2 节</a>中进行。</p>

	<a name="ch05lev3sec13"></a>
        <h5 class="docSection3Title"><tt>const_cast</tt></h5>

        <p class="docText">A <tt>const_cast</tt>, as its name implies, casts away the <tt>const</tt>ness of its expression. For example, we might have a function named <tt>string_copy</tt> that we are certain reads, but does not write, its single parameter of type <tt>char*</tt>. If we have access to the code, the best alternative would be to correct it to take a <tt>const char*</tt>. If that is not possible, we could call <tt>string_copy</tt> on a <tt>const</tt> value using a <tt>const_cast:</tt></p>
	<p class="docText"><tt>const_cast</tt> ，顾名思义，将转换掉表达式的 <tt>const</tt> 性质。例如，假设有函数 <tt>string_copy</tt>，只有唯一的参数，为 <tt>char*</tt> 类型，我们对该函数只读不写。在访问该函数时，最好的选择是修改它让它接受 <tt>const char*</tt> 类型的参数。如果不行，可通过 <tt>const_cast</tt> 用一个 <tt>const</tt> 值调用 <tt>string_copy</tt> 函数：</p>

        <pre>
     const char *pc_str;
     char *pc = string_copy(const_cast&lt;char*&gt;(pc_str));
</pre>

        <p class="docText">Only a <tt>const_cast</tt> can be used to cast away <tt>const</tt>ness. Using any of the other three forms of cast in this case would result in a compile-time error. Similarly, it is a compile-time error to use the <tt>const_cast</tt> notation to perform any type conversion other than adding or removing <tt>const</tt>.</p>
	<p class="docText">只有使用 <tt>const_cast</tt> 才能将 <tt>const</tt> 性质转换掉。在这种情况下，试图使用其他三种形式的强制转换都会导致编译时的错误。类似地，除了添加或删除 <tt>const</tt> 特性，用 <tt>const_cast</tt> 符来执行其他任何类型转换，都会引起编译错误。</p>

	<a name="ch05lev3sec14"></a>
        <h5 class="docSection3Title"><tt>static_cast</tt></h5>

	<a name="idd1e40329"></a><a name="idd1e40335"></a><a name="idd1e40340"></a>
        <p class="docText">Any type conversion that the compiler performs implicitly can be explicitly requested by using a <tt>static_cast:</tt></p>
	<p class="docText">编译器隐式执行的任何类型转换都可以由 <tt>static_cast</tt> 显式完成：</p>
        <pre>
     double d = 97.0;
     // <span class="docEmphItalicAlt">cast specified to indicate that the conversion is intentional</span>
     char ch = static_cast&lt;char&gt;(d);
</pre>

        <p class="docText">Such casts are useful when assigning a larger arithmetic type to a smaller type. The cast informs both the reader of the program and the compiler that we are aware of and are not concerned about the potential loss of precision. Compilers often generate a warning for assignments of a larger arithmetic type to a smaller type. When we provide the explicit cast, the warning message is turned off.</p>
        <p class="docText">当需要将一个较大的算术类型赋值给较小的类型时，使用强制转换非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不关心潜在的精度损失。对于从一个较大的算术类型到一个较小类型的赋值，编译器通常会产生警告。当我们显式地提供强制类型转换时，警告信息就会被关闭。</p>

        <p class="docText">A <tt>static_cast</tt> is also useful to perform a conversion that the compiler will not generate automatically. For example, we can use a <tt>static_cast</tt> to retrieve a pointer value that was stored in a <tt>void*</tt> pointer (<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec4" >Section 4.2.2</a>, p. <a class="docLink" href="ch04lev1sec2.html#ch04lev2sec4" >119</a>):</p>
	<p class="docText">如果编译器不提供自动转换，使用 <tt>static_cast</tt> 来执行类型转换也是很有用的。例如，下面的程序使用 <tt>static_cast</tt> 找回存放在 <tt>void*</tt> 指针中的值（<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec4" >第 4.2.2 节</a>）：</p>
        <pre>
     void* p = &amp;d; // <span class="docEmphItalicAlt">ok: address of any data object can be stored in a</span> <span class="docEmphasis">void*</span>
     // <span class="docEmphItalicAlt">ok: converts</span> <span class="docEmphasis">void*</span> <span class="docEmphItalicAlt">back to the original pointer type</span>
     double *dp = static_cast&lt;double*&gt;(p);
</pre>

        <p class="docText">When we store a pointer in a <tt>void*</tt> and then use a <tt>static_cast</tt> to cast the pointer back to its original type, we are guaranteed that the pointer value is preserved. That is, the result of the cast will be equal to the original address value.</p>
	<p class="docText">可通过 <tt>static_cast</tt> 将存放在 <tt>void*</tt> 中的指针值强制转换为原来的指针类型，此时我们应确保保持指针值。也就是说，强制转换的结果应与原来的地址值相等。</p>

	<a name="ch05lev3sec15"></a>
        <h5 class="docSection3Title"><tt>reinterpret_cast</tt></h5>

        <p class="docText">A <tt>reinterpret_cast</tt> generally performs a low-level reinterpretation of the bit pattern of its operands.</p>
	<p class="docText"><tt>reinterpret_cast</tt> 通常为操作数的位模式提供较低层次的重新解释。</p>

	<a name="ch05note17"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A <tt>reinterpret_cast</tt> is inherently machine-dependent. Safely using <tt>reinterpret_cast</tt> requires completely understanding the types involved as well as the details of how the compiler implements the cast.</p>
		<p class="docText"><tt>reinterpret_cast</tt> 本质上依赖于机器。为了安全地使用 <tt>reinterpret_cast</tt>，要求程序员完全理解所涉及的数据类型，以及编译器实现强制类型转换的细节。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">As an example, in the following cast</p>
        <p class="docText">例如，对于下面的强制转换：</p>
        <pre>
     int *ip;
     char *pc = reinterpret_cast&lt;char*&gt;(ip);
</pre>

        <p class="docText">the programmer must never forget that the actual object addressed by <tt>pc</tt> is an <tt>int</tt>, not a character array. Any use of <tt>pc</tt> that assumes it's an ordinary character pointer is likely to fail <span class="docEmphasis">at run time</span> in interesting ways. For example, using it to initialize a <tt>string</tt> object such as</p>
	<p class="docText">程序员必须永远记得 <tt>pc</tt> 所指向的真实对象其实是 <tt>int</tt> 型，而并非字符数组。任何假设 <tt>pc</tt> 是普通字符指针的应用，都有可能带来有趣的运行时错误。例如，下面语句用 <tt>pc</tt> 来初始化一个 <tt>string</tt> 对象：</p>
        <pre>
     string str(pc);
</pre>

        <p class="docText">is likely to result in bizarre run-time behavior.</p>
        <p class="docText">它可能会引起运行时的怪异行为。</p>

	<a name="idd1e40487"></a><a name="idd1e40490"></a>
        <p class="docText">The use of <tt>pc</tt> to initialize <tt>str</tt> is a good example of why explicit casts are dangerous. The problem is that types are changed, yet there are no warnings or errors from the compiler. When we initialized <tt>pc</tt> with the address of an <tt>int</tt>, there is no error or warning from the compiler because we explicitly said the conversion was okay. Any subsequent use of <tt>pc</tt> will assume that the value it holds is a <tt>char*</tt>. The compiler has no way of knowing that it actually holds a pointer to an <tt>int</tt>. Thus, the initialization of <tt>str</tt> with <tt>pc</tt> is absolutely correctalbeit in this case meaningless or worse! Tracking down the cause of this sort of problem can prove extremely difficult, especially if the cast of <tt>ip</tt> to <tt>pc</tt> occurs in a file separate from the one in which <tt>pc</tt> is used to initialize a <tt>string</tt>.</p>
	<p class="docText">用 <tt>pc</tt> 初始化 <tt>str</tt> 这个例子很好地说明了显式强制转换是多么的危险。问题源于类型已经改变时编译器没有提供任何警告或错误提示。当我们用 <tt>int</tt> 型地址初始化 <tt>pc</tt> 时，由于显式地声明了这样的转换是正确的，因此编译器不提供任何错误或警告信息。后面对 <tt>pc</tt> 的使用都假设它存放的是 <tt>char*</tt> 型对象的地址，编译器确实无法知道 <tt>pc</tt> 实际上是指向 <tt>int</tt> 型对象的指针。因此用 <tt>pc</tt> 初始化 <tt>str</tt> 是完全正确的——虽然实际上是无意义的或是错误的。查找这类问题的原因相当困难，特别是如果 <tt>ip</tt> 到 <tt>pc</tt> 的强制转换和使用 <tt>pc</tt> 初始化 <tt>string</tt> 对象这两个应用发生在不同文件中的时候。</p>

	<a name="ch05sb20"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Advice: Avoid Casts</h2>
	      <h2 class="docSidebarTitle">建议：避免使用强制类型转换</h2>

              <p class="docText"><span class="docEmphStrong">By using a cast, the programmer turns off or dampens normal type-checking (<a class="docLink" href="ch02lev1sec3.html#ch02lev1sec3" >Section 2.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev1sec3" >44</a>). We strongly recommend that programmers avoid casts and believe that most well-formed C++ programs can be written without relying on casts.</span></p>
	      <p class="docText"><span class="docEmphStrong">强制类型转换关闭或挂起了正常的类型检查（<a class="docLink" href="ch02lev1sec3.html#ch02lev1sec3" >第 2.3 节</a>）。强烈建议程序员避免使用强制类型转换，不依赖强制类型转换也能写出很好的 C++ 程序。</span></p>

              <p class="docText"><span class="docEmphStrong">This advice is particularly important regarding use of <tt>reinterpret_casts</tt>. Such casts are always hazardous. Similarly, use of <tt>const_cast</tt> almost always indicates a design flaw. Properly designed systems should not need to cast away <tt>const</tt>. The other casts, <tt>static_cast</tt> and <tt>dynamic_cast</tt>, have their uses but should be needed infrequently. Every time you write a cast, you should think hard about whether you can achieve the same result in a different way. If the cast is unavoidable, errors can be mitigated by limiting the scope in which the cast value is used and by documenting all assumptions about the types involved.</span></p>
	      <p class="docText"><span class="docEmphStrong">这个建议在如何看待 <tt>reinterpret_cast</tt> 的使用时非常重要。此类强制转换总是非常危险的。相似地，使用 <tt>const_cast</tt> 也总是预示着设计缺陷。设计合理的系统应不需要使用强制转换抛弃 <tt>const</tt> 特性。其他的强制转换，如 <tt>static_cast</tt> 和 <tt>dynamic_cast</tt>，各有各的用途，但都不应频繁使用。每次使用强制转换前，程序员应该仔细考虑是否还有其他不同的方法可以达到同一目的。如果非强制转换不可，则应限制强制转换值的作用域，并且记录所有假定涉及的类型，这样能减少错误发生的机会。</span></p>
            </td>
          </tr>
        </table>
        <a name="ch05lev2sec31"></a>

        <h4 class="docSection2Title">5.12.7. Old-Style Casts</h4>
        <h4 class="docSection2Title">5.12.7. 旧式强制类型转换</h4>

        <p class="docText">Prior to the introduction of named cast operators, an explicit cast was performed by enclosing a type in parentheses:</p>
        <p class="docText">在引入命名的强制类型转换操作符之前，显式强制转换用圆括号将类型括起来实现：</p>
        <pre>
     char *pc = (char*) ip;
</pre>

        <p class="docText">The effect of this cast is the same as using the <tt>reinterpret_cast</tt> notation. However, the visibility of this cast is considerably less, making it even more difficult to track down the rogue cast.</p>
	<p class="docText">效果与使用 <tt>reinterpret_cast</tt> 符号相同，但这种强制转换的可视性比较差，难以跟踪错误的转换。</p>

        <p class="docText">Standard C++ introduced the named cast operators to make casts more visible and to give the programmer a more finely tuned tool to use when casts are necessary. For example, nonpointer <tt>static_casts</tt> and <tt>const_casts</tt> tend to be safer than <tt>reinterpret_casts</tt>. As a result, the programmer (as well as readers and tools operating on the program) can clearly identify the potential risk level of each explicit cast in code.</p>
	<p class="docText">标准 C++ 为了加强类型转换的可视性，引入命名的强制转换操作符，为程序员在必须使用强制转换时提供了更好的工具。例如，非指针的  <tt>static_cast</tt>  和 <tt>const_cast</tt> 要比 <tt>reinterpret_cast</tt> 更安全。结果使程序员（以及读者和操纵程序的工具）可清楚地辨别代码中每个显式的强制转换潜在的风险级别。</p>

	<a name="ch05note18"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Although the old-style cast notation is supported by Standard C++, we recommend it be used only when writing code to be compiled either under the C language or pre-Standard C++.</p>
                <p class="docText">虽然标准 C++ 仍然支持旧式强制转换符号，但是我们建议，只有在 C 语言或标准 C++ 之前的编译器上编写代码时，才使用这种语法。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">The old-style cast notation takes one of the following two forms:</p>
        <p class="docText">旧式强制转换符号有下列两种形式：</p>
        <pre>
     type (expr); // <span class="docEmphItalicAlt">Function-style cast notation</span>
     (type) expr; // <span class="docEmphItalicAlt">C-language-style cast notation</span>
</pre>

        <p class="docText">Depending on the types involved, an old-style cast has the same behavior as a <tt>const_cast</tt>, a <tt>static_cast</tt>, ora <tt>reinterpret_cast</tt>. When used where a <tt>static_cast</tt> or a <tt>const_cast</tt> would be legal, an old-style cast does the same conversion as the respective named cast. If neither is legal, then an old-style cast performs a <tt>reinterpret_cast</tt>. For example, we might rewrite the casts from the previous section less clearly using old-style notation:</p>
	<p class="docText">旧式强制转换依赖于所涉及的数据类型，具有与 <tt>const_cast</tt>、 <tt>static_cast</tt> 和 <tt>reinterpret_cast</tt> 一样的行为。在合法使用 <tt>static_cast</tt> 或 <tt>const_cast</tt> 的地方，旧式强制转换提供了与各自对应的命名强制转换一样的功能。如果这两种强制转换均不合法，则旧式强制转换执行 <tt>reinterpret_cast</tt> 功能。例如，我们可用旧式符号重写上一节的强制转换：</p>
        <pre>
     int ival; double dval;
     ival += int (dval); // <span class="docEmphasis">static_cast:</span> <span class="docEmphItalicAlt">converts</span> <span class="docEmphasis">double</span> <span class="docEmphasis">to</span> <span class="docEmphasis">int</span>
     const char* pc_str;
     string_copy((char*)pc_str); // <span class="docEmphasis">const_cast:</span> <span class="docEmphItalicAlt">casts away</span> <span class="docEmphasis">const</span>
     int *ip;
     char *pc = (char*)ip; // <span class="docEmphasis">reinterpret_cast:</span> <span class="docEmphItalicAlt">treats</span> <span class="docEmphasis">int*</span> <span class="docEmphItalicAlt">as</span> <span class="docEmphasis">char*</span>
</pre>

        <p class="docText">The old-style cast notation remains supported for backward compatibility with programs written under pre-Standard C++ and to maintain compatibility with the C language.</p>
        <p class="docText">支持旧式强制转换符号是为了对“在标准 C++ 之前编写的程序”保持向后兼容性，并保持与 C 语言的兼容性。</p>

	<a name="ch05sb21"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 5.12.7</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch05qa15q1"></a><b>Exercise 5.32:</b></td>

                    <td>
                      <p class="docText">Given the following set of definitions,</p>
                      <p class="docText">给定下列定义：</p>
                      <pre>
     char cval;  int ival;   unsigned int ui;
     float fval;             double dval;
</pre><br>

                      <p class="docText">identify the implicit type conversions, if any, taking place:</p>
                      <p class="docText">指出可能发生的（如果有的话）隐式类型转换：</p>
                      <pre>
     (a) cval = 'a' + 3;        (b) fval = ui - ival * 1.0;
     (c) dval = ui * fval;      (d) cval = ival + fval + dval;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch05qa15q2"></a><b>Exercise 5.33:</b></td>

                    <td>
                      <p class="docText">Given the following set of definitions,</p>
                      <p class="docText">给定下列定义：</p>
                      <pre>
     int ival;                         double dval;
     const string *ps;    char *pc;    void *pv;
</pre><br>

                      <p class="docText">rewrite each of the following using a named cast notation:</p>
                      <p class="docText">用命名的强制类型转换符号重写下列语句：</p>
                      <pre>
     (a) pv = (void*)ps;     (b) ival = int(*pc);
     (c) pv = &amp;dval;         (d) pc = (char*) pv;
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch05lev1sec11.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch05lev1sec13.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
