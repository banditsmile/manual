<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 17.2.  Namespaces</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch17lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch17lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch17lev1sec2"></a>

        <h3 class="docSection1Title">17.2. Namespaces</h3>

        <h3 class="docSection1Title">17.2. 命名空间</h3><a name="idd1e138304"></a><a name="idd1e138309"></a><a name="idd1e138315"></a><a name="idd1e138318"></a><a name="idd1e138323"></a><a name="idd1e138328"></a>

        <p class="docText">Every name defined in a given scope must be unique within that scope. This requirement can be difficult to satisfy for large, complex applications. Such applications tend to have many names defined in the global scope. Complex programs composed of independently developed libraries are even more likely to encounter name collisionsthe same name is used in our own code or (more often) in the code supplied to us by independent producers.</p>

        <p class="docText">在一个给定作用域中定义的每个名字在该作用域中必须是唯一的，对庞大、复杂的应用程序而言，这个要求可能难以满足。这样的应用程序的全局作用域中一般有许多名字定义。由独立开发的库构成的复杂程序更有可能遇到名字冲突——同样的名字既可能在我们自己的代码中使用，也可能（更常见地）在独立供应商提供的代码中使用。</p><a name="ch17term19"></a>

        <p class="docText">Libraries tend to define a large number of global namesprimarily names of templates, types and functions. When writing an application using libraries from many different vendors, it is almost inevitable that some of these names will clash. This name-clashing problem is known as the <b><a class="docLink" href="ch17lev1sec5.html#gloss17_19" >namespace pollution</a></b> problem.</p>

        <p class="docText">库倾向于定义许多全局名字——主要是模板名、类型名或函数名。在使用来自多个供应商的库编写应用程序的时候，这些名字中有一些几乎不可避免地会发生冲突，这种名字冲突问题称为<b><a class="docLink" href="ch17lev1sec5.html#gloss17_19" >命名空间污染</a></b>问题。</p>

        <p class="docText">Traditionally, programmers avoided namespace pollution by making names of global entities very long, often prefixing the names in their program with specific character sequences:</p>

        <p class="docText">传统上，程序员通过将全局实体的名字设得很长来避免命名空间污染，经常用特定字符序列作为程序中名字的前缀：</p>
        <pre>
     class cplusplus_primer_Query { ... };
     ifstream&amp;
     cplusplus_primer_open_file(ifstream&amp;, const string&amp;);
</pre><br>
        <a name="ch17term17"></a>

        <p class="docText">This solution is far from ideal: It can be cumbersome for programmers to write and read programs that use such long names. <b><a class="docLink" href="ch17lev1sec5.html#gloss17_17" >Namespaces</a></b> provide a much more controlled mechanism for preventing name collisions. Namespaces partition the global namespace, making it easier to use independently produced libraries. A namespace is a scope. By defining a library's names inside a namespace, library authors (and users) can avoid the limitations inherent in global names.</p>

        <p class="docText">这个解决方案很不理想：程序员编写和阅读使用这种长名字的程序非常麻烦。<b><a class="docLink" href="ch17lev1sec5.html#gloss17_17" >命名空间</a></b>为防止名字冲突提供了更加可控的机制，命名空间能够划分全局命名空间，这样使用独立开发的库就更加容易了。一个命名空间是一个作用域，通过在命名空间内部定义库中的名字，库的作者（以及用户）可以避免全局名字固有的限制。</p><a name="ch17lev2sec12"></a>

        <h4 class="docSection2Title">17.2.1. Namespace Definitions</h4>

        <h4 class="docSection2Title">17.2.1. 命名空间的定义</h4>

        <p class="docText">A namespace definition begins with the keyword <tt>namespace</tt> followed by the namespace name.</p>

        <p class="docText">命名空间定义以关键字 <tt>namespace</tt> 开始，后接命名空间的名字。</p>
        <pre>
     namespace cplusplus_primer {
         class Sales_item { /* ... */};
         Sales_item operator+(const Sales_item&amp;,
                              const Sales_item&amp;);
         class Query {
         public:
             Query(const std::string&amp;);
             std::ostream &amp;display(std::ostream&amp;) const;
             // ...
         };
         class Query_base { /* ... */};
     }
</pre><br>

        <p class="docText">This code defines a namespace named <tt>cplusplus_primer</tt> with four members: two classes, an overloaded <tt>+</tt> operator, and a function.</p>

        <p class="docText">这段代码定义了名为 <tt>cplusplus_primer</tt> 的命名空间，它有四个成员：两个类，一个重载的 <tt>+</tt> 操作符，一个函数。</p><a name="idd1e138382"></a><a name="idd1e138387"></a><a name="idd1e138392"></a><a name="idd1e138397"></a>

        <p class="docText">As with other names, the name of a namespace must be unique within the scope in which the namespace is defined. Namespaces may be defined at global scope or inside another namespace. They may not be defined inside a function or a class.</p>

        <p class="docText">像其他名字一样，命名空间的名字在定义该命名空间的作用域中必须是唯一的。命名空间可以在全局作用域或其他作用域内部定义，但不能在函数或类内部定义。</p>

        <p class="docText">Following the namespace name is a block of declarations and definitions delimited by curly braces. Any declaration that can appear at global scope can be put into a namespace: classes, variables (with their initializations), functions (with their definitions), templates, and other namespaces.</p>

        <p class="docText">命名空间名字后面接着由花括号括住的一块声明和定义，可以在命名空间中放入可以出现在全局作用域的任意声明：类、变量（以及它们的初始化）、函数（以及它们的定义）、模板以及其他命名空间。</p><a name="ch17note19"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A namespace scope does not end with a semicolon.</p>

                <p class="docText">命名空间作用域不能以分号结束。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch17lev3sec29"></a>

        <h5 class="docSection3Title">Each Namespace Is a Scope</h5>

        <h5 class="docSection3Title">每个命名空间是一个作用域</h5>

        <p class="docText">The entities defined in a namespace are called namespace members. Just as is the case for any scope, each name in a namespace must refer to a unique entity within that namespace. Because different namespaces introduce different scopes, different namespaces may have members with the same name.</p>

        <p class="docText">定义在命名空间中的实体称为命名空间成员。像任意作用域的情况一样，命名空间中的每个名字必须引用该命名空间中的唯一实体。因为不同命名空间引入不同作用域，所以不同命名空间可以具有同名成员。</p>

        <p class="docText">Names defined in a namespace may be accessed directly by other members of the namespace. Code outside the namespace must indicate the namespace in which the name is defined:</p>

        <p class="docText">在命名空间中定义的名字可以被命名空间中的其他成员直接成员，命名空间外部的代码必须指出名字定义在哪个命名空间中：</p>
        <pre>
     cplusplus_primer::Query q =
                     cplusplus_primer::Query("hello");
     q.display(cout);
     // ...
</pre><br>

        <p class="docText">If another namespace (say, <tt>AddisonWesley</tt>) also provides a <tt>TextQuery</tt> class and we want to use that class instead of the one defined in <tt>cplusplus_primer</tt>, we can do so by modifying our code as follows:</p>

        <p class="docText">如果另一命名空间（如 <tt>AddisonWesley</tt>）也提供 <tt>TextQuery</tt> 类，而且我们想要使用那个类代替 <tt>cplusplus_primer</tt> 中定义的 <tt>TextQuery</tt>，可以通过这样修改代码而实现：</p>
        <pre>
     AddisonWesley::Query q = AddisonWesley::Query("hello");
     q.display(cout);
     // ...
</pre><br>
        <a name="ch17lev3sec30"></a>

        <h5 class="docSection3Title">Using Namespace Members from Outside the Namespace</h5>

        <h5 class="docSection3Title">从命名空间外部使用命名空间成员</h5>

        <p class="docText">Of course, always referring to a namespace member using the qualified name</p>

        <p class="docText">当然，总是使用限定名</p>
        <pre>
     namespace_name::member_name
</pre><br>

        <p class="docText">can be cumbersome. Just as we've been doing for names defined in the <tt>std</tt> namespace, we can write a <tt>using</tt> declaration (<a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1" >Section 3.1</a>, p. <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1" >78</a>) to obtain direct access to names we know we'll use frequently:</p>

        <p class="docText">引用命名空间成员可能非常麻烦。像对 <tt>std</tt> 中定义的命名空间所做的那样，可以编写 <tt>using</tt> 声明（<a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1" >第 3.1 节</a>）来获得对我们知道将经常使用的名字的直接访问：</p>
        <pre>
     using cplusplus_primer::Query;
</pre><br>

        <p class="docText">After this <tt>using</tt> declaration, our program can use the name <tt>Query</tt> directly without the <tt>cplusplus_primer</tt> qualifier. We'll see other ways to simplify access in <a class="docLink" href="ch17lev1sec2.html#ch17lev2sec15">Section 17.2.4</a> (p. <a class="docLink" href="ch17lev1sec2.html#ch17lev2sec15">720</a>).</p>

        <p class="docText">在这个 <tt>using</tt> 声明之后，程序可以无须 <tt>cplusplus_primer</tt> 限定符而直接使用名字 <tt>Query</tt>，在<a class="docLink" href="ch17lev1sec2.html#ch17lev2sec15">第 17.2.4 节</a>将介绍简化访问的其他方法。</p><a name="ch17lev3sec31"></a>

        <h5 class="docSection3Title">Namespaces Can Be Discontiguous</h5>

        <h5 class="docSection3Title">命名空间可以是不连续的</h5><a name="idd1e138517"></a><a name="idd1e138524"></a><a name="idd1e138529"></a><a name="idd1e138536"></a><a name="idd1e138543"></a><a name="idd1e138548"></a>

        <p class="docText">Unlike other scopes, a namespace can be defined in several parts. A namespace is made up of the sum of its separately defined parts; a namespace is cumulative. The separate parts of a namespace can be spread over multiple files. Namespace definitions in different text files are also cumulative. Of course, the usual restriction continues to apply that names are visible only in the files in which they are declared. So, if one part of the namespace requires a name defined in another file, that name must still be declared.</p>

        <p class="docText">与其他作用域不同，命名空间可以在几个部分中定义。命名空间由它的分离定义部分的总和构成，命名空间是累积的。一个命名空间的分离部分可以分散在多个文件中，在不同文本文件中的命名空间定义也是累积的。当然，名字只在声明名字的文件中可见，这一常规限制继续应用，所以，如果命名空间的一个部分需要定义在另一文件中的名字，仍然必须声明该名字。</p>

        <p class="docText">Writing a namespace definition</p>

        <p class="docText">编写命名空间定义：</p>
        <pre>
     namespace <span class="docEmphasis">namespace_name</span> {
     // <span class="docEmphItalicAlt">declarations</span>
     }
</pre><br>

        <p class="docText">either defines a new namespace or adds to an existing one.</p>

        <p class="docText">既可以定义新的命名空间，也可以添加到现在命名空间中。</p>

        <p class="docText">If the name <span class="docEmphasis">namespace_name</span> does not refer to a previously defined namespace, then a new namespace with that name is created. Otherwise, this definition opens an existing namespace and adds these new declarations to that namespace.</p>

        <p class="docText">如果名字 <span class="docEmphasis">namespace_name</span> 不是引用前面定义的命名空间，则用该名字创建新的命名空间，否则，这个定义打开一个已存在的命名空间，并将这些新声明加到那个命名空间。</p><a name="ch17lev3sec32"></a>

        <h5 class="docSection3Title">Separation of Interface and Implementation</h5>

        <h5 class="docSection3Title">接口和实现的分离</h5>

        <p class="docText">The fact that namespace definitions can be discontiguous means that we can compose a namespace from separate interface and implementation files. Thus, a namespace can be organized in the same way that we manage our own class and function definitions:</p>

        <p class="docText">命名空间定义可以不连续意味着，可以用分离的接口文件和实现文件构成命名空间，因此，可以用与管理自己的类和函数定义相同的方法来组织命名空间：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">Namespace members that define classes and declarations for the functions and objects that are part of the class interface can be put into header files. These headers can be included by files that use namespace members.</p>

                <p class="docList">定义类的命名空间成员，以及作为类接口的一部分的函数声明与对象声明，可以放在头文件中，使用命名空间成员的文件可以包含这些头文件。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">The definitions of namepsace members can be put in separate source files.</p>

                <p class="docList">命名空间成员的定义可以放在单独的源文件中。</p>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">Organizing our namespaces this way also satisfies the requirement that various entitiesnon-inline functions, static data members, variables, and so forthmay be defined only once in a program. This requirement applies equally to names defined in a namespace. By separating the interface and implementation, we can ensure that the functions and other names we need are defined only once, but the same declaration will be seen whenever the entity is used.</p>

        <p class="docText">按这种方式组织命名空间，也满足了不同实体（非内联函数、静态数据成员、变量等）只能在一个程序中定义一次的要求，这个要求同样适用于命名空间中定义的名字。通过将接口和实现分离，可以保证函数和其他我们需要的名字只定义一次，但相同的声明可以在任何使用该实体的地方见到。</p><a name="ch17note20"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Namespaces that define multiple, unrelated types should use separate files to represent each type that the namespace defines.</p>

                <p class="docText">定义多个不相关类型的命名空间应该使用分离的文件，表示该命名空间定义的每个类型。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch17lev3sec33"></a>

        <h5 class="docSection3Title">Defining the Primer Namespace</h5>

        <h5 class="docSection3Title">定义本书的命名空间</h5>

        <p class="docText">Using this strategy for separating interface and implementation, we might define the <tt>cplusplus_primer</tt> library in several separate files. The declarations for <tt>Sales_item</tt> and its related functions that we built in <a class="docLink" href="part01.html#part01" >Part I</a> (p. <a class="docLink" href="part01.html#part01" >31</a>) would be placed in <tt>Sales_item.h</tt>, those for the <tt>Query</tt> classes of <a class="docLink" href="ch15.html#ch15" >Chapter 15</a> (p. <a class="docLink" href="ch15.html#ch15" >557</a>) in <tt>Query.h</tt>, and so on. The corresponding implementation files would be in files such as <tt>Sales_item.cc</tt> and <tt>Query.cc:</tt></p>

        <p class="docText">使用将接口和实现分离的策略，可以将 <tt>cplusplus_primer</tt> 库定义在几个分离的文件中。本书第一部分建立的 <tt>Sales_item</tt> 的声明及其相关函数可以放在 <a class="docLink" href="part01.html#part01" ></a><tt>Sales_item.h</tt> 中，<a class="docLink" href="ch15.html#ch15" >第十五章</a>的 <tt>Query</tt> 类的定义以及相关函数放在 <tt>Query.h</tt> 中，以此类推。对应的实现文件可以是 <tt>Sales_item.cc</tt> 和 <tt>Query.cc:</tt>：</p>
        <pre>
     // <span class="docEmphItalicAlt">---- Sales_item.h ----</span>
     namespace cplusplus_primer {
         class Sales_item { /* ... */};
         Sales_item operator+(const Sales_item&amp;,
                              const Sales_item&amp;);
         // <span class="docEmphItalicAlt">declarations for remaining functions in the</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">interface</span>
     }
     // <span class="docEmphItalicAlt">---- Query.h ----</span>
     namespace cplusplus_primer {
         class Query {
         public:
             Query(const std::string&amp;);
             std::ostream &amp;display(std::ostream&amp;) const;
             // ...
         };
         class Query_base { /* ... */};
     }
     // <span class="docEmphItalicAlt">---- Sales_item.cc ----</span>
     #include "Sales_item.h"
     namespace cplusplus_primer {
     // <span class="docEmphItalicAlt">definitions for</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">members and overloaded operators</span>
     }
     // <span class="docEmphItalicAlt">---- Query.cc ----</span>
     #include "Query.h"
     namespace cplusplus_primer {
         // <span class="docEmphItalicAlt">definitions for</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">members and related functions</span>
     }
</pre><br>

        <p class="docText">This program organization gives both the developers and users of our library the needed modularity. Each class is still organized into its own interface and implementation files. A user of one class need not compile names related to the others. We can hide the implementations from our users, while allowing the files <tt>Sales_item.cc</tt> and <tt>user.cc</tt> to be compiled and linked into one program without causing any compile-time or link-time error. Developers of the library can work independently on the implementation of each type.</p>

        <p class="docText">这种程序组织给予开发者和库用户必要的模块性。每个类仍组织在自己的接口和实现文件中，一个类的用户不必编译与其他类相关的名字。如果允许 <tt>Sales_item.cc</tt> 和 <tt>user.cc</tt> 文件编译和链接到一个程序而不会导致编译时错误和运行时错误，就可以对用户隐藏实现。库的开发者可以独立工作于每个类型的实现。</p>

        <p class="docText">A program using our library would include whichever headers it needed. The names in those headers are defined inside the <tt>cplusplus_primer</tt> namespace:</p>

        <p class="docText">使用我们的库的程序可以包含需要的头文件，那些头文件中的名字定义在命名空间 <tt>cplusplus_primer</tt> 内部：</p>
        <pre>
     // <span class="docEmphItalicAlt">---- user.cc ----</span>
     // <span class="docEmphItalicAlt">defines the</span> <span class="docEmphasis">cplusplus_primer::Sales_item</span> <span class="docEmphItalicAlt">class</span>
     #include "Sales_item.h"
     int main()
     {
         // ...
         cplusplus_primer::Sales_item trans1, trans2;
         // ...
         return 0;
     }
</pre><br>
        <a name="ch17lev3sec34"></a>

        <h5 class="docSection3Title">Defining Namespace Members</h5>

        <h5 class="docSection3Title">定义命名空间成员</h5><a name="idd1e138741"></a><a name="idd1e138748"></a><a name="idd1e138751"></a><a name="idd1e138756"></a><a name="idd1e138761"></a><a name="idd1e138768"></a>

        <p class="docText">Functions defined inside a namespace may use the short form for names defined in the same namespace:</p>

        <p class="docText">在命名空间内部定义的函数可以使用同一命名空间中定义的名字的简写形式：</p>
        <pre>
     namespace cplusplus_primer {
     // <span class="docEmphItalicAlt">members defined inside the namespace may use unqualified names</span>
     std::istream&amp;
     operator&gt;&gt;(std::istream&amp; in, Sales_item&amp; s)
     {
         // ...
     }
</pre><br>

        <p class="docText">It is also possible to define a namespace member outside its namespace definition. We do so in ways that are similar to defining class members outside a class: The namespace declaration of the name must be in scope, and the definition must specify the namespace to which the name belongs:</p>

        <p class="docText">也可以在命名空间定义的外部定义命名空间成员，用类似于在类外部定义类成员的方式：名字的命名空间声明必须在作用域中，并且定义必须指定该名字所属的命名空间：</p>
        <pre>
     // <span class="docEmphItalicAlt">namespace members defined outside the namespace must use qualified names</span>
     cplusplus_primer::Sales_item
     cplusplus_primer::operator+(const Sales_item&amp; lhs,
                                 const Sales_item&amp; rhs)
     {
         Sales_item ret(lhs);
         // ...
     }
</pre><br>

        <p class="docText">This definition should look similar to class member functions defined outside a class. The return type and function name are qualified by the namespace name. Once the fully qualified function name is seen, we are in the scope of the namespace. Thus, references to namespace members in the parameter list and the function body can use unqualified names to reference <tt>Sales_item</tt>.</p>

        <p class="docText">这个定义看起来类似于定义在类外部的类成员函数，返回类型和函数名由命名空间名字限定。一旦看到完全限定的函数名，就处于命名空间的作用域中。因此，形参表和函数体中的命名空间成员引用可以使用非限定名引用 <tt>Sales_item</tt>。</p><a name="ch17lev3sec35"></a>

        <h5 class="docSection3Title">Members May Not Be Defined in Unrelated Namespaces</h5>
        <h5 class="docSection3Title">不能在不相关的命名空间中定义成员</h5>


        <br>
	<p class="docText">Although a namespace member can be defined outside its namespace definition, there are restrictions on where this definition can appear. Only namespaces enclosing the member declaration can contain its definition. For example, <tt>operator+</tt> could be defined in either the <tt>cplusplus_primer</tt> namespace or at global scope. It may not be defined in an unrelated namespace.</p>
	<p class="docText">虽然可以在命名空间定义的外部定义命名空间成员，对这个定义可以出现的地方仍有些限制，只有包围成员声明的命名空间可以包含成员的定义。例如，<tt>operator+</tt> 既可以定义在命名空间 <tt>cplusplus_primer</tt> 中，也可以定义在全局作用域中，但它不能定义在不相关的命名空间中。</p>

        <a name="ch17lev3sec36"></a>
        <h5 class="docSection3Title">The Global Namespace</h5>
        <h5 class="docSection3Title">全局命名空间</h5>

        <a name="ch17term15"></a>
<p class="docText">Names defined at global scopenames declared outside any class, function, or namespaceare defined inside the <b><a class="docLink" href="ch17lev1sec5.html#gloss17_15" >global namespace</a></b>. The global namespace is implicitly declared and exists in every program. Each file that defines entities at global scope adds those names to the global namespace.</p>
<p class="docText">定义在全局作用域的名字（在任意类、函数或命名空间外部声明的名字）是定义在<b><a class="docLink" href="ch17lev1sec5.html#gloss17_15" >全局命名空间</a></b>中的。全局命名空间是隐式声明的，存在于每个程序中。在全局作用域定义实体的每个文件将那些名字加到全局命名空间。</p>

        <a name="ch17term22"></a>
        <br>
	<p class="docText">The <span class="docEmphRoman"><a class="docLink" href="ch17lev1sec5.html#gloss17_22" >scope operator</a></span> can be used to refer to members of the global namespace. Because the global namespace is implicit, it does not have a name; the notation</p>
	<p class="docText">可以用<span class="docEmphRoman"><a class="docLink" href="ch17lev1sec5.html#gloss17_22" >作用域操作符</a></span>引用全局命名空间的成员。因为全局命名空间是隐含的，它没有名字，所以记号</p>
        
        <pre>
     ::member_name
</pre>

<p class="docText">refers to a member of the global namespace.</p>
<p class="docText">引用全局命名空间的成员。</p>

        <a name="ch17sb08"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 17.2.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa7q1"></a><b>Exercise 17.13:</b></td>

                    <td>
                      <a name="idd1e138861"></a><a name="idd1e138866"></a>

                      <p class="docText">Define the bookstore exception classes described in <a class="docLink" href="ch17lev1sec1.html#ch17lev2sec7" >Section 17.1.7</a> (p. <a class="docLink" href="ch17lev1sec1.html#ch17lev2sec7" >697</a>) as members of namespace named <tt>Bookstore</tt>.</p>

                      <p class="docText">定义<a class="docLink" href="ch17lev1sec1.html#ch17lev2sec7" >第 17.7 节</a>描述的书店异常类，作为名为 <tt>Bookstore</tt> 的命名空间的成员。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa7q2"></a><b>Exercise 17.14:</b></td>

                    <td>
                      <p class="docText">Define <tt>Sales_item</tt> and its operators inside the <tt>Bookstore</tt> namespace. Define the addition operator to throw an exception.</p>

                      <p class="docText">在命名空间 <tt>Bookstore</tt> 内部定义 <tt>Sales_item</tt> 及其操作符。定义加操作符抛出一个异常。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa7q3"></a> <b>Exercise 17.15:</b></td>

                    <td>
                      <p class="docText">Write a program that uses the <tt>Sales_item</tt> addition operator and handles any exceptions. Make this program a member of another namespace named <tt>MyApp</tt>. This program should use the exception classes defined in the <tt>Bookstore</tt> namespace by the previous exercise.</p>

                      <p class="docText">编写一个程序，使用 <tt>Sales_item</tt> 加操作符并处理任何异常。使这个程序成为名为 <tt>MyApp</tt> 的另一命名空间的成员。这个程序应使用上题中在命名空间 <tt>Bookstore</tt> 中定义的异常类。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
<br>

        <a name="ch17lev2sec13"></a>
        <h4 class="docSection2Title">17.2.2. Nested Namespaces</h4>
        <h4 class="docSection2Title">17.2.2. 嵌套命名空间</h4>

<p class="docText">A nested namespace is a nested scopeits scope is nested within the namespace that contains it. Names in nested namespaces follow the normal rules: Names declared in an enclosing namespace are hidden by declarations of the same name in a nested namespace. Names defined inside a nested namespace are local to that namespace. Code in the outer parts of the enclosing namespace may refer to a name in a nested namespace only through its qualified name.</p>
<p class="docText">一个嵌套命名空间即是一个嵌套作用域——其作用域嵌套在包含它的命名空间内部。嵌套命名空间中的名字遵循常规规则：外围命名空间中声明的名字被嵌套命名空间中同一名字的声明所屏蔽。嵌套命名空间内部定义的名字局部于该命名空间。外围命名空间之外的代码只能通过限定名引用嵌套命名空间中的名字。</p>

<p class="docText">Nested namespaces can improve the organization of code in a library:</p>
<p class="docText">嵌套命名空间可以改进库中代码的组织：</p>
        
        <pre>
     namespace cplusplus_primer {
         // <span class="docEmphItalicAlt">first nested namespace:</span>
         // <span class="docEmphItalicAlt">defines the</span> <span class="docEmphasis">Query</span> <span class="docEmphItalicAlt">portion of the library</span>
         namespace QueryLib {
             class Query { /* ... */ };
             Query operator&amp;(const Query&amp;, const Query&amp;);
             // ...
         }
         // <span class="docEmphItalicAlt">second nested namespace:</span>
         // <span class="docEmphItalicAlt">defines the</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">portion of the library</span>
         namespace Bookstore {
             class Item_base { /* ... */ };
             class Bulk_item : public Item_base { /* ... */ };
             // ...
         }
     }
</pre>
<br>

<p class="docText">The <tt>cplusplus_primer</tt> namespace now contains two nested namespaces: the namespaces named <tt>QueryLib</tt> and <tt>Bookstore</tt>.</p>
<p class="docText">命名空间 <tt>cplusplus_primer</tt> 现在包含两个嵌套命名空间：名为 <tt>QueryLib</tt> 的命名空间和名为 <tt>Bookstore</tt> 的命名空间。</p>

<p class="docText">Nested namespaces are useful when a library provider needs to prevent names in each part of a library from colliding with names in other parts of the library.</p>
<p class="docText">当库提供者需要防止库中每个部分的名字与库中其他部分的名字冲突的时候，嵌套命名空间是很有用的。</p>

<p class="docText">The name of a member in a nested namespace is formed from the names of the enclosing namespace(s) and the name of the nested namespace. For example, the name of the class declared in the nested namespace <tt>QueryLib</tt> is</p>
<p class="docText">嵌套命名空间中成员的名字由外围命名空间的名字和嵌套命名空间的名字构成。例如，嵌套命名空间 <tt>QueryLib</tt> 中声明的类的名字是</p>
        
        <pre>
     cplusplus_primer::QueryLib::Query
</pre>
<br>

        <a name="ch17sb09"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 17.2.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa8q1"></a><b>Exercise 17.16:</b></td>

                    <td>
                      <a name="idd1e139003"></a><a name="idd1e139008"></a><a name="idd1e139015"></a><a name="idd1e139018"></a>

                      <p class="docText">Organize the programs you have written to answer the questions in each chapter into its own namespace. That is, namespace <tt>chapterrefinheritance</tt> would contain code for the <tt>Query</tt> programs and <tt>chapterrefalgs</tt> would contain the <tt>TextQuery</tt> code. Using this structure, compile the <tt>Query</tt> code examples.</p>

                      <p class="docText">将为回答每章中的问题而编写的程序组织到每一章自己的命名空间中，也就是说，命名空间 <tt>chapterrefinheritance</tt> 将包含 <tt>Query</tt> 程序的代码，而 <tt>chapterrefalgs</tt> 将包含 <tt>TextQuery</tt> 代码。使用这个结构，编译 <tt>Query</tt> 代码示例。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa8q2"></a><b>Exercise 17.17:</b></td>

                    <td>
                      <p class="docText">Over the course of this primer, we defined two different classes named <tt>Sales_item:</tt> the initial simple class defined and used in <a class="docLink" href="part01.html#part01" >Part I</a>, and the handle class defined in <a class="docLink" href="ch15lev1sec8.html#ch15lev2sec21" >Section 15.8.1</a> that interfaced to the <tt>Item_base</tt> inheritance hierarchy. Define two namespaces nested inside the <tt>cplusplus_primer</tt> namespace that could be used to distinguish these two class definitions.</p>

                      <p class="docText">在本书中，我们定义了两个名为 <tt>Sales_item</tt> 的不同类：在<a class="docLink" href="part01.html#part01" >第一部</a>分定义和使用的初始简单类，以及在<a class="docLink" href="ch15lev1sec8.html#ch15lev2sec21" >第 15.8.1 节</a>定义的与 <tt>Item_base</tt> 继承层次接口的句柄类。在命名空间 <tt>cplusplus_primer</tt> 内部定义两个嵌套命名空间，用于区别这两个类定义。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
<br>

        <a name="ch17lev2sec14"></a>
        <h4 class="docSection2Title">17.2.3. Unnamed Namespaces</h4>
        <h4 class="docSection2Title">17.2.3. 未命名的命名空间</h4>

        <a name="ch17term28"></a>
<p class="docText">A namespace may be unnamed. An <b><a class="docLink" href="ch17lev1sec5.html#gloss17_28" >unnamed namespace</a></b> is a namespace that is defined without a name. An unnamed namespace begins with the keyword <tt>namespace</tt>. Following the <tt>namespace</tt> keyword is a block of declarations delimited by curly braces.</p>
<p class="docText">命名空间可以是未命名的，<b><a class="docLink" href="ch17lev1sec5.html#gloss17_28" >未命名的命名空间</a></b>在定义时没有给定名字。未命名的命名空间以关键字 <tt>namespace</tt> 开头，接在关键字 <tt>namespace</tt> 后面的是由花括号定界的声明块。</p>

        <a name="ch17note21"></a>
        
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Unnamed namespaces are not like other namespaces; the definition of an unnamed namespace is local to a particular file and never spans multiple text files.</p>

                <p class="docText">未命名的命名空间与其他命名空间不同，未命名的命名空间的定义局部于特定文件，从不跨越多个文本文件。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

<p class="docText">An unnamed namespace may be discontiguous within a given file but does not span files. Each file has its own unnamed namespace.</p>
<p class="docText">未命名的命名空间可以在给定文件中不连续，但不能跨越文件，每个文件有自己的未命名的命名空间。</p>

<p class="docText">Unnamed namespaces are used to declare entities that are local to a file. Variables defined in an unnamed namespace are created when the program is started and exist until the program ends.</p>
<p class="docText">未命名的命名空间用于声明局部于文件的实体。在未命名的命名空间中定义的变量在程序开始时创建，在程序结束之前一直存在。</p>

<p class="docText">Names defined in an unnamed namespace are used directly; after all, there is no namespace name with which to qualify them. It is not possible to use the scope operator to refer to members of unnamed namespaces.</p>
<p class="docText">未命名的命名空间中定义的名字可直接使用，毕竟，没有命名空间名字来限定它们。不能使用作用域操作符来引用未命名的命名空间的成员。</p>

<p class="docText">Names defined in an unnamed namespace are visible only to the file containing the namespace. If another file contains an unnamed namespace, the namespaces are unrelated. Both unnamed namespaces could define the same name, and the definitions would refer to different entities.</p>
<p class="docText">未命名的命名空间中定义的名字只在包含该命名空间的文件中可见。如果另一文件包含一个未命名的命名空间，两个命名空间不相关。两个命名空间可以定义相同的名字，而这些定义将引用不同的实体。</p>

<p class="docText">Names defined in an unnamed namespace are found in the same scope as the scope at which the namespace is defined. If an unnamed namespace is defined at the outermost scope in the file, then names in the unnamed namespace must differ from names defined at global scope:</p>
<p class="docText">未命名空间中定义的名字可以在定义该命名空间所在的作用域中找到。如果在文件的最外层作用域中定义未命名的命名空间，那么，未命名的空间中的名字必须与全局作用域中定义的名字不同：</p>
        
        <pre>
     int i;   // <span class="docEmphItalicAlt">global declaration for</span> <span class="docEmphasis">i</span>
     namespace {
         int i;
     }
     // <span class="docEmphItalicAlt">error: ambiguous defined globally and in an unnested, unnamed namespace</span>
     i = 10;
</pre>
<br>

        <a name="idd1e139129"></a><a name="idd1e139134"></a><a name="idd1e139143"></a><a name="idd1e139148"></a>
<p class="docText">An unnamed namespace, like any other namespace, may be nested inside another namespace. If the unnamed namespace is nested, then names in it are accessed in the normal way, using the enclosing namespace name(s):</p>
<p class="docText">像任意其他命名空间一样，未命名的命名空间也可以嵌套在另一命名空间内部。如果未命名的命名空间是嵌套的，其中的名字按常规方法使用外围命名空间名字访问：</p>
        
        <pre>
     namespace local {
        namespace {
            int i;
        }
     }
        // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">i</span> <span class="docEmphItalicAlt">defined in a nested unnamed namespace is distinct from global</span> <span class="docEmphasis">i</span>
        local::i = 42;
</pre>
<br>

        <a name="ch17note22"></a>
        
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">If a header defines an unnamed namespace then the names in that namespace will define different local entities in each file that includes the header.</p>

                <p class="docText">如果头文件定义了未命名的命名空间，那么，在每个包含该头文件的文件中，该命名空间中的名字将定义不同的局部实体。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

<p class="docText">In all other ways, the members of an unnamed namespace are normal program entities.</p>
<p class="docText">在所有其他方式中，未命名的命名空间的成员都是普通程序实体。</p>

        <a name="ch17sb10"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Unnamed Namespaces Replace File Statics</h2>
              <h2 class="docSidebarTitle">未命名的命名空间取代文件中的静态声明</h2><a name="ch17term13"></a>

              <p class="docText"><span class="docEmphStrong">Prior to the introduction of namespaces in standard C++, programs had to declare names as <tt>static</tt> to make them local to a file. The use of <b><a class="docLink" href="ch17lev1sec5.html#gloss17_13" >file statics</a></b> is inherited from C. In C, a global entity declared <tt>static</tt> is invisible outside the file in which it is declared.</span></p>

              <p class="docText"><span class="docEmphStrong">在标准 C++ 中引入命名空间之前，程序必须将名字声明为 <tt>static</tt>，使它们局部于一个文件。<b><a class="docLink" href="ch17lev1sec5.html#gloss17_13" >文件中静态声明</a></b>的使用从 C 语言继承而来，在 C 语言中，声明为 <tt>static</tt> 的局部实体在声明它的文件之外不可见。</span></p><a name="ch17note23"></a>

              <div class="docNote">
                <table width="90%" border="0" cellspacing="0" cellpadding="1">
                  <tr>
                    <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

                    <td valign="top">
                      <p class="docText"><span class="docEmphStrong">The use of file static declarations is <span class="docEmphasis">deprecated</span> by the C++ standard. A deprecated feature is one that may not be supported in future releases. File statics should be avoided and unnamed namespaces used instead.</span></p>

                      <p class="docText"><span class="docEmphStrong">C++ <span class="docEmphasis">不赞成</span>文件静态声明。不造成的特征是在未来版本中可能不支持的特征。应该避免文件静态而使用未命名空间代替。</span></p>
                    </td>
                  </tr>
                </table><br>
              </div><br>
            </td>
          </tr>
        </table>
<br>

        <a name="ch17sb11"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 17.2.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa9q1"></a><b>Exercise 17.18:</b></td>

                    <td>
                      <p class="docText">Why would you define your own namespace in your programs? When might you use an unnamed namespace?</p>

                      <p class="docText">为什么在程序中可以定义自己的命名空间？何时可以使用未命名空间？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa9q2"></a><b>Exercise 17.19:</b></td>

                    <td>
                      <p class="docText">Suppose we have the following declaration of the <tt>operator*</tt> that is a member of the nested namespace <tt>cplusplus_primer::MatrixLib:</tt></p>

                      <p class="docText">假定有下面的 <tt>operator*</tt> 的声明，<tt>operator*</tt> 是嵌套命名空间 <tt>cplusplus_primer::MatrixLib:</tt> 的成员：</p>
                      <pre>
     namespace cplusplus_primer {
         namespace MatrixLib {
             class matrix { /* ... */ };
             matrix operator*
                    (const matrix &amp;, const matrix &amp;);
             // ...
         }
     }
</pre><br>

                      <p class="docText">How would you define this operator in global scope? Provide only the prototype for the operator's definition.</p>

                      <p class="docText">怎样在全局作用域中定义这个操作符？只需给出操作符定义的原型。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
<br>

        <a name="ch17lev2sec15"></a>
        <h4 class="docSection2Title">17.2.4. Using Namespace Members</h4>
        <h4 class="docSection2Title">17.2.4. 命名空间成员的使用</h4>


        <a name="idd1e139272"></a><a name="idd1e139275"></a><a name="idd1e139281"></a><a name="idd1e139284"></a><a name="idd1e139291"></a><a name="idd1e139296"></a>
        <br>
<p class="docText">Referring to namespace members as <tt>namespace_name::member_name</tt> is admittedly cumbersome, especially if the namespace name is long. Fortunately, there are ways to make it easier to use namespace members. Our programs have used one of these ways, <tt>using</tt> declarations (<a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1" >Section 3.1</a>, p. <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1" >78</a>). The others, namespace aliases and <tt>using</tt> directives, will be described in this section.</p>
<p class="docText">像命名空间名 <tt>namespace_name::member_name</tt> 成员名这样引用命名空间的成员无可否认是很麻烦，特别是，命名空间名字很长的时候。幸好，有办法让使用命名空间成员比较容易。我们的程序已经使用了其中的一种方法，就是 <tt>using</tt>（<a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1" >第 3.1 节</a>），本节将介绍其他方法：命名空间别名和 <tt>using</tt> 指示。</p>

        <a name="ch17note24"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Header files should not contain <tt>using</tt> directives or <tt>using</tt> declarations except inside functions or other scopes. A header that includes a <tt>using</tt> directive or declaration at its top level scope has the effect of injecting that name into the file that includes the header. Headers should define only the names that are part of its interface, not names used in its own implementation.</p>

                <p class="docText">除了在函数或其他作用域内部，头文件不应该包含 <tt>using</tt> 指示或 <tt>using</tt> 声明。在其顶级作用域包含 <tt>using</tt> 指示或 <tt>using</tt> 声明的头文件，具有将该名字注入包含该头文件的文件中的效果。头文件应该只定义作为其接口的一部分的名字，不要定义在其实现中使用的名字。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

        <a name="ch17lev3sec37"></a>
        

        <h5 class="docSection3Title"><tt>using</tt> Declarations, a Recap</h5>
        <h5 class="docSection3Title"><tt>using</tt> 声明，扼要重述</h5>

        <a name="ch17term29"></a>
<p class="docText">The programs in this book that use names from the standard library generally assume that an appropriate <b><a class="docLink" href="ch17lev1sec5.html#gloss17_29" ><span class="docEmphStrong"><tt>using</tt> declaration</span></a></b> has been made:</p>
<p class="docText">本书中使用标准库中名字的程序一般假设进行了适当的 <b><a class="docLink" href="ch17lev1sec5.html#gloss17_29" ><span class="docEmphStrong">using <tt>声明</tt></span></a></b>：</p>
        
        <pre>
     map&lt;string, vector&lt; pair&lt;size_t, size_t&gt; &gt; &gt; word_map;
</pre>
<br>

<p class="docText">assumes that the following <tt>using</tt> declarations have been made:</p>
<p class="docText">假定进行了下面的声明：</p>
        
        <pre>
     using std::map;
     using std::pair;
     using std::size_t;
     using std::string;
     using std::vector;
</pre>

<p class="docText">A <tt>using</tt> declaration introduces only one namespace member at a time. It allows us to be very specific regarding which names are used in our programs.</p>
<p class="docText">一个 <tt>using</tt> 声明一次只引入一个命名空间成员，它使得无论程序中使用哪些名字，都能够非常明确。</p>

        <a name="ch17lev3sec38"></a>
        <h5 class="docSection3Title">Scope of a <tt>using</tt> Declaration</h5>
        <h5 class="docSection3Title"><tt>using</tt> 声明的作用域</h5>

<p class="docText">Names introduced in a <tt>using</tt> declaration obey normal scope rules. The name is visible from the point of the <tt>using</tt> declaration to the end of the scope in which the declaration is found. Entities with the same name defined in an outer scope are hidden.</p>
<p class="docText"><tt>using</tt> 声明中引入的名字遵循常规作用域规则。从 <tt>using</tt> 声明点开始，直到包含 <tt>using</tt> 声明的作用域的末尾，名字都是可见的。外部作用域中定义的同名实体被屏蔽。</p>

<p class="docText">The shorthand name may be used only within the scope in which it is declared and in scopes nested within that scope. Once the scope ends, the fully qualified name must be used.</p>
<p class="docText">简写名字只能在声明它的作用域及其嵌套作用域中使用，一旦该作用域结束了，就必须使用完全限定名。</p>

<p class="docText">A <tt>using</tt> declaration can appear in global, local, or namespace scope. A <tt>using</tt> declaration in class scope is limited to names defined in a base class of the class being defined.</p>
<p class="docText"><tt>using</tt> 声明可以出现在全局作用域、局部作用域或者命名空间作用域中。类作用域中的 <tt>using</tt> 声明局限于被定义类的基类中定义的名字。</p>

        <a name="ch17lev3sec39"></a>
        <h5 class="docSection3Title">Namespace Aliases</h5>
        <h5 class="docSection3Title">命名空间别名</h5>

        <a name="ch17term18"></a>
<p class="docText">A <b><a class="docLink" href="ch17lev1sec5.html#gloss17_18" >namespace alias</a></b> can be used to associate a shorter synonym with a namespace name. For example, a long namespace name such as</p>
<p class="docText">可用<b><a class="docLink" href="ch17lev1sec5.html#gloss17_18" >命名空间别名</a></b>将较短的同义词与命名空间名字相关联。例如，像</p>
        
        <pre>
     namespace cplusplus_primer { /* ... */ };
</pre>
<br>

        <a name="idd1e139428"></a><a name="idd1e139433"></a><a name="idd1e139440"></a><a name="idd1e139445"></a>
<p class="docText">can be associated with a shorter synonym as follows:</p>
<p class="docText">这样的长命名空间名字，可以像下面这样与较短的同义词相关联：</p>
        
        <pre>
     namespace primer = cplusplus_primer;
</pre>
<br>

<p class="docText">A namespace alias declaration begins with the keyword <tt>namespace</tt>, followed by the (shorter) name of the namespace alias, followed by the <tt>=</tt> sign, followed by the original namespace name and a semicolon. It is an error if the original namespace name has not already been defined as a namespace.</p>
<p class="docText">命名空间别名声明以关键字 <tt>namespace</tt> 开头，接（较短的）命名空间别名名字，再接 <tt>=</tt>，再接原来的命名空间名字和分号。如果原来的命名空间名字是未定义的，就会出错。</p>

<p class="docText">A namespace alias can also refer to a nested namespace. Rather than writing</p>
<p class="docText">命名空间别名也可以引用嵌套的命名空间。除了编写</p>
        
        <pre>
     cplusplus_primer::QueryLib::Query tq;
</pre>
<br>

<p class="docText">we could define and use an alias for <tt>cplusplus_primer::QueryLib:</tt></p>
<p class="docText">之外，我们可以定义和使用 <tt>cplusplus_primer::QueryLib:</tt> 的别名：</p>
        
        <pre>
     namespace Qlib = cplusplus_primer::QueryLib;
     Qlib::Query tq;
</pre>
<br>
        <a name="ch17note25"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A namespace can have many synonyms, or aliases. All the aliases and the original namespace name can be used interchangeably.</p>

                <p class="docText">一个命名空间可以有许多别名，所有别名以及原来的命名空间名字都可以互换使用。</p>
              </td>
            </tr>
          </table><br>
        </div>

        <a name="ch17lev3sec40"></a>

        <h5 class="docSection3Title"><tt>using</tt> Directives</h5>
        <h5 class="docSection3Title"><tt>using</tt> 指示</h5>

<p class="docText">Like a <tt>using</tt> declaration, a <span class="docEmphStrong"><tt>using</tt> directive</span> allows us to use the shorthand form of a namespace name. Unlike a <tt>using</tt> declaration, we retain no control over which names are made visiblethey all are.</p>
<p class="docText">像 <tt>using</tt> 声明一样，<span class="docEmphStrong"><tt>using</tt> 指示</span>使我们能够使用命名空间名字的简写形式。与 <tt>using</tt> 声明不同，<tt>using</tt> 指示无法控制使得哪些名字可见——它们都是可见的。</p>

        <a name="ch17lev3sec41"></a>

        <h5 class="docSection3Title">The Form of a <tt>using</tt> Directive</h5>
        <h5 class="docSection3Title"><tt>using</tt> 指示的形式</h5>

<p class="docText">A <tt>using</tt> directive begins with the keyword <tt>using</tt>, followed by the keyword <tt>namespace</tt>, followed by a namespace name. It is an error if the name is not a previously defined namespace name.</p>
<p class="docText"><tt>using</tt> 指示以关键字 <tt>using</tt> 开头，后接关键字 <tt>namespace</tt>，再接命名空间名字。如果该名字不是已经定义的命名空间名字，就会出错。</p>

<p class="docText">A <tt>using</tt> directive makes all the names from a specific namespace visible without qualification. The short form names can be used from the point of the <tt>using</tt> directive to the end of the scope in which the <tt>using</tt> directive appears.</p>
<p class="docText"><tt>using</tt> 指示使得特定命名空间所有名字可见，没有限制。短格式名字可从 <tt>using</tt> 指示点开始使用，直到出现 <tt>using</tt> 指示的作用域的末尾。</p>

<p class="docText">A <tt>using</tt> directive may appear in namespace, function, or block scope. It may not appear in a class scope.</p>
<p class="docText"><tt>using</tt> 指示使得特定命名空间的所有名字可见，没有限制。短格式名字可从 <tt>using</tt> 指示点开始使用，直到出现 <tt>using</tt> 指示的作用域的末尾。</p>

        <a name="ch17note26"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">It can be tempting to write programs with <tt>using</tt> directives, but doing so reintroduces all the problems inherent in name collisions when using multiple libraries.</p>

                <p class="docText">可以尝试用 <tt>using</tt> 指示编写程序，但在使用多个库的时候，这样做会重新引入名字冲突的所有问题。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

        <a name="ch17lev3sec42"></a>

        <h5 class="docSection3Title"><tt>using</tt> Directives and Scope</h5>
        <h5 class="docSection3Title"><tt>using</tt> 指示与作用域</h5>

        <a name="idd1e139596"></a><a name="idd1e139605"></a>
<p class="docText">The scope of names introduced by a <tt>using</tt> directive is more complicated than those for <tt>using</tt> declarations. A <tt>using</tt> declaration puts the name directly in the same scope in which the <tt>using</tt> declaration itself appears. It is as if the <tt>using</tt> declaration is a local alias for the namespace member. Because the declaration is localized, the chance of collisions is minimized.</p>
<p class="docText">用 <tt>using</tt> 指示引入的名字的作用域比 <tt>using</tt> 声明的更复杂。<tt>using</tt> 声明将名字直接放入出现 <tt>using</tt> 声明的作用域，好像 <tt>using</tt> 声明是命名空间成员的局部别名一样。因为这种声明是局部化的，冲突的机会最小。</p>

        <a name="ch17note27"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A <tt>using</tt> directive does not declare local aliases for the namespace member names. Rather, it has the effect of lifting the namespace members into the nearest scope that contains both the namespace itself and the <tt>using</tt> directive.</p>

                <p class="docText"><tt>using</tt> 指示不声明命名空间成员名字的别名，相反，它具有将命名空间成员提升到包含命名空间本身和 <tt>using</tt> 指示的最近作用域的效果。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

<p class="docText">In the simplest case, assume we have a namespace <tt>A</tt> and a function <tt>f</tt>, both defined at global scope. If <tt>f</tt> has a <tt>using</tt> directive for <tt>A</tt>, then in <tt>f</tt> it will be as if the names in <tt>A</tt> appeared in the global scope prior to the definition of <tt>f</tt>:</p>
<p class="docText">在最简单的情况下，假定有命名空间 <tt>A</tt> 和函数 <tt>f</tt>，二者都在全局作用域中定义。如果 <tt>f</tt> 有关于 <tt>A</tt> 的 <tt>using</tt> 指示，那么，在 <tt>f</tt> 中，将好像 <tt>A</tt> 中的名字出现在全局作用域中 <tt>f</tt> 的定义之前一样：</p>
        
        <pre>
    // <span class="docEmphItalicAlt">namespace</span> <span class="docEmphasis">A</span> <span class="docEmphItalicAlt">and function</span> <span class="docEmphasis">f</span> <span class="docEmphItalicAlt">are defined at global scope</span>
    namespace A {
        int i, j;
    }
    void f()
    {
        using namespace A;      // <span class="docEmphItalicAlt">injects names from</span> <span class="docEmphasis">A</span> <span class="docEmphItalicAlt">into the global scope</span>
        cout &lt;&lt; i * j &lt;&lt; endl; // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">i</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">from namespace</span> <span class="docEmphasis">A</span>
        //...
    }
</pre>
<br>

        <a name="ch17note28"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">One place where <tt>using</tt> directives are useful is in the implementation files for the namespace itself.</p>
                <p class="docText"><tt>using</tt> 指示有用的一种情况是，用在命名空间本身的实现文件中。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

        <a name="ch17lev3sec43"></a>
        <h5 class="docSection3Title"><tt>using</tt> Directives Example</h5>
        <h5 class="docSection3Title"><tt>using</tt> 指示例子</h5>
  
<p class="docText">Let's look at an example:</p>
<p class="docText">看一个例子：</p>
        
        <pre>
    namespace blip {
        int bi = 16, bj = 15, bk = 23;
        // <span class="docEmphItalicAlt">other declarations</span>
    }
    int bj = 0; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">inside</span> <span class="docEmphasis">blip</span> <span class="docEmphItalicAlt">is hidden inside a namespace</span>
    void manip()
    {

         // <span class="docEmphItalicAlt">using directive - names in</span> <span class="docEmphasis">blip</span> <span class="docEmphItalicAlt">"added" to global scope</span>
         using namespace blip;
                         // <span class="docEmphItalicAlt">clash between</span> <span class="docEmphasis">::bj</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">blip::bj</span>
                         // <span class="docEmphItalicAlt">detected only if</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">is used</span>
         ++bi;           // <span class="docEmphItalicAlt">sets</span> <span class="docEmphasis">blip::bi</span> <span class="docEmphItalicAlt">to 17</span>
         ++bj;           // <span class="docEmphItalicAlt">error: ambiguous</span>
                         // <span class="docEmphItalicAlt">global</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">blip::bj</span><span class="docEmphItalicAlt">?</span>
         ++::bj;         // <span class="docEmphItalicAlt">ok: sets global</span> <span class="docEmphasis">bj</span> <span class="docEmphItalicAlt">to 1</span>
         ++blip::bj;     // <span class="docEmphItalicAlt">ok: sets</span> <span class="docEmphasis">blip::bj</span> <span class="docEmphItalicAlt">to 16</span>
         int bk = 97;    // <span class="docEmphItalicAlt">local</span> <span class="docEmphasis">bk</span> <span class="docEmphItalicAlt">hides</span> <span class="docEmphasis">blip::bk</span>
         ++bk;           // <span class="docEmphItalicAlt">sets local</span> <span class="docEmphasis">bk</span> <span class="docEmphItalicAlt">to 98</span>
    }
</pre>
<br>

        <a name="idd1e139849"></a><a name="idd1e139858"></a>
<p class="docText">The <tt>using</tt> directive in <tt>manip</tt> makes all the names in <tt>blip</tt> directly accessible to <tt>manip</tt>: The function can refer to the names of these members, using their short form.</p>
<p class="docText"><tt>manip</tt> 中的 <tt>using</tt> 提示使 <tt>manip</tt> 能够直接访问 <tt>blip</tt> 中的所有名字：使用它们的简化形式，该函数可以引用这些成员的名字。</p>

<p class="docText">The members of <tt>blip</tt> appear as if they were defined in the scope in which both <tt>blip</tt> and <tt>manip</tt> are defined. Given that <tt>blip</tt> is defined at global scope, then the members of <tt>blip</tt> appear as if they were declared in global scope. Because the names are in different scopes, local declarations within <tt>manip</tt> may hide some of the namespace member names. The local variable <tt>bk</tt> hides the namespace member <tt>blip::bk</tt>. Referring to <tt>bk</tt> within <tt>manip</tt> is not ambiguous; it refers to the local variable <tt>bk</tt>.</p>
<p class="docText"><tt>blip</tt> 的成员看来好像是在定义 <tt>blip</tt> 和 <tt>manip</tt> 的作用域中定义的一样。如果在全局作用域中定义 <tt>blip</tt>，则 <tt>blip</tt> 的成员看来好像是声明在全局作用域的一样。因为名字在不同的作用域中，<tt>manip</tt> 内部的局部声明可以屏蔽命名空间的某些成员名字，局部变量 <tt>bk</tt> 屏蔽命名空间名字 <tt>blip::bk</tt>，在 <tt>manip</tt> 内部对 <tt>bk</tt> 的引用没有二义性，它引用局部变量 <tt>bk</tt>。</p>

<p class="docText">It is possible for names in the namespace to conflict with other names defined in the enclosing scope. For example, the <tt>blip</tt> member <tt>bj</tt> appears to <tt>manip</tt> as if it were declared at global scope. However, there is another object named <tt>bj</tt> in global scope. Such conflicts are permitted; but to use the name, we must explicitly indicate which version is wanted. Therefore, the use of <tt>bj</tt> within <tt>manip</tt> is ambiguous: The name refers both to the global variable and to the member of namespace <tt>blip</tt>.</p>
<p class="docText">命名空间中的名字可能会与外围作用域中定义的其他名字冲突。例如，对 <tt>manip</tt> 而言，<tt>blip</tt> 成员 <tt>bj</tt> 看来好像声明在全局作用域中，但是，全局作用域存在另一名为 <tt>bj</tt> 的对象。这种冲突是允许的，但为了使用该名字，必须显式指出想要的是哪个版本，因此，在 <tt>manip</tt> 内部的 <tt>bj</tt> 使用是有二义性的：该名字既可引用全局变量又可引用命名空间 <tt>blip</tt> 的成员。</p>

<p class="docText">To use a name such as <tt>bj</tt>, we must use the scope operator to indicate which name is wanted. We would write <tt>::bj</tt> to obtain the variable defined in global scope. To use the <tt>bj</tt> defined in <tt>blip</tt>, we must use its qualified name, <tt>blip::bj</tt>.</p>
<p class="docText">为了使用像 <tt>bj</tt> 这样的名字，必须使用作用域操作符指出想要的是哪个名字。可以编写 <tt>::bj</tt> 来获得在全局作用域中定义的变量，要使用 <tt>blip</tt> 中定义的 <tt>bj</tt>，必须使用它的限定名字 <tt>blip::bj</tt>。</p>

        <a name="ch17sb12"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 17.2.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa10q3"></a><b>Exercise 17.20:</b></td>

                    <td>
                      <p class="docText">Explain the differences between <tt>using</tt> declarations and <tt>using</tt> directives.</p>

                      <p class="docText">解释 <tt>using</tt> 声明和 <tt>using</tt> 指示之间的区别。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa10q4"></a><b>Exercise 17.21:</b></td>

                    <td>
                      <p class="docText">Consider the following code sample:</p>

                      <p class="docText">考虑下面代码样本：</p>
                      <pre>
    namespace Exercise {
        int ivar = 0;
        double dvar = 0;
        const int limit = 1000;
    }
    int ivar = 0;
    // <span class="docEmphItalicAlt">position 1</span>
    void manip() {
         // <span class="docEmphItalicAlt">position 2</span>
         double dvar = 3.1416;
         int iobj = limit + 1;
         ++ivar;
         ++::ivar;
    }
</pre><br>

                      <p class="docText">What are the effects of the declarations and expressions in this code sample if <tt>using</tt> declarations for all the members of namespace <tt>Exercise</tt> are located at the location labeled <span class="docEmphasis">position 1</span>? At <span class="docEmphasis">position 2</span> instead? Now answer the same question but replace the <tt>using</tt> declarations with a <tt>using</tt> directive for namespace <tt>Exercise</tt>.</p>

                      <p class="docText">如果命名空间 <tt>Exercise</tt> 的所有成员的 <tt>using</tt> 声明放在标为 <span class="docEmphasis">position 1</span> 的地方，这个代码样本中的声明和表达式的效果是什么？如果放在 <span class="docEmphasis">position 2</span> 位置呢？用命名空间 <tt>Exercise</tt> 的 <tt>using</tt> 指示代替 <tt>using</tt> 声明，回答同一问题。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <pre>
<br>

        <a name="ch17sb13"></a>
        
</pre>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Caution: Avoid <tt>Using</tt> Directives</h2>

              <h2 class="docSidebarTitle">警告：避免 <tt>Using</tt> 指示</h2><a name="idd1e140043"></a><a name="idd1e140050"></a><a name="idd1e140055"></a><a name="idd1e140060"></a><b><a name="ch17term30"></a></b>

              <p class="docText"><b><a class="docLink" href="ch17lev1sec5.html#gloss17_30" ><span class="docEmphStrong"><tt>using</tt></span> directives</a></b>, <span class="docEmphStrong">which inject all the names from a namespace, are deceptively simple to use: With only a single statement, all the member names of a namespace are suddenly visible. Although this approach may seem simple, it can introduce its own problems. If an application uses many libraries, and if the names within these libraries are made visible with <tt>using</tt> directives, then we are back to square one, and the global namespace pollution problem reappears.</span></p>

              <p class="docText"><a class="docLink" href="ch17lev1sec5.html#gloss17_30" ><span class="docEmphStrong"><tt>using</tt></span> 指示</a>注入来自一个命名空间的所有名字，它的使用是靠不住的：只用一个语句，命名空间的所有成员名就突然可见了。虽然这个方法看似简单，但也有它自身的问题。如果应用程序使用许多库，并且用 <span class="docEmphStrong"><tt>using</tt></span> 指示使得这些库中的名字可见，那么，全局命名空间污染问题就重新出现。</p>

              <p class="docText"><span class="docEmphStrong">Moreover, it is possible that a working program will fail to compile when a new version of the library is introduced. This problem can arise if a new version introduces a name that conflicts with a name that the application is using.</span></p>

              <p class="docText"><span class="docEmphStrong">而且，当引入库的新版本的时候，正在工作的程序可能会编译失败。如果新版本引入一个与应用程序正在使用的名字冲突的名字，就会引发这个问题。</span></p>

              <p class="docText"><span class="docEmphStrong">Another problem is that ambiguity errors caused by <tt>using</tt> directives are detected only at the point of use. This late detection means that conflicts can arise long after introducing a particular library. If the program begins using a new part of the library, previously undetected collisions may arise.</span></p>

              <p class="docText"><span class="docEmphStrong">另一个问题是，由 <tt>using</tt> 指示引起的二义性错误只能在使用处检测，这个后来的检测意味着，可能在特定库引入很久之后才引发冲突，如果程序开始使用该库的新部分，就可能引发先前未检测到的冲突。</span></p>

              <p class="docText"><span class="docEmphStrong">Rather than relying on a <tt>using</tt> directive, it is better to use a <tt>using</tt> declaration for each namespace name used in the program. Doing so reduces the number of names injected into the namespace. Ambiguity errors caused by <tt>using</tt> declarations are detected at the point of declaration, not use, and so are easier to find and fix.</span></p>

              <p class="docText"><span class="docEmphStrong">相对于依赖于 <tt>using</tt> 指示，对程序中使用的每个命名空间名字使用 <tt>using</tt> 声明更好，这样做减少注入到命名空间中的名字数目，由 <tt>using</tt> 声明引起的二义性错误在声明点而不是使用点检测，因此更容易发现和修正。</span></p>
            </td>
          </tr>
        </table>
<br>

        <a name="ch17lev2sec16"></a>
        <h4 class="docSection2Title">17.2.5. Classes, Namespaces, and Scope</h4>
        <h4 class="docSection2Title">17.2.5. 类、命名空间和作用域</h4>
<p class="docText">As we've noted, namespaces are scopes. As in any other scope, names are visible from the point of their declaration. Names remain visible through any nested scopes until the end of the block in which they were introduced.</p>
<p class="docText">正如我们已经注意到的，命名空间是作用域。像在任意其他作用域中一样，名字从声明点开始可见。名字的可见性穿过任意嵌套作用域，直到引入名字的块的末尾。</p>

<p class="docText">Name lookup for names used inside a namespace follows the normal C++ lookup rules: When looking for a name, we look outward through the enclosing scopes. An enclosing scope for a name used inside a namespace might be one or more nested namespaces ending finally with the all-encompassing global namespace. Only names that have been declared before the point of use that are in blocks that are still open are considered:</p>
<p class="docText">对命名空间内部使用的名字的查找遵循常规 C++ 查找规则：当查找名字的时候，通过外围作用域外查找。对命名空间内部使用的名字而言，外围作用域可能是一个或多个嵌套的命名空间，最终以全包围的全局命名空间结束。只考虑已经在使用点之前声明的名字，而该使用仍在开放的块中：</p>
        
        <pre>
    namespace A {
        int i;
        namespace B {
            int i;        // <span class="docEmphItalicAlt">hides</span> <span class="docEmphasis">A::i</span> <span class="docEmphItalicAlt">within</span> <span class="docEmphasis">B</span>
            int j;
            int f1()
            {
                int j;    // <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">is local to</span> <span class="docEmphasis">f1</span> <span class="docEmphItalicAlt">and hides</span> <span class="docEmphasis">A::B::j</span>
                return i; // <span class="docEmphItalicAlt">returns</span> <span class="docEmphasis">B::i</span>
            }
        } // <span class="docEmphItalicAlt">namespace</span> <span class="docEmphasis">B</span> <span class="docEmphItalicAlt">is closed and names in it are no longer visible</span>
        int f2() {
           return j;     // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">j</span> <span class="docEmphItalicAlt">is not defined</span>
        }
        int j = i;      // <span class="docEmphItalicAlt">initialized from</span> <span class="docEmphasis">A::i</span>
    }
</pre>
<br>

<p class="docText">Names used in a class member definition are resolved in much the same way, with one important difference: If the name is not local to the member function, we first try to resolve the name to a class member before looking in the outer scopes.</p>
<p class="docText">用非常相似的方式确定类成员定义中使用的名字，只有一个重要区别：如果名字不是局部于成员函数的，就试着在查找更外层作用域之前在类成员中确定名字。</p>

<p class="docText">As we saw in <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3" >Section 12.3</a> (p. <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3" >444</a>), members defined inside a class may use names that appear textually after the definition. For example, a constructor defined inside the class body may initialize the data members even if the declaration of those members appears after the constructor definition. When a name is used in a class scope, we look first in the member itself, then in the class, including any base classes. Only after exhausting the class(es) do we examine the enclosing scopes. When a class is wrapped in a namespace, the same lookup happens: Look first in the member, then the class (including base classes), then look in the enclosing scopes, one or more of which might be a namespace:</p>
<p class="docText">正如<a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3" >第 12.3 节</a>所介绍的，类内部所定义的成员可以使用出现在定义文本之后的名字。例如，即使数据成员的定义出现在构造函数定义之后，类定义体内部定义的构造函数也可以初始化那些数据成员。当在类作用域中使用名字的时候，首先在成员本身中查找，然后在类中查找，包括任意基类，只有在查找完类之后，才检查外围作用域。当类包在命名空间中的时候，发生相同的查找：首先在成员中找，然后在类（包括基类）中找，再在外围作用域中找，外围作用域中的一个或多个可以是命名空间：</p>
        
        <pre>
    namespace A {
        int i;
        int k;
        class C1 {
        public:
            C1(): i(0), j(0) { }   // <span class="docEmphItalicAlt">ok: initializes</span> <span class="docEmphasis">C1::i</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">C1::j</span>
            int f1()
            {
                 return k;        // <span class="docEmphItalicAlt">returns</span> <span class="docEmphasis">A::k</span>
            }
            int f2()
            {
                return h;        // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">h</span> <span class="docEmphItalicAlt">is not defined</span>
            }
            int f3();
        private:
           int i;                // <span class="docEmphItalicAlt">hides</span> <span class="docEmphasis">A::i</span> <span class="docEmphItalicAlt">within</span> <span class="docEmphasis">C1</span>
           int j;
        };
        int h = i;               // <span class="docEmphItalicAlt">initialized from</span> <span class="docEmphasis">A::i</span>
     }
     // <span class="docEmphItalicAlt">member</span> <span class="docEmphasis">f3</span> <span class="docEmphItalicAlt">is defined outside class</span> <span class="docEmphasis">C1</span> <span class="docEmphItalicAlt">and outside namespace</span> <span class="docEmphasis">A</span>
     int A::C1::f3()
     {
         return h;               // <span class="docEmphItalicAlt">ok: returns</span> <span class="docEmphasis">A::h</span>
     }
</pre>
<br>

<p class="docText">With the exception of member definitions, scopes are always searched upward: A name must be declared before it can be used. Hence, the <tt>return</tt> in <tt>f2</tt> will not compile. It attempts to reference the name <tt>h</tt> from namespace <tt>A</tt>, but <tt>h</tt> has not yet been defined. Had that name been defined in <tt>A</tt> before the definition of <tt>C1</tt>, the use of <tt>h</tt> would be legal. Similarly, the use of <tt>h</tt> inside <tt>f3</tt> is okay, because <tt>f3</tt> is defined after <tt>A::h</tt> has been defined.</p>
<p class="docText">除了成员定义例外，总是向上查找作用域：名字在使用之前必须声明。因此，<tt>f2</tt> 中的 <tt>return</tt> 语句将不能编译，它试图引用命名空间 <tt>A</tt> 中的名字 <tt>h</tt>，但 <tt>h</tt> 还没有定义。如果使 <tt>A</tt> 中的名字在 <tt>C1</tt> 的定义之前定义，<tt>h</tt> 的使用就是合法的。类似地，<tt>f3</tt> 内部对 <tt>h</tt> 的使用是正确的，因为 <tt>f3</tt> 定义在已经定义了 <tt>A::h</tt> 之后。</p>

        <a name="ch17note29"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The order in which scopes are examined to find a name can be inferred from the qualified name of a function. The qualified name indicates, in reverse order, the scopes that are searched.</p>

                <p class="docText">可以从函数的限定名推断出查找名字时所检查作用域的次序，限定名以相反次序指出被查找的作用域。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

        <a name="idd1e140314"></a><a name="idd1e140317"></a><a name="idd1e140324"></a>
<p class="docText">The qualifiers <tt>A::C1::f3</tt> indicate the reverse order in which the class scopes and namespace scopes are to be searched. The first scope searched is that of the function <tt>f3</tt>. Then the class scope of its enclosing class <tt>C1</tt> is searched. The scope of the namespace <tt>A</tt> is searched last before the scope containing the definition of <tt>f3</tt> is examined.</p>
<p class="docText">限定符 <tt>A::C1::f3</tt> 指出了查找类作用域和命名空间作用域的相反次序，首先查找函数 <tt>f3</tt> 的作用域，然后查找外围类 <tt>C1</tt> 的作用域。在查找包含 <tt>f3</tt> 定义的作用之前，最后查找命名空间 <tt>A</tt> 的作用域。</p>

        <a name="ch17lev3sec44"></a>
        <h5 class="docSection3Title">Argument-Dependent Lookup and Class Type Parameters</h5>
        <h5 class="docSection3Title">实参相关的查找与类类型形参</h5>

<p class="docText">Consider the following simple program:</p>
<p class="docText">考虑下面的简单程序：</p>
        
        <pre>
    std::string s;
    // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">std::getline(std::istream&amp;, const std::string&amp;)</span>
    getline(std::cin, s);
</pre>
<br>

<p class="docText">The program uses the <tt>std::string</tt> type, yet it refers without qualification to the <tt>getline</tt> function. Why can we use this function without a specific <tt>std::</tt> qualifier or a <tt>using</tt> declaration?</p>
<p class="docText">这段程序使用了 <tt>std::string</tt> 类型，但它不加限制地引用了 <tt>getline</tt> 函数。为什么可以无须特定 <tt>std::</tt> 限定符或 <tt>using</tt> 声明而使用该函数？</p>

<p class="docText">It turns out that there is an important exception to the rule that namespace names are hidden.</p>
<p class="docText">它给出了屏蔽命名空间名字规则的一个重要例外。</p>

        <a name="ch17note30"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Functions, including overloaded operators, that take parameters of a class type (or pointer or reference to a class type), and that are defined in the same namespace as the class itself, are visible when an object of (or reference or pointer to) the class type is used as an argument.</p>

                <p class="docText">接受类类型形参（或类类型指针及引用形参）的函数（包括重载操作符），以及与类本身定义在同一命名空间中的函数（包括重载操作符），在用类类型对象（或类类型的引用及指针）作为实参的时候是可见的。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

<p class="docText">When the compiler sees the use of the <tt>getline</tt> function</p>
<p class="docText">当编译器看到 <tt>getline</tt> 函数的使用</p>
        
        <pre>

    getline(std::cin, s);
</pre>
<br>

<p class="docText">it looks for a matching function in the current scope, the scopes enclosing the call to <tt>getline</tt>, <span class="docEmphasis">and in the namespace(s) in which the type of</span> <tt>cin</tt> <span class="docEmphasis">and the</span> <tt>string</tt> <span class="docEmphasis">type are defined</span>. Hence, it looks in the namespace <tt>std</tt> and finds the <tt>getline</tt> function defined by the <tt>string</tt> type.</p>
<p class="docText">的时候，它在当前作用域，包含调用的作用域以及定义 <tt>cin</tt> 的类型和 <tt>string</tt> 类型的命名空间中查找匹配的函数。因此，它在命名空间 <tt>std</tt> 中查找并找到由 <tt>string</tt> 类型定义的 <tt>getline</tt> 函数。</p>

<p class="docText">The reason that functions are made visible if they have a parameter of the class type is to allow nonmember functions that are conceptually part of a class' interface to be used without requiring a separate <tt>using</tt> declaration. Being able to use nonmember operations is particularly useful for operator functions.</p>
<p class="docText">如果函数具有类类型形参就使得函数可见，其原因在于，允许无须单独的 <tt>using</tt> 声明就可以使用概念上作为类接口组成部分的非成员函数。能够使用非成员操作对操作符函数特别有用。</p>

<p class="docText">For example, consider the following simple program:</p>
<p class="docText">例如，考虑下面的简单程序：</p>
        
        <pre>

    std::string s;
    cin &gt;&gt; s;
</pre>
<br>

<p class="docText">In absence of this exception to the lookup rules, we would have to write either:</p>
<p class="docText">如果没有查找规则的这个例外，我们将必须编写下面二者之一：</p>
        
        <pre>

    using std::operator&gt;&gt;;        // <span class="docEmphItalicAlt">need to allow</span> <span class="docEmphasis">cin &gt;&gt; s</span>
    std::operator&gt;&gt;(std::cin, s); // <span class="docEmphItalicAlt">ok: explicitly use</span> <span class="docEmphasis">std::&gt;&gt;</span>
</pre>
<br>

<p class="docText">Either of these declarations is awkward and would make simple uses of <tt>string</tt>s and the IO library more complicated.</p>
<p class="docText">这两个声明都不方便使用，而且可能使 <tt>string</tt> 和 IO 库的使用变得更复杂。</p>

        <a name="ch17lev3sec45"></a>
        <h5 class="docSection3Title">Implicit Friend Declarations and Namespaces</h5>
        <h5 class="docSection3Title">隐式友元声明与命名空间</h5>

        <a name="idd1e140486"></a><a name="idd1e140493"></a><a name="idd1e140498"></a><a name="idd1e140503"></a><a name="idd1e140508"></a>
<p class="docText">Recall that when a class declares a friend function (<a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5" >Section 12.5</a>, p. <a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5" >465</a>), a declaration for the function need not be visible. If there isn't a declaration already visible, then the friend declaration has the effect of putting a declaration for that function or class into the surrounding scope. If a class is defined inside a namespace, then an otherwise undeclared friend function is declared in the same namespace:</p>
<p class="docText">回忆一下，当一个类声明友元函数（<a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5" >第 12.5 节</a>）的时候，函数的声明不必是可见的。如果不存在可见的声明，那么，友元声明具有将该函数或类的声明放入外围作用域的效果。如果类在命名空间内部定义，则没有另外声明的友元函数在同一命名空间中声明。</p>
        
        <pre>

    namespace A {
        class C {
            friend void f(const C&amp;); // <span class="docEmphItalicAlt">makes</span> <span class="docEmphasis">f</span> <span class="docEmphItalicAlt">a member of namespace</span> <span class="docEmphasis">A</span>
        };
    }
</pre>
<br>

<p class="docText">Because the friend takes an argument of a class type and is implicitly declared in the same namespace as the class, it can be used without using an explicit name-space qualifier:</p>
<p class="docText">因为该友元接受类类型实参并与类隐式声明在同一命名空间中，所以使用它时可以无须使用显式命名空间限定符：</p>
        
        <pre>

    // <span class="docEmphasis">f2</span> <span class="docEmphItalicAlt">defined at global scope</span>
    void f2()
    {
         A::C cobj;
         f(cobj); // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">A::f</span>
    }
</pre>
<br>

        <a name="ch17lev2sec17"></a>
        <h4 class="docSection2Title">17.2.6. Overloading and Namespaces</h4>
        <h4 class="docSection2Title">17.2.6. 重载与命名空间</h4>
<p class="docText">As we've seen, each namespace maintains its own scope. As a consequence, functions that are members of two distinct namespaces do not overload one another. However, a given namespace can contain a set of overloaded function members.</p>
<p class="docText">正如我们所见，每个命名空间维持自己的作用域，因此，作为两个不同命名空间的成员的函数不能互相重载。但是，给定命名空间可以包含一组重载函数成员。</p>

<p class="docText">In general, function matching (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >269</a>) within a namespace happens in the same manner as we've already seen:</p>
<p class="docText">一般而言，命名空间内部的函数匹配（<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >第 7.8.2 节</a>）以与我们已经见过的方式相同的方式进行：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">Find the set of candidate functions. A function is a candidate if a declaration for it is visible at the time of the call and if it has the same name as the called function.</p>

                <p class="docList">找到候选函数集。如果一个函数在调用时其声明可见并且与被调用函数同名，这个函数就是候选者。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Select the viable functions from the set of candidates. A function is viable if it has the same number of parameters as the call has arguments and if each parameter could be matched by the corresponding argument.</p>

                <p class="docList">从候选集中选择可行函数。如果函数的形参数目与函数调用的实参数目相同，并且每个形参都可用对应实参匹配，这个函数就是可行的。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Select the single best match from the viable set and generate code to call that function. If the viable set is empty, then the call is in error, having no match. If the viable set is nonempty and there is no best match, then the call is ambiguous.</p>

                <p class="docList">从可行集合中选择一个最佳匹配，并产生代码调用该函数。如果可行集合为空，则调用出错，没有匹配；如果可行集合非空且没有最佳匹配，则调用有二义性。</p>
              </div>
            </li>
          </ol>
        </div>
        
<p class="docText">
        <h5 class="docSection3Title">Candidate Functions and Namespaces</h5>
        <h5 class="docSection3Title">候选函数与命名空间</h5>

<p class="docText">Namespaces can have two impacts on function matching. One of these should be obvious: A <tt>using</tt> declaration or directive can add functions to the candidate set. The other is much more subtle.</p>
<p class="docText">命名空间对函数匹配有两个影响。一个影响是明显的：<tt>using</tt> 声明或 <tt>using</tt> 指示可以将函数加到候选集合。另一个影响则微妙得多。</p>

        <a name="idd1e140611"></a><a name="idd1e140616"></a><a name="idd1e140623"></a>
<p class="docText">As we saw in the previous section, name lookup for functions that have one or more class-type parameters includes the namespace in which each parameter's class is defined. This rule also impacts how we determine the candidate set. Each namespace that defines a class used as a parameter (and those that define its base class(es)) is searched for candidate functions. Any functions in those namespaces that have the same name as the called function are added to the candidate set. These functions are added <span class="docEmphasis">even though they otherwise are not visible at the point of the call.</span> Functions with the matching name in those namespaces are added to the candidate set:</p>
<p class="docText">正如前节所见，有一个或多个类类型形参的函数的名字查找包括定义每个形参类型的命名空间。这个规则还影响怎样确定候选集合，为找候选函数而查找定义形参类（以及定义其基类）的每个命名空间，将那些命名空间中任意与被调用函数名字相同的函数加入候选集合。<span class="docEmphasis">即使这些函数在调用点不可见</span>，也将之加入候选集合。将那些命名空间中带有匹配名字的函数加入候选集合：</p>
        
        <pre>

    namespace NS {
        class Item_base { /* ... */ };
        void display(const Item_base&amp;) { }
    }
    // <span class="docEmphasis">Bulk_item</span><span class="docEmphItalicAlt">'s base class is declared in namespace NS</span>
    class Bulk_item : public NS::Item_base { };
    int main() {
        Bulk_item book1;
        display(book1);
        return 0;
    }
</pre>
<br>

<p class="docText">The argument, <tt>book1</tt>, to the <tt>display</tt> function has class type <tt>Bulk_item</tt>. The candidate functions for the call to <tt>display</tt> are not only the functions with declarations that are visible where the function <tt>display</tt> is called, but also the functions in the namespace where the class <tt>Bulk_item</tt> and its base class <tt>Item_base</tt> are declared. The function <tt>display(const Item_base&amp;)</tt> declared in namespace <tt>NS</tt> is added to the set of candidate functions.</p>
<p class="docText"><tt>display</tt> 函数的实参 <tt>book1</tt> 具有类类型 <tt>Bulk_item</tt>。<tt>display</tt> 调用的候选函数不仅是在调用 <tt>display</tt> 函数的地方其声明可见的函数，还包括声明 <tt>Bulk_item</tt> 类及其基类 <tt>Item_base</tt> 的命名空间中的函数。命名空间 <tt>NS</tt> 中声明的函数 <tt>display(const Item_base&amp;)</tt> 被加到候选函数集合中。</p>

        <a name="ch17lev3sec47"></a>
        
        <h5 class="docSection3Title">Overloading and <tt>using</tt> Declarations</h5>
        <h5 class="docSection3Title">重载与 <tt>using</tt> 声明</h5>

<p class="docText">A <tt>using</tt> declaration declares a name. As we saw in <a class="docLink" href="ch15lev1sec5.html#ch15lev2sec19" >Section 15.5.3</a> (p. <a class="docLink" href="ch15lev1sec5.html#ch15lev2sec19" >592</a>), there is no way to write a <tt>using</tt> declaration to refer to a specific function declaration:</p>
<p class="docText"><tt>using</tt> 声明声明一个名字。正如<a class="docLink" href="ch15lev1sec5.html#ch15lev2sec19" >第 15.5.3 节</a>所见，没有办法编写 <tt>using</tt> 声明来引用特定函数声明：</p>
        
        <pre>

    using NS::print(int); // <span class="docEmphItalicAlt">error: cannot specify parameter list</span>
    using NS::print;      // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">declarations specify names only</span>
</pre>
<br>

<p class="docText">If a function is overloaded within a namespace, then a <tt>using</tt> declaration for the name of that function declares <span class="docEmphasis">all</span> the functions with that name. If there are <tt>print</tt> functions for <tt>int</tt> and <tt>double</tt> in the namespace NS, then a <tt>using</tt> declaration for <tt>NS::print</tt> makes both functions visible in the current scope.</p>
<p class="docText">如果命名空间内部的函数是重载的，那么，该函数名字的 <tt>using</tt> 声明声明了<span class="docEmphasis">所有</span>具有该名字的函数。如果命名空间 <tt>NS</tt> 中有用于 <tt>int</tt> 和 <tt>double</tt> 的函数，则 <tt>NS::print</tt> 的 <tt>using</tt> 声明使得两个函数都在当前作用域中可见。</p>

<p class="docText">A <tt>using</tt> declaration incorporates all versions of an overloaded function to ensure that the interface of the namespace is not violated. The author of a library provided different functions for a reason. Allowing users to selectively ignore some but not all of the functions from a set of overloaded functions could lead to surprising program behavior.</p>
<p class="docText">一个 <tt>using</tt> 声明包括重载函数的所有版本以保证不违反命名空间的接口。库作者为一个理由提供不同函数，允许用户选择性地忽略重载函数集合中的某些但不是全部函数，可能会导致奇怪的程序行为。</p>

<p class="docText">The functions introduced by a <tt>using</tt> declaration overload any other declarations of the functions with the same name already present in the scope where the <tt>using</tt> declaration appears.</p>
<p class="docText">由 <tt>using</tt> 声明引入的函数，重载出现 <tt>using</tt> 声明的作用域中的任意其他同名函数的声明。</p>

        <a name="idd1e140759"></a><a name="idd1e140766"></a>
<p class="docText">If the <tt>using</tt> declaration introduces a function in a scope that already has a function of the same name with the same parameter list, then the <tt>using</tt> declaration is in error. Otherwise, the <tt>using</tt> declaration defines additional overloaded instances of the given name. The effect is to increase the set of candidate functions.</p>
<p class="docText">如果 <tt>using</tt> 声明在已经有同名且带相同形参表的函数的作用域中引入函数，则 <tt>using</tt> 声明出错，否则，<tt>using</tt> 定义给定名字的另一重载实例，效果是增大候选函数集合。</p>

        <a name="ch17lev3sec48"></a>
        <h5 class="docSection3Title">Overloading and <tt>using</tt> Directives</h5>
        <h5 class="docSection3Title">重载与 <tt>using</tt> 指示</h5>
<p class="docText">A <tt>using</tt> directive lifts the namespace members into the enclosing scope. If a namespace function has the same name as a function declared in the scope at which the namespace is placed, then the namespace member is added to the overload set:</p>
<p class="docText"><tt>using</tt> 指示将命名空间成员提升到外围作用域。如果命名空间函数与命名空间所在的作用域中声明的函数同名，就将命名空间成员加到重载集合中：</p>
        
        <pre>

    namespace libs_R_us {
        extern void print(int);
        extern void print(double);
    }
    void print(const std::string &amp;);
    // <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">directive:</span>
    using namespace libs_R_us;
    // <span class="docEmphItalicAlt">using directive added names to the candidate set for calls to</span> <span class="docEmphasis">print:</span>
    // <span class="docEmphasis">print(int)</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">libs_R_us</span>
    // <span class="docEmphasis">print(double)</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">libs_R_us</span>
    // <span class="docEmphasis">print(const std::string &amp;)</span> <span class="docEmphItalicAlt">declared explicitly</span>
    void fooBar(int ival)
    {
         print("Value: "); // <span class="docEmphItalicAlt">calls global</span> <span class="docEmphasis">print(const string &amp;)</span>
         print(ival);      // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">libs_R_us::print(int)</span>
    }
</pre>
<br>


        <a name="ch17lev3sec49"></a>
        <h5 class="docSection3Title">Overloading across Multiple <tt>using</tt> Directives</h5>
        <h5 class="docSection3Title">跨越多个 <tt>using</tt> 指示的重载</h5>

<p class="docText">If many <tt>using</tt> directives are present, then the names from each namespace become part of the candidate set:</p>
<p class="docText">如果存在许多 <tt>using</tt> 指示，则来自每个命名空间的名字成为候选集合的组成部分：</p>
        
        <pre>

    namespace AW {
        int print(int);
    }
    namespace Primer {
        double print(double);
    }
    // <span class="docEmphasis">using</span> <span class="docEmphItalicAlt">directives:</span>
    // <span class="docEmphItalicAlt">form an overload set of functions from different namespaces</span>
    using namespace AW;
    using namespace Primer;
    long double print(long double);
    int main() {
        print(1);   // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">AW::print(int)</span>
        print(3.1); // <span class="docEmphItalicAlt">calls</span> <span class="docEmphasis">Primer::print(double)</span>
        return 0;
    }
</pre>
<br>

        <a name="idd1e140896"></a><a name="idd1e140901"></a><a name="idd1e140906"></a>
<p class="docText">The overload set for the function <tt>print</tt> in global scope contains the functions <tt>print(int), print(double)</tt>, and <tt>print(long double)</tt>. These functions are all part of the overload set considered for the function calls in <tt>main</tt>, even though these functions were originally declared in different namespace scopes.</p>
<p class="docText">全局作用域中 <tt>print</tt> 函数的重载集合包含函数 <tt>print(int)、print(double)</tt> 和 <tt>print(long double)</tt>，即使这些函数原来在不同的命名空间中声明，它们都是为 <tt>main</tt> 中函数调用考虑的重载集合的组成部分。</p>

        <a name="ch17sb14"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 17.2.6</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch17qa11q1"></a><b>Exercise 17.22:</b></td>

                    <td>
                      <p class="docText">Given the following code, determine which function, if any, matches the call to <tt>compute</tt>. List the candidate and viable functions. What type conversion sequence, if any, is applied to the argument to match the parameter in each viable function?</p>

                      <p class="docText">给定下面的代码，如果有，确定哪个函数与 <tt>compute</tt> 函数的调用匹配，列出候选函数与可行函数。如果有，对实参应用什么类型转换序列，以匹配每个可行函数的形参？</p>
                      <pre>
    namespace primerLib {
        void compute();
        void compute(const void *);
    }
    using primerLib::compute;
    void compute(int);
    void compute(double, double = 3.4);
    void compute(char*, char* = 0);

    int main()
    {
        compute(0);
        return 0;
    }
</pre><br>

                      <p class="docText">What would happen if the <tt>using</tt> declaration were located in <tt>main</tt> before the call to <tt>compute</tt>? Answer the same questions as before.</p>

                      <p class="docText">如果 <tt>main</tt> 中的 <tt>using</tt> 声明放在 <tt>compute</tt> 调用之前，会发生什么情况？回答与前面相同的问题。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
<br>

        <a name="ch17lev2sec18"></a>
        <h4 class="docSection2Title">17.2.7. Namespaces and Templates</h4>
        <h4 class="docSection2Title">17.2.7. 命名空间与模板</h4>
<p class="docText">Declaring a template within a namespace impacts how template specializations (<a class="docLink" href="ch16lev1sec6.html#ch16lev1sec6" >Section 16.6</a>, p. <a class="docLink" href="ch16lev1sec6.html#ch16lev1sec6" >671</a>) are declared: An explicit specialization of a template must be declared in the namespace in which the generic template is defined. Otherwise, the specialization would have a different name than the template it specialized.</p>
<p class="docText">在命名空间内部声明模板影响着怎样声明模板特化（<a class="docLink" href="ch16lev1sec6.html#ch16lev1sec6" >第 16.6 节</a>）：模板的显式特化必须在定义通用模板的命名空间中声明，否则，该特化将与它所特化的模板不同名。</p>

<p class="docText">There are two ways to define a specialization: One is to reopen the namespace and add the definition of the specialization, which we can do because namespace definitions are discontiguous, Alternatively, we could define the specialization in the same way that we can define any namespace member outside its namespace definition: by defining the specialization using the template name qualified by the name of the namespace.</p>
<p class="docText">有两种定义特化的方式：一种是重新打开命名空间并加入特化的定义，可以这样做是因为命名空间定义是不连续的；或者，可以用与在命名空间定义外部定义命名空间成员相同的方式来定义特化：使用由命名空间名字限定的模板名定义特化。</p>

        <a name="ch17note31"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">To provide our own specializations of templates defined in a namespace, we must ensure that the specialization definition is defined as being in the namespace containing the original template definition.</p>

                <p class="docText">为了提供命名空间中所定义模板的自己的特化，必须保证在包含原始模板定义的命名空间中定义特化。</p>
              </td>
            </tr>
          </table><br>
        </div>
<br>

        <pre>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
</pre>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch17lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch17lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
