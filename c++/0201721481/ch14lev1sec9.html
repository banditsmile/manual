<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 14.9.  Conversions and Class Types</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch14lev1sec8.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch14lev1sec10.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch14lev1sec9"></a>

        <h3 class="docSection1Title">14.9. Conversions and Class Types</h3>
        <h3 class="docSection1Title">14.9. 转换与类类型</h3>

        <p class="docText">In <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23" >Section 12.4.4</a> (p. <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23" >461</a>) we saw that a non<tt>explicit</tt> constructor that can be called with one argument defines an implicit conversion. The compiler will use that conversion when an object of the argument type is supplied and an object of the class type is needed. Such constructors define conversions to the class type.</p><a name="ch14sb13"></a>
        <p class="docText">在<a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23" >第 12.4.4 节</a>介绍过，可用一个实参调用的非 <tt>explicit</tt> 构造函数定义一个隐式转换。当提供了实参类型的对象而需要一个类类型的对象时，编译器将使用该转换。这种构造函数定义了到类类型的转换。</p>

        <p class="docText">In addition to defining conversions <span class="docEmphasis">to</span> a class type, we can also define conversions <span class="docEmphasis">from</span> the class type. That is, we can define a conversion operator that, given an object of the class type, will generate an object of another type. As with other conversions, the compiler will apply this conversion automatically. Before showing how to define such conversions, we'll look at why they might be useful.</p><a name="ch14lev2sec30"></a>
        <p class="docText">除了定义<span class="docEmphasis">到</span>类类型的转换之外，我们还可以定义<span class="docEmphasis">从</span>类类型的转换。即，我们可以定义转换操作符，给定类类型的对象，该操作符将产生其他类型的对象。像其他转换一样，编译器将自动应用这个转换。在介绍如何定义这种转换之前，将说明它们为什么可能有用。</p>

        <h4 class="docSection2Title">14.9.1. Why Conversions Are Useful</h4>
        <h4 class="docSection2Title">14.9.1. 转换为什么有用</h4>

        <p class="docText">Assume that we want to define a class, which we'll name <tt>SmallInt</tt>, to implement safe small integers. Our class will allow us to define objects that could hold the same range of values as an 8-bit unsigned <tt>char</tt>that is, 0 to 255. This class would catch under- and overflow errors and so would be safer to use than a built-in <tt>unsigned char</tt>.</p>
        <p class="docText">假定想要定义一个名为 <tt>SmallInt</tt> 的类，该类实现安全小整数，这个类将使我们能够定义对象以保存与 8 位 <tt>unsigned char</tt> 同样范围的值，即，0 到 255。这个类可以捕获下溢和上溢错误，因此使用起来比内置 <tt>unsigned char</tt> 更安全。</p>

        <p class="docText">We'd want our class to define all the same operations as are supported by an <tt>unsigned char</tt>. In particular, we'd want to define the five arithmetic operators (<tt>+, -, *, /</tt>, and <tt>%)</tt> and the corresponding compound-assignment operators; the four relational operators (<tt>&lt;, &lt;=, &gt;</tt>, and <tt>&gt;=);</tt> and the equality operators (<tt>==</tt> and <tt>!=</tt>). Evidently, we'd need to define 16 operators.</p><a name="ch14lev3sec18"></a>
	<p class="docText">我们希望这个类定义 <tt>unsigned char</tt> 支持的所有操作。具体而言，我们想定义 5 个算术操作符（<tt>+</tt>、<tt>-</tt>、<tt>*</tt>、<tt>/</tt>、<tt>%</tt>）及其对应的复合赋值操作符，4 个关系操作符（<tt>&lt;</tt>、<tt>&lt;=</tt>、<tt>&gt;</tt>、<tt>&gt;=</tt>），以及相等操作符（<tt>==</tt>、<tt>!=</tt>）。显然，需要定义 16 个操作符。</p>

        <h5 class="docSection3Title">Supporting Mixed-Type Expressions</h5>
        <h5 class="docSection3Title">支持混合类型表达式</h5>

        <p class="docText">Moreover, we'd like to be able to use these operators in mixed-mode expressions. For example, it should be possible to add two <tt>SmallInt</tt> objects and also possible to add any of the arithmetic types to a <tt>SmallInt</tt>. We could come close by defining three instances for each operator:</p>
        <p class="docText">而且，我们希望可以在混合模式表达式中使用这些操作符。例如，应该可以将两个 <tt>SmallInt</tt> 对象相加，也可以将任意算术类型加到 <tt>SmallInt</tt>。通过为每个操作符定义三个实例来达到目标：</p>
        <pre>
     int operator+(int, const SmallInt&amp;);
     int operator+(const SmallInt&amp;, int);
     SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;);
</pre><br>

	<a name="idd1e109572"></a><a name="idd1e109577"></a><a name="idd1e109582"></a><a name="idd1e109587"></a>
        <p class="docText">Because there is a conversion to <tt>int</tt> from any of the arithmetic types, these three functions would cover our desire to support mixed mode use of <tt>SmallInt</tt> objects. However, this design only approximates the behavior of built-in integer arithmetic. It wouldn't properly handle mixed-mode operations for the floating-point types, nor would it properly support addition of <tt>long, unsigned int</tt>, or <tt>unsigned long</tt>. The problem is that this design converts all arithmetic types even those bigger than <tt>int</tt>to <tt>int</tt> and does an <tt>int</tt> addition.</p>
	<p class="docText">因为存在从任意算术类型到 <tt>int</tt> 的转换，这三个函数可以涵盖支持 <tt>SmallInt</tt> 对象的混合模式使用的要求。但是，这个设计仅仅接近内置整数运算的行为，它不能适当处理浮点类型混合模式操作，也不能适当支持 <tt>long</tt> 、<tt>unsigned int</tt> 或 <tt>unsigned long</tt> 的加运算。问题在于这个设计将所有算术类型（甚至包括那些比 <tt>int</tt> 大的）转换为 <tt>int</tt> 并进行 <tt>int</tt> 加运算。</p>

	<a name="ch14lev3sec19"></a>
        <h5 class="docSection3Title">Conversions Reduce the Number of Needed Operators</h5>
        <h5 class="docSection3Title">转换减少所需操作符的数目</h5>

        <p class="docText">Even ignoring the issue of floating-point or large integral operands, if we implemented this design, we'd have to define 48 operators! Fortunately, C++ provides a mechanism by which a class can define its own conversions that can be applied to objects of its class type. For <tt>SmallInt</tt>, we could define a conversion from <tt>SmallInt</tt> to type <tt>int</tt>. If we define the conversion, then we won't need to define any of the arithmetic, relational, or equality operators. Given a conversion to <tt>int</tt>, a <tt>SmallInt</tt> object could be used anywhere an <tt>int</tt> could be used.</p>
        <p class="docText">即使忽略浮点或大整型操作数的问题，如果要实现这个设计，也必须定义 48 个操作符！幸好，C++ 提供了一种机制，利用这种机制，一个类可以定义自己的转换，应用于其类类型对象。对 <tt>SmallInt</tt> 而言，可以定义一个从 <tt>SmallInt</tt> 到 <tt>int</tt> 类型的转换。如果定义了该转换，则无须再定义任何算术、关系或相等操作符。给定到 <tt>int</tt> 的转换，<tt>SmallInt</tt> 对象可以用在任何可用 <tt>int</tt> 值的地方。</p>

        <p class="docText">If there were a conversion to <tt>int</tt>, then</p>
        <p class="docText">如果存在一个到 <tt>int</tt> 的转换，则以下代码：</p>
        <pre>
     SmallInt si(3);
     si + 3.14159;         // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span>, <span class="docEmphItalicAlt">then convert to</span> <span class="docEmphasis">double</span>
</pre><br>

        <p class="docText">would be resolved by</p>
        <p class="docText">可这样确定：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">Converting <tt>si</tt> to an <tt>int</tt>.</p>
                <p class="docList">将 <tt>si</tt> 转换为 <tt>int</tt> 值。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Converting the resulting <tt>int</tt> to <tt>double</tt> and adding it to the double literal constant <tt>3.14159</tt>, yielding a <tt>double</tt> value.</p>
                <p class="docList">将所得 <tt>int</tt> 结果转换为 <tt>double</tt> 值并与双精度字面值常量 <tt>3.14159</tt> 相加，得到 <tt>double</tt> 值。</p>
              </div>
            </li>
          </ol>
        </div><a name="ch14lev2sec31"></a>

        <h4 class="docSection2Title">14.9.2. Conversion Operators</h4>
        <h4 class="docSection2Title">14.9.2. 转换操作符</h4>

        <p class="docText">A <b><a name="ch14term4"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_04" >conversion operator</a></b> is a special kind of class member function. It defines a conversion that converts a value of a class type to a value of some other type. A conversion operator is declared in the class body by specifying the keyword <tt>operator</tt> followed by the type that is the target type of the conversion:</p>
        <p class="docText"><b><a class="docLink" href="ch14lev1sec11.html#gloss14_04" >转换操作符</a></b>是一种特殊的类成员函数。它定义将类类型值转变为其他类型值的转换。转换操作符在类定义体内声明，在保留字 <tt>operator</tt> 之后跟着转换的目标类型：</p>
        <pre>
     class SmallInt {
     public:
         SmallInt(int i = 0): val(i)
         { if (i &lt; 0 || i &gt; 255)
            throw std::out_of_range("Bad SmallInt initializer");
         }
         operator int() const { return val; }
     private:
         std::size_t val;
     };
</pre><br>

        <p class="docText">A conversion function takes the general form</p>
        <p class="docText">转换函数采用如下通用形式：</p>
        <pre>
     operator <span class="docEmphasis">type()</span>;
</pre><br>

        <p class="docText">where <span class="docEmphasis">type</span> represents the name of a built-in type, a class type, or a name defined by a typedef. Conversion functions can be defined for any type (other than <tt>void</tt>) that <a name="idd1e109743"></a>could be a function return type. In particular, conversions to an array or function type are not permitted. Conversions to pointer typesboth data and function pointersand to reference types are allowed.</p><a name="ch14note25"></a>
        <p class="docText">这里，<span class="docEmphasis">type</span> 表示内置类型名、类类型名或由类型别名定义的名字。对任何可作为函数返回类型的类型（除了 <tt>void</tt> 之外）都可以定义转换函数。一般而言，不允许转换为数组或函数类型，转换为指针类型（数据和函数指针）以及引用类型是可以的。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A conversion function must be a member function. The function may not specify a return type, and the parameter list must be empty.</p>
                <p class="docText">转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">All of the following declarations are errors:</p>
        <p class="docText">下述所有声明都是错误的：</p>
        <pre>
     operator int(SmallInt &amp;);            // <span class="docEmphItalicAlt">error: nonmember</span>

     class SmallInt {
     public:
         int operator int();              // <span class="docEmphItalicAlt">error: return type</span>
         operator int(int = 0);           // <span class="docEmphItalicAlt">error: parameter list</span>
         // ...
     };
</pre><br>

        <p class="docText">Although a conversion function does not specify a return type, each conversion function must explicitly return a value of the named type. For example, <tt>operator int</tt> returns an <tt>int</tt>; if we defined an <tt>operator Sales_item</tt>, it would return a <tt>Sales_item;</tt> and so on.</p>
        <p class="docText">虽然转换函数不能指定返回类型，但是每个转换函数必须显式返回一个指定类型的值。例如，<tt>operator int</tt> 返回一个 <tt>int</tt> 值；如果定义 <tt>operator Sales_item</tt>，它将返回一个 <tt>Sales_item</tt> 对象，诸如此类。</p>

<a name="ch14note26"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Conversion operations ordinarily should not change the object they are converting. As a result, conversion operators usually should be defined as <tt>const</tt> members.</p>
                <p class="docText">转换函数一般不应该改变被转换的对象。因此，转换操作符通常应定义为 <tt>const</tt> 成员。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch14lev3sec20"></a>

        <h5 class="docSection3Title">Using a Class-Type Conversion</h5>
        <h5 class="docSection3Title">使用类类型转换</h5>

        <p class="docText">Once a conversion exists, the compiler will call it automatically (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec25" >Section 5.12.1</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec25" >179</a>) in the same places that a built-in conversion would be used:</p>
        <p class="docText">只要存在转换，编译器将在可以使用内置转换的地方自动调用它（<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec25" >第 5.12.1 节</a>）：</p>

        <ul>
          <li>
            <p class="docList">In expressions:</p>
            <p class="docList">在表达式中：</p>
            <pre>
     SmallInt si;
     double dval;
     si &gt;= dval          // <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and then convert to</span> <span class="docEmphasis">double</span>
</pre><br>
          </li>

          <li>
            <p class="docList">In conditions:</p>
            <p class="docList">在条件中：</p>
            <pre>
     if (si)                // <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and then convert to</span> <span class="docEmphasis">bool</span>
</pre><br>
          </li>

          <li>
            <p class="docList">When passing arguments to or returning values from a function:</p>
            <p class="docList">将实参传给函数或从函数返回值：</p>
            <pre>
     int calc(int);
     SmallInt si;
     int i = calc(si);      // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and call</span> <span class="docEmphasis">calc</span>
</pre><br>
          </li>

          <li>
            <p class="docList">As operands to overloaded operators:</p>
            <p class="docList">作为重载操作符的操作数：</p>
            <pre>
     // <span class="docEmphItalicAlt">convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">then call opeator&lt;&lt; on the</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">value</span>
     cout &lt;&lt; si &lt;&lt; endl;
</pre><br>
          </li>

          <li>
		<a name="idd1e109936"></a><a name="idd1e109941"></a>
		<p class="docList">In an explicit cast:</p>
		<p class="docList">在显式类型转换中：</p>
            <pre>
     int ival;
     SmallInt si = 3.541; //
     <span class="docEmphItalicAlt">instruct compiler to cast si to int</span>
     ival = static_cast&lt;int&gt;(si) + 3;
</pre><br>
          </li>
        </ul><a name="ch14lev3sec21"></a>

        <h5 class="docSection3Title">Class-Type Conversions and Standard Conversions</h5>
        <h5 class="docSection3Title">类类型转换和标准转换</h5>

        <p class="docText">When using a conversion function, the converted type need not exactly match the needed type. A class-type conversion can be followed by a standard conversion (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec27" >Section 5.12.3</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec27" >181</a>) if needed to obtain the desired type. For example, in the comparison between a <tt>SmallInt</tt> and a <tt>double</tt></p>
        <p class="docText">使用转换函数时，被转换的类型不必与所需要的类型完全匹配。必要时可在类类型转换之后跟上标准转换以获得想要的类型。例如，在一个 <tt>SmallInt</tt> 对象与一个 <tt>double</tt> 值的比较中：</p>
        <pre>
     SmallInt si;
     double dval;
     si &gt;= dval // <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and then convert to</span> <span class="docEmphasis">double</span>
</pre><br>

        <p class="docText"><tt>si</tt> is first converted from a <tt>SmallInt</tt> to an <tt>int</tt>, and then the <tt>int</tt> value is converted to <tt>double</tt>.</p><a name="ch14lev3sec22"></a>
        <p class="docText">首先将 <tt>si</tt> 从 <tt>SmallInt</tt> 对象转换为 <tt>int</tt> 值，然后将该 <tt>int</tt> 值转换为 <tt>double</tt> 值。</p>

        <h5 class="docSection3Title">Only One Class-Type Conversion May Be Applied</h5><a name="ch14note27"></a>
        <h5 class="docSection3Title">只能应用一个类类型转换</h5>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A class-type conversion may not be followed by another class-type conversion. If more than one class-type conversion is needed then the code is in error.</p>
                <p class="docText">类类型转换之后不能再跟另一个类类型转换。如果需要多个类类型转换，则代码将出错。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">For example, assume we had another class, <tt>Integral</tt>, that could be converted to <tt>SmallInt</tt> but that had no conversion to <tt>int</tt>:</p>
        <p class="docText">例如，假定有另一个类 <tt>Integral</tt>，它可以转换为 <tt>SmallInt</tt> 但不能转换为 <tt>int</tt>：</p>
        <pre>
     // <span class="docEmphItalicAlt">class to hold unsigned integral values</span>
     class Integral {
     public:
         Integral(int i = 0): val(i) { }
         operator SmallInt() const { return val % 256; }
     private:
         std::size_t val;
     };
</pre><br>

        <p class="docText">We could use an <tt>Integral</tt> where a <tt>SmallInt</tt> is needed, but not where an <tt>int</tt> is required:</p>
	<p class="docText">可以在需要 <tt>SmallInt</tt> 的地方使用 <tt>Integral</tt>，但不能在需要 <tt>int</tt> 的地方使用 <tt>Integeral</tt>：</p>
        <pre>
     int calc(int);
     Integral intVal;
     SmallInt si(intVal);  // <span class="docEmphItalicAlt">ok: convert</span> <span class="docEmphasis">intVal</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">and copy to</span> <span class="docEmphasis">si</span>
     int i = calc(si);     // <span class="docEmphItalicAlt">ok: convert</span> <span class="docEmphasis">si</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and call</span> <span class="docEmphasis">calc</span>
     int j = calc(intVal); // <span class="docEmphasis">error: no conversion to int from Integral</span>
</pre><br>

        <p class="docText">When we create <tt>si</tt>, we use the <tt>SmallInt</tt> copy constructor. First <tt>int_val</tt> is converted to a <tt>SmallInt</tt> by invoking the <tt>Integral</tt> conversion operator to generate a temporary value of type <tt>SmallInt</tt>. The (synthesized) <tt>SmallInt</tt> copy constructor then uses that value to initialize <tt>si</tt>.</p>
	<p class="docText">创建 <tt>si</tt> 时使用 <tt>SmallInt</tt> 复制构造函数。首先调用 <tt>Integral</tt> 转换操作符产生一个 <tt>SmallInt</tt> 类型的临时值，将 <tt>int_val</tt> 对象转换为 <tt>SmallInt</tt>。然后（合成的）复制构造函数使用该对象值初始化 <tt>si</tt>。</p>

	<a name="idd1e110138"></a><a name="idd1e110145"></a><a name="idd1e110152"></a>
        <p class="docText">The first call to <tt>calc</tt> is also okay: The argument <tt>si</tt> is automatically converted to <tt>int</tt>, and the <tt>int</tt> value is passed to the function.</p>
        <p class="docText">第一个 <tt>calc</tt> 调用也是正确的：将实参 <tt>si</tt> 自动转换为 <tt>int</tt>，然后将 <tt>int</tt> 值传给函数。</p>

        <p class="docText">The second call is an error: There is no direct conversion from <tt>Integral</tt> to <tt>int</tt>. To get an <tt>int</tt> from an <tt>Integral</tt> would require two class-type conversions: first from <tt>Integral</tt> to <tt>SmallInt</tt> and then from <tt>SmallInt</tt> to <tt>int</tt>. However, the language allows only one class-type conversion, so the call is in error.</p><a name="ch14lev3sec23"></a>
	<p class="docText">第二个 <tt>calc</tt> 调用是错误的：没有从 <tt>Integral</tt> 到 <tt>int</tt> 的直接转换。从 <tt>int</tt> 需要两次类类型转换：首先从 <tt>Integral</tt> 到 <tt>SmallInt</tt>，然后从 <tt>SmallInt</tt> 到 <tt>int</tt>。但是，语言只允许一次类类型转换，所以该调用出错。</p>

        <h5 class="docSection3Title">Standard Conversions Can Precede a Class-Type Conversion</h5>
        <h5 class="docSection3Title">标准转换可放在类类型转换之前</h5>

        <p class="docText">When using a constructor to perform an implicit conversion (<a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23" >Section 12.4.4</a>, p. <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23" >462</a>), the parameter type of the constructor need not exactly match the type supplied. For example, the following code invokes the constructor <tt>SmallInt(int)</tt> defined in class <tt>SmallInt</tt> to convert <tt>sobj</tt> to the type <tt>SmallInt</tt>:</p>
        <p class="docText">使用构造函数执行<a class="docLink" href="ch12lev1sec4.html#ch12lev2sec23" >隐式转换（第 12.4.4 节）</a>的时候，构造函数的形参类型不必与所提供的类型完全匹配。例如，下面的代码调用 <tt>SmallInt(int)</tt> 类中定义的构造函数（<tt>SmallInt(int)</tt>）将 <tt>sobj</tt> 转换为 <tt>SmallInt</tt> 类型：</p>
        <pre>
     void calc(SmallInt);
     short sobj;
     // <span class="docEmphasis">sobj</span> <span class="docEmphItalicAlt">promoted from</span> <span class="docEmphasis">short</span> <span class="docEmphItalicAlt">to int</span>
     // <span class="docEmphItalicAlt">that</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">through the</span> <span class="docEmphasis">SmallInt(int)</span> <span class="docEmphItalicAlt">constructor</span>
     calc(sobj);
</pre><br>

        <p class="docText">If needed, a standard conversion sequence can be applied to an argument before a constructor is called to perform a class-type conversion. To call the function <tt>calc()</tt>, a standard conversion is applied to convert <tt>dobj</tt> from type <tt>double</tt> to type <tt>int</tt>. The <tt>SmallInt(int)</tt> constructor is then invoked to convert the result of the conversion to the type <tt>SmallInt</tt>.</p><a name="ch14sb14"></a>
        <p class="docText">如果需要，在调用构造函数执行类类型转换之前，可将一个标准转换序列应用于实参。为了调用函数 <tt>calc()</tt>，应用标准转换将 <tt>dobj</tt> 从 <tt>double</tt> 类型转换为 <tt>int</tt> 类型，然后调用构造函数 <tt>SmallInt(int)</tt> 将转换结果转换为 <tt>SmallInt</tt> 类型。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 14.9.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa13q1"></a><b>Exercise 14.40:</b></td>

                    <td>
                      <p class="docText">Write operators that could convert a <tt>Sales_item</tt> to <tt>string</tt> and to <tt>double</tt>. What values do you think these operators should return? Do you think these conversions are a good idea? Explain why or why not.</p>
                      <p class="docText">编写可将 <tt>Sales_item</tt> 对象转换为 <tt>string</tt> 类型和 <tt>double</tt> 类型的操作符。你认为这些操作符应返回什么值？你认为定义这些操作符是个好办法吗？解释你的结论。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa13q2"></a><b>Exercise 14.41:</b></td>

                    <td>
                      <p class="docText">Explain the difference between these two conversion operators:</p>
                      <p class="docText">解释这两个转换操作符之间的不同：</p>
                      <pre>
     class Integral {
     public:
         const int();
         int() const;
     };
</pre><br>

                      <p class="docText">Are either of these conversions too restricted? If so, how might you make the conversion more general?</p>
                      <p class="docText">这两个转换操作符是否太严格了？如果是，怎样使得转换更通用一些？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa13q3"></a><b>Exercise 14.42:</b></td>

                    <td>
                      <p class="docText">Define a conversion operator to <tt>bool</tt> for the <tt>CheckoutRecord</tt> class from the exercises in <a class="docLink" href="ch14lev1sec2.html#ch14sb04" >Section 14.2.1</a> (p. <a class="docLink" href="ch14lev1sec2.html#ch14sb04" >515</a>).</p>
		      <p class="docText">为<a class="docLink" href="ch14lev1sec2.html#ch14sb04" >第 14.2.1 节</a>习题中的 <tt>CheckoutRecord</tt> 类定义到 <tt>bool</tt> 的转换操作符。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa13q4"></a><b>Exercise 14.43:</b></td>

                    <td>
                      <p class="docText">Explain what the <tt>bool</tt> conversion operator does. Is that the only possible meaning for this conversion for the <tt>CheckoutRecord</tt> type? Explain whether you think this conversion is a good use of a conversion operation.</p>
                      <p class="docText">解释　<tt>bool</tt>　转换操作符做了什么。这是这个　<tt>CheckoutRecord</tt>　类型转换唯一可能的含义吗？解释你是否认为这个转换是一种转换操作的良好使用。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch14lev2sec32"></a>

        <h4 class="docSection2Title">14.9.3. Argument Matching and Conversions</h4>
        <h4 class="docSection2Title">14.9.3. 实参匹配和转换</h4>

<a name="ch14note28"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
		<a name="idd1e110385"></a><a name="idd1e110390"></a><a name="idd1e110397"></a><a name="idd1e110404"></a><a name="idd1e110409"></a><a name="idd1e110416"></a><a name="idd1e110423"></a>
                <p class="docText"> The rest of this chapter covers a somewhat advanced topic. It can be safely skipped on first reading.</p>
                <p class="docText">本章其余部分讨论比较高级的主题。在第一次阅读时可跳过这些内容。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Class-type conversions can be a boon to implementing and using classes. By defining a conversion to <tt>int</tt> for <tt>SmallInt</tt>s, we made the class easier to implement and easier to use. The <tt>int</tt> conversion lets users of <tt>SmallInt</tt> use all the arithmetic and relational operators on <tt>SmallInt</tt> objects. Moreover, users can safely write expressions that intermix <tt>SmallInt</tt>s and other arithmetic types. The class implementor's job is made much easier by defining a single conversion operator instead of having to define 48 (or more) overloaded operators.</p>
	<p class="docText">类类型转换可能是实现和使用类的一个好处。通过为 <tt>SmallInt</tt> 定义到　<tt>int</tt>　的转换，能够更容易实现和使用 <tt>SmallInt</tt> 类。<tt>int</tt> 转换使 <tt>SmallInt</tt> 的用户能够对 <tt>SmallInt</tt> 对象使用所有算术和关系操作符，而且，用户可以安全编写将 <tt>SmallInt</tt> 和其他算术类型混合使用的表达式。定义一个转换操作符就能代替定义 48 个（或更多）重载操作符，类实现者的工作就简单多了。</p>

        <p class="docText">Class-type conversions can also be a great source of compile-time errors. Problems arise when there are multiple ways to convert from one type to another. If there are several class-type conversions that could be used, the compiler must figure out which one to use for a given expression. In this section, we look at how class-type conversions are used to match an argument to its corresponding parameter. We look first at how parameters are matched for functions that are not overloaded and then look at overloaded functions.</p>
        <p class="docText">类类型转换也可能是编译时错误的一大来源。当从一个类型转换到另一类型有多种方式时，问题就出现了。如果有几个类类型转换可以使用，编译器必须决定对给定表达式使用哪一个。在这一节，我们介绍怎样用类类型转换将实参和对应形参相匹配。首先介绍非重载函数的形参匹配，然后介绍重载函数的形参匹配。</p>

	<a name="ch14note29"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Used carefully, class-type conversions can greatly simplify both class and user code. Used too freely, they can lead to mysterious compile-time errors that can be hard to understand and hard to avoid.</p>
                <p class="docText">如果小心使用，类类型转换可以大大简化类代码和用户代码。如果使用得太过自由，类类型转换会产生令人迷惑的编译时错误，这些错误难以理解而且难以避免。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch14lev3sec24"></a>
        <h5 class="docSection3Title">Argument Matching and Multiple Conversion Operators</h5>
        <h5 class="docSection3Title">实参匹配和多个转换操作符</h5>

        <p class="docText">To illustrate how conversions on values of class type interact with function matching, we'll add two additional conversions to our <tt>SmallInt</tt> class. We'll add a second constructor that takes a <tt>double</tt> and also define a second conversion operator to convert <tt>SmallInt</tt> to <tt>double</tt>:</p>
        <p class="docText">为了举例说明类类型值的转换怎样与函数匹配相互作用，我们给　<tt>SmallInt</tt>　类加上另外两个转换，包括接受一个 <tt>double</tt> 参数的构造函数和一个将 <tt>SmallInt</tt> 转换为 <tt>double</tt> 的转换操作符：</p>
        <pre>
     // <span class="docEmphItalicAlt">unwise class definition:</span>
     // <span class="docEmphItalicAlt">multiple constructors and conversion operators to and from the built-in types</span>
     // <span class="docEmphItalicAlt">can lead to ambiguity problems</span>
     class SmallInt {
     public:
         // <span class="docEmphItalicAlt">conversions to</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">double</span>
         SmallInt(int = 0);
         SmallInt(double);
         // <span class="docEmphItalicAlt">Conversions to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">SmallInt</span>
         // <span class="docEmphasis">Usually it is unwise to define conversions to multiple arithmetic types</span>
         operator int() const { return val; }
         operator double() const { return val; }
         // ...
     private:
         std::size_t val;
     };
</pre><br>

        <a name="ch14note30"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
		<a name="idd1e110546"></a><a name="idd1e110550"></a><a name="idd1e110554"></a><a name="idd1e110558"></a>
                <p class="docText"> Ordinarily it is a bad idea to give a class conversions to or from two built-in types. We do so here to illustrate the pitfalls involved.</p>
                <p class="docText">一般而言，给出一个类与两个内置类型之间的转换是不好的做法，在这里这样做是为了举例说明所包含的缺陷。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Consider the simple case where we call a function that is not overloaded:</p>
        <p class="docText">考虑最简单的调用非重载函数的情况：</p>
        <pre>
     void compute(int);
     void fp_compute(double);
     void extended_compute(long double);
     SmallInt si;
     compute(si);          // <span class="docEmphasis">SmallInt::operator int() const</span>
     fp_compute(si);       // <span class="docEmphasis">SmallInt::operator double() const</span>
     extended_compute(si); // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>

        <p class="docText">Either conversion operator could be used in the call to <tt>compute</tt>:</p>
        <p class="docText">任一转换操作符都可用于 <tt>compute</tt> 调用中：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList"><tt>operator int</tt> generates an exact match to the parameter type.</p>
                <p class="docList"><tt>operator int</tt> 产生对形参类型的完全匹配。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList"><tt>operator double</tt> followed by the standard conversion from <tt>double</tt> to <tt>int</tt> matches the parameter type.</p>
                <p class="docList">首先调用 <tt>operator double</tt> 进行转换，后跟从 <tt>double</tt> 到 <tt>int</tt> 的标准转换与形参类型匹配。</p>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">An exact match is a better conversion than one that requires a standard conversion. Hence, the first conversion sequence is better. The conversion function <tt>SmallInt::operator int()</tt> is chosen to convert the argument.</p>
        <p class="docText">完全匹配转换比需要标准转换的其他转换更好，因此，第一个转换序列更好，选择转换函数 <tt>SmallInt::operator int()</tt> 来转换实参。</p>

        <p class="docText">Similarly, in the second call, <tt>fp_compute</tt> could be called using either conversion. However, the conversion to <tt>double</tt> is an exact match; it requires no additional standard conversion.</p>
        <p class="docText">类似地，在第二个调用中，可用任一转换调用 <tt>fp_compute</tt>。但是，到 <tt>double</tt> 的转换是一个完全匹配，不需要额外的标准转换。</p>

        <p class="docText">The final call to <tt>extended_compute</tt> is ambiguous. Either conversion function could be used, but each would have to be followed by a standard conversion to get to <tt>long double</tt>. Hence, neither conversion is better than the other, so the call is ambiguous.</p><a name="ch14note31"></a>
        <p class="docText">最后一个对 <tt>extended_compute</tt> 的调用有二义性。可以使用任一转换函数，但每个都必须跟上一个标准转换来获得 <tt>long double</tt>，因此，没有一个转换比其他的更好，调用具有二义性。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">If two conversion operators could be used in a call, then the rank of the standard conversion (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec30" >Section 7.8.4</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec30" >272</a>), if any, <span class="docEmphasis">following</span> the conversion function is used to select the best match.</p>
                <p class="docText">如果两个转换操作符都可用在一个调用中，而且在转换函数之后存在标准转换（<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec30" >第 7.8.4 节</a>），则根据该标准转换的类别选择最佳匹配。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch14lev3sec25"></a>
        <h5 class="docSection3Title">Argument Matching and Conversions by Constructors</h5>
        <h5 class="docSection3Title">实参匹配和构造函数转换</h5>

        <p class="docText">Just as there might be two conversion operators, there can also be two constructors that might be applied to convert a value to the target type of a conversion.</p>
        <p class="docText">正如可能存在两个转换操作符，也可能存在两个构造函数可以用来将一个值转换为目标类型。</p>

        <p class="docText">Consider the <tt>manip</tt> function, which takes an argument of type <tt>SmallInt</tt>:</p>
        <p class="docText">考虑 <tt>manip</tt> 函数，它接受一个 <tt>SmallInt</tt> 类型的实参：</p>
        <pre>
     void manip(const SmallInt &amp;);
     double d; int i; long l;
     manip(d);     // <span class="docEmphItalicAlt">ok: use</span> <span class="docEmphasis">SmallInt(double)</span> <span class="docEmphItalicAlt">to convert the argument</span>
     manip(i);     // <span class="docEmphItalicAlt">ok: use</span> <span class="docEmphasis">SmallInt(int)</span> <span class="docEmphItalicAlt">to convert the argument</span>
     manip(l);     // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>

        <p class="docText">In the first call, we could use either of the <tt>SmallInt</tt> constructors to convert <tt>d</tt> to a value of type <tt>SmallInt</tt>. The <tt>int</tt> constructor requires a standard conversion on <tt>d</tt>, whereas the <tt>double</tt> constructor is an exact match. Because an exact match is better than a standard conversion, the constructor <tt>SmallInt(double)</tt> is used for the conversion.</p>
        <p class="docText">在第一个调用中，可以用任一构造函数将 <tt>d</tt> 转换为 <tt>SmallInt</tt> 类型的值。<tt>int</tt> 构造函数需要对 <tt>d</tt> 的标准转换，而 <tt>double</tt> 构造函数完全匹配。因为完全匹配比标准转换更好，所以用构造函数 <tt>SmallInt(double)</tt> 进行转换。</p>

        <p class="docText">In the second call, the reverse is true. The <tt>SmallInt(int)</tt> constructor provides an exact matchno additional conversion is needed. To call the <tt>SmallInt</tt> constructor that takes a <tt>double</tt> would require that <tt>i</tt> first be converted to <tt>double</tt>. For this call, the <tt>int</tt> constructor would be used to convert the argument.</p>
	<p class="docText">在第二个调用中，情况恰恰相反，构造函数 <tt>SmallInt(int)</tt> 提供完全匹配——不需要附加的转换，调用接受一个 <tt>double</tt> 参数的 <tt>SmallInt</tt> 构造函数需要首先将 <tt>i</tt> 转换为 <tt>double</tt> 类型。对于这个调用，用 <tt>int</tt> 构造函数转换实参。</p>

        <p class="docText">The third call is ambiguous. Neither constructor is an exact match for <tt>long</tt>. Each would require that the argument be converted before using the constructor:</p>
        <p class="docText">第三个调用具有二义性。没有构造函数完全匹配于 <tt>long</tt>。使用每一个构造函数之前都需要对实参进行转换：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">standard conversion (<tt>long</tt> to <tt>double</tt>) followed by <tt>SmallInt(double)</tt></p>
                <p class="docList">标准转换（从 <tt>long</tt> 到 <tt>double</tt>）后跟 <tt>SmallInt(double)</tt>。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">standard conversion (<tt>long</tt> to <tt>int</tt>) followed by <tt>SmallInt(int)</tt></p>
                <p class="docList">标准转换（从 <tt>long</tt> 到 <tt>int</tt>）后跟 <tt>SmallInt(int)</tt>。</p>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">These conversion sequences are indistinguishable, so the call is ambiguous.</p>
        <p class="docText">这些转换序列是不能区别的，所以该调用具有二义性。</p>

	<a name="ch14note32"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">When two constructor-defined conversions could be used, the rank of the standard conversion, if any, required on the constructor argument is used to select the best match.</p>
                <p class="docText">当两个构造函数定义的转换都可以使用时，如果存在构造函数实参所需的标准转换，就用该标准转换的类型选择最佳匹配。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch14lev3sec26"></a>

        <h5 class="docSection3Title">Ambiguities When Two Classes Define Conversions</h5>
        <h5 class="docSection3Title">当两个类定义了转换时的二义性</h5>

        <p class="docText">When two classes define conversions to each other, ambiguities are likely:</p>
        <p class="docText">当两个类定义了相互转换时，很可能存在二义性：</p>
        <pre>
     class Integral;
     class SmallInt {
     public:
         SmallInt(Integral); // <span class="docEmphItalicAlt">convert from</span> <span class="docEmphasis">Integral to SmallInt</span>
         // ...
      };
     class Integral {
     public:
         operator SmallInt() const; // <span class="docEmphItalicAlt">convert from</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphItalicAlt">Integral</span>
         // ...
      };
     void compute(SmallInt);
     Integral int_val;
     compute(int_val);  // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>

        <p class="docText">The argument <tt>int_val</tt> can be converted to a <tt>SmallInt</tt> in two different ways. The compiler could use the <tt>SmallInt</tt> constructor that takes an <tt>Integral</tt> object or it could use the <tt>Integral</tt> conversion operation that converts an <tt>Integral</tt> to a <tt>SmallInt</tt>. Because these two functions are equally good, the call is in error.</p>
        <p class="docText">实参 <tt>int_val</tt> 可以用两种不同方式转换为 <tt>SmallInt</tt> 对象，编译器可以使用接受 <tt>Integral</tt> 对象的构造函数，也可以使用将 <tt>Integral</tt> 对象转换为 <tt>SmallInt</tt> 对象的 <tt>Integral</tt> 转换操作。因为这两个函数没有高下之分，所以这个调用会出错。</p>

        <p class="docText">In this case, we cannot use a cast to resolve the ambiguitythe cast itself could use either the conversion operation or the constructor. Instead, we would need to explicitly call the conversion operator or the constructor:</p>
        <p class="docText">在这种情况下，不能用显式类型转换来解决二义性——显式类型转换本身既可以使用转换操作又可以使用构造函数，相反，需要显式调用转换操作符或构造函数：</p>
        <pre>
     compute(int_val.operator SmallInt());   // <span class="docEmphItalicAlt">ok: use conversion operator</span>
     compute(SmallInt(int_val));             // <span class="docEmphItalicAlt">ok: use</span> <span class="docEmphasis">SmallInt</span> <span class="docEmphItalicAlt">constructor</span>
</pre><br>

	<a name="idd1e110877"></a><a name="idd1e110882"></a>
        <p class="docText">Moreover, conversions that we might think would be ambiguous can be legal for what seem like trivial reasons. For example, our <tt>SmallInt</tt> class constructor copies its <tt>Integral</tt> argument. If we change the constructor so that it takes a reference to <tt>const Integral</tt></p>
        <p class="docText">而且，由于某些似乎微不足道的原因，我们认为可能有二义性的转换是合法的。例如，<tt>SmallInt</tt> 类构造函数复制它的 <tt>Integral</tt> 实参，如果改变构造函数以接受　<tt>const Integral</tt> 引用：</p>
        <pre>
     class SmallInt {
     public:
     SmallInt(const Integral&amp;);
     };
</pre><br>

        <p class="docText">our call to <tt>compute(int_val)</tt> is no longer ambiguous! The reason is that using the <tt>SmallInt</tt> constructor requires binding a reference to <tt>int_val</tt>, whereas using class <tt>Integral</tt>'s conversion operator avoids this extra step. This small difference is enough to tip the balance in favor of using the conversion operator.</p><a name="ch14note33"></a>
        <p class="docText">则对 <tt>compute(int_val)</tt> 的调用不再有二义性！原因在于使用 <tt>SmallInt</tt> 构造函数需要将一个引用绑定到 <tt>int_val</tt>，而使用 <tt>Integral</tt> 类的转换操作符可以避免这个额外的步骤。这一小小区别足以使我们倾向于使用转换操作符。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The best way to avoid ambiguities or surprises is to avoid writing pairs of classes where each offers an implicit conversion to the other.</p>
                <p class="docText">避免二义性最好的方法是避免编写互相提供隐式转换的成对的类。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch14sb15"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Caution: Avoid Overuse of Conversion Functions</h2>
	      <h2 class="docSidebarTitle">警告：避免转换函数的过度使用</h2>

              <p class="docText"><span class="docEmphStrong">As with using overloaded operators, judicious use of conversion operators can greatly simplify the job of a class designer and make using a class easier. However, there are two potential pitfalls: Defining too many conversion operators can lead to ambiguous code, and some conversions can be confusing rather than helpful.</span></p>
              <p class="docText"><span class="docEmphStrong">与使用重载操作符一样，转换操作符的适当使用可以大大简化类设计者的工作并使得类的使用更简单。但是，有两个潜在的缺陷：定义太多转换操作符可能导致二义性代码，一些转换可能利大于弊。</span></p>

              <p class="docText"><span class="docEmphStrong">The best way to avoid ambiguities is to ensure that there is at most one way to convert one type to another. The best way to do that is to limit the number of conversion operators. In particular there should be only one conversion to a built-in type.</span></p>
              <p class="docText"><span class="docEmphStrong">避免二义性最好的方法是，保证最多只有一种途径将一个类型转换为另一类型。做到这点，最好的办法是限制转换操作符的数目，尤其是，到一种内置类型应该只有一个转换。</span></p>

              <p class="docText"><span class="docEmphStrong">Conversion operators can be misleading when they are used where there is no obvious single mapping between the class type and the conversion type. In such cases, providing a conversion function may be confusing to the user of the class.</span></p>
              <p class="docText"><span class="docEmphStrong">当转换操作符用于没有明显映射关系的类类型和转换类型之间时，容易引起误解，在这种情况下，提供转换函数可能会令类的使用者迷惑不解。</span></p>

              <p class="docText"><span class="docEmphStrong">As an example, if we had a class that represented a <tt>Date</tt>, we might think it would be a good idea to provide a conversion from <tt>Date</tt> to <tt>int</tt>. However, what value should the conversion function return? The function might return the julian date, which is the sequence number of the current date starting from 0 as January 1. But should the year precede the day or follow it? That is, would January 31, 1986 be represented as 1986031 or 311986? Alternatively, the conversion operator might return an <tt>int</tt> representing the day count since some epoch point. The counter might count days since January 1, 1971 or some other starting point.</span></p>
              <p class="docText"><span class="docEmphStrong">例如，如果有一个表示 <tt>Date</tt> 的类，我们可能会认为提供从 <tt>Date</tt> 到 <tt>int</tt> 的转换是个好主意，但是，这个转换函数应返回什么值？该函数可以返回公历日期，这是表示当前日期的一个顺序数，以 0 表示 1 月 1 日，但年份是否应放在日期之前或之后？即，1986 年 1 月 31 日是否应表示为 1986031 或 311986？作为一种选择，转换操作符可以返回一个表示从某个新纪元点开始计数的天数，计数器可以从 1971 年 1 月 1 是或其他起始点开始计算天数。</span></p>

              <p class="docText"><span class="docEmphStrong">The problem is that whatever choice is made, the use of <tt>Date</tt> objects will be ambiguous because there is no single one-to-one mapping between an object of type <tt>Date</tt> and a value of type <tt>int</tt>. In such cases, it is better not to define the conversion operator. Instead, the class ought to define one or more ordinary members to extract the information in these various forms.</span></p>
              <p class="docText"><span class="docEmphStrong">问题在于，无论怎样选择，<tt>Date</tt> 对象的使用将具有二义性，因为没有一个 <tt>Date</tt> 类型对象与 <tt>int</tt> 类型值之间的一对一映射。在这种情况下，不定义转换函数更好。相反，这个类应该定义一个或多个普通成员从这些不同形式中抽取信息。</span></p>
            </td>
          </tr>
        </table><br>

        <a name="ch14lev2sec33"></a>
        <h4 class="docSection2Title">14.9.4. Overload Resolution and Class Arguments</h4>
        <h4 class="docSection2Title">14.9.4. 重载确定和类的实参</h4>

        <p class="docText">As we have just seen, the compiler automatically applies a class conversion operator or constructor when needed to convert an argument to a function. Class <a name="idd1e110983"></a><a name="idd1e110989"></a><a name="idd1e110994"></a><a name="idd1e110999"></a><a name="idd1e111004"></a><a name="idd1e111011"></a>conversion operators, therefore, are considered during function resolution. Function overload resolution (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >269</a>) consists of three steps:</p><a name="ch14pro01"></a>
        <p class="docText">正如我们看到的，在需要转换函数的实参时，编译器自动应用类的转换操作符或构造函数。因此，应该在函数确定期间考虑类转换操作符。函数重载确定（<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >第 7.8.2 节</a>）由三步组成：</p>

        <table border="0" class="docText">
          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>1.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                Determine the set of candidate functions: These are the functions with the same name as the function being called.<br>
              <div class="docText">确定候选函数集合：这些是与被调用函数同名的函数。<br>
                <br>
              </div>
            </td>
          </tr>

          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>2.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                Select the viable functions: These are the candidate functions for which the number and type of the function's parameters match the arguments in the call. When selecting the viable functions, the compiler also determines which conversion operations, if any, are needed to match each parameter.<br>
              <div class="docText">选择可行的函数：这些是形参数目和类型与函数调用中的实参相匹配的候选函数。选择可行函数时，如果有转换操作，编译器还要确定需要哪个转换操作来匹配每个形参。<br>
                <br>
              </div>
            </td>
          </tr>

          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>3.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                The best match function is selected. To determine the best match, the type conversions needed to convert argument(s) to the type of the corresponding parameter(s) are ranked. For arguments and parameters of class type, the set of possible conversions includes class-type conversions.<br>
              <div class="docText">选择最佳匹配的函数。为了确定最佳匹配，对将实参转换为对应形参所需的类型转换进行分类。对于类类型的实参和形参，可能的转换的集合包括类类型转换。<br>
                <br>
              </div>
            </td>
          </tr>
  </table>
  
  <a name="ch14lev3sec27"></a>
        <h5 class="docSection3Title">Standard Conversions Following Conversion Operator</h5>
        <h5 class="docSection3Title">转换操作符之后的标准转换</h5>

        <p class="docText">Which function is the best match can depend on whether one or more class-type conversions are involved in matching different functions.</p>
        <p class="docText">哪个函数是最佳匹配，可能依赖于在匹配不同函数中是否涉及了一个或多个类类型转换。</p>

	<a name="ch14note34"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">If two functions in the overload set can be matched <span class="docEmphasis">using the same conversion function</span>, then the rank of the standard conversion sequence that follows or precedes the conversion is used to determine which function has the best match.</p>
                <p class="docText">如果重载集中的两个函数可以用<span class="docEmphasis">同一转换函数</span>匹配，则使用在转换之后或之前的标准转换序列的等级来确定哪个函数具有最佳匹配。</p>
              </td>
            </tr>
          </table><br>

          <p class="docText">Otherwise, if <span class="docEmphasis">different conversion operations</span> could be used, then the conversions are considered equally good matches, regardless of the rank of any standard conversions that might or might not be required.</p>
          <p class="docText">否则，如果可以使用<span class="docEmphasis">不同转换</span>操作，则认为这两个转换是一样好的匹配，不管可能需要或不需要的标准转换的等级如何。</p>
        </div><br>

        <p class="docText">On page <a class="docLink" href="ch14lev1sec9.html#ch14lev2sec32">541</a> we looked at the effect of class-type conversions on calls to functions that are not overloaded. Now, we'll look at similar calls but assume that the functions are overloaded:</p>
        <p class="docText"><a class="docLink" href="ch14lev1sec9.html#ch14lev2sec32">第 14.9.3 节</a>中介绍了类类型转换在非重载函数调用上的效果，现在，我们将看看类似的调用，但假定函数是重载的：</p>
        <pre>
     void compute(int);
     void compute(double);
     void compute(long double);
</pre><br>

        <p class="docText">Assuming we use our original <tt>SmallInt</tt> class that only defines one conversion operatorthe conversion to <tt>int</tt>then if we pass a <tt>SmallInt</tt> to <tt>compute</tt>, the call is matched to the version of <tt>compute</tt> that takes an <tt>int</tt>.</p>
	<p class="docText">假定使用原来的 <tt>SmallInt</tt> 类，该类只定义了一个转换操作符——从 <tt>SmallInt</tt> 到 <tt>int</tt> 的转换，那么，如果将 <tt>SmallInt</tt> 对象传给 <tt>compute</tt>，该调用与接受一个 <tt>int</tt> 的 <tt>compute</tt> 版本相匹配。</p>

        <p class="docText">All three <tt>compute</tt> functions are viable:</p>
        <p class="docText">三个函数都是可行的：</p>

        <ul>
          <li>
            <p class="docList"><tt>compute(int)</tt> is viable because <tt>SmallInt</tt> has a conversion to <tt>int</tt>. That conversion is an exact match for the parameter.</p>
            <p class="docList"><tt>compute(int)</tt> 可行，因为 <tt>SmallInt</tt> 有到 <tt>int</tt> 的转换，该转换是对形参的完全匹配。</p>
          </li>

          <li>
            <p class="docList"><tt>compute(double)</tt> and <tt>compute(long double)</tt> are also viable, by using the conversion to <tt>int</tt> followed by the appropriate standard conversion to either <tt>double</tt> or <tt>long double</tt>.</p>
            <p class="docList"><tt>compute(double)</tt> 和 <tt>compute(long double)</tt> 也是可行的，可以使用到 <tt>int</tt> 的转换，后面跟上适当的用于 <tt>double</tt> 或 <tt>long double</tt> 的标准转换。</p>
          </li>
        </ul>

	<a name="idd1e111148"></a><a name="idd1e111155"></a>
        <p class="docText">Because all three functions would be matched using the <span class="docEmphasis">same</span> class-type conversion, the rank of the standard conversion, if any, is used to determine the best match. Because an exact match is better than a standard conversion, the function <tt>compute(int)</tt> is chosen as the best viable function.</p>
        <p class="docText">因为可以用<span class="docEmphasis">同一</span>类类型转换来匹配这三个函数，如果存在标准转换，就用标准转换的等级确定最佳匹配。因为完全匹配比标准转换更好，所以选择 <tt>compute(int)</tt> 函数作为最佳可行函数。</p>

	<a name="ch14note35"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The standard conversion sequence following a class-type conversion is used as a selection criterion only if the two conversion sequences use the same conversion operation.</p>
                <p class="docText">只有两个转换序列使用同一转换操作时，才用类类型转换之后的标准转换序列作为选择标准。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch14lev3sec28"></a>
        <h5 class="docSection3Title">Multiple Conversions and Overload Resolution</h5>
        <h5 class="docSection3Title">多个转换和重载确定</h5>

        <p class="docText">We can now see one reason why adding a conversion to <tt>double</tt> is a bad idea. If we use the revised <tt>SmallInt</tt> class that defines conversions to both <tt>int</tt> and <tt>double</tt>, then calling <tt>compute</tt> on a <tt>SmallInt</tt> value is ambiguous:</p>
        <p class="docText">现在可以看看为什么增加一个到 <tt>double</tt> 的转换是个坏主意。如果使用修改后的定义了到 <tt>int</tt> 和 <tt>double</tt> 的转换的 <tt>SmallInt</tt> 类，则用 <tt>SmallInt</tt> 值调用 <tt>compute</tt> 具有二义性：</p>
        <pre>
     class SmallInt {
     public:
         // <span class="docEmphItalicAlt">Conversions to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">SmallInt</span>
         // <span class="docEmphItalicAlt">Usually it is unwise to define conversions to multiple arithmetic types</span>
         operator int() const { return val; }
         operator double() const { return val; }
         // ...
     private:
         std::size_t val;
     };
     void compute(int);
     void compute(double);
     void compute(long double);
     SmallInt si;
     compute(si);    // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>

        <p class="docText">In this case we could use the <tt>operator int</tt> to convert <tt>si</tt> and call the version of <tt>compute</tt> that takes an <tt>int</tt>. Or we could use <tt>operator double</tt> to convert <tt>si</tt> and call <tt>compute(double)</tt>.</p>
        <p class="docText">在这个例子中，可以使用 <tt>operator int</tt> 转换 <tt>si</tt> 并调用接受 <tt>int</tt> 参数的 <tt>compute</tt> 版本，或者，可以使用 <tt>operator double</tt> 转换 <tt>si</tt> 并调用 <tt>compute(double)</tt>。</p>

        <p class="docText">The compiler will not attempt to distinguish between two different class-type conversions. In particular, even if one of the calls required a standard conversion following the class-type conversion and the other were an exact match, the compiler would still flag the call as an error.</p><a name="ch14lev3sec29"></a>
        <p class="docText">编译器将不会试图区别两个不同的类类型转换。具体而言，即使一个调用需要在类类型转换之后跟一个标准转换，而另一个是完全匹配，编译器仍会将该调用标记为错误。</p>

        <h5 class="docSection3Title">Explicit Constructor Call to Disambiguate</h5>
        <h5 class="docSection3Title">显式强制转换消除二义性</h5>

        <p class="docText">A programmer who is faced with an ambiguous conversion can use a cast to indicate explicitly which conversion operation to apply:</p>
        <p class="docText">面对二义性转换，程序员可以使用强制转换来显式指定应用哪个转换操作：</p>
        <pre>
     void compute(int);
     void compute(double);
     SmallInt si;
     compute(static_cast&lt;int&gt;(si)); // <span class="docEmphItalicAlt">ok: convert and call</span> <span class="docEmphasis">compute(int)</span>
</pre><br>

        <p class="docText">This call is now legal because it explicitly says which conversion operation to apply to the argument. The type of the argument is forced to <tt>int</tt> by the cast. That type exactly matches the parameter of the first version of <tt>compute</tt> that takes an <tt>int</tt>.</p><a name="ch14lev3sec30"></a>
        <p class="docText">这个调用现在是合法的，因为它显式指出了将哪个转换操作应用到实参。实参类型强制转换为 <tt>int</tt>，该类型与接受 <tt>int</tt> 参数的第一个 <tt>compute</tt> 版本完全匹配。</p>

        <h5 class="docSection3Title">Standard Conversions and Constructors</h5>
        <h5 class="docSection3Title">标准转换和构造函数</h5>

	<a name="idd1e111298"></a><a name="idd1e111305"></a><a name="idd1e111312"></a><a name="idd1e111317"></a><a name="idd1e111322"></a>
        <p class="docText">Let's look at overload resolution when multiple conversion constructors exist:</p>
        <p class="docText">现在来看存在多个转换构造函数的重载确定：</p>
        <pre>
     class SmallInt {
     public:
         SmallInt(int = 0);
     };
     class Integral {
     public:
         Integral(int = 0);
     };
     void manip(const Integral&amp;);
     void manip(const SmallInt&amp;);
     manip(10); // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>

        <p class="docText">The problem is that both classes, <tt>Integral</tt> and <tt>SmallInt</tt>, provide constructors that take an <tt>int</tt>. Either constructor could be used to match a version of <tt>manip</tt>. Hence, the call is ambiguous: It could mean convert the <tt>int</tt> to <tt>Integral</tt> and call the first version of <tt>manip</tt>, or it could mean convert the <tt>int</tt> to a <tt>SmallInt</tt> and call the second version.</p>
	<p class="docText">问题在于，<tt>Integral</tt> 和 <tt>SmallInt</tt> 这两个类都提供接受 <tt>int</tt> 参数的构造函数，其中任意一个构造函数都可以与 <tt>manip</tt> 的一个版本相匹配，因此，函数调用有二义性：它既可以表示将 <tt>Integral</tt> 转换为 <tt>int</tt> 并调用 <tt>manip</tt> 的第一个版本，也可以表示 <tt>SmallInt</tt> 转换为 <tt>int</tt> 并调用 <tt>manip</tt> 的第二个版本。</p>

        <p class="docText">This call would be ambiguous even if one of the classes defined a constructor that required a standard conversion for the argument. For example, if <tt>SmallInt</tt> defined a constructor that took a <tt>short</tt> instead of an <tt>int</tt>, the call <tt>manip(10)</tt> would require a standard conversion from <tt>int</tt> to <tt>short</tt> before using that constructor. The fact that one call requires a standard conversion and the other does not is immaterial when selecting among overloaded versions of a call. The compiler will not prefer the direct constructor; the call would still be ambiguous.</p><a name="ch14lev3sec31"></a>
        <p class="docText">即使其中一个类定义了实参需要标准转换的构造函数，这个函数调用也可能具有二义性。例如，如果 <tt>SmallInt</tt> 定义了一个构造函数，接受 <tt>short</tt> 而不是 <tt>int</tt> 参数，函数调用 <tt>manip(10)</tt> 将在使用构造函数之前需要一个从 <tt>int</tt> 到 <tt>short</tt> 的标准转换。在函数调用的重载版本中进行选择时，一个调用需要标准转换而另一个不需要，这一事实不是实质性，编译器不会更喜欢直接构造函数，调用仍具有二义性。</p>

        <h5 class="docSection3Title">Explicit Constructor Call to Disambiguate</h5>
        <h5 class="docSection3Title">显式构造函数调用消除二义性</h5>

        <p class="docText">The caller can disambiguate by explicitly constructing a value of the desired type:</p>
        <p class="docText">调用者可以通过显式构造所需类型的值而消除二义性：</p>
        <pre>
     manip(SmallInt(10));    // <span class="docEmphItalicAlt">ok: call manip(SmallInt)</span>
     manip(Integral(10));    // <span class="docEmphItalicAlt">ok: call manip(Integral)</span>
</pre><br>

        <a name="ch14note36"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Needing to use a constructor or a cast to convert an argument in a call to an overloaded function is a sign of bad design.</p>
                <p class="docText">在调用重载函数时，需要使用构造函数或强制类型转换来转换实参，这是设计拙劣的表现。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch14sb16"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 14.9.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa14q1"></a><b>Exercise 14.44:</b></td>

                    <td>
                      <p class="docText">Show the possible class-type conversion sequences for each of the following initializations. What is the outcome of each initialization?</p>
                      <p class="docText">为下述每个初始化列出可能的类类型转换序列。每个初始化的结果是什么？</p>
                      <pre>
     class LongDouble {
         operator double();
         operator float();
     };
     LongDouble ldObj;
     (a) int ex1 = ldObj;    (b) float ex2 = ldObj;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa14q2"></a><b>Exercise 14.45:</b></td>

                    <td>
                      <p class="docText">Which <tt>calc()</tt> function, if any, is selected as the best viable function for the following call? Show the conversion sequences needed to call each function and explain why the best viable function is selected.</p>
                      <p class="docText">哪个 <tt>calc()</tt> 函数是如下函数调用的最佳可行函数？列出调用每个函数所需的转换序列，并解释为什么所选定的就是最佳可行函数。</p>
                      <pre>
     class LongDouble {
     public
         LongDouble(double);
         // ...
     };
     void calc(int);
     void calc(LongDouble);
     double dval;

     calc(dval); // <span class="docEmphItalicAlt">which function?</span>
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <a name="ch14lev2sec34"></a>
        <h4 class="docSection2Title">14.9.5. Overloading, Conversions, and Operators</h4>
        <h4 class="docSection2Title">14.9.5. 重载、转换和操作符</h4>

        <p class="docText">Overloaded operators are overloaded functions. The same process that is used to resolve a call to an overloaded function is used to determine which operator built-in or class-typeto apply to a given expression. Given code such as</p>
        <p class="docText">重载操作符就是重载函数。使用与确定重载函数调用一样的过程来确定将哪个操作符（内置的还是类类型的）应用于给定表达式。给定如下代码：</p>
        <pre>
     ClassX sc;
     int iobj = sc + 3;
</pre><br>

        <p class="docText">there are four possibilities:</p>
        <p class="docText">有四种可能性：</p>

	<a name="ch14pro02"></a>
        <ul class="doclist" start="">
          <li>There is an overloaded addition operator that matches <tt>ClassX</tt> and <tt>int</tt>.<br>
          <li>有一个重载的加操作符与 <tt>ClassX</tt> 和 <tt>int</tt> 相匹配。<br>
          </li>

          <li>There are conversions to convert <tt>sc</tt> and/or to convert an <tt>int</tt> to types for which <tt>+</tt> is defined. If so, this expression will use the conversion(s) followed by applying the appropriate addition operator.<br>
          <li>存在转换，将 <tt>sc</tt> 和／或 <tt>int</tt> 值转换为定义了 <tt>+</tt> 的类型。如果是这样，该表达式将先使用转换，接着应用适当的加操作符。<br>
          </li>

          <li>The expression is ambiguous because both a conversion operator and an overloaded version of <tt>+</tt> are defined.<br>
          <li>因为既定义了转换操作符又定义了 <tt>+</tt> 的重载版本，该表达式具有二义性。<br>
          </li>

          <li>The expression is invalid because there is neither a conversion nor an over-loaded <tt>+</tt> to use.<br>
          <li>因为既没有转换又没有重载的 <tt>+</tt> 可以使用，该表达式非法。<br>
          </li>
  </ul>
  
  <a name="ch14lev3sec32"></a>
        <h5 class="docSection3Title">Overload Resolution and Operators</h5>
        <h5 class="docSection3Title">重载确定和操作符</h5>

	<a name="ch14note37"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The fact that member and nonmember functions are possible changes how the set of candidate functions is selected.</p>
                <p class="docText">成员函数和非成员函数都是可能的，这一事实改变了选择候选函数集的方式。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Overload resolution (<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >Section 7.8.2</a>, p. <a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >269</a>) for operators follows the usual three-step process:</p><a name="ch14pro03"></a>
        <p class="docText">操作符的重载确定（<a class="docLink" href="ch07lev1sec8.html#ch07lev2sec28" >第 7.8.2 节</a>）遵循常见的三步过程：</p>

        <table border="0" class="docText">
          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>1.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                Select the candidate functions.<br>
              <div class="docText">选择候选函数。<br>
              </div>
            </td>
          </tr>

          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>2.</b>
              </div>
            </td>

            <td>
              <div class="docText">
		<a name="idd1e111565"></a><a name="idd1e111570"></a>
                Select the viable functions including identifying potential conversions sequences for each argument.<br>
              <div class="docText">选择可行函数，包括识别每个实参的潜在转换序列。<br>
              </div>
            </td>
          </tr>

          <tr>
            <td width="25" valign="top">
              <div class="docText">
                <b>3.</b>
              </div>
            </td>

            <td>
              <div class="docText">
                Select the best match function.<br>
              <div class="docText">选择最佳匹配的函数。<br>
              </div>
            </td>
          </tr>
  </table>
  
  <a name="ch14lev3sec33"></a>

        <h5 class="docSection3Title">Candidate Functions for Operators</h5>
        <h5 class="docSection3Title">操作符的候选函数</h5>

        <p class="docText">As usual, the set of candidate functions consists of all functions that have the name of the function being used, and that are visible from the place of the call. In the case of an operator used in an expression, the candidate functions include the built-in versions of the operator along with all the ordinary nonmember versions of that operator. In addition, if the left-hand operand has class type, then the candidate set will contain the overloaded versions of the operator, if any, defined by that class.</p>
        <p class="docText">一般而言，候选函数集由所有与被使用的函数同名的函数构成，被使用的函数可以从函数调用处看到。对于操作符用在表达式中的情况，候选函数包括操作符的内置版本以及该操作符的普通非成员版本。另外，如果左操作符具有类类型，而且该类定义了该操作符的重载版本，则候选集将包含操作符的重载版本。</p>

	<a name="ch14note38"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Ordinarily, the candidate set for a call includes only member functions or nonmember functions but not both. When resolving the use of an operator, it is possible for both nonmember and member versions of the operator to be candidates.</p>
                <p class="docText">一般而言，函数调用的候选集只包括成员函数或非成员函数，不会两者都包括。而确定操作符的使用时，操作符的非成员和成员版本可能都是候选者。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">When resolving a call to a named function (as opposed to the use of an operator), the call itself determines the scope of names that will be considered. If the call is through an object of a class type (or through a reference or pointer to such an object), then only the member functions of that class are considered. Member and nonmember functions with the same name do <span class="docEmphasis">not</span> overload one another. When we use an overloaded operator, the call does not tell us anything about the scope of the operator function that is being used. Therefore, both member and nonmember versions must be considered.</p>
	<p class="docText">确定指定函数的调用时，与操作符的使用相反，由调用本身确定所考虑的名字的作用域。如果是通过类类型的对象（或通过这种对象的引用或指针）的调用，则只需考虑该类的成员函数。具有同一名字的成员函数和非成员函数<span class="docEmphasis">不会</span>相互重载。使用重载操作符是时，调用本身不会告诉我们与使用的操作符函数作用域相关的任何事情，因此，成员和非成员版本都必须考虑。</p>

	<a name="ch14sb17"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Caution: Conversions and Operators</h2>
              <h2 class="docSidebarTitle">警告：转换和操作符</h2>

              <p class="docText"><span class="docEmphStrong">Correctly designing the overloaded operators, conversion constructors, and conversion functions for a class requires some care. In particular, ambiguities are easy to generate if a class defines both conversion operators and overloaded operators. A few rules of thumb can be helpful:</span></p>
              <p class="docText"><span class="docEmphStrong">正确设计类的重载操作符、转换构造函数和转换函数需要多加小心。尤其是，如果类既定义了转换操作符又定义了重载操作符，容易产生二义性。下面几条经验规则会有所帮助：</span></p>

              <div style="font-weight:bold">
                <ol class="docList" type="1">
                  <li>
                    <div style="font-weight:normal">
                      <p class="docList"><span class="docEmphStrong">Never define mutually converting classesthat is, if class <tt>Foo</tt> has a constructor that takes an object of class <tt>Bar</tt>, do not give class <tt>Bar</tt> a conversion operator to type <tt>Foo</tt></span>.</p>
                      <p class="docList"><span class="docEmphStrong">不要定义相互转换的类，即如果类 <tt>Foo</tt> 具有接受类 <tt>Bar</tt> 的对象的构造函数，不要再为类 <tt>Bar</tt> 定义到类型 <tt>Foo</tt> 的转换操作符。</span></p>
                    </div>
                  </li>

                  <li>
                    <div style="font-weight:normal">
                      <p class="docList"><span class="docEmphStrong">Avoid conversions to the built-in arithmetic types. In particular, if you do define a conversion to an arithmetic type, then</span></p>
                      <p class="docList"><span class="docEmphStrong">避免到内置算术类型的转换。具体而言，如果定义了到算术类型的转换，则</span></p>

                      <ul>
                        <li>
                          <p class="docList"><span class="docEmphStrong">Do not define overloaded versions of the operators that take arithmetic types. If users need to use these operators, the conversion operation will convert objects of your type, and then the built-in operators can be used.</span></p>
                          <p class="docList"><span class="docEmphStrong">不要定义接受算术类型的操作符的重载版本。如果用户需要使用这些操作符，转换操作符将转换你所定义的类型的对象，然后可以使用内置操作符。</span></p>
                        </li>

                        <li>
                          <p class="docList"><span class="docEmphStrong">Do not define a conversion to more than one arithmetic type. Let the standard conversions provide conversions to the other arithmetic types.</span></p>
                          <p class="docList"><span class="docEmphStrong">不要定义转换到一个以上算术类型的转换。让标准转换提供到其他算术类型的转换。</span></p>
                        </li>
                      </ul>
                    </div>
                  </li>
                </ol>
              </div>

              <p class="docText"><span class="docEmphStrong">The easiest rule of all: Avoid defining conversion functions and limit nonexplicit constructors to those that are "obviously right."</span></p>
              <p class="docText"><span class="docEmphStrong">最简单的规则是：对于那些“明显正确”的，应避免定义转换函数并限制非显式构造函数。</span></p>
            </td>
          </tr>
        </table><br>
        <a name="ch14lev3sec34"></a>

        <h5 class="docSection3Title">Conversions Can Cause Ambiguity with Built-In Operators</h5>
        <h5 class="docSection3Title">转换可能引起内置操作符的二义性</h5>

	<a name="idd1e111671"></a><a name="idd1e111676"></a><a name="idd1e111681"></a>
        <p class="docText">Let's extend our <tt>SmallInt</tt> class once more. This time, in addition to a conversion operator to <tt>int</tt> and a constructor from <tt>int</tt>, we'll give our class an overloaded addition operator:</p>
        <p class="docText">我们再次扩展 <tt>SmallInt</tt> 类。这一次，除了到 <tt>int</tt> 的转换操作符和接受 <tt>int</tt> 参数的构造函数之外，将增加一个重载的加操作符：</p>
        <pre>
     class SmallInt {
     public:
         SmallInt(int = 0); // <span class="docEmphItalicAlt">convert from</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">SmallInt</span>
         // <span class="docEmphItalicAlt">conversion to</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">SmallInt</span>
         operator int() const { return val; }
         // <span class="docEmphItalicAlt">arithmetic operators</span>
         friend SmallInt
         operator+(const SmallInt&amp;, const SmallInt&amp;);
     private:
          std::size_t val;
     };
</pre><br>

        <p class="docText">Now we could use this class to add two <tt>SmallInts</tt>, but we will run into ambiguity problems if we attempt to perform mixed-mode arithmetic:</p>
        <p class="docText">现在，可以用这个类将两个 <tt>SmallInts</tt> 对象相加，但是，如果试图进行混合模式运算，将会遇到二义性问题：</p>
        <pre>
     SmallInt s1, s2;
     SmallInt s3 = s1 + s2;         // <span class="docEmphItalicAlt">ok: uses overloaded</span> <span class="docEmphasis">operator+</span>
     int i = s3 + 0;                // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>

        <p class="docText">The first addition uses the overloaded version of <tt>+</tt> that takes two <tt>SmallInt</tt> values. The second addition is ambiguous. The problem is that we could convert <tt>0</tt> to a <tt>SmallInt</tt> and use the <tt>SmallInt</tt> version of <tt>+</tt>, or we could convert <tt>s3</tt> to <tt>int</tt> and use the built-in addition operator on <tt>int</tt>s.</p><a name="ch14note39"></a>
        <p class="docText">第一个加使用接受两个 <tt>SmallInt</tt> 值的 <tt>+</tt> 的重载版本。第二个加有二义性，问题在于，可以将 <tt>0</tt> 转换为 <tt>SmallInt</tt> 并使用 <tt>+</tt> 的 <tt>SmallInt</tt> 版本，也可以将 <tt>s3</tt> 转换为 <tt>int</tt> 值并使用 <tt>int</tt> 值上的内置加操作符。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Providing both conversion functions to an arithmetic type and over-loaded operators for the same class type may lead to ambiguities between the overloaded operators and the built-in operators.</p>
                <p class="docText">既为算术类型提供转换函数，又为同一类类型提供重载操作符，可能会导致重载操作符和内置操作符之间的二义性。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch14lev3sec35"></a>
        <h5 class="docSection3Title">Viable Operator Functions and Conversions</h5>
        <h5 class="docSection3Title">可行的操作符函数和转换</h5>

        <p class="docText">We can understand the behavior of these two calls by listing the viable functions for each call. In the first call, there are two viable addition operators:</p>
        <p class="docText">通过为每个调用列出可行函数，可以理解这两个调用的行为。在第一个调用中，有两个可行的加操作符：</p>

        <ul>
          <li>
            <p class="docList"><tt>operator+(const SmallInt&amp;, const SmallInt&amp;)</tt></p>
          </li>

          <li>
            <p class="docList">The built-in <tt>operator+(int, int)</tt></p>
            <p class="docList">内置的 <tt>operator+(int, int)</tt>。</p>
          </li>
        </ul>

        <p class="docText">The first addition requires no conversions on either argument <tt>s1</tt> and <tt>s2</tt> match exactly the types of the parameters. Using the built-in addition operator for this addition would require conversions on both arguments. Hence, the overloaded operator is a better match for both arguments and is the one that is called. For the second addition</p>
        <p class="docText">第一个加不需要实参转换——<tt>s1</tt> 和 <tt>s2</tt> 与形参的类型完全匹配。使用内置加操作符对两个实参都需要转换，因此，重载操作符与两个实参匹配得较好，所以将调用它。对于第二个加运算：</p>
        <pre>
     int i = s3 + 0;          // <span class="docEmphItalicAlt">error: ambiguous</span>
</pre><br>

        <p class="docText">the same two functions are viable. In this case, the overloaded version of <tt>+</tt> matches the first argument exactly, but the built-in version is an exact match for the second argument. The first viable function is better for the left operand, whereas the second viable function is better for the right operand. The call is flagged as ambiguous because no best viable function can be found.</p><a name="ch14sb18"></a>
        <p class="docText">两个函数同样可行。在这种情况下，重载的 <tt>+</tt> 版本与第一个实参完全匹配，而内置版本与第二个实参完全匹配。第一个可行函数对左操作数而言较好，而第二个可行函数对右操作数而言较好。因为找不到最佳可行函数，所以将该调用标记为有二义性的。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 14.9.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa15q1"></a><b>Exercise 14.46:</b></td>

                    <td>
                      <p class="docText">Which <tt>operator+</tt>, if any, is selected as the best viable function for the addition operation in <tt>main</tt>? List the candidate functions, the viable functions, and the type conversions on the arguments for each viable function.</p>
                      <p class="docText">对于 <tt>main</tt> 中的加操作，哪个 <tt>operator+</tt> 是最佳可行函数？列出候选函数、可行函数以及对每个可行函数中实参的类型转换。</p>
                      <pre>
     class Complex {
         Complex(double);
         // ...
     };
     class LongDouble {
         friend LongDouble operator+(LongDouble&amp;, int);
     public:
         LongDouble(int);
         operator double();
         LongDouble operator+(const complex &amp;);
         // ...
      };
     LongDouble operator+(const LongDouble &amp;, double);
     LongDouble ld(16.08);
     double res = ld + 15.05; // <span class="docEmphItalicAlt">which operator+ ?</span>
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch14lev1sec8.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch14lev1sec10.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>

