<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 16.1.  Template Definitions</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch16.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch16lev1sec2.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch16lev1sec1"></a>

        <h3 class="docSection1Title">16.1. Template Definitions</h3>
        <h3 class="docSection1Title">16.1. 模板定义</h3>

        <p class="docText">Let's imagine that we want to write a function to compare two values and indicate whether the first is less than, equal to, or greater than the second. In practice, we'd want to define several such functions, each of which could compare values of a given type. Our first attempt might be to define several overloaded functions:</p>
        <p class="docText">假设想要编写一个函数比较两个值并指出第一个值是小于、等于还是大于第二个值。实践中，我们可能希望定义几个这样的函数，每一个可以比较一种给定类型的值，第一次尝试可能是定义几个重载函数：</p>
        <pre>
     // <span class="docEmphItalicAlt">returns 0 if the values are equal</span>, <span class="docEmphasis">-1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">is smaller</span>, <span class="docEmphasis">1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v2</span> <span class="docEmphItalicAlt">is smaller</span>
     int compare(const string &amp;v1, const string &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
     int compare(const double &amp;v1, const double &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><br>

        <p class="docText">These functions are nearly identical: The only difference between them is the type of their parameters. The function body is the same in each function.</p>
        <p class="docText">这些函数几乎相同，它们之间唯一的区别是形参的类型，每个函数的函数体是相同的。</p>

        <p class="docText">Having to repeat the body of the function for each type that we compare is tedious and error-prone. More importantly, we need to know <span class="docEmphasis">in advance</span> all the types that we might ever want to <tt>compare</tt>. This strategy cannot work if we want to be able to use the function on types that we don't know about.</p>
        <p class="docText">每个要比较的类型都需要重复函数的函数体，不仅麻烦而且容易出错。更重要的是，需要事先知道空间可能会比较哪些类型。如果希望将函数用于未知类型，这种策略就不起作用了。</p>

<a name="ch16lev2sec1"></a>
        <h4 class="docSection2Title">16.1.1. Defining a Function Template</h4>
        <h4 class="docSection2Title">16.1.1. 定义函数模板</h4>

	<a name="idd1e123771"></a><a name="idd1e123778"></a><a name="idd1e123784"></a><a name="idd1e123789"></a><a name="idd1e123792"></a><a name="idd1e123798"></a><a name="idd1e123803"></a><a name="idd1e123810"></a><a name="idd1e123815"></a><a name="idd1e123818"></a><a name="idd1e123823"></a><a name="idd1e123826"></a><a name="idd1e123831"></a><a name="idd1e123836"></a>
	<a name="ch16term3"></a>
        <p class="docText">Rather than defining a new function for each type, we can define a single <b><a class="docLink" href="ch16lev1sec9.html#gloss16_03" >function template</a></b>. A function template is a type-independent function that is used as a formula for generating a type-specific version of the function. For example, we might write a function template named <tt>compare</tt>, which would tell the compiler how to generate specific versions of <tt>compare</tt> for the types that we want to compare.</p>
        <p class="docText">我们可以不用为每个类型定义一个新函数，而是只定义一个函数模板（function template）。函数模板是一个独立于类型的函数，可作为一种方式，产生函数的特定类型版本。例如，可以编写名为 compare 的函数模板，它告诉编译器如何为我们想要比较的类型产生特定的 compare 版本。</p>

        <p class="docText">The following is a template version of <tt>compare</tt>:</p>
        <p class="docText">下面是 <tt>compare</tt> 的模板版本：</p>
        <pre>
     // <span class="docEmphItalicAlt">implement</span> <span class="docEmphasis">strcmp-</span><span class="docEmphItalicAlt">like generic compare function</span>
     // <span class="docEmphItalicAlt">returns 0 if the values are equal</span>, <span class="docEmphasis">1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">is larger</span>, <span class="docEmphasis">-1</span> <span class="docEmphItalicAlt">if</span> <span class="docEmphasis">v1</span> <span class="docEmphItalicAlt">is smaller</span>
     template &lt;typename T&gt;
     int compare(const T &amp;v1, const T &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><br>

<a name="ch16term14"></a><a name="ch16term13"></a>
        <p class="docText">A template definition starts with the keyword <tt>template</tt> followed by a <b><a class="docLink" href="ch16lev1sec9.html#gloss16_14" >template parameter list</a></b>, which is a comma-separated list of one or more <b><a class="docLink" href="ch16lev1sec9.html#gloss16_13" >template parameters</a></b> bracketed by the less-than (<tt>&lt;</tt>) and greater-than (<tt>&gt;</tt>) tokens.</p>
        <p class="docText">模板定义以关键字 <tt>template</tt> 开始，后接<b><a class="docLink" href="ch16lev1sec9.html#gloss16_14" >模板形参表</a></b>，模板形参表是用尖括号括住的一个或多个<b><a class="docLink" href="ch16lev1sec9.html#gloss16_13" >模板形参</a></b>的列表，形参之间以逗号分隔。</a>

<a name="ch16note01"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The template parameter list cannot be empty.</p>
        <p class="docText">模板形参表不能为空。</a>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16lev3sec1"></a>

        <h5 class="docSection3Title">Template Parameter List</h5>
        <h5 class="docSection3Title">模板形参表</h5>

        <p class="docText">The template parameter list acts much like a function parameter list. A function parameter list defines local variable(s) of a specified type but leaves those variables uninitialized. At run time, arguments are supplied that initialize the parameters.</p>
        <p class="docText">模板形参表很像函数形参表，函数形参表定义了特定类型的局部变量但并不初始化那些变量，在运行时再提供实参来初始化形参。</a>

        <p class="docText">Analogously, template parameters represent types or values we can use in the definition of a class or function. For example, our <tt>compare</tt> function declares one type parameter named <tt>T</tt>. Inside <tt>compare</tt>, we can use the name <tt>T</tt> to refer to a type. Which <span class="docEmphasis">actual type</span> <tt>T</tt> represents is determined by the compiler based on how the function is used.</p>
	<p class="docText">同样，模板形参表示可以在类或函数的定义中使用的类型或值。例如，<tt>compare</tt> 函数声明一个名为 <tt>T</tt> 的类型形参。在 <tt>compare</tt> 内部，可以使用名字 <tt>T</tt> 引用一个类型，<tt>T</tt> 表示哪个实际类型由编译器根据所用的函数而确定。</a>

	<a name="ch16term16"></a><a name="ch16term8"></a>
        <p class="docText">A template parameter can be a <b><a class="docLink" href="ch16lev1sec9.html#gloss16_16" >type parameter</a></b>, which represents a type, or a <b><a class="docLink" href="ch16lev1sec9.html#gloss16_08" >nontype parameter</a></b>, which represents a constant expression. A nontype parameter is declared following a type specifier. We'll see more about nontype parameters in <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec5">Section 16.1.5</a> (p. <a class="docLink" href="ch16lev1sec1.html#ch16lev2sec5">632</a>). A type parameter is defined following the keyword <tt>class</tt> or <tt>typename</tt>. For example, <tt>class T</tt> is a type parameter named <tt>T</tt>. There is no difference between <tt>class</tt> and <tt>typename</tt> in this context.</p>
	<p class="docText">模板形参可以是表示类型的<b><a class="docLink" href="ch16lev1sec9.html#gloss16_16" >类型形参</a></b>，也可以是表示常量表达式的<b><a class="docLink" href="ch16lev1sec9.html#gloss16_08" >非类型形参</a></b>。非类型形参跟在类型说明符之后声明，<a class="docLink" href="ch16lev1sec1.html#ch16lev2sec5">第 16.1.5 节</a>将进一步介绍非类型形参。类型形参跟在关键字 <tt>class</tt> 或 <tt>typename</tt> 之后定义，例如，<tt>class T</tt> 是名为 <tt>T</tt> 的类型形参，在这里 <tt>class</tt> 和 <tt>typename</tt> 没有区别。</a>

<a name="ch16lev3sec2"></a>
        <h5 class="docSection3Title">Using a Function Template</h5>
        <h5 class="docSection3Title">使用函数模板</h5>

	<a name="ch16term11"></a><a name="idd1e124001"></a><a name="idd1e124007"></a>
        <p class="docText">When we use a function template, the compiler infers what <b><a class="docLink" href="ch16lev1sec9.html#gloss16_11" >template argument(s)</a></b> to bind to the template parameter(s). Once the compiler determines the actual template argument(s), it <span class="docEmphStrong">instantiates</span> an instance of the function template for us. Essentially, the compiler figures out what type to use in place of each type parameter and what value to use in place of each nontype parameter. Having deduced the actual template arguments, it generates and compiles a version of the function using those arguments in place of the corresponding template parameters. The compiler takes on the tedium of (re)writing the function for each type we use.</p>
        <p class="docText">使用函数模板时，编译器会推断哪个（或哪些）<b><a class="docLink" href="ch16lev1sec9.html#gloss16_11" >模板实参</a></b>绑定到模板形参。一旦编译器确定了实际的模板实参，就称它<span class="docEmphStrong">实例化</span>了函数模板的一个实例。实质上，编译器将确定用什么类型代替每个类型形参，以及用什么值代替每个非类型形参。推导出实际模板实参后，编译器使用实参代替相应的模板形参产生编译该版本的函数。编译器承担了为我们使用的每种类型而编写函数的单调工作。</a>

        <p class="docText">Given the calls</p>
        <p class="docText">对于以下调用</a>
        <pre>
     int main ()
     {
         // <span class="docEmphasis">T</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">int;</span>
         // <span class="docEmphItalicAlt">compiler instantiates</span> <span class="docEmphasis">int compare(const int&amp;, const int&amp;)</span>
         cout &lt;&lt; compare(1, 0) &lt;&lt; endl;
         // <span class="docEmphasis">T</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">string;</span>
         // <span class="docEmphItalicAlt">compiler instantiates</span> <span class="docEmphasis">int compare(const string&amp;, const string&amp;)</span>
         string s1 = "hi", s2 = "world";
         cout &lt;&lt; compare(s1, s2) &lt;&lt; endl;
         return 0;
     }
</pre><br>

        <p class="docText">the compiler will instantiate two different versions of <tt>compare</tt>. The compiler will create one version that replaces <tt>T</tt> by <tt>int</tt> and a second version that uses <tt>string</tt> in place of <tt>T</tt>.</p>
	<p class="docText">编译器将实例化 <tt>compare</tt> 的两个不同版本，编译器将用 <tt>int</tt> 代替 <tt>T</tt> 创建第一个版本，并用 <tt>string</tt> 代替 <tt>T</tt> 创建第二个版本。</a>

<a name="ch16lev3sec3"></a>
        <h5 class="docSection3Title"><tt>inline</tt> Function Templates</h5>
	<h5 class="docSection3Title"><tt>inline</tt> 函数模板</h5>

        <p class="docText">A function template can be declared <tt>inline</tt> in the same way as a nontemplate function. The specifier is placed following the template parameter list and before the return type. It is not placed in front of the <tt>template</tt> keyword.</p>
	<p class="docText">函数模板可以用与非模板函数一样的方式声明为 <tt>inline</tt>。说明符放在模板形参表之后、返回类型之前，不能放在关键字 <tt>template</tt> 之前。</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: inline specifier follows template parameter list</span>
     template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);
     // <span class="docEmphItalicAlt">error: incorrect placement of inline specifier</span>
     inline template &lt;typename T&gt; T min(const T&amp;, const T&amp;);
</pre><br>
        <a name="ch16sb01"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.1.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa1q1"></a><b>Exercise 16.1:</b></td>

                    <td>
                      <p class="docText">Write a template that returns the absolute value of its parameter. Call the template on values of at least three different types. Note: until we discuss how the compiler handles template <span class="docEmphRoman"><a name="ch16term6"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_06" >instantiation</a></span> in <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3" >Section 16.3</a> (p. <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3" >643</a>), you should put each template definition and all uses of that template in the same file.</p>
        <p class="docText">编写一个模板返回形参的绝对值。至少用三种不同类型的值调用模板。注意：在<a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3" >第 16.3 节</a>讨论编译器怎样处理模板实例化之前，你应该将每个模板定义和该模板的所有使用放在同一文件中。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa1q2"></a><b>Exercise 16.2:</b></td>

                    <td>
                      <p class="docText">Write a function template that takes a reference to an <tt>ostream</tt> and a value, and writes the value to the stream. Call the function on at least four different types. Test your program by writing to <tt>cout</tt>, to a file, and to a <tt>stringstream</tt>.</p>
        <p class="docText">编写一个函数模板，接受一个 <tt>ostream</tt> 引用和一个值，将该值写入流。用至少四种不同类型调用函数。通过写至 <tt>cout</tt>、写至文件和写至 <tt>stringstream</tt> 来测试你的程序。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa1q3"></a><b>Exercise 16.3:</b></td>

                    <td>
                      <p class="docText">When we called <tt>compare</tt> on two <tt>string</tt>s, we passed two <tt>string</tt> objects, which we initialized from string literals. What would happen if we wrote:</p>
        <p class="docText">当调用两个 <tt>string</tt> 对象的 <tt>compare</tt> 时，传递用字符串字面值初始化的两个 <tt>string</tt> 对象。如果编写以下代码会发生什么？</p>
                      <pre>
     compare ("hi", "world");
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec2"></a>

        <h4 class="docSection2Title">16.1.2. Defining a Class Template</h4>
        <h4 class="docSection2Title">16.1.2. 定义类模板</h4>

<a name="idd1e124186"></a><a name="idd1e124189"></a><a name="idd1e124194"></a><a name="idd1e124199"></a><a name="idd1e124205"></a>
        <p class="docText">Just as we can define function templates, we can also define class templates.</p><a name="ch16note02"></a>
        <p class="docText">就像可以定义函数模板一样，也可以定义类模板。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">To illustrate class templates, we'll implement our own version of the standard library <tt>queue</tt> (<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7" >Section 9.7</a>, p. <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7" >348</a>) class. User programs ought to use the standard <tt>queue</tt> class, not the one we define here.</p>
		<p class="docText">为了举例说明类模板，我们将为标准库 <tt>queue</tt> 类（<a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7" >第 9.7 节</a>）实现一个自己的版本。用户程序应使用标准的 <tt>queue</tt> 类，而不是我们这里定义的这个 <tt>Queue</tt> 类。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Our <tt>Queue</tt> must be able to hold objects of different types, so we'll define it as a <b><a name="ch16term1"></a><a class="docLink" href="ch16lev1sec9.html#gloss16_01" >class template</a></b>. The operations our <tt>Queue</tt> will support are a subset of the interface of the standard <tt>queue</tt>:</p>
	<p class="docText">我们自定义的 <tt>Queue</tt> 类必须能够支持不同类型的对象，所以将它定义为<b><a class="docLink" href="ch16lev1sec9.html#gloss16_01" >类模板</a></b>。<tt>Queue</tt> 类将支持的操作是标准 <tt>queue</tt> 类接口的子集：</p>

        <ul>
          <li>
            <p class="docList"><tt>push</tt> to add an item to the back of the queue</p>
            <p class="docList"><tt>push</tt> 操作，在队尾增加一项</p>
          </li>

          <li>
            <p class="docList"><tt>pop</tt> to remove the item at the head of the queue</p>
            <p class="docList"><tt>pop</tt> 操作，从队头删除一项</p>
          </li>

          <li>
		<p class="docList"><tt>front</tt> to return a reference to the element at the head of the queue</p>
		<p class="docList"><tt>front</tt> 操作，返回队头元素的引用</p>
          </li>

          <li>
		<p class="docList"><tt>empty</tt> to indicate whether there are any elements in the queue</p>
		<p class="docList"><tt>empty</tt> 操作，指出队列中是否有元素</p>
          </li>
        </ul>

        <p class="docText">We'll look at how we might implement our <tt>Queue</tt> in <a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4" >Section 16.4</a> (p. <a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4" >647</a>), but we can start by defining its interface:</p>
	<p class="docText"><a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4" >第 16.4 节</a>将介绍怎样实现 <tt>Queue</tt> 类，这里先定义它的接口：</p>
        <pre>
     template &lt;class Type&gt; class Queue {
     public:
         Queue ();                // <span class="docEmphItalicAlt">default constructor</span>
         Type &amp;front ();          // <span class="docEmphItalicAlt">return element from head of</span> <span class="docEmphasis">Queue</span>
         const Type &amp;front () const;
         void push (const Type &amp;); // <span class="docEmphItalicAlt">add element to back of</span> <span class="docEmphasis">Queue</span>
         void pop();              // <span class="docEmphItalicAlt">remove element from head of</span> <span class="docEmphasis">Queue</span>
         bool empty() const;      // <span class="docEmphItalicAlt">true if no elements in the</span> <span class="docEmphasis">Queue</span>
     private:
         // ...
     };
</pre><br>

        <p class="docText">A class template is a template, so it must begin with the keyword <tt>template</tt> followed by a template parameter list. Our <tt>Queue</tt> template takes a single template type parameter named <tt>Type</tt>.</p>
	<p class="docText">类模板也是模板，因此必须以关键字 <tt>template</tt> 开头，后接模板形参表。<tt>Queue</tt> 模板接受一个名为 <tt>Type</tt> 的模板类型形参。</p>

        <p class="docText">With the exception of the template parameter list, the definition of a class template looks like any other class. A class template may define data, function, and type members; it may use access labels to control access to those members; it defines constructors and destructors; and so on. In the definition of the class and its members, we can use the template parameters as stand-ins for types or values that will be supplied when the class is used.</p>
        <p class="docText">除了模板形参表外，类模板的定义看起来与任意其他类问相似。类模板可以定义数据成员、函数成员和类型成员，也可以使用访问标号控制对成员的访问，还可以定义构造函数和析构函数等等。在类和类成员的定义中，可以使用模板形参作为类型或值的占位符，在使用类时再提供那些类型或值。</p>

        <p class="docText">For example, our <tt>Queue</tt> template has one template type parameter. We can use that parameter anywhere a type name can be used. In this template definition, we use <tt>Type</tt> to name the return type from the overloaded <tt>front</tt> operations and as the parameter type for the <tt>push</tt> operation.</p>
	<p class="docText">例如，<tt>Queue</tt> 模板有一个模板类型形参，可以在任何可以使用类型名字的地方使用该形参。在这个模板定义中，用 <tt>Type</tt> 指定重载 <tt>front</tt> 操作的返回类型以及作为 <tt>push</tt> 操作的形参类型。</p>

<a name="ch16lev3sec4"></a>

        <h5 class="docSection3Title">Using a Class Template</h5>
        <h5 class="docSection3Title">使用类模板</h5>

	<a name="idd1e124363"></a><a name="idd1e124368"></a><a name="idd1e124373"></a><a name="idd1e124376"></a><a name="idd1e124381"></a><a name="idd1e124384"></a><a name="idd1e124389"></a><a name="idd1e124394"></a><a name="idd1e124399"></a>
        <p class="docText">In contrast to calling a function template, when we use a class template, we must explicitly specify arguments for the template parameters:</p>
        <p class="docText">与调用函数模板形成对比，使用类模板时，必须为模板形参显式指定实参：</p>
        <pre>
     Queue&lt;int&gt; qi;                 // <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> int<span class="docEmphasis">s</span>
     Queue&lt; vector&lt;double&gt; &gt; qc;    // <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> <span class="docEmphasis">vectors</span> <span class="docEmphItalicAlt">of</span> <span class="docEmphasis">double</span><span class="docEmphItalicAlt">s</span>
     Queue&lt;string&gt; qs;              // <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> <span class="docEmphasis">string</span><span class="docEmphItalicAlt">s</span>
</pre><br>

        <p class="docText">The compiler uses the arguments to instantiate a type-specific version of the class. Essentially, the compiler rewrites our <tt>Queue</tt> class replacing <tt>Type</tt> by the specified actual type provided by the user. In this case, the compiler will instantiate three classes: a version of <tt>Queue</tt> with <tt>Type</tt> replaced by <tt>int</tt>, a second <tt>Queue</tt> class that uses <tt>vector&lt;double&gt;</tt> in place of <tt>Type</tt>, and a third that replaces <tt>Type</tt> by <tt>string</tt>.</p>
	<p class="docText">编译器使用实参来实例化这个类的特定类型版本。实质上，编译器用用户提供的实际特定类型代替 <tt>Type</tt>，重新编写 <tt>Queue</tt> 类。在这个例子中，编译器将实例化三个 <tt>Queue</tt> 类：第一个用 <tt>int</tt> 代替 <tt>Type</tt>，第二个用 <tt>vector&lt;double&gt;</tt> 代替 <tt>Type</tt>，第三个用 <tt>string</tt> 代替 <tt>Type</tt>。</p>

<a name="ch16sb02"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.1.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa2q4"></a><b>Exercise 16.4:</b></td>

                    <td>
                      <p class="docText">What is a function template? What is a class template?</p>
                      <p class="docText">什么是函数模板？什么是类模板？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa2q5"></a><b>Exercise 16.5:</b></td>

                    <td>
                      <p class="docText">Define a function template to return the larger of two values.</p>
                      <p class="docText">定义一个函数模板，返回两个值中较大的一个。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa2q6"></a><b>Exercise 16.6:</b></td>

                    <td>
                      <p class="docText">Similar to our a simplified version of <tt>queue</tt>, write a class template named <tt>List</tt> that is a simplified version of the standard <tt>list</tt> class.</p>
                      <p class="docText">类似于我们的 queue 简化版本，编写一个名为 List 的类模板，作为标准 list 类的简化版本。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec3"></a>

        <h4 class="docSection2Title">16.1.3. Template Parameters</h4>
        <h4 class="docSection2Title">16.1.3. 模板形参</h4>

        <p class="docText">As with a function parameter, the name chosen by the programmer for a template parameter has no intrinsic meaning. In our example, we named <tt>compare</tt>'s template type parameter <tt>T</tt>, but we could have named it anything:</p>
	<p class="docText">像函数形参一样，程序员为模板形参选择的名字没有本质含义。在我们的例子中，将 <tt>compare</tt> 的模板类型形参命名为 <tt>T</tt>，但也可以将它命名为任意名字：</p>
        <pre>
     // <span class="docEmphItalicAlt">equivalent template definition</span>
     template &lt;class Glorp&gt;
     int compare(const Glorp &amp;v1, const Glorp &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><br>

        <p class="docText">This code defines the same <tt>compare</tt> template as before.</p>
	<p class="docText">该代码定义的 <tt>compare</tt> 模板与前面一样。</p>

        <p class="docText">The only meaning we can ascribe to a template parameter is to distinguish whether the parameter is a type parameter or a nontype parameter. If it is a type parameter, then we know that the parameter represents an as yet unknown type. If it is a nontype parameter, we know it is an as yet unknown value.</p>
	<p class="docText">可以给模板形参赋予的唯一含义是区别形参是类型形参还是非类型形参。如果是类型形参，我们就知道该形参表示未知类型，如果是非类型形参，我们就知道它是一个未知值。</p>

        <p class="docText">When we wish to use the type or value that a template parameter represents, we use the same name as the corresponding template parameter. For example, all references to <tt>Glorp</tt> in the <tt>compare</tt> function template will be resolved to the same type when the function is instantiated.</p><a name="ch16lev3sec5"></a>
	<p class="docText">如果希望使用模板形参所表示的类型或值，可以使用与对应模板形参相同的名字。例如，<tt>compare</tt> 函数中所有的 <tt>Glorp</tt> 引用将在该函数被实例化时确定为同一类型。</p>

        <h5 class="docSection3Title">Template Parameter Scope</h5>
        <h5 class="docSection3Title">模板形参作用域</h5>

<a name="idd1e124582"></a><a name="idd1e124587"></a><a name="idd1e124592"></a><a name="idd1e124597"></a><a name="idd1e124602"></a><a name="idd1e124609"></a>
        <p class="docText">The name of a template parameter can be used after it has been declared as a template parameter and until the end of the template declaration or definition.</p>
	<p class="docText">模板形参的名字可以在声明为模板形参之后直到模板声明或定义的末尾处使用。</p>

        <p class="docText">Template parameters follow normal name-hiding rules. A template parameter with the same name as an object, function, or type declared in global scope hides the global name:</p>
	<p class="docText">模板形参遵循常规名字屏蔽规则。与全局作用域中声明的对象、函数或类型同名的模板形参会屏蔽全局名字：</p>
        <pre>
     typedef double T;
     template &lt;class T&gt; T calc(const T &amp;a, const T &amp;b)
     {
          // <span class="docEmphasis">tmp</span> <span class="docEmphItalicAlt">has the type of the template parameter</span> <span class="docEmphasis">T</span>
          // <span class="docEmphItalicAlt">not that of the global typedef</span>
          T tmp = a;
          // ...
          return tmp;
     }
</pre><br>

        <p class="docText">The global typedef that defines <tt>T</tt> as <tt>double</tt> is hidden by the type parameter named <tt>T</tt>. Thus, <tt>tmp</tt> is not a <tt>double</tt>. Instead, the type of <tt>tmp</tt> is whatever type gets bound to the template parameter <tt>T</tt>.</p>
	<p class="docText">将 <tt>T</tt> 定义为 <tt>double</tt> 的全局类型型别名将被名为 <tt>T</tt> 的类型形参所屏蔽，因此，<tt>tmp</tt> 不是 <tt>double</tt> 型，相反，<tt>tmp</tt> 的类型是绑定到模板形参的任意类型。</p>

<a name="ch16lev3sec6"></a>
        <h5 class="docSection3Title">Restrictions on the Use of a Template Parameter Name</h5>
        <h5 class="docSection3Title">使用模板形参名字的限制</h5>

        <p class="docText">A name used as a template parameter may not be reused within the template:</p>
	<p class="docText">用作模板形参的名字不能在模板内部重用。</p>
        <pre>
     template &lt;class T&gt; T calc(const T &amp;a, const T &amp;b)
     {
         typedef double T; // <span class="docEmphItalicAlt">error: redeclares template parameter T</span>
         T tmp = a;
         // ...
         return tmp;
     }
</pre><br>

	<p class="docText">This restriction also means that the name of a template parameter can be used only once within the same template parameter list:</p>
	<p class="docText">这一限制还意味着模板形参的名字只能在同一模板形参表中使用一次：</p>
        <pre>
     // <span class="docEmphItalicAlt">error: illegal reuse of template parameter name</span> <span class="docEmphasis">V</span>
     template &lt;class V, class V&gt; V calc(const V&amp;, const V&amp;) ;
</pre><br>

        <p class="docText">Of course, just as we can reuse function parameter names, the name of a template parameter can be reused across different templates:</p>
	<p class="docText">当然，正如可以重用函数形参名字一样，模板形参的名字也能在不同模板中重用：</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: reuses parameter type name across different templates</span>
     template &lt;class T&gt; T calc (const T&amp;, const T&amp;) ;
     template &lt;class T&gt; int compare(const T&amp;, const T&amp;) ;
</pre><br>
        <a name="ch16lev3sec7"></a>

        <h5 class="docSection3Title">Template Declarations</h5>
        <h5 class="docSection3Title">模板声明</h5>

        <p class="docText">As with any other function or class, we can declare a template without defining it. A declaration must indicate that the function or class is a template:</p>
	<p class="docText">像其他任意函数或类一样，对于模板可以只声明而不定义。声明必须指出函数或类是一个模板：</p>
<pre>
// <span class="docEmphItalicAlt">declares</span> <span class="docEmphasis">compare</span> <span class="docEmphItalicAlt">but does not define it</span>
     template &lt;class T&gt; int compare(const T&amp;, const T&amp;) ;
</pre><br>

<a name="idd1e124731"></a><a name="idd1e124738"></a><a name="idd1e124743"></a><a name="idd1e124746"></a>
        <p class="docText">The names of the template parameters need not be the same across declarations and the definition of the same template:</p>
	<p class="docText">同一模板的声明和定义中，模板形参的名字不必相同。</p>
        <pre>
     // <span class="docEmphItalicAlt">all three uses of calc refer to the same function template</span>
     // <span class="docEmphItalicAlt">forward declarations of the template</span>
     template &lt;class T&gt; T calc(const T&amp;, const T&amp;) ;
     template &lt;class U&gt; U calc(const U&amp;, const U&amp;) ;
     // <span class="docEmphItalicAlt">actual definition of the template</span>
     template &lt;class Type&gt;
     Type calc(const Type&amp; a, const Type&amp; b) { /* ... */ }
</pre><br>

        <p class="docText">Each template type parameter must be preceded either by the keyword <tt>class</tt> or <tt>typename</tt>; each nontype parameter must be preceded by a type name. It is an error to omit the keyword or a type specifier:</p>
	<p class="docText">每个模板类型形参前面必须带上关键字 <tt>class</tt> 或 <tt>typename</tt>，每个非类型形参前面必须带上类型名字，省略关键字或类型说明符是错误的：</p>
        <pre>
     // <span class="docEmphItalicAlt">error: must precede</span> <span class="docEmphasis">U</span> <span class="docEmphItalicAlt">by either</span> <span class="docEmphasis">typename</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">class</span>
     template &lt;typename T, U&gt; T calc (const T&amp;, const U&amp;) ;
</pre><br>
        <a name="ch16sb03"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.1.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa3q1"></a><b>Exercise 16.7:</b></td>

                    <td>
                      <p class="docText">Explain each of the following function template definitions and identify whether any are illegal. Correct each error that you find.</p>
                      <p class="docText">解释下面每个函数模板的定义并指出是否有非法的。改正所发现的错误。</p>
                      <pre>
     (a) template &lt;class T, U, typename V&gt; void f1(T, U, V) ;
     (b) template &lt;class T&gt; T f2(int &amp;T) ;
     (c) inline template &lt;class T&gt; T foo(T, unsigned int*) ;
     (d) template &lt;class T&gt; f4 (T, T) ;
     (e) typedef char Ctype ;
         template &lt;typename Ctype&gt; Ctype f5(Ctype a) ;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa3q2"></a><b>Exercise 16.8:</b></td>

                    <td>
                      <p class="docText">Explain which, if any, of the following declarations are errors and why.</p>
                      <p class="docText">如果有，解释下面哪些声明是错误的说明为什么。</p>
                      <pre>
     (a) template &lt;class Type&gt; Type bar(Type, Type) ;
         template &lt;class Type&gt; Type bar(Type, Type) ;
     (b) template &lt;class T1, class T2&gt; void bar(T1, T2) ;
         template &lt;class C1, typename C2&gt; void bar(C1, C2) ;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa3q3"></a><b>Exercise 16.9:</b></td>

                    <td>
                      <p class="docText">Write a template that acts like the library <tt>find</tt> algorithm. Your template should take a single type parameter that will name the type for a pair of iterators that should be parameters to the function. Use your function to find a given value in a <tt>vector&lt;int&gt;</tt> and in a <tt>list&lt;string&gt;</tt>.</p>
		      <p class="docText">编写行为类似于标准库中 <tt>find</tt> 算法的模板。你的模板应接受一个类型形参，该形参指定函数形参（一对迭代器）的类型。使用你的函数在 <tt>vector&lt;int&gt;</tt> 和 <tt>list&lt;string&gt;</tt> 中查找给定值。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec4"></a>

        <h4 class="docSection2Title">16.1.4. Template Type Parameters</h4>
        <h4 class="docSection2Title">16.1.4. 模板类型形参</h4>

        <p class="docText">Type parameters consist of the keyword <tt>class</tt> or the keyword <tt>typename</tt> followed by an identifier. In a template parameter list, these keywords have the same meaning: They indicate that the name that follows represents a type.</p>
	<p class="docText">类型形参由关键字 <tt>class</tt> 或 <tt>typename</tt> 后接说明符构成。在模板形参表中，这两个关键字具有相同的含义，都指出后面所接的名字表示一个类型。</p>

<a name="idd1e124883"></a><a name="idd1e124892"></a>
        <p class="docText">A template type parameter can be used as a type specifier anywhere in the template, in exactly the same way as a built-in or class type specifier. In particular, it can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body:</p>
                      <p class="docText">模板类型形参可作为类型说明符在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同。具体而言，它可以用于指定返回类型或函数形参类型，以及在函数体中用于变量声明或强制类型转换。</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: same type used for the return type and both parameters</span>
     template &lt;class T&gt; T calc (const T&amp; a, const T&amp; b)
     {
          // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">tmp</span> <span class="docEmphItalicAlt">will have same type as the parameters &amp; return type</span>
          T tmp = a;
          // ...
          return tmp;
     }
</pre><br>
        <a name="ch16lev3sec8"></a>

        <h5 class="docSection3Title">Distinction Between <tt>typename</tt> and <tt>class</tt></h5>
	<h5 class="docSection3Title"><tt>typename</tt> 与 <tt>class</tt> 的区别</h5>

        <p class="docText">In a function template parameter list, the keywords <tt>typename</tt> and <tt>class</tt> have the same meaning and can be used interchangeably. Both keywords can be used in the same template parameter list:</p>
	<p class="docText">在函数模板形参表中，关键字 <tt>typename</tt> 和 <tt>class</tt> 具有相同含义，可以互换使用，两个关键字都可以在同一模板形参表中使用：</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: no distinction between typename and class in template parameter list</span>
     template &lt;typename T, class U&gt; calc (const T&amp;, const U&amp;);
</pre><br>

        <p class="docText">It may seem more intuitive to use the keyword <tt>typename</tt> instead of the keyword <tt>class</tt> to designate a template type parameter; after all, we can use built-in (nonclass types) types as the actual type parameter. Moreover, <tt>typename</tt> more clearly indicates that the name that follows is a type name. However, the keyword <tt>typename</tt> was added to C++ as part of Standard C++, so older programs are more likely to use the keyword <tt>class</tt> exclusively.</p>
	<p class="docText">使用关键字 <tt>typename</tt> 代替关键字 <tt>class</tt> 指定模板类型形参也许更为直观，毕竟，可以使用内置类型（非类类型）作为实际的类型形参，而且，<tt>typename</tt> 更清楚地指明后面的名字是一个类型名。但是，关键字 <tt>typename</tt> 是作为标准 C++ 的组成部分加入到 C++ 中的，因此旧的程序更有可能只用关键字 <tt>class</tt>。</p>

<a name="ch16lev3sec9"></a>
        <h5 class="docSection3Title">Designating Types inside the Template Definition</h5>
        <h5 class="docSection3Title">在模板定义内部指定类型</h5>

        <p class="docText">In addition to defining data or function members, a class may define type members. For example, the library container classes define various types, such as <tt>size_type</tt>, that allow us to use the containers in a machine-independent way. When we want to use such types inside a function template, we must tell the compiler that the name we are using refers to a type. We must be explicit because the compiler (and a reader of our program) cannot tell by inspection when a name defined by a type parameter is a type or a value. As an example, consider the following function:</p>
	<p class="docText">除了定义数据成员或函数成员之外，类还可以定义类型成员。例如，标准库的容器类定义了不同的类型，如 size_type，使我们能够以独立于机器的方式使用容器。如果要在函数模板内部使用这样的类型，必须告诉编译器我们正在使用的名字指的是一个类型。必须显式地这样做，因为编译器（以及程序的读者）不能通过检查得知，由类型形参定义的名字何时是一个类型何时是一个值。例如，考虑下面的函数：</p>
        <pre>
     template &lt;class Parm, class U&gt;
     Parm fcn(Parm* array, U value)
     {
         Parm::size_type * p; // <span class="docEmphItalicAlt">If Parm::size_type is a type, then a declaration</span>
                              // <span class="docEmphItalicAlt">If Parm::size_type is an object, then multiplication</span>
     }
</pre><br>

        <p class="docText">We know that <tt>size_type</tt> must be a member of the type bound to <tt>Parm</tt>, but we do not know whether <tt>size_type</tt> is the name of a type or a data member. By default, the compiler assumes that such names name data members, not types.</p>
	<p class="docText">我们知道 <tt>size_type</tt> 必定是绑定到 <tt>Parm</tt> 的那个类型的成员，但我们不知道 <tt>size_type</tt> 是一个类型成员的名字还是一个数据成员的名字，默认情况下，编译器假定这样的名字指定数据成员，而不是类型。</p>

	<a name="idd1e125004"></a><a name="idd1e125007"></a><a name="idd1e125012"></a>
        <p class="docText">If we want the compiler to treat <tt>size_type</tt> as a type, then we must explicitly tell the compiler to do so:</p>
	<p class="docText">如果希望编译器将 <tt>size_type</tt> 当作类型，则必须显式告诉编译器这样做：</p>
        <pre>
     template &lt;class Parm, class U&gt;
     Parm fcn(Parm* array, U value)
     {
         typename Parm::size_type * p; // <span class="docEmphItalicAlt">ok: declares</span> <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">to be a pointer</span>
     }
</pre><br>

        <p class="docText">We tell the compiler to treat a member as a type by prefixing uses of the member name with the keyword <tt>typename</tt>. By writing <tt>typename Parm::size_type</tt> we say that member <tt>size_type</tt> of the type bound to <tt>Parm</tt> is the name of a type. Of course, this declaration puts an obligation on the types used to instantiate <tt>fcn</tt>: Those types must have a member named <tt>size_type</tt> that is a type.</p><a name="ch16note03"></a>
	<p class="docText">通过在成员名前加上关键字 <tt>typename</tt> 作为前缀，可以告诉编译器将成员当作类型。通过编写 <tt>typename parm::size_type</tt>，指出绑定到 <tt>Parm</tt> 的类型的 <tt>size_type</tt> 成员是类型的名字。当然，这一声明给用实例化 <tt>fcn</tt> 的类型增加了一个职责：那些类型必须具有名为 <tt>size_type</tt> 的成员，而且该成员是一个类型。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">If there is any doubt as to whether <tt>typename</tt> is necessary to indicate that a name is a type, it is a good idea to specify it. There is no harm in specifying <tt>typename</tt> before a type, so if the <tt>typename</tt> was unnecessary, it won't matter.</p>
		<p class="docText">如果拿不准是否需要以 <tt>typename</tt> 指明一个名字是一个类型，那么指定它是个好主意。在类型之前指定 <tt>typename</tt> 没有害处，因此，即使 <tt>typename</tt> 是不必要的，也没有关系。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16sb04"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.1.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa4q1"></a><b>Exercise 16.10:</b></td>

                    <td>
                      <p class="docText">What, if any, are the differences between a type parameter that is declared as a <tt>typename</tt> and one that is declared as a <tt>class</tt>?</p>
		      <p class="docText">声明为 <tt>typename</tt> 的类型形参与声明为 <tt>class</tt> 的类型形参有区别吗？区别在哪里？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa4q2"></a><b>Exercise 16.11:</b></td>

                    <td>
                      <p class="docText">When must <tt>typename</tt> be used?</p>
		      <p class="docText">何时必须使用 <tt>typename</tt>？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa4q3"></a><b>Exercise 16.12:</b></td>

                    <td>
                      <p class="docText">Write a function template that takes a pair of values that represent iterators of unknown type. Find the value that occurs most frequently in the sequence.</p>
                      <p class="docText">编写一个函数模板，接受表示未知类型迭代器的一对值，找出在序列中出现得最频繁的值。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa4q4"></a><b>Exercise 16.13:</b></td>

                    <td>
                      <p class="docText">Write a function that takes a reference to a container and prints the elements in that container. Use the container's <tt>size_type</tt> and <tt>size</tt> members to control the loop that prints the elements.</p>
		      <p class="docText">编写一个函数，接受一个容器的引用并打印该容器的元素。使用容器的 <tt>size_type</tt> 和 <tt>size</tt> 成员控制打印元素的循环。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa4q5"></a><b>Exercise 16.14:</b></td>

                    <td>
                      <p class="docText">Rewrite the function from the previous exercise to use iterators returned from <tt>begin</tt> and <tt>end</tt> to control the loop.</p>
		      <p class="docText">重新编写上题的函数，使用从 <tt>begin</tt> 和 <tt>end</tt> 返回的迭代器来控制循环。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec5"></a>

        <h4 class="docSection2Title">16.1.5. Nontype Template Parameters</h4>
        <h4 class="docSection2Title">16.1.5. 非类型模板形参</h4>

        <p class="docText">A template parameter need not be a type. In this section we'll look at nontype parameters as used by function templates. We'll look at nontype parameters for class templates in <a class="docLink" href="ch16lev1sec4.html#ch16lev2sec19" >Section 16.4.2</a> (p. <a class="docLink" href="ch16lev1sec4.html#ch16lev2sec19" >655</a>) after we've seen more about how class templates are implemented.</p>
                      <p class="docText">模板形参不必都是类型。本节将介绍函数模板使用的非类型形参。在介绍了类模板实现的更多内容之后，<a class="docLink" href="ch16lev1sec4.html#ch16lev2sec19" >第 16.4.2 节</a>将介绍类模板的非类型形参。</p>

        <p class="docText">Nontype parameters are replaced by values when the function is called. The type of that value is specified in the template parameter list. For example, the following function template declares <tt>array_init</tt> as a function template with one type and one nontype template parameter. The function itself takes a single parameter, which is a reference to an array (<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >Section 7.2.4</a>, p. <a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >240</a>):</p>
                      <p class="docText">在调用函数时非类型形参将用值代替，值的类型在模板形参表中指定。例如，下面的函数模板声明了 <tt>array_init</tt> 是一个含有一个类型模板形参和一个非类型模板形参的函数模板。函数本身接受一个形参，该形参是数组的引用（<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >第 7.2.4 节</a>）：</p>
        <pre>
     // <span class="docEmphItalicAlt">initialize elements of an array to zero</span>
     template &lt;class T, size_t N&gt; void array_init(T (&amp;parm)[N])
     {
         for (size_t i = 0; i != N; ++i) {
             parm[i] = 0;
         }
     }
</pre><br>

<a name="idd1e125201"></a><a name="idd1e125206"></a><a name="idd1e125213"></a><a name="idd1e125218"></a>
        <p class="docText">A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are requiredfor example, as we do hereto specify the size of an array.</p>
                      <p class="docText">模板非类型形参是模板定义内部的常量值，在需要常量表达式的时候，可使用非类型形参（例如，像这里所做的一样）指定数组的长度。</p>

        <p class="docText">When <tt>array_init</tt> is called, the compiler figures out the value of the nontype parameter from the array argument:</p>
                      <p class="docText">当调用 <tt>array_init</tt> 时，编译器从数组实参计算非类型形参的值：</p>
        <pre>
     int x[42];
     double y[10];
     array_init(x);  // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">array_init(int(&amp;)[42]</span>
     array_init(y);  // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">array_init(double(&amp;)[10]</span>
</pre><br>

        <p class="docText">The compiler will instantiate a separate version of <tt>array_init</tt> for each kind of array used in a call to <tt>array_init</tt>. For the program above, the compiler instantiates two versions of <tt>array_init:</tt> The first instance has its parameter bound to <tt>int[42]</tt>, and in the other, that parameter is bound to <tt>double[10]</tt>.</p>
                      <p class="docText">编译器将为 <tt>array_init</tt> 调用中用到的每种数组实例化一个 <tt>array_init</tt> 版本。对于上面的程序，编译器将实例化 array_init 的两个版本：第一个实例的形参绑定到 <tt>int[42]</tt>，另一个实例中的形参绑定到 <tt>double[10]</tt>。</p>

<a name="ch16lev3sec10"></a>
        <h5 class="docSection3Title">Type Equivalence and Nontype Parameters</h5>
        <h5 class="docSection3Title">类型等价性与非类型形参</h5>

        <p class="docText">Expressions that evaluate to the same value are considered equivalent template arguments for a template nontype parameter. The following calls to <tt>array_init</tt> both refer to the same instantiation, <tt>array_init&lt;int, 42&gt;</tt>:</p>
                      <p class="docText">对模板的非类型形参而言，求值结果相同的表达式将认为是等价的。下面的两个 <tt>array_init</tt> 调用引用的是相同的实例—— <tt>array_init&lt;int, 42&gt;</tt>：</p>
        <pre>
     int x[42];
     const int sz = 40;
     int y[sz + 2];
     array_init(x);  // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">array_init(int(&amp;)[42])</span>
     array_init(y);  // <span class="docEmphItalicAlt">equivalent instantiation</span>
</pre><br>
        <a name="ch16sb05"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.1.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa5q1"></a><b>Exercise 16.15:</b></td>

                    <td>
                      <p class="docText">Write a function template that can determine the size of an array.</p>
                      <p class="docText">编写可以确定数组长度的函数模板。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa5q2"></a><b>Exercise 16.16:</b></td>

                    <td>
                      <p class="docText">Rewrite the <tt>printValues</tt> function from page <a class="docLink" href="ch07lev1sec2.html#ch07note10" >240</a> as a function template that could be used to print the contents of arrays of varying sizes.</p>
                      <p class="docText">将<a class="docLink" href="ch07lev1sec2.html#ch07note10" >第 7.2.4 节</a>的 <tt>printValues</tt> 函数重新编写为可用于打印不同长度数组内容的函数模板。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec6"></a>

        <h4 class="docSection2Title">16.1.6. Writing Generic Programs</h4>
        <h4 class="docSection2Title">16.1.6. 编写泛型程序</h4>

        <p class="docText">When we write a template, the code may not be overtly type-specific, but template code always makes some assumptions about the types that will be used. For example, although our <tt>compare</tt> function is technically valid for any type, in practice the instantiated version might be illegal.</p>
        <p class="docText">编写模板时，代码不可能针对特定类型，但模板代码总是要对将使用的类型做一些假设。例如，虽然 <tt>compare</tt> 函数从技术上说任意类型都是有效的，但实际上，实例化的版本可能是非法的。</p>

<a name="idd1e125350"></a><a name="idd1e125355"></a><a name="idd1e125360"></a><a name="idd1e125365"></a><a name="idd1e125370"></a><a name="idd1e125375"></a>
        <p class="docText">Whether the generated program is legal depends on the operations used in the function and the operations supported by the type or types used. Our <tt>compare</tt> function has has three statements:</p>
        <p class="docText">产生的程序是否合法，取决于函数中使用的操作以及所用类型支持的操作。<tt>compare</tt> 函数有三条语句：</p>
        <pre>
     if (v1 &lt; v2) return -1; // <span class="docEmphItalicAlt">&lt; on two objects of type</span> <span class="docEmphasis">T</span>
     if (v2 &lt; v1) return 1;  // <span class="docEmphItalicAlt">&lt; on two objects of type</span> <span class="docEmphasis">T</span>
     return 0;               // <span class="docEmphItalicAlt">return</span> <span class="docEmphasis">int;</span> <span class="docEmphItalicAlt">not dependent on</span> <span class="docEmphasis">T</span>
</pre><br>

        <p class="docText">The first two statements contain code that implicitly depends on the parameter type. The <tt>if</tt> tests use the <tt>&lt;</tt> operator on the parameters. The type of those parameters isn't known until the compiler sees a call to <tt>compare</tt> and <tt>T</tt> is bound to an actual type. Which <tt>&lt;</tt> operator is used depends entirely on the argument type.</p>
        <p class="docText">前两条语句包含隐式依赖于形参类型的代码，<tt>if</tt> 测试对形参使用 <tt>&lt;</tt> 操作符，直到编译器看见 <tt>compare</tt> 调用并且 <tt>T</tt> 绑定到一个实际类型时，才知道形参的类型，使用哪个 <tt>&lt;</tt> 操作符完全取决于实参类型。</p>

        <p class="docText">If we call <tt>compare</tt> on an object that does not support the <tt>&lt;</tt> operator, then the call will be invalid:</p>
        <p class="docText">如果用不支持 <tt>&lt;</tt> 操作符的对象调用 <tt>compare</tt>，则该调用将是无效的：</p>
        <pre>
     Sales_item item1, item2;
     // <span class="docEmphItalicAlt">error: no &lt; on Sales_item</span>
     cout &lt;&lt; compare(item1, item2) &lt;&lt; endl;
</pre><br>

        <p class="docText">The program is in error. The <tt>Sales_item</tt> type does not define the <tt>&lt;</tt> operator, so the program won't compile.</p>
        <p class="docText">程序会出错。<tt>Sales_item</tt> 类型没有定义 <tt>&lt;</tt> 操作符，所以该程序不能编译。</p>

<a name="ch16note04"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The operations performed inside a function template constrains the types that can be used to instantiate the function. It is up to the programmer to guarantee that the types used as the function arguments actually support any operations that are used, and that those operations behave correctly in the context in which the template uses them.</p>
                <p class="docText">在函数模板内部完成的操作限制了可用于实例化该函数的类型。程序员的责任是，保证用作函数实参的类型实际上支持所用的任意操作，以及保证在模板使用哪些操作的环境中那些操作运行正常。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16lev3sec11"></a>

        <h5 class="docSection3Title">Writing Type-Independent Code</h5>
        <h5 class="docSection3Title">编写独立于类型的代码</h5>

        <p class="docText">The art of writing good generic code is beyond the scope of this language primer. However, there is one overall guideline that is worth noting.</p>
                <p class="docText">编写良好泛型代码的技巧超出了本书的范围，但是，有个一般原则值得注意。</p>

<a name="ch16note05"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">When writing template code, it is useful to keep the number of requirements placed on the argument types as small as possible.</p>
                <p class="docText">编写模板代码时，对实参类型的要求尽可能少是很有益的。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Simple though it is, our <tt>compare</tt> function illustrates two important principles for writing generic code:</p>
                <p class="docText">虽然简单，但它说明了编写泛型代码的两个重要原则：</p>

        <ul>
          <li>
            <p class="docList">The parameters to the template are <tt>const</tt> references.</p>
            <p class="docList">模板的形参是 <tt>const</tt> 引用。</p>
          </li>

          <li>
            <p class="docList">The tests in the body use only <tt>&lt;</tt> comparisons.</p>
            <p class="docList">函数体中的测试只用 <tt>&lt;</tt> 比较。</p>
          </li>
        </ul>

        <p class="docText">By making the parameters <tt>const</tt> references, we allow types that do not allow copying. Most typesincluding the built-in types and, except for the IO types, all the library types we've useddo allow copying. However, there can be class types that do not allow copying. By making our parameters <tt>const</tt> references, we ensure that such types can be used with our <tt>compare</tt> function. Moreover, if <tt>compare</tt> is called with large objects, then this design will also make the function run faster.</p>
                <p class="docText">通过将形参设为 <tt>const</tt> 引用，就可以允许使用不允许复制的类型。大多数类型（包括内置类型和我们已使用过的除 IO 类型之外的所有标准库的类型）都允许复制。但是，也有不允许复制的类类型。将形参设为 <tt>const</tt> 引用，保证这种类型可以用于 <tt>compare</tt> 函数，而且，如果有比较大的对象调用 <tt>compare</tt>，则这个设计还可以使函数运行得更快。</p>

        <p class="docText">Some readers might think it would be more natural for the comparisons to be done using both the <tt>&lt;</tt> and <tt>&gt;</tt> operators:</p>
                <p class="docText">一些读者可能认为使用 <tt>&lt;</tt> 和 <tt>&gt;</tt> 操作符两者进行比较会更加自然：</p>
        <pre>
     // <span class="docEmphItalicAlt">expected comparison</span>
     if (v1 &lt; v2) return -1;
     if (v1 &gt; v2) return 1;
     return 0;
</pre><br>

	<a name="idd1e125545"></a><a name="idd1e125550"></a><a name="idd1e125555"></a><a name="idd1e125560"></a><a name="idd1e125565"></a><a name="idd1e125570"></a><a name="idd1e125573"></a>
        <p class="docText">However, by writing the code as</p>
                <p class="docText">但是，将代码编写为</p>
        <pre>
     // <span class="docEmphItalicAlt">expected comparison</span>
     if (v1 &lt; v2) return -1;
     if (v2 &lt; v1) return 1; // <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">v1 &gt; v2</span>
     return 0;
</pre><br>

        <p class="docText">we reduce the requirements on types that can be used with our <tt>compare</tt> function. Those types must support <tt>&lt;</tt>, but they need not also support <tt>&gt;</tt>.</p>
	<p class="docText">可以减少对可用于 <tt>compare</tt> 函数的类型的要求，这些类型必须支持 <tt>&lt;</tt>，但不必支持 <tt>&gt;</tt>。</p>

<a name="ch16sb06"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.1.6</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa6q1"></a><b>Exercise 16.17:</b></td>

                    <td>
                      <p class="docText">In the "Key Concept" box on page <a class="docLink" href="ch03lev1sec3.html#ch03sb09" >95</a>, we noted that as a matter of habit C++ programmers prefer using <tt>!=</tt> to using <tt>&lt;</tt>. Explain the rationale for this habit.</p>
                      <p class="docText">在<a class="docLink" href="ch03lev1sec3.html#ch03sb09" >第 3.3.2 节</a>的“关键概念”中，我们注意到，C++ 程序员习惯于使用 <tt>!=</tt> 而不用 <tt>&lt;</tt>，解释这一习惯的基本原理。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa6q2"></a><b>Exercise 16.18:</b></td>

                    <td>
                      <p class="docText">In this section we noted that we deliberately wrote the test in <tt>compare</tt> to avoid requiring a type to have both the <tt>&lt;</tt> and <tt>&gt;</tt> operators. On the other hand, we tend to assume that types will have both <tt>==</tt> and <tt>!=</tt>. Explain why this seeming discrepancy in treatment actually reflects good programming style.</p>
		      <p class="docText">本节中我们提到应该慎重地编写 <tt>compare</tt> 中的信息论以避免要求类型同时具有 <tt>&lt;</tt> 和 <tt>&gt</tt> 操作符，另一方面，往往假定类型既有 <tt>==</tt> 又有 <tt>!=</tt>。解释为什么这一看似不一致的处理实际上反映了良好的编程风格。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16sb07"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Caution: Compile-Time Errors at Link-Time</h2>
              <h2 class="docSidebarTitle">警告：链接时的编译时错误</h2>

              <p class="docText"><span class="docEmphStrong">In general, when compiling a template, there are three stages during which the compiler might flag an error: The first is when we compile the template definition itself. The compiler generally can't find many errors at this stage. Syntax errors, such as forgetting a semicolon or misspelling a variable name, can be detected.</span></p>
                      <p class="docText">一般而言，编译模板时，编译器可能会在三个阶段中标识错误：第一阶段是编译模板定义本身时。在这个阶段中编译器一般不能发现许多错误，可以检测到诸如漏掉分号或变量名拼写错误一类的语法错误。</p>

              <p class="docText"><span class="docEmphStrong">The second error-detection time is when the compiler sees a use of the template. At this stage, there is still not much the compiler can check. For a call to a function template, many compilers check only that the number and types of the arguments are appropriate. The compiler can detect that there are too many or too few arguments. It can also detect whether two arguments that are supposed to have the same type do so. For a class template, the compiler can check that the right number of template arguments are provided but not much else.</span></p>
                      <p class="docText">第二个错误检测时间是在编译器见到模板的使用时。在这个阶段，编译器仍没有很多检查可做。对于函数模板的调用，许多编译器只检查实参的数目和类型是否恰当，编译器可以检测到实参太多或太少，也可以检测到假定类型相同的两个实参是否真地类型相同。对于类模板，编译器可以检测提供的模板实参的正确数目。</p>

              <p class="docText"><span class="docEmphStrong">The third time when errors are generated is during instantiation. It is only then that type-related errors can be found. Depending on how the compiler manages instantiation, which we'll cover on page <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3" >643</a>, these errors may be reported at link time.</span></p>
                      <p class="docText">产生错误的第三个时间是在实例化的时候，只有在这个时候可以发现类型相关的错误。根据编译器管理实例化的方式（将在<a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3" >第 16.3 节</a>讨论），有可能在链接时报告这些错误。</p>

              <p class="docText"><span class="docEmphStrong">It is important to realize that when we compile a template definition, we do not know much about how valid the program is. Similarly, we may obtain compiler errors even after we have successfully compiled each file that uses the template. It is not uncommon to detect errors only during instantiation, which may happen at link-time.</span></p>
                      <p class="docText">重要的是，要认识到编译模板定义的时候，对程序是否有效所知不多。类似地，甚至可能会在已经成功编译了使用模板的每个文件之后出现编译错误。只在实例化期间检测错误的情况很少，错误检测可能发生在链接时。</p>
            </td>
          </tr>
        </table><br>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch16.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch16lev1sec2.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
