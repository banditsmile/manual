<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Keyterm Defined Terms</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch18lev1sec8.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="app01.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch18lev1sec9"></a>

        <h3 class="docSection1Title" id="432172-897">Defined Terms</h3>
        <h3 class="docSection1Title" id="432172-897">术语</h3>

<a name="gloss18_01"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term1" >allocator class（allocator 类）</a></b></dt>

          <dd>
            <p class="docText">Standard library class that supports type-specific allocation of raw, unconstructed memory. The <tt>allocator</tt> class is a class template that defines member functions to <tt>allocate, deallocate, construct</tt>, and <tt>destroy</tt> objects of the <tt>allocator</tt>'s template parameter type.</p>
	    <p class="docText">标准库类，支持原始未构造内存的类特定的分配。<tt>allocator</tt> 类是一个类模板，定义了成员函数，对 <tt>allocator</tt> 的模板形参类型的对象进行 <tt>allocate</tt>、<tt>deallocate</tt>、<tt>construct</tt> 和 <tt>destroy</tt>。</p>
          </dd>
        </dl><a name="gloss18_02"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec5.html#ch18term2" >anonymous union（匿名联合）</a></b></dt>

          <dd>
            <p class="docText">Unnamed union that is not used to define an object. Members of the anonymous union are referred to directly. These unions may not have member functions and may not have private or protected members.</p>
            <p class="docText">不用于定义对象的未命名联合。直接引用匿名联合的成员。这些联合不能具有成员函数，也不能具有私有或受保护成员。</p>
          </dd>
        </dl><a name="gloss18_03"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec7.html#ch18term3" >bit-field（位域）</a></b></dt>

          <dd>
<a name="idd1e153977"></a><a name="idd1e153984"></a><a name="idd1e153991"></a><a name="idd1e153999"></a><a name="idd1e154003"></a><a name="idd1e154011"></a><a name="idd1e154014"></a><a name="idd1e154018"></a><a name="idd1e154021"></a><a name="idd1e154024"></a><a name="idd1e154027"></a><a name="idd1e154032"></a><a name="idd1e154037"></a><a name="idd1e154040"></a><a name="idd1e154044"></a><a name="idd1e154052"></a><a name="idd1e154057"></a>
            <p class="docText">Class member with an signed or unsigned integral type that specifies the number of bits to allocate to the member. Bit-fields defined in consecutive order in the class are, if possible, compacted into a common integral value.</p>
            <p class="docText">有符号或无符号整型类成员，它指定了分配给成员的位数。如果可能，将类中以连续次序定义的位域压缩到公共整型值中。</p>
          </dd>
        </dl><a name="gloss18_04"></a>

        <dl class="docList">
          <dt><b>delete expression（delete 表达式）</b></dt>

          <dd>
            <p class="docText">A <tt>delete</tt> expression destroys a dynamically allocated object of a specified type and frees the memory used by that object. A <tt>delete[]</tt> expression destroys the elements of a dynamically allocated array of a specified type and frees the memory used by the array. These expressions use the corresponding version of the library or class-specific <tt>operator delete</tt> functions to free raw memory that held the object or array.</p>
            <p class="docText"><tt>delete</tt> 表达式撤销特定类型的动态分配对象，并释放该对象所用的内存。<tt>delete[]</tt> 表达式撤销特定类型动态分配数组的元素，并释放数组使用的内存。这些表达式使用库函数或类特定的 <tt>operator delete</tt> 函数的对应版本来释放保存对象或数组的原始内存。</p>
          </dd>
        </dl><a name="gloss18_05"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec5.html#ch18term5" >discriminant（判别式）</a></b></dt>

          <dd>
            <p class="docText">Programming technique that uses an object to determine which actual type is held in a union at any given time.</p>
            <p class="docText">一种编程技术，使用对象来确定任意给定时刻联合中保存的实际类型。</p>
          </dd>
        </dl><a name="gloss18_06"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec2.html#ch18term6" >dynamic_cast</a></b></dt>

          <dd>
            <p class="docText">Operator that performs a checked cast from a base type to a derived type. The base type must define at least one <tt>virtual</tt> function. The operator checks the dynamic type of the object to which the reference or pointer is bound. If the object type is the same as the type of the cast (or a type derived from that type), then the cast is done. Otherwise, a zero pointer is returned for a pointer cast, or an exception is thrown for a cast of a reference.</p>
            <p class="docText">执行从基类类型到派生类型的带检查强制转换的操作符。基类类型必须定义至少一个 <tt>virtual</tt> 函数。这个操作符检查引用或指针所绑定对象的动态类型。如果对象类型与转换的类型（或者从该类型派生的类型）相同，则进行转换；否则，指针转换返回 0 指针，引用的转换抛出一个异常。</p>
          </dd>
        </dl><a name="gloss18_07"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term7" >freelist（自由列表）</a></b></dt>

          <dd>
            <p class="docText">Memory management technique that involves preallocating unconstructed memory to hold objects that will be created as needed. When objects are freed, their memory is put back on the free list rather than being returned to the system.</p>
            <p class="docText">一种内存管理技术，涉及预先分配未构造内存以保存在需要时创建的对象。释放对象的时候，将它们的内在放回自由列表，而不是返还给系统。</p>
          </dd>
        </dl><a name="gloss18_08"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec7.html#ch18term8" >linkage directive（链接指示）</a></b></dt>

          <dd>
            <p class="docText">Mechanism used to allow functions written in a different language to be called from a C++ program. All compilers must support calling C and C++ functions. It is compiler-dependent whether any other languages are supported.</p>
            <p class="docText">一种机制，用于允许从 C++ 程序调用以不同语言编写的函数。所有编译器都支持调用 C 和 C++ 函数，是否支持任何其他语言随编译器而定。</p>
          </dd>
        </dl><a name="gloss18_09"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec6.html#ch18term9" >local class（局部类）</a></b></dt>

          <dd>
            <p class="docText">Class defined inside a function. A local class is visible only inside the function in which it is defined. All members of the class must be defined inside the class body. There can be no static members of a local class. Local class members may not access the local variables defined in the enclosing function. They may use type names, static variables, or enumerators defined in the enclosing function.</p>
            <p class="docText">在函数内部定义的类。局部类只在定义它的函数内部可见，类的所有成员必须定义在类定义体内部。局部类不能有静态成员，局部类成员不能访问外围函数中定义的局部变量，它们可以使用外围函数中定义的类型名、静态变量和枚举成员。</p>
          </dd>
        </dl><a name="gloss18_10"></a>

        <dl class="docList">
          <dt><b>member operators new and delete（成员操作符 new 和 delete）</b></dt>

          <dd>
            <p class="docText">Class member functions that override the default memory allocation performed by the global library <tt>operator new</tt> and <tt>operator delete</tt> functions. Both object (<tt>new</tt>) and array (<tt>new[]</tt>) forms of these functions may be defined. The member <tt>new</tt> and <tt>delete</tt> functions are implicitly declared as <tt>static</tt>. These operators allocate (deal-locate) memory. They are used automatically by <tt>new</tt> (<tt>delete</tt>) expressions, which handle object initialization and destruction.</p>
	    <p class="docText">类成员函数，覆盖由全局库函数 <tt>operator new</tt> 和 <tt>operator delete</tt> 执行的默认内存分配。可以定义这些函数的对象形式（<tt>new</tt>）和数组形式（<tt>new[]</tt>）。成员 <tt>new</tt> 和 <tt>delete</tt> 函数隐式声明为 <tt>static</tt>，这些操作符分配（释放）内存，它们由 <tt>new</tt>（<tt>delete</tt>）表达式自动使用，<tt>new</tt>（<tt>delete</tt>）表达式处理对象初始化和撤销。</p>
          </dd>
        </dl><a name="gloss18_11"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec4.html#ch18term11" >nested class（嵌套类）</a></b></dt>

          <dd>
            <p class="docText">Class defined inside another class. A nested class is defined inside its enclosing scope: Nested-class names must be unique within the class scope in which they are defined but can be reused in scopes outside the enclosing class. Access to the nested class outside the enclosing class requires use of the scope operator to specify the scope(s) in which the class is nested.</p>
            <p class="docText">在其他类内部定义的类。嵌套类定义在其外围作用域内部：嵌套类名字必须在定义它们的类作用域　中唯一，但可以在外围类之外的作用域中重用。在外围类之外访问嵌套类需要使用作用域操作符指定包含嵌套类的作用域。</p>
          </dd>
        </dl><a name="gloss18_12"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec4.html#ch18term12" >nested type（嵌套类型）</a></b></dt>

          <dd>
            <p class="docText">Synonym for nested class.</p>
            <p class="docText">嵌套类的同义词。</p>
          </dd>
        </dl><a name="gloss18_13"></a>

        <dl class="docList">
          <dt><b>new expression（new 表达式）</b></dt>

          <dd>
            <p class="docText">A <tt>new</tt> expression allocates and constructs an object of a specified type. A <tt>new[]</tt> expression allocates and constructs an array of objects. These expressions use the corresponding version of the library <tt>operator new</tt> functions to allocate raw memory in which the expression constructs an object or array of the specified type.</p>
            <p class="docText"><tt>new</tt> 表达式分配和构造特定类型的对象。<tt>new[]</tt> 表达式分配和构造对象数组。这些表达式使用库函数 <tt>operator new</tt> 的对应版本分配原始内存，并在该内存中构造特定类型的对象或数组。</p>
          </dd>
        </dl><a name="gloss18_14"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term14" >operator delete</a></b></dt>

          <dd>
            <p class="docText">A library function that frees untyped, unconstructed memory allocated by <tt>operator new</tt>. The library <tt>operator delete[]</tt> frees memory used to hold an array that was allocated by <tt>operator new[]</tt>.</p>
            <p class="docText">释放由 <tt>operator new</tt> 分配的未类型化的未构造内存的库函数。库函数 <tt>operator delete[]</tt> 释放由 <tt>operator new[]</tt> 分配的用于保存数组的内存。</p>
          </dd>
        </dl><a name="gloss18_15"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term15" >operator new</a></b></dt>

          <dd>
<a name="idd1e154216"></a><a name="idd1e154219"></a><a name="idd1e154224"></a><a name="idd1e154230"></a><a name="idd1e154236"></a><a name="idd1e154241"></a><a name="idd1e154244"></a><a name="idd1e154247"></a><a name="idd1e154250"></a><a name="idd1e154254"></a><a name="idd1e154259"></a><a name="idd1e154262"></a>
            <p class="docText">A library function that allocates untyped, unconstructed memory of a given size. The library function <tt>operator new[]</tt> allocates raw memory for arrays. These library functions provide a more primitive allocation mechanism than the library <tt>allocator</tt> class. Modern C++ programs should use the <tt>allocator</tt> classes rather than these library functions.</p>
            <p class="docText">一个库函数，它分配给定大小未类型化的未构造内存。库函数 <tt>operator new[]</tt> 为数组分配原始内存。这些库函数提供了比库类 <tt>allocator</tt> 更基本的分配机制。现代 C++ 程序应使用 <tt>allocator</tt> 类而不是这些库函数。</p>
          </dd>
        </dl><a name="gloss18_16"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec1.html#ch18term16" >placement new expression（定位 new 表达式）</a></b></dt>

          <dd>
            <p class="docText">The form of <tt>new</tt> that constructs its object in specified memory. It does no allocation; instead, it takes an argument that specifies where the object should be constructed. It is a lower-level analog of the behavior provided by the <tt>construct</tt> member of the <tt>allocator</tt> class.</p>
            <p class="docText">在特定内存中构造对象的 <tt>new</tt> 的形式。它不进行分配，相反，它接受指定在何处构造对象的实参。它是对 <tt>allocator</tt> 类的 <tt>construct</tt> 成员所提供的行为的低级模拟。</p>
          </dd>
        </dl><a name="gloss18_17"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec3.html#ch18term17" >pointer to member（成员指针）</a></b></dt>

          <dd>
            <p class="docText">Pointer that encapsulates the class type as well as the member type to which the pointer points. The definition of a pointer to member must specify the class name as well as the type of the member(s) to which the pointer may point:</p>
            <p class="docText">封装类类型以及指针所指向的成员类型的指针。成员指针的定义必须指定类名以及指针可以指向的成员的类型：</p>
            <pre>
     TC::*pmem = &amp;C::member;
</pre><br>

            <p class="docText">This statement defines <tt>pmem</tt> as a pointer that can point to members of the class named <span class="docEmphasis">C</span> that have type <span class="docEmphasis">T</span> and initializes it to point to the member in <span class="docEmphasis">C</span> named <span class="docEmphasis">member</span>. When the pointer is dereferenced, it must be bound to an object of or pointer to type <span class="docEmphasis">C</span>:</p>
	    <p class="docText">这个语句将 <tt>pmem</tt> 定义为指针，它可以指向名为 <span class="docEmphasis">C</span> 的类的类型为 <span class="docEmphasis">T</span> 的成员，并将 <tt>pmem</tt> 初始化为 <span class="docEmphasis">C</span> 中名为 <span class="docEmphasis">member</span> 的成员。对该指针解引用的时候，它必须是绑定到类型 <span class="docEmphasis">C</span> 的对象或指向类型 <span class="docEmphasis">C</span> 的指针：</p>
            <pre>
     <span class="docEmphasis">classobj</span>.*pmem;
     <span class="docEmphasis">classptr</span>-&gt;*pmem;
</pre><br>

            <p class="docText">fetches <span class="docEmphasis">member</span> from the object <span class="docEmphasis">classobj</span> of the object pointed to by <span class="docEmphasis">classptr</span>.</p>
            <p class="docText">从 <span class="docEmphasis">classptr</span> 所指对象的 <span class="docEmphasis">classobj</span> 对象获取 <span class="docEmphasis">member</span>。</p>
          </dd>
        </dl><a name="gloss18_18"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec7.html#ch18term18" >portable（可移植的）</a></b></dt>

          <dd>
            <p class="docText">Term used to describe a program that can be moved to a new machine with relatively little effort.</p>
            <p class="docText">一个用来描述用相对较少的努力就可以移到新机器的程序的术语。</p>
          </dd>
        </dl><a name="gloss18_19"></a>

        <dl class="docList">
          <dt><b>run-time type identification（运行时类型识别）</b></dt>

          <dd>
            <p class="docText">Term used to describe the language and library facilities that allow the dynamic type of a reference or pointer to be obtained at run time. The RTTI operators, <tt>typeid</tt> and <tt>dynamic_cast</tt>, provide the dynamic type only for references or pointers to class types with virtual functions. When applied to other types, the type returned is the static type of the reference or pointer.</p>
            <p class="docText">用来描述语言和库设施的术语，这种设施允许在运行时获得引用或指针的动态类型。RTTI 操作符 <tt>typeid</tt> 和 <tt>dynamic_cast</tt> 只为带虚函数的类类型提供动态类型，应用于其他类型的时候，返回引用或指针的静态类型。</p>
          </dd>
        </dl><a name="gloss18_20"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec2.html#ch18term20" >typeid</a></b></dt>

          <dd>
            <p class="docText">Unary operator that takes an expression and returns a reference to an object of the library type named <tt>type_info</tt> that describes the type of the expression. When the expression is an object of a type that has virtual functions, then the dynamic type of the expression is returned. If the type is a reference, pointer, or other type that does not define virtual functions, then the type returned is the static type of the reference, pointer, or object.</p>
            <p class="docText">一元操作符，接受一个表达式，并返回描述表达式类型的名为 <tt>type_info</tt> 的库类型的对象引用。如果表达式是具有虚函数的类型的对象，就返回表达式的动态类型；如果该类型是没有定义虚函数的引用、指针或其他类型，就返回引用、指针或对象的静态类型。</p>
          </dd>
        </dl><a name="gloss18_21"></a>

        <dl class="docList">
          <dt><b>type_info</b></dt>

          <dd>
            <p class="docText">Library type that describes a type. The <tt>type_info</tt> class is inherently machine-dependent, but any library must define <tt>type_info</tt> with members listed in <a class="docLink" href="ch18lev1sec2.html#ch18table02" >Table 18.2</a> (p. <a class="docLink" href="ch18lev1sec2.html#ch18table02" >779</a>). <tt>type_info</tt> objects may not be copied.</p>
            <p class="docText">描述类型的库类型。<tt>type_info</tt> 类是固有机器相关的，但任何库都必须定义带有<a class="docLink" href="ch18lev1sec2.html#ch18table02" >表 18.2</a> 中所列出成员的 <tt>type_info</tt>。<tt>type_info</tt> 对象不能复制。</p>
          </dd>
        </dl><a name="gloss18_22"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec5.html#ch18term22" >union（联合）</a></b></dt>

          <dd>
            <p class="docText">Classlike aggregate type that may define multiple data members, only one of which can have a value at any one point. Members of a union must be simple types: They can be a built-in or compound type or a class type that does not define a constructor, destructor, or the assignment operator. Unions may have member functions, including constructors and destructors. A union may not serve as a base class.</p>
            <p class="docText">类形式的聚合类型，它可以定义多个数据成员，但在任意点只有一个成员可以具有值。联合的成员必须为简单类型：内置类型，复合类型，没有定义构造函数、析构函数或赋值操作符的类类型。联合可以有成员函数，包括构造函数和析构函数。联合不能作基类使用。</p>
          </dd>
        </dl><a name="gloss18_23"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch18lev1sec7.html#ch18term23" >volatile</a></b></dt>

          <dd>
            <p class="docText">Type qualifier that signifies to the compiler that a variable might be changed outside the direct control of the program. It is a signal to the compiler that it may not perform certain optimizations.</p>
            <p class="docText">类型限定符，告诉编译器可以在程序的直接控制之外改变一个变量。它是告诉编译器不能执行某些优化的信号。</p>
          </dd>
        </dl>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch18lev1sec8.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="app01.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
