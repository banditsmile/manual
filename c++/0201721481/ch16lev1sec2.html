<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 16.2.  Instantiation</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch16lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch16lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch16lev1sec2"></a>

        <h3 class="docSection1Title">16.2. Instantiation</h3>
        <h3 class="docSection1Title">16.2. 实例化</h3>

<a name="idd1e125697"></a><a name="idd1e125702"></a><a name="idd1e125707"></a><a name="idd1e125712"></a>
        <p class="docText">A template is a blueprint; it is not itself a class or a function. The compiler uses the template to generate type-specific versions of the specified class or function. The process of generatng a type-specific instance of a template is known as instantiation. The term reflects the notion that a new "instance" of the template type or function is created.</p>
        <p class="docText">模板是一个蓝图，它本身不是类或函数。编译器用模板产生指定的类或函数的特定类型版本。产生模板的特定类型实例的过程称为实例化，这个术语反映了创建模板类型或模板函数的新“实例”的概念。</p>

        <p class="docText">A template is instantiated when we use it. A class template is instantiated when we refer to the an actual template class type, and a function template is instantiated when we call it or use it to initialize or assign to a pointer to function.</p>
        <p class="docText">模板在使用时将进行实例化，类模板在引用实际模板类类型时实例化，函数模板在调用它或用它对函数指针进行初始化或赋值时实例化。</p>

<a name="ch16lev2sec7"></a>
        <h4 class="docSection2Title">Instantiating a Class</h4>
        <h4 class="docSection2Title">类的实例化</h4>

        <p class="docText">When we write</p>
        <p class="docText">当编写</p>
        <pre>
     Queue&lt;int&gt; qi;
</pre><br>

        <p class="docText">the compiler automatially creates a class named <tt>Queue&lt;int&gt;</tt>. In effect, the compiler creates the <tt>Queue&lt;int&gt;</tt> class by rewriting the <tt>Queue</tt> template, replacing every occurrence of the template parameter <tt>Type</tt> by the type <tt>int</tt>. The instantiated class is as if we had written:</p>
        <p class="docText">编译器自动创建名为 Queue<int> 的类。实际上，编译器通过重新编写 Queue 模板，用类型 int 代替模板形参的每次出现而创建 Queue<int> 类。实例化的类就像已经编写的一样：</p>
        <pre>
     // <span class="docEmphItalicAlt">simulated version of</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">instantiated for type</span> <span class="docEmphasis">int</span>
     template &lt;class Type&gt; class Queue&lt;int&gt; {
     public:
         Queue();                  // <span class="docEmphItalicAlt">this bound to</span> <span class="docEmphasis">Queue&lt;int&gt;*</span>
         int &amp;front();             // <span class="docEmphItalicAlt">return type bound to</span> <span class="docEmphasis">int</span>
         const int &amp;front() const; // <span class="docEmphItalicAlt">return type bound to</span> <span class="docEmphasis">int</span>
         void push(const int &amp;);   // <span class="docEmphItalicAlt">parameter type bound to</span> <span class="docEmphasis">int</span>
         void pop();               // <span class="docEmphItalicAlt">type invariant code</span>
         bool empty() const;       // <span class="docEmphItalicAlt">type invariant code</span>
     private:
         // ...
     };
</pre><br>

        <p class="docText">To create a <tt>Queue</tt> class for objects of type <tt>string</tt>, we'd write:</p>
        <p class="docText">要为 string 类型的对象创建 Queue 类，可以编写</p>
        <pre>
     Queue&lt;string&gt; qs;
</pre><br>

        <p class="docText">In this case, each occurrence of <tt>Type</tt> would be replaced by <tt>string</tt>.</p><a name="ch16note06"></a>
        <p class="docText">在这个例子中，用 string 代替 Type 的每次出现。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Each instantiation of a class template constitutes an independent class type. The <tt>Queue</tt> instantiation for the type <tt>int</tt> has no relationship to nor any special access to the members of any other <tt>Queue</tt> type.</p>
        <p class="docText">类模板的每次实例化都会产生一个独立的类类型。为 int 类型实例化的 Queue 与任意其他 Queue 类型没有关系，对其他 Queue 类型成员也没有特殊的访问权。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch16lev2sec8"></a>

        <h4 class="docSection2Title">Class Template Arguments Are Required</h4>
        <h4 class="docSection2Title">类模板形参是必需的</h4>

        <p class="docText">When we want to use a class template, we must always specify the template arguments explicitly.</p>
        <p class="docText">想要使用类模板，就必须显式指定模板实参：</p>
        <pre>
     Queue qs; // <span class="docEmphItalicAlt">error: which template instantiation?</span>
</pre><br>

	<a name="idd1e125863"></a><a name="idd1e125866"></a><a name="idd1e125871"></a><a name="idd1e125874"></a><a name="idd1e125879"></a><a name="idd1e125884"></a><a name="idd1e125891"></a><a name="idd1e125896"></a><a name="idd1e125901"></a>
        <p class="docText">A class template does not define a type; only a specific instantiation defines a type. We define a specific instantiation by providing a template argument to match each template parameter. Template arguments are specified in a comma-separated list and bracketed by the (<tt>&lt;</tt>) and (<tt>&gt;)</tt> tokens:</p>
        <p class="docText">类模板不定义类型，只有特定的实例才定义了类型。特定的实例化是通过提供模板实参与每个模板形参匹配而定义的。模板实参在用逗号分隔并用尖括号括住的列表中指定：</p>
        <pre>
     Queue&lt;int&gt; qi;         // <span class="docEmphItalicAlt">ok: defines</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> <span class="docEmphasis">int</span><span class="docEmphItalicAlt">s</span>
     Queue&lt;string&gt; qs;      // <span class="docEmphItalicAlt">ok: defines</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">that holds</span> <span class="docEmphasis">string</span><span class="docEmphItalicAlt">s</span>
</pre><br>

        <p class="docText">The type defined by a template class always includes the template argument(s). For example, <tt>Queue</tt> is not a type; <tt>Queue&lt;int&gt;</tt> or <tt>Queue&lt;string&gt;</tt> are.</p>
	<p class="docText">用模板类定义的类型总是模板实参。例如，<tt>Queue</tt> 不是类型，而 <tt>Queue&lt;int&gt;</tt> 或 <tt>Queue&lt;string&gt;</tt> 是类型。</p>

	<a name="ch16lev2sec9"></a>
        <h4 class="docSection2Title">Function-Template Instantiation</h4>
        <h4 class="docSection2Title">函数模板实例化</h4>

        <p class="docText">When we use a function template, the compiler will usually infer the template arguments for us:</p>
        <p class="docText">使用函数模板时，编译器通常会为我们推断模板实参：</p>
        <pre>
     int main()
     {
        compare(1, 0);             // <span class="docEmphItalicAlt">ok: binds template parameter to</span> <span class="docEmphasis">int</span>
        compare(3.14, 2.7);        // <span class="docEmphItalicAlt">ok: binds template parameter to</span> <span class="docEmphasis">double</span>
        return 0;
     }
</pre><br>

        <p class="docText">This program instantiates two versions of <tt>compare</tt>: one where <tt>T</tt> is replaced by <tt>int</tt> and the other where it is replaced by <tt>double</tt>. The compiler essentially writes for us these two instances of <tt>compare</tt>:</p>
	<p class="docText">这个程序实例化了 <tt>compare</tt> 的两个版本：一个用 <tt>int</tt> 代替 <tt>T</tt>，另一个用 <tt>double</tt> 代替 <tt>T</tt>，实质上是编译器为我们编写了 <tt>compare</tt> 的这两个实例：</p>
        <pre>
     int compare(const int &amp;v1, const int &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
     int compare(const double &amp;v1, const double &amp;v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><br>
        <a name="ch16lev2sec10"></a>

        <h4 class="docSection2Title">16.2.1. Template Argument Deduction</h4>
        <h4 class="docSection2Title">16.2.1. 模板实参推断</h4>

        <p class="docText">To determine which functions to instantiate, the compiler looks at each argument. If the corresponding parameter was declared with a type that is a type parameter, then the compiler infers the type of the parameter from the type of the argument. In the case of <tt>compare</tt>, both arguments have the same template type: they were each declared using the type parameter <tt>T</tt>.</p>
	<p class="docText">要确定应该实例化哪个函数，编译器会查看每个实参。如果相应形参声明为类型形参的类型，则编译器从实参的类型推断形参的类型。在 <tt>compare</tt> 的例子中，两个实参有同样的模板类型，都是用类型形参 <tt>T</tt> 声明的。</p>

<a name="ch16term12"></a><a name="ch16lev3sec12"></a>
        <p class="docText">In the first call, <tt>compare(1, 0)</tt>, those arguments are type <tt>int</tt>; in the second, <tt>compare(3.14, 2.7)</tt>, they have type <tt>double</tt>. The process of determining the types and values of the template arguments from the type of the function arguments is called <b><a class="docLink" href="ch16lev1sec9.html#gloss16_12" >template argument deduction</a></b>.</p>
	<p class="docText">第一个调用 <tt>compare(1, 0)</tt> 中，实参为 <tt>int</tt> 类型；第二个调用 <tt>compare(3.14, 2.7)</tt> 中，实参为 <tt>double</tt> 类型。从函数实参确定模板实参的类型和值的过程叫做<b><a class="docLink" href="ch16lev1sec9.html#gloss16_12" >模板实参推断</a></b>。</p>

        <h5 class="docSection3Title">Multiple Type Parameter Arguments Must Match Exactly</h5>
        <h5 class="docSection3Title">多个类型形参的实参必须完全匹配</h5>

	<a name="idd1e126048"></a><a name="idd1e126053"></a><a name="idd1e126060"></a><a name="idd1e126067"></a><a name="idd1e126072"></a>
        <p class="docText">A template type parameter may be used as the type of more than one function parameter. In such cases, template type deduction must generate the same template argument type for each corresponding function argument. If the deduced types do not match, then the call is an error:</p>
        <p class="docText">模板类型形参可以用作一个以上函数形参的类型。在这种情况下，模板类型推断必须为每个对应的函数实参产生相同的模板实参类型。如果推断的类型不匹配，则调用将会出错：</p>
        <pre>
     template &lt;typename T&gt;
     int compare(const T&amp; v1, const T&amp; v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
     int main()
     {
         short si;
         // <span class="docEmphItalicAlt">error: cannot instantiate compare(short, int)</span>
         // <span class="docEmphItalicAlt">must be: compare(short, short) or</span>
         // <span class="docEmphItalicAlt">compare(int, int)</span>
         compare(si, 1024);
         return 0;
     }
</pre><br>

        <p class="docText">This call is in error because the arguments to <tt>compare</tt> don't have the same type. The template argument deduced from the first argument is <tt>short</tt>; the one for the second is <tt>int</tt>. These types don't match, so template argument deduction fails.</p>
	<p class="docText">这个调用是错误的，因为调用 <tt>compare</tt> 时的实参类型不相同，从第一个实参推断出的模板类型是 <tt>short</tt>，从第二个实参推断出 <tt>int</tt> 类型，两个类型不匹配，所以模板实参推断失败。</p>

        <p class="docText">If the designer of <tt>compare</tt> wants to allow normal conversions on the arguments, then the function must be defined with two type parameters:</p>
	<p class="docText">如果 <tt>compare</tt> 的设计者想要允许实参的常规转换，则函数必须用两个类型形参来定义：</p>
        <pre>
     // <span class="docEmphItalicAlt">argument types can differ, but must be compatible</span>
     template &lt;typename A, typename B&gt;
     int compare(const A&amp; v1, const B&amp; v2)
     {
         if (v1 &lt; v2) return -1;
         if (v2 &lt; v1) return 1;
         return 0;
     }
</pre><br>

        <p class="docText">Now the user may supply arguments of different types:</p>
        <p class="docText">现在用户可以提供不同类型的实参了：</p>
        <pre>
     short si;
     compare(si, 1024); // <span class="docEmphItalicAlt">ok: instantiates compare(short, int)</span>
</pre><br>

        <p class="docText">However, a <tt>&lt;</tt> operator must exist that can compare values of those types.</p>
        <p class="docText">但是，比较那些类型的值的 <tt>&lt;</tt> 操作符必须存在。</p>

	<a name="ch16lev3sec13"></a>
        <h5 class="docSection3Title">Limited Conversions on Type Parameter Arguments</h5>
        <h5 class="docSection3Title">类型形参的实参的受限转换</h5>

        <p class="docText">Consider the following calls to <tt>compare</tt>:</p>
	<p class="docText">考虑下面的 <tt>compare</tt> 调用：</p>
        <pre>
     short s1, s2;
     int i1, i2;
     compare(i1, i2);           // <span class="docEmphItalicAlt">ok: instantiate</span> <span class="docEmphasis">compare(int, int)</span>
     compare(s1, s2);           // <span class="docEmphItalicAlt">ok: instantiate</span> <span class="docEmphasis">compare(short, short)</span>
</pre><br>

	<a name="idd1e126170"></a><a name="idd1e126177"></a><a name="idd1e126185"></a><a name="idd1e126192"></a><a name="idd1e126199"></a><a name="idd1e126208"></a>
        <p class="docText">The first call generates an instance of <tt>compare</tt> with <tt>T</tt> bound to <tt>int</tt>. A new instance is created for the second call, binding <tt>T</tt> to <tt>short</tt>.</p>
	<p class="docText">第一个调用产生将 <tt>T</tt> 绑定到 <tt>int</tt> 的实例，为第二个调用创建新实例，将 <tt>T</tt> 绑定到 <tt>short</tt>。</p>

        <p class="docText">Had <tt>compare(int, int)</tt> been an ordinary nontemplate function, then the second call would match that function. The <tt>short</tt> arguments would be promoted (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec26" >Section 5.12.2</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec26" >180</a>) to <tt>int</tt>. Because <tt>compare</tt> is a template, a new function is instantiated with the type parameter bound to <tt>short</tt>.</p>
	<p class="docText">如果 <tt>compare(int, int)</tt> 是普通的非模板函数，则第二个调用会匹配那个函数，<tt>short</tt> 实参将提升（<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec26" >第 5.12.2 节</a>）为 <tt>int</tt>。因为 <tt>compare</tt> 是一个模板，所以将实例化一个新函数，将类型形参绑定到 <tt>short</tt>。</p>

        <p class="docText">In general, arguments are not converted to match an existing instantiation; instead, a new instance is generated. There are only two kinds of conversions that the compiler will perform rather than generating a new instantiation:</p>
        <p class="docText">一般而论，不会转换实参以匹配已有的实例化，相反，会产生新的实例。除了产生新的实例化之外，编译器只会执行两种转换：</p>

        <ul>
          <li>
            <p class="docList"><tt>const</tt> conversions: A function that takes a reference or pointer to a <tt>const</tt> can be called with a reference or pointer to non<tt>const</tt> object, respectively, without generating a new instantiation. If the function takes a nonreference type, then <tt>const</tt> is ignored on either the parameter type or the argument. That is, the same instantiation will be used whether we pass a <tt>const</tt> or non<tt>const</tt> object to a function defined to take a nonreference type.</p>
	    <p class="docList"><tt>const</tt> 转换：接受 <tt>const</tt> 引用或 <tt>const</tt> 指针的函数可以分别用非 <tt>const</tt> 对象的引用或指针来调用，无须产生新的实例化。如果函数接受非引用类型，形参类型实参都忽略 <tt>const</tt>，即，无论传递 <tt>const</tt> 或非 <tt>const</tt> 对象给接受非引用类型的函数，都使用相同的实例化。</p>
          </li>

          <li>
            <p class="docList">array or function to pointer conversions: If the template parameter is not a reference type, then the normal pointer conversion will be applied to arguments of array or function type. An array argument will be treated as a pointer to its first element, and a function argument will be treated as a pointer to the function's type.</p>
            <p class="docList">数组或函数到指针的转换：如果模板形参不是引用类型，则对数组或函数类型的实参应用常规指针转换。数组实参将当作指向其第一个元素的指针，函数实参当作指向函数类型的指针。</p>
          </li>
        </ul>

        <p class="docText">As examples, consider calls to the functions <tt>fobj</tt> and <tt>fref</tt>. The <tt>fobj</tt> function copies its parameters, whereas <tt>fref</tt>'s parameters are references:</p>
	<p class="docText">例如，考虑对函数 <tt>fobj</tt> 和 <tt>fref</tt> 的调用。<tt>fobj</tt> 函数复制它的形参，而 <tt>fref</tt> 的形参是引用：</p>
        <pre>
     template &lt;typename T&gt; T fobj(T, T); // <span class="docEmphItalicAlt">arguments are copied</span>
     template &lt;typename T&gt;
     T fref(const T&amp;, const T&amp;);       // <span class="docEmphItalicAlt">reference arguments</span>
     string s1("a value");
     const string s2("another value");
     fobj(s1, s2);     // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">f(string, string)</span>, <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">is ignored</span>
     fref(s1, s2);     // <span class="docEmphItalicAlt">ok: non</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">object</span> <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">converted to</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">reference</span>
     int a[10], b[42];
     fobj(a, b); // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">f(int*, int*)</span>
     fref(a, b); // <span class="docEmphItalicAlt">error: array types don't match; arguments aren't converted to pointers</span>
</pre><br>

        <p class="docText">In the first case, we pass a <tt>string</tt> and a <tt>const string</tt> as arguments. Even though these types do not match exactly, both calls are legal. In the call to <tt>fobj</tt>, the arguments are copied, so whether the original object is <tt>const</tt> doesn't matter. In the call to <tt>fref</tt>, the parameter type is a reference to <tt>const</tt>. Conversion to <tt>const</tt> for a reference parameter is one of the acceptable conversions, so this call is also okay.</p>
	<p class="docText">第一种情况下，传递 <tt>string</tt> 对象和 <tt>const string</tt> 对象作为实参，即使这些类型不完全匹配，两个调用也都是合法的。在 <tt>fobj</tt> 的调用中，实参被复制，因此原来的对象是否为 <tt>const</tt> 无关紧要。在 <tt>fref</tt> 的调用中，形参类型是 <tt>const</tt> 引用，对引用形参而言，转换为 <tt>const</tt> 是可以接受的转换，所以这个调用也正确。</p>

        <p class="docText">In the next case, we pass array arguments in which the arrays are different sizes. In the call to <tt>fobj</tt>, the fact that the arrays are different doesn't matter. Both arrays are converted to pointers. The template parameter type in <tt>fobj</tt> is <tt>int*</tt>. The call to <tt>fref</tt>, however, is illegal. When the parameter is a reference (<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >Section 7.2.4</a>, p. <a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >240</a>), the arrays are not converted to pointers. The types of <tt>a</tt> and <tt>b</tt> don't match, so the call is in error.</p>
	<p class="docText">在第二种情况中，将传递不同长度的数组实参。<tt>fobj</tt> 的调用中，数组不同无关紧要，两个数组都转换为指针，<tt>fobj</tt> 的模板形参类型是 <tt>int*</tt>。但是，<tt>fref</tt> 的调用是非法的，当形参为引用时（<a class="docLink" href="ch07lev1sec2.html#ch07lev2sec9" >第 7.2.4 节</a>），数组不能转换为指针，<tt>a</tt> 和 <tt>b</tt> 的类型不匹配，所以调用将出错。</p>

	<a name="ch16lev3sec14"></a>
        <h5 class="docSection3Title">Normal Conversions Apply for Nontemplate Arguments</h5>
        <h5 class="docSection3Title">应用于非模板实参的常规转换</h5><a name="ch16note07"></a>

<a name="ch16note07"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
<a name="idd1e126420"></a><a name="idd1e126425"></a><a name="idd1e126430"></a><a name="idd1e126437"></a><a name="idd1e126444"></a>
                <p class="docText"> The restriction on type conversions applies only to those arguments whose types are template parameters.</p>
        <p class="docText">类型转换的限制只适用于类型为模板形参的那些实参。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Normal conversions (<a class="docLink" href="ch07lev1sec1.html#ch07lev2sec5" >Section 7.1.2</a>, p. <a class="docLink" href="ch07lev1sec1.html#ch07lev2sec5" >229</a>) are allowed for parameters defined using ordinary types. The following function template <tt>sum</tt> has two parameters:</p>
	<p class="docText">用普通类型定义的形参可以使用常规转换（<a class="docLink" href="ch07lev1sec1.html#ch07lev2sec5" >第 7.1.2 节</a>），下面的函数模板 <tt>sum</tt> 有两个形参：</p>
        <pre>
     template &lt;class Type&gt; Type sum(const Type &amp;op1, int op2)
     {
         return op1 + op2;
     }
</pre><br>

        <p class="docText">The first parameter, <tt>op1</tt>, has a template parameter type. Its actual type cannot be known until the function is used. The type of the second parameter, <tt>op2</tt>, is known: It's <tt>int</tt>.</p>
	<p class="docText">第一个形参 <tt>op1</tt> 具有模板形参类型，它的实际类型到函数使用时才知道。第二个形参 <tt>op2</tt> 的类型已知，为 <tt>int</tt>。</p>

        <p class="docText">Because the type of <tt>op2</tt> is fixed, normal conversions can be applied to arguments passed to <tt>op2</tt> when <tt>sum</tt> is called:</p>
	<p class="docText">因为 <tt>op2</tt> 的类型是固定的，在调用 <tt>sum</tt> 的时候，可以对传递给 <tt>op2</tt> 的实参应用常规转换：</p>
        <pre>
     double d = 3.14;
     string s1("hiya"), s2(" world");
     sum(1024, d); // <span class="docEmphItalicAlt">ok: instantiates</span> <span class="docEmphasis">sum(int, int),</span> <span class="docEmphItalicAlt">converts</span> <span class="docEmphasis">d</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span>
     sum(1.4, d); // <span class="docEmphItalicAlt">ok: instantiates</span> <span class="docEmphasis">sum(double, int),</span> <span class="docEmphItalicAlt">converts</span> <span class="docEmphasis">d</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int</span>
     sum(s1, s2); // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">s2</span> <span class="docEmphItalicAlt">cannot be converted to</span> <span class="docEmphasis">int</span>
</pre><br>

        <p class="docText">In the first two calls, the type of the second argument <tt>dd</tt> is not the same as the type of the corresponding function parameter. However, these calls are okay: There is a conversion from <tt>double</tt> to <tt>int</tt>. Because the type of the second parameter does not depend on a template parameter, the compiler will implicitly convert <tt>dd</tt>. The first call causes the function <tt>sum(int, int)</tt> to be instantiated; <tt>sum(double, int)</tt> is instantiated by the second call.</p>
	<p class="docText">在前两个调用中，第二个实参 <tt>dd</tt> 的类型与对应函数形参的类型不同，但是，这些调用是正确的：有从 <tt>double</tt> 到 <tt>int</tt> 的转换。因为第二个形参的类型独立模板形参，编译器将隐式转换 <tt>dd</tt>。第一个调用导致实例化函数 <tt>sum(int, int)</tt>，第二个调用实例化 <tt>sum(double, int)</tt>。</p>

        <p class="docText">The third call is an error. There is no conversion from <tt>string</tt> to <tt>int</tt>. Using a <tt>string</tt> argument to match an <tt>int</tt> parameter is, as usual, illegal.</p><a name="ch16lev3sec15"></a>
	<p class="docText">第三个调用是错误的。没有从 <tt>string</tt> 到 <tt>int</tt> 的转换，使用 <tt>string</tt> 实参来匹配 <tt>int</tt> 形参与一般情况一样，是非法的。</p>

        <h5 class="docSection3Title">Template Argument Deduction and Function Pointers</h5>
        <h5 class="docSection3Title">模板实参推断与函数指针</h5>

        <p class="docText">We can use a function template to initialize or assign to a function pointer (<a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9" >Section 7.9</a>, p. <a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9" >276</a>). When we do so, the compiler uses the type of the pointer to instantiate a version of the template with the appropriate template argument(s).</p>
        <p class="docText">可以使用函数模板对函数指针进行初始化或赋值（<a class="docLink" href="ch07lev1sec9.html#ch07lev1sec9" >第 7.9 节</a>），这样做的时候，编译器使用指针的类型实例化具有适当模板实参的模板版本。</p>

        <p class="docText">As an example, assume we have a function pointer that points to a function returning an <tt>int</tt> that takes two parameters, each of which is a reference to a <tt>const int</tt>. We could use that pointer to point to an instantiation of <tt>compare</tt>:</p>
	<p class="docText">例如，假定有一个函数指针指向返回 <tt>int</tt> 值的函数，该函数接受两个形参，都是 <tt>const int</tt> 引用，可以用该指针指向 <tt>compare</tt> 的实例化</p>
        <pre>
     template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);
     // <span class="docEmphasis">pf1</span> <span class="docEmphItalicAlt">points to the instantiation</span> <span class="docEmphasis">int compare (const int&amp;, const int&amp;)</span>
     int (*pf1) (const int&amp;, const int&amp;) = compare;
</pre><br>

        <p class="docText">The type of <tt>pf1</tt> is "pointer to function returning an <tt>int</tt> taking two parameters of type <tt>const int&amp;</tt>." The type of the parameters in <tt>pf1</tt> determines the type of the template argument for <tt>T</tt>. The template argument for <tt>T</tt> is <tt>int</tt>. The pointer <tt>pf1</tt> refers to the instantiation with <tt>T</tt> bound to <tt>int</tt>.</p>
	<p class="docText"><tt>pf1</tt> 的类型是一个指针，指向“接受两个 <tt>const int&amp;</tt> 类型形参并返回 <tt>int</tt> 值的函数”，形参的类型决定了 <tt>T</tt> 的模板实参的类型，<tt>T</tt> 的模板实参为 <tt>int</tt> 型，指针 <tt>pf1</tt> 引用的是将 <tt>T</tt> 绑定到 <tt>int</tt> 的实例化。</p>

	<a name="ch16note08"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">When the address of a function-template instantiation is taken, the context must be such that it allows a unique type or value to be determined for each template parameter.</p>
        <p class="docText">获取函数模板实例化的地址的时候，上下文必须是这样的：它允许为每个模板形参确定唯一的类型或值。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">It is an error if the template arguments cannot be determined from the function pointer type. For example, assume we have two functions named <tt>func</tt>. Each function takes a pointer to function argument. The first version of <tt>func</tt> takes a pointer to a function that has two <tt>const string</tt> reference parameters and returns a <tt>string</tt>. The second version of <tt>func</tt> takes a pointer to a function taking two <tt>const int</tt> reference parameters and returning an <tt>int</tt>. We cannot use <tt>compare</tt> as an argument to <tt>func</tt>:</p>
	<p class="docText">如果不能从函数指针类型确定模板实参，就会出错。例如，假定有两个名为 <tt>func</tt> 的函数，每个函数接受一个指向函数实参的指针。<tt>func</tt> 的第一个版本接受有两个 <tt>const string</tt> 引用形参并返回 <tt>string</tt> 对象的函数的指针，<tt>func</tt> 的第二个版本接受带两个 <tt>const int</tt> 引用形参并返回 <tt>int</tt> 值的函数的指针，不能使用 <tt>compare</tt> 作为传给 <tt>func</tt> 的实参：</p>
        <pre>
     // <span class="docEmphItalicAlt">overloaded versions of</span> <span class="docEmphasis">func;</span> <span class="docEmphasis">each take a different function pointer type</span>
     void func(int(*) (const string&amp;, const string&amp;));
     void func(int(*) (const int&amp;, const int&amp;));
     func(compare); // <span class="docEmphItalicAlt">error: which instantiation of</span> <span class="docEmphasis">compare?</span>
</pre><br>

        <p class="docText">The problem is that by looking at the type of <tt>func</tt>'s parameter, it is not possible to determine a unique type for the template argument. The call to <tt>func</tt> could instantiate either of the following functions:</p>
	<p class="docText">问题在于，通过查看 <tt>func</tt> 的形参类型不可能确定模板实参的唯一类型，对 <tt>func</tt> 的调用可以实例化下列函数中的任意一个：</p>
        <pre>
     compare(const string&amp;, const string&amp;)
     compare(const int&amp;, const int&amp;)
</pre><br>

        <p class="docText">Because it is not possible to identify a unique instantiation for the argument to <tt>func</tt>, this call is a compile-time (or link-time) error.</p>
	<p class="docText">因为不能为传给 <tt>func</tt> 的实参确定唯一的实例化，该调用会产生一个编译时（或链接时）错误。</p>

<a name="ch16sb08"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.2.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa7q1"></a><b>Exercise 16.19:</b></td>

                    <td>
                      <p class="docText">What is instantiation?</p>
                      <p class="docText">什么是实例化？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa7q2"></a><b>Exercise 16.20:</b></td>

                    <td>
                      <p class="docText">What happens during template argument deduction?</p>
                      <p class="docText">在模板实参推断期间发生什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa7q3"></a><b>Exercise 16.21:</b></td>

                    <td>
                      <p class="docText">Name two type conversions allowed on function arguments involved in template argument deduction.</p>
                      <p class="docText">指出对模板实参推断中涉及的函数实参允许的类型转换。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa7q4"></a><b>Exercise 16.22:</b></td>

                    <td>
                      <p class="docText">Given the following templates</p>
                      <p class="docText">对于下面的模板</p>
                      <pre>
     template &lt;class Type&gt;
     Type calc (const Type* array, int size);
     template &lt;class Type&gt;
     Type fcn(Type p1,Type p2;
</pre><br>

                      <p class="docText">which ones of the following calls, if any, are errors? Why?</p>
                      <p class="docText">下面这些调用有错吗？如果有，哪些是错误的？为什么？</p>
                      <pre>
     double dobj;    float fobj;    char cobj;
     int ai[5] = { 511, 16, 8, 63, 34 };

     (a) calc(cobj, 'c');
     (b) calc(dobj, fobj);
     (c) fcn(ai, cobj);
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch16lev2sec11"></a>

        <h4 class="docSection2Title">16.2.2. Function-Template Explicit Arguments</h4>
        <h4 class="docSection2Title">16.2.2. 函数模板的显式实参</h4>

	<a name="idd1e126822"></a><a name="idd1e126827"></a><a name="idd1e126834"></a><a name="idd1e126839"></a>
        <p class="docText">In some situations, it is not possible to deduce the types of the template arguments. This problem arises most often when a function return type must be a type that differs from any used in the parameter list. In such situations, it is necessary to override the template argument deduction mechanism and explicitly specify the types or values to be used for the template parameters.</p>
                      <p class="docText">在某些情况下，不可能推断模板实参的类型。当函数的返回类型必须与形参表中所用的所有类型都不同时，最常出现这一问题。在这种情况下，有必要覆盖模板实参推断机制，并显式指定为模板形参所用的类型或值。</p>

<a name="ch16lev3sec16"></a>
        <h5 class="docSection3Title">Specifying an Explicit Template Argument</h5>
        <h5 class="docSection3Title">指定显式模板实参</h5>

        <p class="docText">Consider the following problem. We wish to define a function template called <tt>sum</tt> that takes arguments of two differnt types. We'd like the return type to be large enough to contain the sum of two values of any two types passed in any order. How can we do that? How should we specify <tt>sum</tt>'s return type?</p>
	<p class="docText">考虑下面的问题。我们希望定义名为 <tt>sum</tt>、接受两个不同类型实参的函数模板，希望返回类型足够大，可以包含按任意次序传递的任意两个类型的两个值的和，怎样才能做到？应如何指定 <tt>sum</tt> 的返回类型？</p>
        <pre>
     // <span class="docEmphasis">T</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">U</span> <span class="docEmphItalicAlt">as the returntype?</span>
     template &lt;class T, class U&gt; ??? sum(T, U);
</pre><br>

        <p class="docText">In this case, the answer is that neither parameter works all the time. Using either parameter is bound to fail at some point:</p>
        <p class="docText">在这个例子中，答案是没有一个形参在任何时候都可行，使用任一形参都一定会在某些时候失败：</p>
        <pre>
     // <span class="docEmphItalicAlt">neither</span> <span class="docEmphasis">T</span> <span class="docEmphItalicAlt">nor</span> <span class="docEmphasis">U</span> <span class="docEmphItalicAlt">works as return type</span>
     sum(3, 4L); // <span class="docEmphItalicAlt">second type is larger; want</span> <span class="docEmphasis">U</span> <span class="docEmphItalicAlt">sum(T, U)</span>
     sum(3L, 4); // <span class="docEmphItalicAlt">first type is larger; want</span> <span class="docEmphasis">T</span> <span class="docEmphasis">sum(T, U)</span>
</pre><br>

        <p class="docText">One approach to solving this problem would be to force callers of <tt>sum</tt> to cast (<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28" >Section 5.12.4</a>, p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28" >183</a>) the smaller type to the type we wish to use as the result:</p>
	<p class="docText">解决这一问题的一个办法，可能是强制 <tt>sum</tt> 的调用者将较小的类型强制转换（<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28" >第 5.12.4 节</a>）为希望作为结果使用的类型：</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: now either</span> <span class="docEmphasis">T</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">U</span> <span class="docEmphItalicAlt">works as return type</span>
     int i; short s;
     sum(static_cast&lt;int&gt;(s), i); // <span class="docEmphItalicAlt">ok: instantiates</span> <span class="docEmphasis">int sum(int, int)</span>
</pre><br>
        <a name="ch16lev3sec17"></a>

        <h5 class="docSection3Title">Using a Type Parameter for the Return Type</h5>
        <h5 class="docSection3Title">在返回类型中使用类型形参</h5>

        <p class="docText">An alternative way to specify the return type is to introduce a third template parameter that must be explicitly specified by our caller:</p>
        <p class="docText">指定返回类型的一种方式是引入第三个模板形参，它必须由调用者显式指定：</p>
        <pre>
     // <span class="docEmphasis">T1</span> <span class="docEmphItalicAlt">cannot be deduced: it doesn't appear in the function parameter list</span>
     template &lt;class T1, class T2, class T3&gt;
     T1 sum(T2, T3);
</pre><br>

        <p class="docText">This version adds a template parameter to specify the return type. There is only one catch: There is no argument whose type can be used to infer the type of <tt>T1</tt>. Instead, the caller must explicitly provide an argument for this parameter on each call to <tt>sum</tt>.</p>
	<p class="docText">这个版本增加了一个模板形参以指定返回类型。只有一个问题：没有实参的类型可用于推断 <tt>T1</tt> 的类型，相反，调用者必须在每次调用 <tt>sum</tt> 时为该形参显式提供实参。</p>

        <p class="docText">We supply an explicit template argument to a call in much the same way that we define an instance of a class template. Explicit template arguments are specified in a comma-separated list, bracketed by the less-than (<tt>&lt;</tt>) and greater-than (<tt>&gt;</tt>) tokens. The list of explicit template types appears after the function name and before the argument list:</p>
        <p class="docText">为调用提供显式模板实参与定义类模板的实例很类似，在以逗号分隔、用尖括号括住的列表中指定显式模板实参。显式模板类型的列表出现在函数名之后、实参表之前：</p>
        <pre>
     // <span class="docEmphItalicAlt">ok</span> <span class="docEmphasis">T1</span> <span class="docEmphItalicAlt">explicitly specified;</span> <span class="docEmphasis">T2</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">T3</span> <span class="docEmphItalicAlt">inferred from argument types</span>
     long val3 = sum&lt;long&gt;(i, lng); // <span class="docEmphItalicAlt">ok: calls</span> <span class="docEmphasis">long sum(int, long)</span>
</pre><br>

<a name="idd1e127035"></a><a name="idd1e127042"></a><a name="idd1e127049"></a><a name="idd1e127054"></a>
        <p class="docText">This call explicitly specifies the type for <tt>T1</tt>. The compiler deduces the types for <tt>T2</tt> and <tt>T3</tt> from the arguments passed in the call.</p>
	<p class="docText">这一调用显式指定 <tt>T1</tt> 的类型，编译器从调用中传递的实参推断 <tt>T2</tt> 和 <tt>T3</tt> 的类型。</p>

        <p class="docText">Explicit template argument(s) are matched to corresponding template parameter(s) from left to right; the first template argument is matched to the first template parameter, the second argument to the second parameter, and so on. An explicit template argument may be omitted only for the trailing (rightmost) parameters, assuming these can be deduced from the function parameters. If our <tt>sum</tt> function had been written as</p>
	<p class="docText">显式模板实参从左至右对应模板形参相匹配，第一个模板实参与第一个模板形参匹配，第二个实参与第二个形参匹配，以此类推。假如可以从函数形参推断，则结尾（最右边）形参的显式模板实参可以省略。如果这样编写 <tt>sum</tt> 函数：</p>
        <pre>
     // <span class="docEmphItalicAlt">poor design: Users must explicitly specify all three template parameters</span>
     template &lt;class T1, class T2, class T3&gt;
     T3 alternative_sum(T2, T1);
</pre><br>

        <p class="docText">then we would always have to specify arguments for all three parameters:</p>
	<p class="docText">则总是必须为所有三个形参指定实参：</p>
        <pre>
     // <span class="docEmphItalicAlt">error: can't infer initial template parameters</span>
     long val3 = alternative_sum&lt;long&gt;(i, lng);
     // <span class="docEmphItalicAlt">ok: All three parameters explicitly specified</span>
     long val2 = alternative_sum&lt;long, int, long&gt;(i, lng);
</pre><br>
        <a name="ch16lev3sec18"></a>

        <h5 class="docSection3Title">Explicit Arguments and Pointers to Function Templates</h5>
        <h5 class="docSection3Title">显式实参与函数模板的指针</h5>

        <p class="docText">Another example where explicit template arguments would be useful is the ambiguous program from page <a class="docLink" href="ch16lev1sec2.html#ch16note08">641</a>. We could disambiguate that case by using explicit template argument:</p>
        <p class="docText">可以使用显式模板实参的另一个例子是<a class="docLink" href="ch16lev1sec2.html#ch16note08">第 16.2.1 节</a>中有二义性程序，通过使用显式模板实参能够消除二义性：</p>
        <pre>
     template &lt;typename T&gt; int compare(const T&amp;, const T&amp;);
     // <span class="docEmphItalicAlt">overloaded versions of</span> <span class="docEmphasis">func;</span> <span class="docEmphItalicAlt">each take a different function pointer type</span>
     void func(int(*) (const string&amp;, const string&amp;));
     void func(int(*) (const int&amp;, const int&amp;));
     func(compare&lt;int&gt;); // <span class="docEmphItalicAlt">ok: explicitly specify which version of</span> <span class="docEmphasis">compare</span>
</pre><br>

        <p class="docText">As before, we want to pass an instantiation of <tt>compare</tt> in the call to the overloaded function named <tt>func</tt>. It is not possible to select which instantiation of <tt>compare</tt> to pass by looking at the parameter lists for the different versions of <tt>func</tt>. Two different instantiations of <tt>compare</tt> could satisfy the call. The explicit template argument indicates which instantiation of <tt>compare</tt> should be used and which <tt>func</tt> function is called.</p>
	<p class="docText">像前面一样，需要在调用中传递 <tt>compare</tt> 实例给名为 <tt>func</tt> 的重载函数。只查看不同版本 <tt>func</tt> 的形参表来选择传递 <tt>compare</tt> 的哪个实例是不可能的，两个不同的实例都可能满足该调用。显式模板形参需要指出应使用哪个 <tt>compare</tt> 实例以及调用哪个 <tt>func</tt> 函数。</p>
      </td>
    </tr>
  </table>

<a name="ch16sb09"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 16.2.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa8q1"></a><b>Exercise 16.23:</b></td>

                    <td>
			    <a name="idd1e127188"></a><a name="idd1e127193"></a><a name="idd1e127198"></a><a name="idd1e127205"></a><a name="idd1e127212"></a><a name="idd1e127215"></a>
                      <p class="docText">The library <tt>max</tt> function takes a single type parameter. Could you call <tt>max</tt> passing it an <tt>int</tt> and a <tt>double</tt>? If so, how? If not, why not?</p>
		      <p class="docText">标准库函数 <tt>max</tt> 接受单个类型形参，可以传递 <tt>int</tt> 和 <tt>double</tt> 对象调用 <tt>max</tt> 吗？如果可以，怎样做？如果不能，为什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa8q2"></a><b>Exercise 16.24:</b></td>

                    <td>
                      <p class="docText">In <a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10" >Section 16.2.1</a> (p. <a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10" >638</a>) we saw that the arguments to the version of <tt>compare</tt> that has a single template type parameter must match exactly. If we wanted to call the function with compatible types, such as <tt>int</tt> and <tt>short</tt>, we could use an explicit template argument to specify either <tt>int</tt> or <tt>short</tt> as the parameter type. Write a program that uses the version of <tt>compare</tt> that has one template parameter. Call <tt>compare</tt> using an explicit template argument that will let you pass arguments of type <tt>int</tt> and <tt>short</tt>.</p>
		      <p class="docText">在<a class="docLink" href="ch16lev1sec2.html#ch16lev2sec10" >第 16.2.1 节</a>我们看到，对于具有单个模板类型形参的 <tt>compare</tt> 版本，传给它的实参必须完全匹配，如果想要用兼容类型如 <tt>int</tt> 和 <tt>short</tt> 调用该函数，可以使用显式模板实参指定 <tt>int</tt> 或 <tt>short</tt> 作为形参类型。编写程序使用具有一个模板形参的 <tt>compare</tt> 版本，使用允许你传递 <tt>int</tt> 和 <tt>short</tt> 类型实参的显式模板实参调用 <tt>compare</tt>。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa8q3"></a><b>Exercise 16.25:</b></td>

                    <td>
                      <p class="docText">Use an explicit template argument to make it sensible to call <tt>compare</tt> passing two string literals.</p>
		      <p class="docText">使用显式模板实参，传递两个字符串字面值调用 <tt>compare</tt> 是切合实际的。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch16qa8q4"></a><b>Exercise 16.26:</b></td>

                    <td>
                      <p class="docText">Given the following template definition for <tt>sum</tt></p>
		      <p class="docText">对于下面的 <tt>sum</tt> 模板定义：</p>
                      <pre>
     template &lt;class T1, class T2, class T3&gt; T1 sum(T2, T3);
</pre><br>

                      <p class="docText">explain each of the following calls. Indicate which, if any, are errors. For each error, explain what is wrong.</p>
		      <p class="docText">解释下面的每个调用，是否有错？如果有，指出哪些是错误的，对每个错误，解释错在哪里。</p>
                      <pre>
     double dobj1, dobj2; float fobj1, fobj2; char cobj1, cobj2;

     (a) sum(dobj1, dobj2);
     (b) sum&lt;double, double, double&gt;(fobj1, fobj2);
     (c) sum&lt;int&gt;(cobj1, cobj2);
     (d) sum&lt;double, ,double&gt;(fobj2, dobj2);
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch16lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch16lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
