<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 12.6.  static Class Members</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch12lev1sec5.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch12lev1sec7.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch12lev1sec6"></a>

        <h3 class="docSection1Title">12.6. <tt>static</tt> Class Members</h3>
	<h3 class="docSection1Title">12.6. <tt>static</tt> 类成员</h3>

        <p class="docText">It is sometimes necessary for all the objects of a particular class type to access a global object. Perhaps a count is needed of how many objects of a particular class type have been created at any one point in the program, or the global object may be a pointer to an error-handling routine for the class, or it may be a pointer to the free-store memory for objects of this class type.</p>
        <p class="docText">对于特定类类型的全体对象而言，访问一个全局对象有时是必要的。也许，在程序的任意点需要统计已创建的特定类类型对象的数量；或者，全局对象可能是指向类的错误处理例程的一个指针；或者，它是指向类类型对象的内在自由存储区的一个指针。</p>

	<a name="ch12term3"></a><a name="ch12term23"></a>
        <p class="docText">However, making the object global violates encapsulation: The object exists to support the implementation of a particular class abstraction. If the object is global, general user code can modify the value. Rather than defining a generally accessible global object, a class can define a <b><a class="docLink" href="ch12lev1sec8.html#gloss12_03" >class</a></b> <b><a class="docLink" href="ch12lev1sec8.html#gloss12_23" ><span class="docEmphStrong"><tt>static</tt> member</span></a></b>.</p>
        <p class="docText">然而，全局对象会破坏封装：对象需要支持特定类抽象的实现。如果对象是全局的，一般的用户代码就可以修改这个值。类可以定义<b><a class="docLink" href="ch12lev1sec8.html#gloss12_03" >类</a></b> <b><a class="docLink" href="ch12lev1sec8.html#gloss12_23" ><span class="docEmphStrong"><tt>静态</tt>成员</span></a></b>，而不是定义一个可普遍访问的全局对象。</p>

        <p class="docText">Ordinary, non<tt>static</tt> data members exist in each object of the class type. Unlike ordinary data members, a <tt>static</tt> data member exists independently of any object of its class; each <tt>static</tt> data member is an object associated with the class, not with the objects of that class.</p>
	<p class="docText">通常，非 <tt>static</tt> 数据成员存在于类类型的每个对象中。不像普通的数据成员，<tt>static</tt> 数据成员独立于该类的任意对象而存在；每个 <tt>static</tt> 数据成员是与类关联的对象，并不与该类的对象相关联。</p>

        <p class="docText">Just as a class may define shared <tt>static</tt> data members, it may also define <tt>static</tt> member functions. A <tt>static</tt> member function has no <tt>this</tt> parameter. It may directly access the <tt>static</tt> members of its class but may not directly use the non<tt>static</tt> members.</p>
	<p class="docText">正如类可以定义共享的 <tt>static</tt> 数据成员一样，类也可以定义 <tt>static</tt> 成员函数。<tt>static</tt> 成员函数没有 <tt>this</tt> 形参，它可以直接访问所属类的 <tt>static</tt> 成员，但不能直接使用非 <tt>static</tt> 成员。</p>

	<a name="ch12lev2sec29"></a>
        <h4 class="docSection2Title">Advantages of Using Class <tt>static</tt> Members</h4>
	<h4 class="docSection2Title">使用类的 <tt>static</tt> 成员的优点</h4>

<a name="idd1e97196"></a><a name="idd1e97200"></a>
        <p class="docText">There are three advantages to using <tt>static</tt> members rather than globals:</p>
	<p class="docText">使用 <tt>static</tt> 成员而不是全局对象有三个优点。</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">The name of a <tt>static</tt> member is in the scope of the class, thereby avoiding name collisions with members of other classes or global objects.</p>
		<p class="docList"><tt>static</tt> 成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Encapsulation can be enforced. A <tt>static</tt> member can be a private member; a global object cannot.</p>
		<p class="docList">可以实施封装。<tt>static</tt> 成员可以是私有成员，而全局对象不可以。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">It is easy to see by reading the program that a <tt>static</tt> member is associated with a particular class. This visibility clarifies the programmer's intentions.</p>
		<p class="docList">通过阅读程序容易看出 <tt>static</tt> 成员是与特定类关联的。这种可见性可清晰地显示程序员的意图。</p>
              </div>
            </li>
          </ol>
        </div>

	<a name="ch12lev2sec30"></a>
        <h4 class="docSection2Title">Defining <tt>static</tt> Members</h4>
	<h4 class="docSection2Title">定义 <tt>static</tt> 成员</h4>

        <p class="docText">Amember ismade <tt>static</tt> by prefixing the member declaration with the keyword <tt>static</tt>. The <tt>static</tt> members obey the normal public/private access rules.</p>
	<p class="docText">在成员声明前加上关键字 <tt>static</tt> 将成员设为 <tt>static</tt>。<tt>static</tt> 成员遵循正常的公有／私有访问规则。</p>

        <p class="docText">As an example, consider a simple class intended to represent a bank account. Each account has a balance and an owner. Each account earns interest monthly, but the interest rate applied to each account is always the same. We could write this class as</p>
        <p class="docText">例如，考虑一个简单的表示银行账户的类。每个账户具有余额和拥有者，并且按月获得利息，但应用于每个账户的利率总是相同的。可以按下面的这样编写这个类</p>
        <pre>
     class Account {
     public:
         // <span class="docEmphItalicAlt">interface functions here</span>
         void applyint() { amount += amount * interestRate; }
         static double rate() { return interestRate; }
         static void rate(double); // <span class="docEmphItalicAlt">sets a new rate</span>
     private:
         std::string owner;
         double amount;
         static double interestRate;
         static double initRate();
     };
</pre><br>

        <p class="docText">Each object of this class has two data members: <tt>owner</tt> and <tt>amount</tt>. Objects do not have data members that correspond to <tt>static</tt> data members. Instead, there is a single <tt>interestRate</tt> object that is shared by all objects of type <tt>Account</tt>.</p>
	<p class="docText">这个类的每个对象具有两个数据成员：<tt>owner</tt> 和 <tt>amount</tt>。对象没有与 <tt>static</tt> 数据成员对应的数据成员，但是，存在一个单独的 <tt>interestRate</tt> 对象，由 <tt>Account</tt> 类型的全体对象共享。</p>

<a name="ch12lev2sec31"></a>
        <h4 class="docSection2Title">Using a Class <tt>static</tt> Member</h4>
	<h4 class="docSection2Title">使用类的 <tt>static</tt> 成员</h4>

        <p class="docText">A <tt>static</tt> member can be invoked directly from the class using the scope operator or indirectly through an object, reference, or pointer to an object of its class type.</p>
	<p class="docText">可以通过作用域操作符从类直接调用 <tt>static</tt> 成员，或者通过对象、引用或指向该类类型对象的指针间接调用。</p>
        <pre>
     Account ac1;
     Account *ac2 = &amp;ac1;
     // <span class="docEmphItalicAlt">equivalent ways to call the</span> <span class="docEmphasis">static</span> <span class="docEmphItalicAlt">member</span> <span class="docEmphasis">rate</span> <span class="docEmphItalicAlt">function</span>
     double rate;
     rate = ac1.rate();        // <span class="docEmphItalicAlt">through an</span> <span class="docEmphasis">Account</span> <span class="docEmphItalicAlt">object or reference</span>
     rate = ac2-&gt;rate();       // <span class="docEmphItalicAlt">through a pointer to an</span> <span class="docEmphasis">Account</span> <span class="docEmphItalicAlt">object</span>
     rate = Account::rate();   // <span class="docEmphItalicAlt">directly from the class using the scope operator</span>
</pre><br>

	<a name="idd1e97353"></a><a name="idd1e97361"></a><a name="idd1e97365"></a><a name="idd1e97373"></a><a name="idd1e97383"></a><a name="idd1e97393"></a><a name="idd1e97402"></a><a name="idd1e97409"></a><a name="idd1e97420"></a><a name="idd1e97429"></a>
        <p class="docText">As with other members, a class member function can refer to a class <tt>static</tt> member without the use of the scope operator:</p>
	<p class="docText">像使用其他成员一样，类成员函数可以不用作用域操作符来引用类的 <tt>static</tt> 成员：</p>
        <pre>
     class Account {
     public:
          // <span class="docEmphItalicAlt">interface functions here</span>
          void applyint() { amount += amount * interestRate; }
     };
</pre><br>

        <a name="ch12sb19"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.6</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa15q1"></a><b>Exercise 12.36:</b></td>

                    <td>
                      <p class="docText">What is a <tt>static</tt> class member? What are the advantages of <tt>static</tt> members? How do they differ from ordinary members?</p>
		      <p class="docText">什么是 <tt>static</tt> 类成员？<tt>static</tt> 成员的优点是什么？它们与普通有什么不同？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa15q2"></a><b>Exercise 12.37:</b></td>

                    <td>
                      <p class="docText">Write your own version of the <tt>Account</tt> class.</p>
		      <p class="docText">编写自己的 <tt>Account</tt> 类版本。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev2sec32"></a>

        <h4 class="docSection2Title">12.6.1. <tt>static</tt> Member Functions</h4>
        <h4 class="docSection2Title">12.6.1. <tt>static</tt> 成员函数</h4>

        <p class="docText">Our <tt>Account</tt> class has two <tt>static</tt> member functions named <tt>rate</tt>, one of which was defined inside the class. When we define a <tt>static</tt> member outside the class, we do not respecify the <tt>static</tt> keyword. The keyword appears only with the declaration inside the class body:</p>
	<p class="docText"><tt>Account</tt> 类有两个名为 <tt>rate</tt> 的 <tt>static</tt> 成员函数，其中一个定义在类的内部。当我们在类的外部定义 <tt>static</tt> 成员时，无须重复指定 <tt>static</tt> 保留字，该保留字只出现在类定义体内部的声明处：</p>
        <pre>
     void Account::rate(double newRate)
     {
         interestRate = newRate;
     }
</pre><br>

        <a name="ch12lev3sec29"></a>
        <h5 class="docSection3Title"><tt>static</tt> Functions Have No <tt>this</tt> Pointer</h5>
	<h5 class="docSection3Title"><tt>static</tt> 函数没有 <tt>this</tt> 指针</h5>

        <p class="docText">A <tt>static</tt> member is part of its class but not part of any object. Hence, a <tt>static</tt> member function does not have a <tt>this</tt> pointer. Referring to <tt>this</tt> either explicitly or implicitly by using a non<tt>static</tt> member is a compile-time error.</p>
	<p class="docText"><tt>static</tt> 成员是类的组成部分但不是任何对象的组成部分，因此，<tt>static</tt> 成员函数没有 <tt>this</tt> 指针。通过使用非 <tt>static</tt> 成员显式或隐式地引用 <tt>this</tt> 是一个编译时错误。</p>

        <p class="docText">Because a <tt>static</tt> member is not part of any object, <tt>static</tt> member functions may not be declared as <tt>const</tt>. After all, declaring a member function as <tt>const</tt> is a promise not to modify the object of which the function is a member. Finally, <tt>static</tt> member functions may also not be declared as virtual. We'll learn about virtual functions in <a class="docLink" href="ch15lev1sec2.html#ch15lev2sec6" >Section 15.2.4</a> (p. <a class="docLink" href="ch15lev1sec2.html#ch15lev2sec6" >566</a>).</p><a name="ch12lev2sec33"></a>
	<p class="docText">因为 <tt>static</tt> 成员不是任何对象的组成部分，所以 <tt>static</tt> 成员函数不能被声明为 <tt>const</tt>。毕竟，将成员函数声明为 <tt>const</tt> 就是承诺不会修改该函数所属的对象。最后，<tt>static</tt> 成员函数也不能被声明为虚函数。我们将在<a class="docLink" href="ch15lev1sec2.html#ch15lev2sec6" >第 15.2.4 节</a>学习虚函数。</p>

	<a name="ch12sb20"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.6.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa16q1"></a><b>Exercise 12.38:</b></td>

                    <td>
			    <a name="idd1e97615"></a><a name="idd1e97622"></a><a name="idd1e97631"></a><a name="idd1e97638"></a><a name="idd1e97645"></a>
      			    <p class="docText">Define a class named <tt>Foo</tt> that has a single data member of type <tt>int</tt>. Give the class a constructor that takes an <tt>int</tt> value and initializes the data member from that value. Give it a function that returns the value of its data member.</p>
			    <p class="docText">定义一个命名为 <tt>Foo</tt> 的类，具有单个 <tt>int</tt> 型数据成员。为该类定义一个构造函数，接受一个 <tt>int</tt> 值并用该值初始化数据成员。为该类定义一个函数，返回其数据成员的值。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa16q2"></a><b>Exercise 12.39:</b></td>

                    <td>
			    <p class="docText">Given the class <tt>Foo</tt> defined in the previous exercise, define another class <tt>Bar</tt> with two <tt>static</tt> data elements: one of type <tt>int</tt> and another of type <tt>Foo</tt>.</p>
			    <p class="docText">给定上题中定义的 <tt>Foo</tt> 类定义另一个 <tt>Bar</tt> 类。<tt>Bar</tt> 类具有两个 <tt>static</tt> 数据成员：一个为 <tt>int</tt> 型，另一个为 <tt>Foo</tt> 类型。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa16q3"></a><b>Exercise 12.40:</b></td>

                    <td>
			    <p class="docText">Using the classes from the previous two exercises, add a pair of <tt>static</tt> member functions to class <tt>Bar</tt>. The first <tt>static</tt>, named <tt>FooVal</tt>, should return the value of class <tt>Bar</tt>'s <tt>static</tt> member of type <tt>Foo</tt>. The second member, named <tt>callsFooVal</tt>, should keep a count of how many times <tt>xval</tt> is called.</p>
			    <p class="docText">使用上面两题中定义的类，给 <tt>Bar</tt> 类增加一对成员函数：第一个成品命名为 <tt>FooVal</tt>，返回 <tt>Bar</tt> 类的 <tt>Foo</tt> 类型 <tt>static</tt> 成员的值；第二个成员命名为 <tt>callsFooVal</tt>，保存 <tt>xval</tt> 被调用的次数。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

        <h4 class="docSection2Title">12.6.2. <tt>static</tt> Data Members</h4>
        <h4 class="docSection2Title">12.6.2. <tt>static</tt> 数据成员</h4>

        <p class="docText"><tt>static</tt> data members can be declared to be of any type. They can be <tt>const</tt>s, references, arrays, class types, and so forth.</p>
	<p class="docText"><tt>static</tt> 数据成员可以声明为任意类型，可以是常量、引用、数组、类类型，等等。</p>

        <p class="docText"><tt>static</tt> data members must be defined (exactly once) outside the class body. Unlike ordinary data members, <tt>static</tt> members are not initialized through the class constructor(s) and instead should be initialized when they are defined.</p>
	<p class="docText"><tt>static</tt> 数据成员必须在类定义体的外部定义（正好一次）。不像普通数据成员，<tt>static</tt> 成员不是通过类构造函数进行初始化，而是应该在定义时进行初始化。</p>

        <a name="ch12note32"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The best way to ensure that the object is defined exactly once is to put the definition of <tt>static</tt> data members in the same file that contains the definitions of the class noninline member functions.</p>
		<p class="docText">保证对象正好定义一次的最好办法，就是将 <tt>static</tt> 数据成员的定义放在包含类非内联成员函数定义的文件中。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText"><tt>static</tt> data members are defined in the same way that other class members and other variables are defined. The member is defined by naming its type followed by the fully qualified name of the member.</p>
	<p class="docText">定义 <tt>static</tt> 数据成员的方式与定义其他类成员和变量的方式相同：先指定类型名，接着是成员的完全限定名。</p>

        <p class="docText">We might define <tt>interestRate</tt> as follows:</p>
	<p class="docText">可以定义如下 <tt>interestRate</tt>：</p>
        <pre>
     // <span class="docEmphItalicAlt">define and initialize static class member</span>
     double Account::interestRate = initRate();
</pre><br>

        <p class="docText">This statement defines the <tt>static</tt> object named <tt>interestRate</tt> that is a member of class <tt>Account</tt> and has type <tt>double</tt>. Like other member definitions, the definition of a <tt>static</tt> member is in class scope once the member name is seen. As a result, we can use the <tt>static</tt> member function named <tt>initRate</tt> directly without qualification as the initializer for <tt>rate</tt>. Note that even though <tt>initRate</tt> is <tt>private</tt>, we can use this function to initialize <tt>interestRate</tt>. The definition of <tt>interestRate</tt>, like any other member definition, is in the scope of the class and hence has access to the <tt>private</tt> members of the class.</p>
	<p class="docText">这个语句定义名为 <tt>interestRate</tt> 的 <tt>static</tt> 对象，它是类 <tt>Account</tt> 的成员，为 <tt>double</tt> 型。像其他成员定义一样，一旦成员名出现，<tt>static</tt> 成员的就是在类作用域中。因此，我们可以没有限定地直接使用名为 <tt>initRate</tt> 的 <tt>static</tt> 成员函数，作为 <tt>interestRate</tt> 初始化式。注意，尽管 <tt>initRate</tt> 是私有的，我们仍然可以使用该函数来初始化 <tt>interestRate</tt>。像任意的其他成员定义一样，<tt>interestRate</tt> 的定义是在类的作用域中，因此可以访问该类的私有成员。</p>

	<a name="ch12note33"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">As with any class member, when we refer to a class <tt>static</tt> member outside the class body, we must specify the class in which the member is defined. The <tt>static</tt> keyword, however, is used <span class="docEmphasis">only</span> on the declaration inside the class body. Definitions are not labeled <tt>static</tt>.</p>
		<p class="docText">像使用任意的类成员一样，在类定义体外部引用类的 <tt>static</tt> 成员时，必须指定成员是在哪个类中定义的。然而，<tt>static</tt> 关键字只能用于类定义体内部的声明中，定义不能标示为 <tt>static</tt>。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <a name="ch12lev3sec30"></a>
        <h5 class="docSection3Title">Integral <tt>const static</tt> Members Are Special</h5>
	<h5 class="docSection3Title">特殊的整型 <tt>const static</tt> 成员</h5>

        <p class="docText">Ordinarily, class <tt>static</tt> members, like ordinary data members, cannot be initialized in the class body. Instead, <tt>static</tt> data members are normally initialized when they are defined.</p>
	<p class="docText">一般而言，类的 <tt>static</tt> 成员，像普通数据成员一样，不能在类的定义体中初始化。相反，<tt>static</tt> 数据成员通常在定义时才初始化。</p>

        <p class="docText">One exception to this rule is that a <tt>const static</tt> data member of integral type can be initialized within the class body as long as the initializer is a constant expression:</p>
	<p class="docText">这个规则的一个例外是，只要初始化式是一个常量表达式，整型 <tt>const static</tt> 数据成员就可以在类的定义体中进行初始化：</p>
        <pre>
     class Account {
     public:
         static double rate() { return interestRate; }
         static void rate(double);  // <span class="docEmphItalicAlt">sets a new rate</span>
     private:
         static const int period = 30; // <span class="docEmphItalicAlt">interest posted every 30 days</span>
         double daily_tbl[period]; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">period</span> <span class="docEmphItalicAlt">is constant expression</span>
     };
</pre><br>

	<a name="idd1e97872"></a><a name="idd1e97881"></a><a name="idd1e97890"></a><a name="idd1e97897"></a><a name="idd1e97904"></a>
        <p class="docText">A <tt>const static</tt> data member of integral type initialized with a constant value is a constant expression. As such, it can be used where a constant expression is required, such as to specify the dimension for the array member <tt>daily_tbl</tt>.</p>
	<p class="docText">用常量值初始化的整型 <tt>const static</tt> 数据成员是一个常量表达式。同样地，它可以用在任何需要常量表达式的地方，例如指定数组成员 <tt>daily_tbl</tt> 的维。</p>

	<a name="ch12note34"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">When a <tt>const static</tt> data member is initialized in the class body, the data member must still be defined outside the class definition.</p>
		<p class="docText"><tt>const static</tt> 数据成员在类的定义体中初始化时，该数据成员仍必须在类的定义体之外进行定义。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">When an initializer is provided inside the class, the definition of the member must not specify an initial value:</p>
        <p class="docText">在类内部提供初始化式时，成员的定义不必再指定初始值：</p>
        <pre>
     // <span class="docEmphItalicAlt">definition of static member with no initializer;</span>
     // <span class="docEmphItalicAlt">the initial value is specified inside the class definition</span>
     const int Account::period;
</pre><br>

        <a name="ch12lev3sec31"></a>
        <h5 class="docSection3Title"><tt>static</tt> Members Are Not Part of Class Objects</h5>
        <h5 class="docSection3Title"><tt>static</tt> 成员不是类对象的组成部分</h5>

        <p class="docText">Ordinary members are part of each object of the given class. <tt>static</tt> members exist independently of any object and are not part of objects of the class type. Because <tt>static</tt> data members are not part of any object, they can be used in ways that would be illegal for non<tt>static</tt> data members.</p>
	<p class="docText">普通成员都是给定类的每个对象的组成部分。<tt>static</tt> 成员独立于任何对象而存在，不是类类型对象的组成部分。因为 <tt>static</tt> 数据成员不是任何对象的组成部分，所以它们的使用方式对于非 <tt>static</tt> 数据成员而言是不合法的。</p>

        <p class="docText">As an example, the type of a <tt>static</tt> data member can be the class type of which it is a member. A non<tt>static</tt> data member is restricted to being declared as a pointer or a reference to an object of its class:</p>
	<p class="docText">例如，<tt>static</tt> 数据成员的类型可以是该成员所属的类类型。非 <tt>static</tt> 成员被限定声明为其自身类对象的指针或引用：</p>
        <pre>
     class Bar {
     public:
         // ...
     private:
         static Bar mem1; // <span class="docEmphItalicAlt">ok</span>
         Bar *mem2;       // <span class="docEmphItalicAlt">ok</span>
         Bar mem3;        // <span class="docEmphItalicAlt">error</span>
     };
</pre><br>

        <p class="docText">Similarly, a <tt>static</tt> data member can be used as a default argument:</p>
	<p class="docText">类似地，<tt>static</tt> 数据成员可用作默认实参：</p>
        <pre>
     class Screen {
     public:
         // <span class="docEmphItalicAlt">bkground refers to the static member</span>
         // <span class="docEmphItalicAlt">declared later in the class definition</span>
         Screen&amp; clear(char = bkground);
     private:
         static const char bkground = '#';
     };
</pre><br>

        <p class="docText">A non<tt>static</tt> data member may not be used as a default argument because its value cannot be used independently of the object of which it is a part. Using a non<tt>static</tt> data member as a default argument provides no object from which to obtain the member's value and so is an error.</p>
	<p class="docText">非 <tt>static</tt> 数据成员不能用作默认实参，因为它的值不能独立于所属的对象而使用。使用非 <tt>static</tt> 数据成员作默认实参，将无法提供对象以获取该成员的值，因而是错误的。</p>

<a name="ch12sb21"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.6.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa17q1"></a><b>Exercise 12.41:</b></td>

                    <td>
                      <p class="docText">Given the classes <tt>Foo</tt> and <tt>Bar</tt> that you wrote for the exercises to <a class="docLink" href="ch12lev1sec6.html#ch12lev2sec32">Section 12.6.1</a> (p. <a class="docLink" href="ch12lev1sec6.html#ch12lev2sec32">470</a>), initialize the <tt>static</tt> members of <tt>Foo</tt>. Initialize the <tt>int</tt> member to 20 and the <tt>Foo</tt> member to 0.</p>
                      <p class="docText">利用<a class="docLink" href="ch12lev1sec6.html#ch12lev2sec32">第 12.6.1 节</a>的习题中编写的类 <tt>Foo</tt> 和 <tt>Bar</tt>，初始化 <tt>Foo</tt> 的 <tt>static</tt> 成员。将 <tt>int</tt> 成员初始化为 20，并将 <tt>Foo</tt> 成员初始化为 0。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa17q2"></a><b>Exercise 12.42:</b></td>

                    <td>
                      <p class="docText">Which, if any, of the following <tt>static</tt> data member declarations and definitions are errors? Explain why.</p>
		      <p class="docText">下面的 <tt>static</tt> 数据成员声明和定义中哪些是错误的（如果有的话）？解释为什么。</p>
                      <pre>
     // <span class="docEmphItalicAlt">example.h</span>
     class Example {
     public:
         static double rate = 6.5;

         static const int vecSize = 20;
         static vector&lt;double&gt; vec(vecSize);
     };

     // <span class="docEmphItalicAlt">example.C</span>
     #include "example.h"
     double Example::rate;
     vector&lt;double&gt; Example::vec;
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch12lev1sec5.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch12lev1sec7.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
