<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 11.5.  Container-Specific Algorithms</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch11lev1sec4.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch11lev1sec6.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch11lev1sec5"></a>

        <h3 class="docSection1Title">11.5. Container-Specific Algorithms</h3>
        <h3 class="docSection1Title">11.5. 容器特有的算法</h3>

        <p class="docText">The iterators on <tt>list</tt> are bidirectional, not random access. Because the <tt>list</tt> container does not support random access, we cannot use the algorithms that require random-access iterators. These algorithms include the <tt>sort</tt>-related algorithms. There are other algorithms, defined generically, such as <tt>merge, remove, reverse</tt>, and <tt>unique</tt>, that can be used on <tt>lists</tt> but at a cost in performance. These algorithms can be implemented more efficiently if they can take advantage of how <tt>list</tt>s are implemented.</p>
	<p class="docText"><tt>list</tt> 容器上的迭代器是双向的，而不是随机访问类型。由于 <tt>list</tt> 容器不支持随机访问，因此，在此容器上不能使用需要随机访问迭代器的算法。这些算法包括 <tt>sort</tt> 及其相关的算法。还有一些其他的泛型算法，如 <tt>merge</tt>、<tt>remove</tt>、<tt>reverse</tt> 和 <tt>unique</tt>，虽然可以用在 <tt>list</tt> 上，但却付出了性能上的代价。如果这些算法利用 <tt>list</tt> 容器实现的特点，则可以更高效地执行。</p>
	

        <p class="docText">It is possible to write much faster algorithms if the internal structure of the <tt>list</tt> can be exploited. Rather than relying solely on generic operations, the library defines a more elaborate set of operations for <tt>list</tt> than are supported for the other sequential containers. These <tt>list</tt>-specific operations are described in <a class="docLink" href="ch11lev1sec5.html#ch11table04">Table 11.4</a> on the next page. Generic algorithms not listed in the table that take bidirectional or weaker iterators execute equally efficiently on <tt>list</tt>s as on other containers.</p>
                      <p class="docText">如果可以结合利用 <tt>list</tt> 容器的内部结构，则可能编写出更快的算法。与其他顺序容器所支持的操作相比，标准库为 <tt>list</tt> 容器定义了更精细的操作集合，使它不必只依赖于泛型操作。<a class="docLink" href="ch11lev1sec5.html#ch11table04">表 11.4</a> 列出了 <tt>list</tt> 容器特有的操作，其中不包括要求支持双向或更弱的迭代器类型的泛型算法，这类泛型算法无论是用在 <tt>list</tt> 容器上，还是用在其他容器上，都具有相同的效果。</p>


        <h5 class="docTableTitle">Table 11.4. <tt>list</tt>-Specific Operations</h5>
        <h5 class="docTableTitle">表 11.4. list 容器特有的操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top" colspan="2">
              <p class="docText"><tt>lst.merge(lst2)</tt>
              <tt>lst.merge(lst2, comp)</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top"> </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Merges elements from <tt>lst2</tt> onto <tt>lst</tt>. Both lists must be sorted. Elements are removed from <tt>lst2</tt>. After the <tt>merge, lst2</tt> is empty. Returns <tt>void</tt>. The first version uses the <tt>&lt;</tt> operator; the second version uses the specified comparison.</p>
	      <p class="docText">将 <tt>lst2</tt> 的元素合并到 <tt>lst</tt> 中。这两个 <tt>list</tt> 容器对象都必须排序。<tt>lst2</tt> 中的元素将被删除。合并后，<tt>lst2</tt> 为空。返回 <tt>void</tt> 类型。第一个版本使用 <tt>&lt;</tt> 操作符，而第二个版本则使用 <tt>comp</tt> 指定的比较运算</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top" colspan="2">
              <p class="docText"><tt>lst.remove(val)</tt>
              <tt>lst.remove_if(unaryPred)</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top"> </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes, by calling <tt>lst.erase</tt>, each element that equals a specified value or for which the specified predicate returns a nonzero value. Returns <tt>void</tt>.</p>
	      <p class="docText">调用 <tt>lst.erase</tt> 删除所有等于指定值或使指定的谓词函数返回非零值的元素。返回 <tt>void</tt> 类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>lst.reverse()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Reverses the order of the elements in <tt>lst</tt>.</p>
	      <p class="docText">反向排列 <tt>lst</tt> 中的元素</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>lst.sort</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Sorts the elements of the <tt>lst</tt>.</p>
	      <p class="docText">对 <tt>lst</tt> 中的元素排序</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top" colspan="2">
              <p class="docText"><tt>lst.splice(iter, lst2)</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top" colspan="2">
              <p class="docText"><tt>lst.splice(iter, lst2, iter2)</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top" colspan="2">
              <p class="docText"><tt>lst.splice(iter, beg, end)</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top"> </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Moves element(s) from <tt>lst2</tt> into <tt>lst</tt> just before the element (in <tt>lst</tt>) referred to by the iterator <tt>iter</tt>. Removes element(s) that are moved from <tt>lst2</tt>. The first version moves all elements from <tt>lst2</tt> into <tt>lst</tt>; after the <tt>splice, lst2</tt> is empty. <tt>lst</tt> and <tt>lst2</tt> may not be the same <tt>list</tt>. The second version moves only the element referred to by <tt>iter2</tt>, which must refer to an element in <tt>lst2</tt>. In this case, <tt>lst2</tt> and <tt>lst</tt> could be the same <tt>list</tt>. That is, <tt>splice</tt> can be used to move an element within a single <tt>list</tt>. The third version moves the elements in the range denoted by the iterators <tt>beg</tt> and <tt>end</tt>. As usual, <tt>beg</tt> and <tt>end</tt> must refer to a valid range. The iterators can refer to a range in any <tt>list</tt>, including <tt>lst</tt>. If the iterators refer to <tt>lst</tt>, the operation is undefined if <tt>iter</tt> refers to an element in the range.</p>
	      <p class="docText">将 <tt>lst2</tt> 的元素移到 <tt>lst</tt> 中迭代器 <tt>iter</tt> 指向的元素前面。在 <tt>lst2</tt> 中删除移出的元素。第一个版本将 <tt>lst2</tt> 的所有元素移到 <tt>lst</tt> 中；合并后，<tt>lst2</tt> 为空。<tt>lst</tt> 和 <tt>lst2</tt> 不能是同一个 <tt>list</tt> 对象。第二个版本只移动 <tt>iter2</tt> 所指向的元素，这个元素必须是 <tt>lst2</tt> 中的元素。在这种情况中，<tt>lst</tt> 和 <tt>lst2</tt> 可以是同一个 <tt>list</tt> 对象。也就是说，可在一个 <tt>list</tt> 对象中使用 <tt>splice</tt> 运算移动一个元素。第三个版本移动迭代器 <tt>beg</tt> 和 <tt>end</tt> 标记的范围内的元素。<tt>beg</tt> 和 <tt>end</tt> 照例必须指定一个有效的范围。这两个迭代器可标记任意 <tt>list</tt> 对象内的范围，包括 <tt>lst</tt>。当它们指定 <tt>lst</tt> 的一段范围时，如果 <tt>iter</tt> 也指向这个范围的一个元素，则该运算未定义。</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top" colspan="2">
              <p class="docText"><tt>lst.unique()</tt>
              <tt>lst.unique(binaryPred)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top"> </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top"> </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Deletes, by calling <tt>erase</tt>, consecutive copies of the same value. The first version uses <tt>==</tt> to determine if elements are equal; the second uses the specified predicate.</p>
	      <p class="docText">调用 <tt>erase</tt> 删除同一个值的团结副本。第一个版本使用 <tt>==</tt> 操作符判断元素是否相等；第二个版本则使用指定的谓词函数实现判断</p>
            </td>
          </tr>
  </table><br />
        <a name="ch11note11"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The <tt>list</tt> member versions should be used in preference to the generic algorithms when applied to a <tt>list</tt> object.</p>
		<p class="docText">对于 <tt>list</tt> 对象，应该优先使用 <tt>list</tt> 容器特有的成员版本，而不是泛型算法。</p>
              </td>
            </tr>
          </table>
        </div>

        <p class="docText">Most of the <tt>list</tt>-specific algorithms are similarbut not identicalto their counterparts that we have already seen in their generic forms:</p>
	<p class="docText">大多数 <tt>list</tt> 容器特有的算法类似于其泛型形式中已经见过的相应的算法，但并不相同：</p>

        <pre>
     l.remove(val);     // <span class="docEmphItalicAlt">removes all instances of</span> <span class="docEmphasis">val</span> <span class="docEmphItalicAlt">from</span> <span class="docEmphasis">1</span>
     l.remove_if(pred); // <span class="docEmphItalicAlt">removes all instances for which</span> <span class="docEmphasis">pred</span> <span class="docEmphItalicAlt">is true from</span> <span class="docEmphasis">1</span>
     l.reverse();       // <span class="docEmphItalicAlt">reverses the order of elements in</span> <span class="docEmphasis">1</span>
     l.sort();          // <span class="docEmphItalicAlt">use element type</span> <span class="docEmphasis">&lt;</span> <span class="docEmphItalicAlt">operator to compare elements</span>
     l.sort(comp);      // <span class="docEmphItalicAlt">use</span> <span class="docEmphasis">comp</span> <span class="docEmphItalicAlt">to compare elements</span>
     l.unique();        // <span class="docEmphItalicAlt">uses element == to remove adjacent duplicates</span>
     l.unique(comp);    // <span class="docEmphItalicAlt">uses comp to remove duplicate adjacent copies</span>
</pre>

        <p class="docText">There are two crucially important differences between the <tt>list</tt>-specific operations and their generic counterparts. One difference is that the <tt>list</tt> versions of <tt>remove</tt> and <tt>unique</tt> change the underlying container; the indicated elements are actually removed. For example, second and subsequent duplicate elements are removed from the list by <tt>list::unique</tt>.</p>
	<p class="docText"><tt>list</tt> 容器特有的算法与其泛型算法版本之间有两个至关重要的差别。其中一个差别是 <tt>remove</tt> 和 <tt>unique</tt> 的 <tt>list</tt> 版本修改了其关联的基础容器：真正删除了指定的元素。例如，<tt>list::unique</tt> 将 <tt>list</tt> 中第二个和后续重复的元素删除出该容器。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
		      <p class="docText">Unlike the corresponding generic algorithms, the <tt>list</tt>-specific operations do add and remove elements.</p>
		      <p class="docText">与对应的泛型算法不同，<tt>list</tt> 容器特有的操作能添加和删除元素。</p>
              </td>
            </tr>
          </table>
        </div>

	<a name="idd1e90237"></a><a name="idd1e90244"></a><a name="idd1e90251"></a><a name="idd1e90258"></a><a name="idd1e90265"></a><a name="idd1e90272"></a><a name="idd1e90279"></a><a name="idd1e90286"></a><a name="idd1e90293"></a><a name="idd1e90301"></a><a name="idd1e90308"></a><a name="idd1e90315"></a>
        <p class="docText">The other difference is that the <tt>list</tt> operations, <tt>merge</tt> and <tt>splice</tt>, are destructive on their arguments. When we use the generic version of <tt>merge</tt>, the merged sequence is written to a destination iterator, and the two input sequences are left unchanged. In the case of the <tt>merge</tt> function that is a member of <tt>list</tt>, the argument <tt>list</tt> is destroyedelements are moved from the argument and removed as they are merged into the <tt>list</tt> object on which <tt>merge</tt> was called.</p>
	<p class="docText">另一个差别是 <tt>list</tt> 容器提供的 <tt>merge</tt> 和 <tt>splice</tt> 运算会破坏它们的实参。使用 <tt>merge</tt> 的泛型算法版本时，合并的序列将写入目标迭代器指向的对象，而它的两个输入序列保持不变。但是，使用 <tt>list</tt> 容器的 <tt>merge</tt> 成员函数时，则会破坏它的实参 <tt>list</tt> 对象——当实参对象的元素合并到调用 <tt>merge</tt> 函数的 <tt>list</tt> 对象时，实参对象的元素被移出并删除。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 11.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch11qa10q1"></a><b>Exercise 11.29:</b></td>

                    <td>
                      <p class="docText">Reimplement the program that eliminated duplicate words that we wrote in <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >Section 11.2.3</a> (p. <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >400</a>) to use a <tt>list</tt> instead of a <tt>vector</tt>.</p>
		      <p class="docText">用 <tt>list</tt> 容器取代 <tt>vector</tt> 重新实现liminated duplicate words that we wrote in <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >第 11.2.3 节</a>编写的排除重复单词的程序。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch11lev1sec4.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch11lev1sec6.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
