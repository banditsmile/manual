<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 18.4.  Nested Classes</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch18lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch18lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch18lev1sec4"></a>

        <h3 class="docSection1Title">18.4. Nested Classes</h3>
        <h3 class="docSection1Title">18.4. 嵌套类</h3>

<a name="ch18term11"></a><a name="ch18term12"></a>
        <p class="docText">A class can be defined within another class. Such a class is a <b><a class="docLink" href="ch18lev1sec9.html#gloss18_11" >nested class</a></b>, also referred to as a <b><a class="docLink" href="ch18lev1sec9.html#gloss18_12" >nested type</a></b>. Nested classes are most often used to define implementation classes, such as the <tt>QueueItem</tt> class from <a class="docLink" href="ch16.html#ch16" >Chapter 16</a>.</p>
        <p class="docText">可以在另一个类内部定义一个类，这样的类是<b><a class="docLink" href="ch18lev1sec9.html#gloss18_11" >嵌套类</a></b>，也称为<b><a class="docLink" href="ch18lev1sec9.html#gloss18_12" >嵌套类型</a></b>。嵌套类最常用于定义执行类，如<a class="docLink" href="ch16.html#ch16" >第十六章</a>的 <tt>QueueItem</tt> 类。</p>

        <p class="docText">Nested classes are independent classes and are largely unrelated to their enclosing class. Objects of the enclosing and nested classes are, therefore, independent from one another. An object of the nested type does not have members defined by the enclosing class. Similarly, an object of the enclosing class does not have members defined by the nested class.</p>
        <p class="docText">嵌套类是独立的类，基本上与它们的外围类不相关，因此，外围类和嵌套类的对象是互相独立的。嵌套类型的对象不具备外围类所定义的成员，同样，外围类的成员也不具备嵌套类所定义的成员。</p>

        <p class="docText">The name of a nested class is visible in its enclosing class scope but not in other class scopes or in the scope in which the enclosing class is defined. The name of a nested class will not collide with the same name declared in another scope.</p>
        <p class="docText">嵌套类的名字在其外围类的作用域中可见，但在其他类作用域或定义外围类的作用域中不可见。嵌套类的名字将不会与另一作用域中声明的名字冲突。</p>

        <p class="docText">A nested class can have the same kinds of members as a nonnested class. Just like any other class, a nested class controls access to its own members using access labels. Members may be declared <tt>public, private</tt>, or <tt>protected</tt>. The enclosing class has no special access to the members of a nested class and the nested class has no special access to members of its enclosing class.</p>
	<p class="docText">嵌套类可以具有与非嵌套类相同种类的成员。像任何其他类一样，嵌套类使用访问标号控制对自己成员的访问。成员可以声明为 <tt>public</tt>、<tt>private</tt> 或 <tt>protected</tt>。外围类对嵌套类的成员没有特殊访问权，并且嵌套类对其外围类的成员也没有特殊访问权。</p>

        <p class="docText">A nested class defines a type member in its enclosing class. As with any other member, the enclosing class determines access to this type. A nested class defined in the <tt>public</tt> part of the enclosing class defines a type that may be used anywhere. A nested class defined in the <tt>protected</tt> section defines a type that is accessible only by the enclosing class, its friends, or its derived classes. A <tt>private</tt> nested class defines a type that is accessible only to the members of the enclosing class or its friends.</p>
        <p class="docText">嵌套类定义了其外围类中的一个类型成员。像任何其他成员一样，外围类决定对这个类型的访问。在外围类的 <tt>public</tt> 部分定义的嵌套类定义了可在任何地方使用的类型，在外围类的 <tt>protected</tt> 部分定义的嵌套类定义了只能由外围类、友元或派生类访问的类型，在外围类的 <tt>private</tt> 部分定义的嵌套类定义了只能被外围类或其友元访问的类型。</p>

<a name="ch18lev2sec14"></a>
        <h4 class="docSection2Title">18.4.1. A Nested-Class Implementation</h4>
        <h4 class="docSection2Title">18.4.1. 嵌套类的实现</h4>

        <p class="docText">The <tt>Queue</tt> class that we implemented in <a class="docLink" href="ch16.html#ch16" >Chapter 16</a> defined a companion implementation class named <tt>QueueItem</tt>. That class was a private classit had only <tt>private</tt> membersbut it was defined at the global scope. General user code cannot use objects of class <tt>QueueItem</tt>: All its members, including constructors, are <tt>private</tt>. However, the name <tt>QueueItem</tt> is visible globally. We cannot define our own type or other entity named <tt>QueueItem</tt>.</p>
        <p class="docText">在<a class="docLink" href="ch16.html#ch16" >第十六章</a>中实现的 <tt>Queue</tt> 类定义了一个名为 <tt>QueueItem</tt> 的伙伴执行类，<tt>QueueItem</tt> 类是私有类（它只有 <tt>private</tt> 成员）但它是在全局作用域中定义的。普通用户代码不能使用 <tt>QueueItem</tt> 类的对象：它的所有成员，包括构造函数，均为 <tt>private</tt>。但是，名字 <tt>QueueItem</tt> 是全局可见的，不能定义名为 <tt>QueueItem</tt> 的自有类型或其他实体。</p>

<a name="idd1e151183"></a><a name="idd1e151188"></a><a name="idd1e151193"></a><a name="idd1e151198"></a>
        <p class="docText">A better design would be to make the <tt>QueueItem</tt> class a <tt>private</tt> member of class <tt>Queue</tt>. That way, the <tt>Queue</tt> class (and its friends) could use <tt>QueueItem</tt>, but the <tt>QueueItem</tt> class type would not be visible to general user code. Once the class itself is <tt>private</tt>, we can make its members <tt>public</tt>only <tt>Queue</tt> or the friends of <tt>Queue</tt> can access the <tt>QueueItem</tt> type, so there is no need to protect its members from general program access. We make the members <tt>public</tt> by defining <tt>QueueItem</tt> using the keyword <tt>struct</tt>.</p>
	<p class="docText">一个更好的设计可能是，将 <tt>QueueItem</tt> 类设为 <tt>Queue</tt> 类的 <tt>private</tt> 成员，那样，<tt>Queue</tt> 类（及其友元）可以使用 <tt>QueueItem</tt>，但 <tt>QueueItem</tt> 类类型对普通用户代码不可见。一旦 <tt>QueueItem</tt> 类本身为 <tt>private</tt>，我们就可以使其成员为 <tt>public</tt> 成员——只有 <tt>Queue</tt> 或 <tt>Queue</tt> 的友元可以访问 <tt>QueueItem</tt> 类型，所以不必防止一般程序访问 <tt>QueueItem</tt> 成员。通过用保留字 <tt>struct</tt> 定义 <tt>QueueItem</tt> 使成员为 <tt>public</tt> 成员。</p>

        <p class="docText">Our new design looks like:</p>
        <p class="docText">新的设计如下：</p>
        <pre>
     template &lt;class Type&gt; class Queue {
         // <span class="docEmphItalicAlt">interface functions to</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">are unchanged</span>
     private:
         // <span class="docEmphItalicAlt">public members are ok:</span> <span class="docEmphasis">QueueItem</span> <span class="docEmphItalicAlt">is a private member of</span> <span class="docEmphasis">Queue</span>
         // <span class="docEmphItalicAlt">only</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">and its friends may access the members of</span> <span class="docEmphasis">QueueItem</span>
         struct QueueItem {
             QueueItem(const Type &amp;);
             Type item;            // <span class="docEmphItalicAlt">value stored in this element</span>
             QueueItem *next;      // <span class="docEmphItalicAlt">pointer to next element in the</span> <span class="docEmphasis">Queue</span>
         };
         QueueItem *head;      // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
         QueueItem *tail;      // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
     };
</pre><br>

        <p class="docText">Because the class is a <tt>private</tt> member, only members and friends of the <tt>Queue</tt> class can use the <tt>QueueItem</tt> type. Having made the class a <tt>private</tt> member, we can make the <tt>QueueItem</tt> members <tt>public</tt>. Doing so lets us eliminate the friend declarations in <tt>QueueItem</tt>.</p>
	<p class="docText">因为 <tt>QueueItem</tt> 类是 <tt>private</tt> 成员，所以只有 <tt>Queue</tt> 类的成员和友元可以使用 <tt>QueueItem</tt> 类型。使 <tt>QueueItem</tt> 类成为 <tt>private</tt> 成员之后，就可以使 <tt>QueueItem</tt> 成员 <tt>public</tt>，这样做使我们能够删去 <tt>QueueItem</tt> 中的友元声明。</p>

<a name="ch18lev3sec31"></a>
        <h5 class="docSection3Title">Classes Nested Inside a Class Template Are Templates</h5>
        <h5 class="docSection3Title">嵌套在类模板内部的类是模板</h5>

        <p class="docText">Because <tt>Queue</tt> is a template, its members are implicitly templates as well. In particular, the nested class <tt>QueueItem</tt> is implicitly a class template. Again, like any other member in <tt>Queue</tt>, the template parameter for <tt>QueueItem</tt> is the same as the template parameter of its enclosing class: class <tt>Queue</tt>.</p>
        <p class="docText">因为 <tt>Queue</tt> 类是一个模板，它的成员也隐含地是模板。具体而言，嵌套类 <tt>QueueItem</tt> 隐含地是一个类模板。像 <tt>Queue</tt> 类中任何其他成员一样，<tt>QueueItem</tt> 的模板形参与其外围类（<tt>Queue</tt> 类）的模板形参相同。</p>

        <p class="docText">Each instantiation of <tt>Queue</tt> generates its own <tt>QueueItem</tt> class with the appropriate template argument for <tt>Type</tt>. The mapping between an instantiation for the QueueItem class template and an instantiation of the enclosing Queue class template is one to one.</p>
        <p class="docText"><tt>Queue</tt> 类的每次实例化用对应于 <tt>Type</tt> 的适当模板实参产生自己的 <tt>QueueItem</tt> 类。<tt>QueueItem</tt> 类模板的实例化与外围 <tt>Queue</tt> 类模板的实例化之间的映射是一对一的。</p>

<a name="ch18lev3sec32"></a>
        <h5 class="docSection3Title">Defining the Members of a Nested Class</h5>
        <h5 class="docSection3Title">定义嵌套类的成员</h5>

        <p class="docText">In this version of <tt>QueueItem</tt>, we chose not to define the <tt>QueueItem</tt> constructor inside the class. Instead, we'll define it separately. The only trick is where to define it and how to name it.</p>
        <p class="docText">这个 <tt>QueueItem</tt> 类版本中，我们选择不在类内部定义 <tt>QueueItem</tt> 构造函数，相反，我们单独定义它。唯一复杂的是在哪里定义以及怎样命名。</p>

<a name="ch18note22"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A nested-class member defined outside its own class must be defined in the same scope as the scope in which the enclosing class is defined. A member of a nested class defined outside its own class may not be defined inside the enclosing class itself. A member of a nested class is not a member of the enclosing class.</p>
                <p class="docText">在其类外部定义的嵌套类成员，必须定义在定义外围类的同一作用域中。在其类外部定义的嵌套类的成员，不能定义在外围类内部，嵌套类的成员不是外围类的成员。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

<a name="idd1e151377"></a><a name="idd1e151382"></a>
        <p class="docText">The constructor for <tt>QueueItem</tt> is not a member of class <tt>Queue</tt>. Therefore, it cannot be defined elsewhere in the body of class <tt>Queue</tt>. It must be defined at the same scope as the <tt>Queue</tt> class but outside that class. To define a member outside the nested-class body, we must remember that its name is not visible outside the class. To define the constructor, we must indicate that <tt>QueueItem</tt> is a nested class within the scope of class <tt>Queue</tt>. We do so by qualifying the class name <tt>QueueItem</tt> with the name of its enclosing class <tt>Queue</tt>:</p>
        <p class="docText"><tt>QueueItem</tt> 类的构造函数不是 <tt>Queue</tt> 类的成员，因此，不能将它定义在 <tt>Queue</tt> 类定义体中的任何地方，它必须与 <tt>Queue</tt> 类在同一作用域但在 <tt>Queue</tt> 类的外部定义。为了将成员定义在嵌套类定义体外部，必须记住，成员的名字在类外部是不可见的。要定义这个构造函数，必须指出，<tt>QueueItem</tt> 是 <tt>Queue</tt> 类作用域中的嵌套类，通过用外围 <tt>Queue</tt> 类的名字限定类名 <tt>QueueItem</tt> 来做到这一点：</p>
        <pre>
     // <span class="docEmphItalicAlt">defines the</span> <span class="docEmphasis">QueueItem</span> <span class="docEmphItalicAlt">constructor</span>
     // <span class="docEmphItalicAlt">for class</span> <span class="docEmphasis">QueueItem</span> <span class="docEmphItalicAlt">nested inside class</span> <span class="docEmphasis">Queue&lt;Type&gt;</span>
     template &lt;class Type&gt;
     Queue&lt;Type&gt;::QueueItem::QueueItem(const Type &amp;t):
                              item(t), next(0) { }
</pre><br>

        <p class="docText">Of course, both <tt>Queue</tt> and <tt>QueueItem</tt> are class templates. The constructor, therefore, is also a template.</p>
        <p class="docText">当然，<tt>Queue</tt> 和 <tt>QueueItem</tt> 都是类模板，因此，这个构造函数也是模板。</p>

        <p class="docText">This code defines a function template, parameterized by a single type parameter named <tt>Type</tt>. Reading the name of the function from right to left, this function is the constructor for class <tt>QueueItem</tt>, which is a nested in the scope of class <tt>Queue&lt;Type&gt;</tt>.</p>
        <p class="docText">这段代码定义了一个函数模板，以名为 <tt>Type</tt> 的单个类型形参化为形参。从右至左读函数的名字，这个函数是 <tt>QueueItem</tt> 类的构造函数，它嵌套在 <tt>Queue&lt;Type&gt;</tt> 类的作用域中。</p>

<a name="ch18lev3sec33"></a>
        <h5 class="docSection3Title">Defining the Nested Class Outside the Enclosing Class</h5>
        <h5 class="docSection3Title">在外围类外部定义嵌套类</h5>

        <p class="docText">Nested classes often support implementation details for the enclosing class. We might want to prevent users of the enclosing class from seeing the code that implements the nested class.</p>
        <p class="docText">嵌套类通常支持外围类的实现细节。我们可能希望防止外围类的用户看见嵌套类的实现代码。</p>

        <p class="docText">For example, we might want to put the definition of class <tt>QueueItem</tt> in its own file, which we would include in those files containing the implementation of the <tt>Queue</tt> class and its members. Just as we can define the members of a nested class outside the class body, we can define the entire class outside the body of the enclosing class:</p>
        <p class="docText">例如，我们可能希望将 <tt>QueueItem</tt> 类的定义放在它自己的文件中，我们可以在 <tt>Queue</tt> 类及其成员的实现文件中包含这个文件。正如可以在类定义体外部定义嵌套类的成员一样，我们也可以在外围类定义体的外部定义整个嵌套类：</p>
        <pre>
     template &lt;class Type&gt; class Queue {
         // <span class="docEmphItalicAlt">interface functions to</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">are unchanged</span>
     private:
         struct QueueItem; // <span class="docEmphItalicAlt">forward declaration of nested type</span> <span class="docEmphasis">QueueItem</span>
         QueueItem *head;  // <span class="docEmphItalicAlt">pointer to first element in</span> <span class="docEmphasis">Queue</span>
         QueueItem *tail;  // <span class="docEmphItalicAlt">pointer to last element in</span> <span class="docEmphasis">Queue</span>
     };
     template &lt;class Type&gt;
     struct Queue&lt;Type&gt;::QueueItem {
         QueueItem(const Type &amp;t): item(t), next(0) { }
         Type item;        // <span class="docEmphItalicAlt">value stored in this element</span>
         QueueItem *next; // <span class="docEmphItalicAlt">pointer to next element in the</span> <span class="docEmphasis">Queue</span>
     };
</pre><br>

        <p class="docText">To define the class body outside its enclosing class, we must qualify the name of the nested class by the name of its enclosing class. Note that we must still <span class="docEmphasis">declare</span> <tt>QueueItem</tt> in the body of class <tt>Queue</tt>.</p>
        <p class="docText">为了在外围类的外部定义类体，必须用外围类的名字限定嵌套类的名字。注意，我们仍然必须在 <tt>Queue</tt> 类的定义体<span class="docEmphasis">声明</span> <tt>QueueItem</tt> 类。</p>

        <p class="docText">A nested class also can be declared and then later defined in the body of the enclosing class. As with other forward declarations, a forward declaration of a nested class allows for nested classes that have members that refer to one another.</p>
        <p class="docText">也可以在外围类的定义体中声明然后定义嵌套类。像其他前向声明一样，嵌套类的前向声明使嵌套类能够具有相互引用的成员。</p>

<a name="ch18note23"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
<a name="idd1e151530"></a><a name="idd1e151535"></a>
                <p class="docText"> Until the actual definition of a nested class that is defined outside the class body is seen, that class is an incomplete type (<a class="docLink" href="ch12lev1sec1.html#ch12lev2sec4" >Section 12.1.4</a>, p. <a class="docLink" href="ch12lev1sec1.html#ch12lev2sec4" >437</a>). All the normal retrictions on using an incomplete type apply.</p>
                <p class="docText">在看到在类定义体外部定义的嵌套类的实际定义之前，该类是不完全类型（<a class="docLink" href="ch12lev1sec1.html#ch12lev2sec4" >第 12.1.4 节</a>），应用所有使用不完全类型的常规限制。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch18lev3sec34"></a>

        <h5 class="docSection3Title">Nested-Class Static Member Definitions</h5>
        <h5 class="docSection3Title">嵌套类静态成员定义</h5>

        <p class="docText">If <tt>QueueItem</tt> had declared a static member, its definition would also need to be defined in the outer scope. Assuming <tt>QueueItem</tt> had a static member, its definition would look somthing like:</p>
        <p class="docText">如果 <tt>QueueItem</tt> 类声明了一个静态成员，它的定义也需要放在外层作用域中。假定 <tt>QueueItem</tt> 类有一个静态成员，它的定义看起来可能像下面这样：</p>
        <pre>
     // <span class="docEmphItalicAlt">defines an</span> <span class="docEmphasis">int</span> <span class="docEmphItalicAlt">static member of</span> <span class="docEmphasis">QueueItem,</span>
     // <span class="docEmphItalicAlt">which is a type nested inside</span> <span class="docEmphasis">Queue&lt;Type&gt;</span>
     template &lt;class Type&gt;
     int Queue&lt;Type&gt;::QueueItem::static_mem = 1024;
</pre><br>
        <a name="ch18lev3sec35"></a>

        <h5 class="docSection3Title">Using Members of the Enclosing Class</h5>
        <h5 class="docSection3Title">使用外围类的成员</h5>

<a name="ch18note24"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">There is no connection between the objects of an enclosing scope and objects of its nested type(s).</p>
                <p class="docText">外围作用域的对象与其嵌套类型的对象之间没有联系。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Nonstatic functions in the nested class have an implicit <tt>this</tt> pointer that points to an object of the nested type. A nested-type object contains only the members of the nested type. The <tt>this</tt> pointer may not be used to fetch members of the enclosing class. Similarly, the nonstatic member functions in the enclosing class have a <tt>this</tt> pointer that points to an object of the enclosing type. That object has only the members defined in the enclosing class.</p>
        <p class="docText">嵌套类中的非静态函数具有隐含的 <tt>this</tt> 指针，指向嵌套类型的对象。嵌套类型对象只包含嵌套类型的成员，不能使用 <tt>this</tt> 指针获取外围类的成员。同样，外围类中的非静态成员函数也具有 <tt>this</tt> 指针，它指向外围类型的对象，该对象只具有外围类中定义的成员。</p>

        <p class="docText">Any use of a nonstatic data or function member of the enclosing class requires that it be done through a pointer, reference, or object of the enclosing class. The <tt>pop</tt> function in class <tt>Queue</tt> may not use <tt>item</tt> or <tt>next</tt> directly:</p>
        <p class="docText">外围类的非静态数据或函数成员的任何使用都要求通过外围类的指针、引用或对象进行。<tt>Queue</tt> 类中的 <tt>pop</tt> 函数不能直接使用 <tt>item</tt> 或 <tt>next</tt>：</p>
        <pre>
     template &lt;class Type&gt;
     void Queue&lt;Type&gt;::pop()
     {
          // <span class="docEmphItalicAlt">pop is unchecked: popping off an empty</span> <span class="docEmphasis">Queue</span> <span class="docEmphItalicAlt">is undefined</span>
          QueueItem* p = head;        // <span class="docEmphItalicAlt">keep pointer to head so can delete it</span>
          head = head-&gt;next;          // <span class="docEmphItalicAlt">head now points to next element</span>
          delete p;                   // <span class="docEmphItalicAlt">delete old head element</span>
     }
</pre><br>

        <p class="docText">Objects of type <tt>Queue</tt> do not have members named <tt>item</tt> or <tt>next</tt>. Function members of <tt>Queue</tt> can use the <tt>head</tt> and <tt>tail</tt> members, which are pointers to <tt>QueueItem</tt> objects, to fetch those <tt>QueueItem</tt> members.</p>
        <p class="docText"><tt>Queue</tt> 类型的对象没有名为 <tt>item</tt> 或 <tt>next</tt> 成员。<tt>Queue</tt> 类的函数成员可以使用 <tt>head</tt> 和 <tt>tail</tt> 成员（它们是指向 <tt>QueueItem</tt> 对象的指针）来获取那些 <tt>QueueItem</tt> 成员。</p>

<a name="ch18lev3sec36"></a>
        <h5 class="docSection3Title">Using Static or Other Type Members</h5>
        <h5 class="docSection3Title">使用静态成员或其他类型的成员</h5>

        <p class="docText">A nested class may refer to the static members, type names, and enumerators (<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >Section 2.7</a>, p. <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >62</a>) of the enclosing class directly. Of course, referring to a type name or static member outside the scope of the enclosing class requires the scope-resolution operator.</p>
        <p class="docText">嵌套类可以直接引用外围类的静态成员、类型名和枚举成员（<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >第 2.7 节</a>），当然，引用外围类作用域之外的类型名或静态成员，需要作用域确定操作符。</p>

<a name="ch18lev3sec37"></a>
        <h5 class="docSection3Title">Instantiation for Nested Templates</h5>
        <h5 class="docSection3Title">嵌套模板的实例化</h5>

<a name="idd1e151710"></a><a name="idd1e151715"></a><a name="idd1e151720"></a><a name="idd1e151725"></a>
        <p class="docText">A nested class of a class template is not instantiated automatically when the enclosing class template is instantiated. Like any member function, the nested class is instantiated only if it is itself used in a context that requires a complete class type. For example, a definition such as</p>
        <p class="docText">实例化外围类模板的时候，不会自动实例化类模板的嵌套类。像任何成员函数一样，只有当在需要完整类类型的情况下使用嵌套类本身的时候，才会实例化嵌套类。例如，像</p>
        <pre>
     Queue&lt;int&gt; qi; // <span class="docEmphItalicAlt">instantiates</span> <span class="docEmphasis">Queue&lt;int&gt;</span> <span class="docEmphItalicAlt">but not</span> <span class="docEmphasis">QueueItem&lt;int&gt;</span>
</pre><br>

        <p class="docText">instantiates the template <tt>Queue</tt> with type <tt>int</tt> but does not yet instantiate the type <tt>QueueItem&lt;int&gt;</tt>. The <tt>Queue</tt> members <tt>head</tt> and <tt>tail</tt> are pointers to <tt>QueueItem&lt;int&gt;</tt>. There is no need to instantiate <tt>QueueItem&lt;int&gt;</tt> to define pointers to that class.</p>
        <p class="docText">这样的定义，用 <tt>int</tt> 类型实例化了 <tt>Queue</tt> 模板，但没有实例化 <tt>QueueItem&lt;int&gt;</tt> 类型。成员 <tt>head</tt> 和 <tt>tail</tt> 是指向 <tt>QueueItem&lt;int&gt;</tt> 指针，这里不需要实例化 <tt>QueueItem&lt;int&gt;</tt> 来定义那个类的指针。</p>

        <p class="docText">Making <tt>QueueItem</tt> a nested class of the class template <tt>Queue</tt> does not change the instantiation of <tt>QueueItem</tt>. The <tt>QueueItem&lt;int&gt;</tt> class will be instantiated only when <tt>QueueItem</tt> is usedin this case, only when <tt>head</tt> or <tt>tail</tt> is dereferenced from a member function of class <tt>Queue&lt;int&gt;</tt>.</p>
	<p class="docText">使 <tt>QueueItem</tt> 类成为类模板 <tt>Queue</tt> 的嵌套类并不改变 <tt>QueueItem</tt> 的实例化。只有在使用 <tt>QueueItem&lt;int&gt;</tt> 的时候——本例中，只有当 <tt>Queue&lt;int&gt;</tt> 类的成员函数中对 <tt>head</tt> 和 <tt>tail</tt> 解引用的蚨，才实例化 <tt>Queue&lt;int&gt;</tt> 类。</p>

<a name="ch18lev2sec15"></a>
        <h4 class="docSection2Title">18.4.2. Name Lookup in Nested Class Scope</h4>
        <h4 class="docSection2Title">18.4.2. 嵌套类作用域中的名字查找</h4>

        <p class="docText">Name lookup (<a class="docLink" href="ch12lev1sec3.html#ch12lev2sec15" >Section 12.3.1</a>, p. <a class="docLink" href="ch12lev1sec3.html#ch12lev2sec15" >447</a>) for names used in a nested class proceeds in the same manner as for a normal class, the only difference being that now there may be one or more enclosing class scopes to search.</p>
        <p class="docText">对嵌套类中所用名字的名字查找（<a class="docLink" href="ch12lev1sec3.html#ch12lev2sec15" >第 12.3.1 节</a>）在普通类的名字查找之前进行，现在唯一的区别是可能要查找一个或多个外围类作用域。</p>

<a name="ch18note25"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">When processing the declarations of the class members, any name used must appear prior to its use. When processing definitions, the entire nested and enclosing class(es) are in scope.</p>
                <p class="docText">当处理类成员声明的时候，所用的任意名字必须在使用之前出现。当处理定义的时候，整个嵌套类和外围类均在作用域中。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">As an example of name lookup in a nested class, consider the following class declarations:</p>
        <p class="docText">作为嵌套类中名字查找的例子，考虑下面的类声明：</p>
        <pre>
     class Outer {
     public:
         struct Inner {
             // <span class="docEmphItalicAlt">ok: reference to incomplete class</span>
             void process(const Outer&amp;);
             Inner2 val; // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">Outer::Inner2</span> <span class="docEmphItalicAlt">not in scope</span>
         };
         class Inner2 {
         public:
             // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">Inner2::val</span> <span class="docEmphItalicAlt">used in definition</span>
             Inner2(int i = 0): val(i) { }
             // <span class="docEmphItalicAlt">ok: definition of</span> <span class="docEmphasis">process</span> <span class="docEmphItalicAlt">compiled after enclosing class is complete</span>
             void process(const Outer &amp;out) { out.handle(); }
         private:
             int val;
         };
         void handle() const; // <span class="docEmphItalicAlt">member of class</span> <span class="docEmphasis">Outer</span>
     };
</pre><br>

<a name="idd1e151876"></a>
        <p class="docText">The compiler first processes the declarations of the members of classes <tt>Outer, Outer::Inner</tt>, and <tt>Outer::Inner2</tt>.</p>
	<p class="docText">编译器首先处理 <tt>Outer</tt> 类成员的声明 <tt>Outer::Inner</tt> 和 <tt>Outer::Inner2</tt>。</p>

        <p class="docText">The use of the name <tt>Outer</tt> as a parameter to <tt>Inner::process</tt> is bound to the enclosing class. That class is still incomplete when the declaration of <tt>process</tt> is seen, but the parameter is a reference, so this usage is okay.</p>
        <p class="docText">将名字 <tt>Outer</tt> 作为 <tt>Inner::process</tt> 形参的使用被绑定到外围类，在看到 <tt>process</tt> 的声明时，那个类仍是不完整的，但形参是一个引用，所以这个使用是正确的。</p>

        <p class="docText">The declaration of the data member <tt>Inner::val</tt> is an error. The type <tt>Inner2</tt> has not yet been seen.</p>
        <p class="docText">数据成员 <tt>Inner::val</tt> 的声明是错误的，还没有看到 <tt>Inner2</tt> 类型。</p>

        <p class="docText">The declarations in <tt>Inner2</tt> pose no problemsmostly they just use the built-in type <tt>int</tt>. The only exception is the <tt>process</tt> member function. Its parameter resolves to the incomplete type <tt>Outer</tt>. Because the parameter is a reference, the fact that <tt>Outer</tt> is an incomplete type doesn't matter.</p>
        <p class="docText"><tt>Inner2</tt> 中的声明看来没有问题——它们大多只使用内置类型 <tt>int</tt>。唯一的例外是成员函数 <tt>process</tt>，它的形参确定为不完全类型 <tt>Outer</tt>。因为其形参是一个引用，所以 <tt>Outer</tt> 为不完全类型是无关紧要的。</p>

        <p class="docText">The definitions of the constructor and <tt>process</tt> member are not processed by the compiler until the remaining declarations in the enclosing class have been seen. Completing the declarations of class <tt>Outer</tt> puts the declaration of the function <tt>handle</tt> in scope.</p>
        <p class="docText">直到看到了外围类中的其余声明之后，编译器才处理构造函数和 <tt>process</tt> 成员的定义。对 <tt>Outer</tt> 类声明的完成将函数 <tt>handle</tt> 的声明放在作用域中。</p>

        <p class="docText">When the compiler looks up the names used in the definitions in class <tt>Inner2</tt>, all the names in class <tt>Inner2</tt> and class <tt>Outer</tt> are in scope. The use of <tt>val</tt>, which appears before the declaration of <tt>val</tt>, is okay: That reference is bound to the data member in class <tt>Inner2</tt>. Similarly, the use of <tt>handle</tt> from class <tt>Outer</tt> in the body of the <tt>Inner2::process</tt> member is okay. The entire <tt>Outer</tt> class is in scope when the members of class <tt>Inner2</tt> are compiled.</p>
        <p class="docText">当编译器查找 <tt>Inner2</tt> 类中的定义所用的名字时，<tt>Inner2</tt> 类和 <tt>Outer</tt> 类中的所有名字都在作用域中。<tt>val</tt> 的使用（出现在 <tt>val</tt> 的声明之前）是正确的：将该引用绑定到 <tt>Inner2</tt> 类中的数据成员。同样，<tt>Inner2::process</tt> 成员函数体中对 <tt>Outer</tt> 类的 <tt>handle</tt> 的使用也正确，当编译 <tt>Inner2</tt> 类的成员的时候，整个 <tt>Outer</tt> 类在作用域中。</p>

<a name="ch18lev3sec38"></a>
        <h5 class="docSection3Title">Using the Scope Operator to Control Name Lookup</h5>
        <h5 class="docSection3Title">使用作用域操作符控制名字查找</h5>

        <p class="docText">The global version of <tt>handle</tt> can be accessed using the scope operator:</p>
        <p class="docText">可以使用作用域操作符访问 <tt>handle</tt> 的全局版本。</p>
        <pre>
     class Inner2 {
     public:
         // ...
         // <span class="docEmphItalicAlt">ok: programmer explicitly specifies which</span> <span class="docEmphasis">handle</span> <span class="docEmphItalicAlt">to call</span>
         void process(const Outer &amp;out) { ::handle(out); }
     };
</pre><br>
        <a name="ch18sb12"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 18.4.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
<a name="ch18qa11q1"></a>
                    <td align="right" class="docText" width="50"><b>Exercise 18.32:</b></td>

                    <td>
                      <p class="docText">Reimplement the <tt>Queue</tt> and <tt>QueueItem</tt> classes from <a class="docLink" href="ch16.html#ch16" >Chapter 16</a> making <tt>QueueItem</tt> a nested class inside <tt>Queue</tt>.</p>
                      <p class="docText">重新实现<a class="docLink" href="ch16.html#ch16" >第十六章</a>的 <tt>Queue</tt> 和 <tt>QueueItem</tt> 类，使 <tt>QueueItem</tt> 成为 <tt>Queue</tt> 内部的嵌套类。</p>
                    </td>
                  </tr>

                  <tr valign="top">
<a name="ch18qa11q2"></a>
                    <td align="right" class="docText" width="50"><b>Exercise 18.33:</b></td>

                    <td>
                      <p class="docText">Explain the pros and cons of the original and the nested-class version of the <tt>Queue</tt> design.</p>
                      <p class="docText">解释 <tt>Queue</tt> 设计的原来版本和嵌套类版本的优缺点。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch18lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch18lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
