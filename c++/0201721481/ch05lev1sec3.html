<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 5.3.  The Bitwise Operators</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch05lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch05lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch05lev1sec3"></a>

        <h3 class="docSection1Title" id="432172-882">5.3. The Bitwise Operators</h3>
        <h3 class="docSection1Title" id="432172-882">5.3. 位操作符</h3>

        <p class="docText">The bitwise operators take operands of integral type. These operators treat their integral operands as a collection of bits, providing operations to test and set individual bits. In addition, these operators may be applied to <tt>bitset</tt> (<a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5" >Section 3.5</a>, p. <a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5" >101</a>) operands with the behavior as described here for integral operands.</p>
	<p class="docText">位操作符（表5-3）使用整型的操作数。位操作符将其整型操作数视为二进制位的集合，为每一位提供检验和设置的功能。另外，这类操作符还可用于 <tt>bitset</tt> 类型（<a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5" >第 3.5 节</a>）的操作数，该类型具有这里所描述的整型操作数的行为。</p>

	<a name="ch05table03"></a>
        <h5 class="docTableTitle">Table 5.3. Bitwise Operators</h5>
        <h5 class="docTableTitle">表 5.3. 位操作符</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="groups" cellpadding="5">
          <colgroup>
            <col width="175">
            <col width="175">
            <col width="150">
          </colgroup>

          <thead>
            <tr>
              <th class="bottomBorder thead" scope="col" align="center" valign="top">
		<a name="idd1e32574"></a><a name="idd1e32579"></a><a name="idd1e32584"></a><a name="idd1e32589"></a><a name="idd1e32598"></a><a name="idd1e32604"></a><a name="idd1e32609"></a><a name="idd1e32615"></a><a name="idd1e32620"></a><a name="idd1e32628"></a><a name="idd1e32634"></a><a name="idd1e32640"></a><a name="idd1e32648"></a><a name="idd1e32654"></a>
                <p class="docText">Operator</p>
                <p class="docText">操作符</p>
              </th>

              <th class="bottomBorder thead" scope="col" align="left" valign="top">
                <p class="docText">Function</p>
                <p class="docText">功能</p>
              </th>

              <th class="bottomBorder thead" scope="col" align="center" valign="top">
                <p class="docText">Use</p>
                <p class="docText">用法</p>
              </th>
            </tr>
          </thead>

          <tr>
            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>~</tt></p>
            </td>

            <td class="bottomBorder" align="left" valign="top">
              <p class="docText">bitwise NOT（位求反）</p>
            </td>

            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>~expr</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="center" valign="top">
              <p class="docText"><tt>&lt;&lt;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">left shift（左移）</p>
            </td>

            <td class="docTableCell" align="center" valign="top">
              <p class="docText"><tt>expr1 &lt;&lt; expr2</tt></p>
            </td>
          </tr>

          <tr>
            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>&gt;&gt;</tt></p>
            </td>

            <td class="bottomBorder" align="left" valign="top">
              <p class="docText">right shift（右移）</p>
            </td>

            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>expr1 &gt;&gt; expr2</tt></p>
            </td>
          </tr>

          <tr>
            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>&amp;</tt></p>
            </td>

            <td class="bottomBorder" align="left" valign="top">
              <p class="docText">bitwise AND（位与）</p>
            </td>

            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>expr1 &amp; expr2</tt></p>
            </td>
          </tr>

          <tr>
            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>^</tt></p>
            </td>

            <td class="bottomBorder" align="left" valign="top">
              <p class="docText">bitwise XOR（位异或）</p>
            </td>

            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>expr1 ^ expr2</tt></p>
            </td>
          </tr>

          <tr>
            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>|</tt></p>
            </td>

            <td class="bottomBorder" align="left" valign="top">
              <p class="docText">bitwise OR（位或）</p>
            </td>

            <td class="bottomBorder" align="center" valign="top">
              <p class="docText"><tt>expr1 | expr2</tt></p>
            </td>
          </tr>
        </table><br>

        <p class="docText">The type of an integer manipulated by the bitwise operators can be either signed or unsigned. If the value is negative, then the way that the "sign bit" is handled in a number of the bitwise operations is machine-dependent. It is, therefore, likely to differ across implementations; programs that work under one implementation may fail under another.</p>
        <p class="docText">位操作符操纵的整数的类型可以是有符号的也可以是无符号的。如果操作数为负数，则位操作符如何处理其操作数的符号位依赖于机器。于是它们的应用可能不同：在一个应用环境中实现的程序可能无法用于另一应用环境。</p>

	<a name="ch05note04"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Because there are no guarantees for how the sign bit is handled, we strongly recommend using an <tt>unsigned</tt> type when using an integral value with the bitwise operators.</p>
                <p class="docText">对于位操作符，由于系统不能确保如何处理其操作数的符号位，所以强烈建议使用unsigned整型操作数。</p>
              </td>
            </tr>
          </table>
        </div>

	<a name="ch05term24"></a>
        <p class="docText">In the following examples we assume that an <tt>unsigned char</tt> has 8 bits. The bitwise NOT operator (<b><a class="docLink" href="ch05lev1sec14.html#gloss05_24" ><span class="docEmphStrong"><tt>~</tt></span></a></b>) is similar in behavior to the <tt>bitset flip</tt> (<a class="docLink" href="ch03lev1sec5.html#ch03lev2sec16" >Section 3.5.2</a>, p. <a class="docLink" href="ch03lev1sec5.html#ch03lev2sec16" >105</a>) operation: It generates a new value with the bits of its operand inverted. Each 1 bit is set to 0; each 0 bit is set to 1:</p>
	<p class="docText">在下面的例子中，假设 <tt>unsigned char</tt> 类型有 8 位。位求反操作符（<b><a class="docLink" href="ch05lev1sec14.html#gloss05_24" ><span class="docEmphStrong"><tt>~</tt></span></a></b>）的功能类似于 <tt>bitset</tt> 的 <tt>flip</tt> 操作（<a class="docLink" href="ch03lev1sec5.html#ch03lev2sec16" >第 3.5.2 节</a>）：将操作数的每一个二进制位取反：将 1 设置为 0、0 设置为 1，生成一个新值：</p>

        <table cellspacing="0" frame="void" rules="none" cellpadding="5">
          <colgroup>
            <col width="375">
            <col width="125">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>unsigned char bits = 0227;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/155fig01.gif;400478" ></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bits = ~bits;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/155fig02.gif;400478" ></p>
            </td>
          </tr>
        </table><br>

	<a name="ch05term32"></a>
        <p class="docText">The <tt>&lt;&lt;, &gt;&gt;</tt> operators are the bitwise shift operators. These operators use their right-hand operand to indicate by how many bits to shift. They yield a value that is a copy of the left-hand operand with the bits shifted as directed by the right-hand operand. The bits are shifted left (<b><a class="docLink" href="ch05lev1sec14.html#gloss05_32" ><span class="docEmphStrong"><tt>&lt;&lt;</tt></span></a></b>) or right (<b><a name="ch05term33"></a><a class="docLink" href="ch05lev1sec14.html#gloss05_33" ><span class="docEmphStrong"><tt>&gt;&gt;</tt></span></a></b>), discarding the bits that are shifted off the end.</p>
	<p class="docText"><tt>&lt;&lt;</tt> 和 <tt>&gt;&gt;</tt> 操作符提供移位操作，其右操作数标志要移动的位数。这两种操作符将其左操作数的各个位向左（<tt>&lt;&lt;</tt>）或向右（<tt>&gt;&gt;</tt>）移动若干个位（移动的位数由其右操作数指定），从而产生新的值，并丢弃移出去的位。</p>

        <table cellspacing="0" frame="void" rules="none" cellpadding="5">
          <colgroup>
            <col width="375">
            <col width="125">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>unsigned char bits = 1;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/155fig03.gif;400478" ></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bits &lt;&lt; 1;</tt> // <span class="docEmphasis">left shift</span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/155fig04.gif;400478" ></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bits &lt;&lt; 2;</tt> // <span class="docEmphasis">left shift</span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/155fig05.gif;400478" ></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>bits &gt;&gt; 3;</tt> // <span class="docEmphasis">right shift</span></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="21" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/155fig06.gif;400478" ></p>
            </td>
          </tr>
        </table><br>

	<a name="idd1e32955"></a><a name="idd1e32960"></a><a name="idd1e32965"></a><a name="idd1e32970"></a><a name="idd1e32976"></a><a name="idd1e32982"></a><a name="idd1e32988"></a><a name="idd1e32995"></a><a name="idd1e33001"></a><a name="idd1e33009"></a><a name="idd1e33017"></a>
        <p class="docText">The left shift operator (<tt>&lt;&lt;</tt>) inserts 0-valued bits in from the right. The right shift operator (<tt>&gt;&gt;</tt>) inserts 0-valued bits in from the left if the operand is unsigned. If the operand is signed, it can either insert copies of the sign bit or insert 0-valued bits; which one it uses is implementation defined. The right-hand operand must not be negative and must be a value that is strictly less than the number of bits in the left-hand operand. Otherwise, the effect of the operation is undefined.</p>
        <p class="docText">左移操作符（<tt>&lt;&lt;</tt>）在右边插入 0 以补充空位。对于右移操作符（<tt>&gt;&gt;</tt>），如果其操作数是无符号数，则从左边开始插入 0；如果操作数是有符号数，则插入符号位的副本或者 0 值，如何选择需依据具体的实现而定。移位操作的右操作数不可以是负数，而且必须是严格小于左操作数位数的值。否则，操作的效果未定义。</p>

        <p class="docText">The bitwise AND operator (<tt>&amp;</tt>) takes two integral operands. For each bit position, the result is 1 if both operands contain 1; otherwise, the result is 0.</p>
        <p class="docText">位与操作（<tt>&amp;</tt>）需要两个整型操作数，在每个位的位置，如果两个操作数对应的位都为 1，则操作结果中该位为 1，否则为 0。</p>

	<a name="ch05note05"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
		<a name="ch05term29"></a>
                <p class="docText">It is a common error to confuse the bitwise AND operator (<tt>&amp;</tt>) with the logical AND operator (<tt>&amp;&amp;</tt>) (<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2" >Section 5.2</a>, p. <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2" >152</a>). Similarly, it is common to confuse the bitwise OR operator (<b><a class="docLink" href="ch05lev1sec14.html#gloss05_29" ><span class="docEmphStrong"><tt>|</tt></span></a></b>) and the logical OR operator(<tt>||</tt>).</p>
                <p class="docText">常犯的错误是把位与操作（<tt>&amp;</tt>）和逻辑与操作（<tt>&amp;&amp;</tt>）（<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2" >第 5.2节</a>）混淆了。同样地，位或操作（<b><a class="docLink" href="ch05lev1sec14.html#gloss05_29" ><span class="docEmphStrong"><tt>|</tt></span></a></b>）和逻辑或操作（<tt>||</tt>）也很容易搞混。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Here we illustrate the result of bitwise AND of two <tt>unsigned char</tt> values, each of which is initialized by an octal literal:</p>
	<p class="docText">下面我们用图解的方法说明两个 <tt>unsigned char</tt>类型值的位与操作，这两个操作数均用八进制字面常量初始化：</p>

        <table cellspacing="0" frame="void" rules="none" cellpadding="5">
          <colgroup>
            <col width="375">
            <col width="125">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>unsigned char b1 = 0145;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="21" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/156fig01.gif;400478" ></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>unsigned char b2 = 0257;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/156fig02.gif;400478" ></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>unsigned char result = b1 &amp; b2;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="127" height="19" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/156fig03.gif;400478" ></p>
            </td>
          </tr>
        </table><br>

	<a name="ch05term28"></a>
        <p class="docText">The bitwise XOR (exclusive or) operator (<b><a class="docLink" href="ch05lev1sec14.html#gloss05_28" ><span class="docEmphStrong"><tt>^</tt></span></a></b>) also takes two integral operands. For each bit position, the result is 1 if either but not both operands contain 1; otherwise, the result is 0.</p>
        <p class="docText">位异或（互斥或，exclusive or）操作符（<b><a class="docLink" href="ch05lev1sec14.html#gloss05_28" ><span class="docEmphStrong"><tt>^</tt></span></a></b>）也需要两个整型操作数。在每个位的位置，如果两个操作数对应的位只有一个（不是两个）为 1，则操作结果中该位为 1，否则为 0。</p>

        <table cellspacing="0" frame="void" rules="none" cellpadding="5">
          <colgroup>
            <col width="375">
            <col width="125">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>result = b1 ^ b2;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="126" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/156fig04.gif;400478" ></p>
            </td>
          </tr>
        </table><br>

        <p class="docText">The bitwise OR (inclusive or) operator (<tt>|</tt>) takes two integral operands. For each bit position, the result is 1 if either or both operands contain 1; otherwise, the result is 0.</p>
        <p class="docText">位或（包含或，inclusive or）操作符（<tt>|</tt>）需要两个整型操作数。在每个位的位置，如果两个操作数对应的位有一个或者两个都为 1，则操作结果中该位为 1，否则为 0。</p>

        <table cellspacing="0" frame="void" rules="none" cellpadding="5">
          <colgroup>
            <col width="375">
            <col width="125">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>result = b1 | b2;</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><img border="0" alt="" id="195131139046" width="126" height="20" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/156fig05.gif;400478" ></p>
            </td>
          </tr>
        </table>
        <a name="ch05lev2sec5"></a>

        <h4 class="docSection2Title">5.3.1. Using <tt>bitset</tt> Objects or Integral Values</h4>
	<h4 class="docSection2Title">5.3.1. <tt>bitset</tt> 对象或整型值的使用</h4>

        <p class="docText">We said that the <tt>bitset</tt> class was easier to use than the lower-level bitwise operations on integral values. Let's look at a simple example and show how we might solve a problem using either a <tt>bitset</tt> or the bitwise operators. Assume that a teacher has 30 students in a class. Each week the class is given a pass/fail quiz. We'll track the results of each quiz using one bit per student to represent the pass or fail grade on a given test. We might represent each quiz in either a <tt>bitset</tt> or as an integral value:</p>
	<p class="docText"><tt>bitset</tt> 类比整型值上的低级位操作更容易使用。观察下面简单的例子，了解如何使用 <tt>bitset</tt> 类型或者位操作来解决问题。假设某老师带了一个班，班中有 30 个学生，每个星期在班上做一次测验，只有及格和不及格两种测验成绩，对每个学生用一个二进制位来记录一次测试及格或不及格，以方便我们跟踪每次测验的结果，这样就可以用一个bitset对象或整数值来代表一次测验：</p>
        <pre>
     bitset&lt;30&gt; bitset_quiz1;     //  <span class="docEmphasis">bitset</span> <span class="docEmphItalicAlt">solution</span>
     unsigned long int_quiz1 = 0; // <span class="docEmphItalicAlt">simulated collection of bits</span>
</pre>

        <p class="docText">In the <tt>bitset</tt> case we can define <tt>bitset_quiz1</tt> to be exactly the size we need. By default each of the bits is set to zero. In the case where we use a built-in type to hold our quiz results, we define <tt>int_quiz1</tt> as an <tt>unsigned long</tt>, meaning <a name="idd1e33241"></a><a name="idd1e33246"></a>that it will have at least 32 bits on any machine. Finally, we explicitly initialize <tt>int_quiz1</tt> to ensure that the bits start out with well-defined values.</p>
	<p class="docText">使用 <tt>bitset</tt> 类型时，可根据所需要的大小明确地定义 <tt>bitset_quiz1</tt>，它的每一个位都默认设置为 0 值。如果使用内置类型来存放测验成绩，则应将变量 <tt>int_quiz1</tt> 定义为 <tt>unsigned long</tt> 类型，这种数据类型在所有机器上都至少拥有32位的长度。最后，显式地初始化 <tt>int_quiz1</tt> 以保证该变量在使用前具有明确定义的值。</p>

        <p class="docText">The teacher must be able to set and test individual bits. For example, assuming that the student represented by position 27 passed, we'd like to be able to set that bit appropriately:</p>
        <p class="docText">老师可以设置和检查每个位。例如，假设第27位所表示的学生及格了，则可以使用下面的语句适当地设置对应的位：</p>
        <pre>
     bitset_quiz1.set(27);   //  <span class="docEmphItalicAlt">indicate student number 27 passed</span>
     int_quiz1 |= 1UL&lt;&lt;27;   //  <span class="docEmphItalicAlt">indicate student number 27 passed</span>
</pre>

        <p class="docText">In the <tt>bitset</tt> case we do so directly by passing the bit we want turned on to <tt>set</tt>. The <tt>unsigned long</tt> case will take a bit more explanation. The way we'll set a specific bit is to OR our quiz data with another integer that has only one bitthe one we wantturned on. That is, we need an <tt>unsigned long</tt> where bit 27 is a one and all the other bits are zero. We can obtain such a value by using the left shift operator and the integer constant 1:</p>
	<p class="docText">如果使用 <tt>bitset</tt> 实现，可直接传递要置位的位给 <tt>set</tt> 函数。而用 <tt>unsigned long</tt> 实现时，实现的方法则比较复杂。设置指定位的方法是：将测验数据与一个整数做位或操作，该整数只有一个指定的位为 1。也就是说，我们需要一个只有第 27 位为 1 其他位都为0的无符号长整数（unsigned long），这样的整数可用左移操作符和整型常量 1 生成：</p>
        <pre>
     1UL &lt;&lt; 27;  //  <span class="docEmphItalicAlt">generate a value with only bit number 27 set</span>
</pre>

        <p class="docText">Now when we bitwise OR this value with <tt>int_quiz1</tt>, all the bits except bit 27 will remain unchanged. That bit will be turned on. We use a compound assignment (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5" >Section 1.4.1</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5" >13</a>) to OR this value into <tt>int_quiz1</tt>. This operator, <tt>|=</tt>, executes in the same way that <tt>+=</tt> does. It is equivalent to the more verbose:</p>
	<p class="docText">然后让这个整数与 <tt>int_quiz1</tt> 做位或操作，操作后，除了第 27 位外其他所有位的值都保持不变，而第 27 位则被设置为 1。这里，使用复合赋值操作（<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec5" >第 1.4.1 节</a>）将位或操作的结果赋给 <tt>int_quiz1</tt>，该操作符 <tt>|=</tt> 操作的方法与 <tt>+=</tt> 相同。于是，上述功能等效于下面更详细的形式：</p>
        <pre>
     //  <span class="docEmphItalicAlt">following assignment is equivalent to</span> <span class="docEmphasis">int_quiz1</span> |= <span class="docEmphasis">1UL &lt;&lt; 27;</span>
     int_quiz1 = int_quiz1 | 1UL &lt;&lt; 27;
</pre>

        <p class="docText">Imagine that the teacher reexamined the quiz and discovered that student 27 actually had failed the test. The teacher must now turn off bit 27:</p>
        <p class="docText">如果老师重新复核测验成绩，发现第 27 个学生实际上在该次测验中不及格，这时老师应把第 27 位设置为 0：</p>
        <pre>
     bitset_quiz1.reset(27);   // <span class="docEmphItalicAlt">student number 27 failed</span>
     int_quiz1 &amp;= ~(1UL&lt;&lt;27);  // <span class="docEmphItalicAlt">student number 27 failed</span>
</pre>

        <p class="docText">Again, the <tt>bitset</tt> version is direct. We <tt>reset</tt> the indicated bit. For the simulated case, we need to do the inverse of what we did to set the bit: This time we'll need an integer that has bit 27 turned off and all the other bits turned on. We'll bitwise AND this value with our quiz data to turn off just that bit. We can obtain a value with all but bit 27 turned on by inverting our previous value. Applying the bitwise NOT to the previous integer will turn on every bit except the 27th. When we bitwise AND this value with <tt>int_quiz1</tt>, all except bit 27 will remain unchanged.</p>
	<p class="docText">使用 <tt>bitset</tt> 的版本可直接实现该功能，只要复位（<tt>reset</tt>）指定的位即可。而对于另一种情况，则需通过反转左移操作后的结果来实现设置：此时，我们需要一个只有第 27 位为 0 而其他位都为 1 的整数。然后将这个整数与测验数据做位与操作，把指定的位设置为 0。位求反操作使得除了第 27 位外其他位都设置为 1，然后此值和 <tt>int_quiz1</tt> 做位与操作，保证了除第 27 位外所有的位都保持不变。</p>

        <p class="docText">Finally, we might want to know how the student at position 27 fared. To do so, we could write</p>
        <p class="docText">最后，可通过以下代码获知第 27 个学生是否及格：</p>
        <pre>
     bool status;
     status = bitset_quiz1[27];       // <span class="docEmphItalicAlt">how did student number 27 do?</span>
     status = int_quiz1 &amp; (1UL&lt;&lt;27);  // <span class="docEmphItalicAlt">how did student number 27 do?</span>
</pre>

        <p class="docText">In the <tt>bitset</tt> case we can fetch the value directly to determine how that student did. In the <tt>unsigned long</tt> case, the first step is to set the 27th bit of an integer to 1. The bitwise AND of this value with <tt>int_quiz1</tt> evaluates to nonzero if bit 27 of <tt>int_quiz1</tt> is also on; otherwise, it evaluates to zero.</p>
	<p class="docText">使用 <tt>bitset</tt> 的版本中，可直接读取其值判断他是否及格。使用 <tt>unsigned long</tt> 时，首先要把一个整数的第 27 位设置为 1，然后用该整数和 <tt>int_quiz1</tt> 做位与操作，如果 <tt>int_quiz1</tt> 的第 27 位为 1，则结果为非零值，否则，结果为零。</p>

	<a name="ch05note06"></a>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
		<a name="idd1e33392"></a><a name="idd1e33399"></a><a name="idd1e33406"></a><a name="idd1e33414"></a><a name="idd1e33425"></a><a name="idd1e33433"></a><a name="idd1e33441"></a><a name="idd1e33452"></a><a name="idd1e33460"></a>
                <p class="docText"> In general, the library <tt>bitset</tt> operations are more direct, easier to read, easier to write, and more likely to be used correctly. Moreover, the size of a <tt>bitset</tt> is not limited by the number of bits in an <tt>unsigned</tt>. Ordinarily <tt>bitset</tt> should be used in preference to lower-level direct bit manipulation of integral values.</p>
		<p class="docText">一般而言，标准库提供的 <tt>bitset</tt> 操作更直接、更容易阅读和书写、正确使用的可能性更高。而且，<tt>bitset</tt> 对象的大小不受 <tt>unsigned</tt> 数的位数限制。通常来说，<tt>bitset</tt> 优于整型数据的低级直接位操作。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch05sb04"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 5.3.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch05qa3q1"></a><b>Exercise 5.9:</b></td>

                    <td>
                      <p class="docText">Assume the following two definitions:</p>
                      <p class="docText">假设有下面两个定义</p>
                      <pre>
     unsigned long ul1 = 3, ul2 = 7;
</pre>

                      <p class="docText">What is the result of each of the following expressions?</p>
                      <p class="docText">下列表达式的结果是什么？</p>
                      <pre>
     (a) ul1 &amp; ul2     (c)  ul1 | ul2
     (b) ul1 &amp;&amp; ul2    (d)  ul1 || ul2
</pre>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch05qa3q3"></a><b>Exercise 5.10:</b></td>

                    <td>
                      <p class="docText">Rewrite the <tt>bitset</tt> expressions that set and reset the quiz results using a subscript operator.</p>
		      <p class="docText">重写 <tt>bitset</tt> 表达式：使用下标操作符对测验结果进行置位（置 1）和复位（置 0）。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table>

        <a name="ch05lev2sec6"></a>
        <h4 class="docSection2Title">5.3.2. Using the Shift Operators for IO</h4>
        <h4 class="docSection2Title">5.3.2. 将移位操作符用于IO</h4>

        <p class="docText">The IO library redefines the bitwise <tt>&gt;&gt;</tt> and <tt>&lt;&lt;</tt> operators to do input and output. Even though many programmers never need to use the bitwise operators directly, most programs do make extensive use of the overloaded versions of these operators for IO. When we use an overloaded operator, it has the same precedence and associativity as is defined for the built-in version of the operator. Therefore, programmers need to understand the precedence and associativity of these operators even if they never use them with their built-in meaning as the shift operators.</p>
        <p class="docText">输入输出标准库（IO library）分别重载了位操作符 <tt>&gt;&gt;</tt> 和 <tt>&lt;&lt;</tt> 用于输入和输出。即使很多程序员从未直接使用过位操作符，但是相当多的程序都大量用到这些操作符在IO标准库中的重载版本。重载的操作符与该操作符的内置类型版本有相同的优先级和结合性。因此，即使程序员从不使用这些操作符的内置含义来实现移位操作，但是还是应该先了解这些操作符的优先级和结合性。</p>

	<a name="ch05lev3sec1"></a>
        <h5 class="docSection3Title">The IO Operators Are Left Associative</h5>
        <h5 class="docSection3Title">IO 操作符为左结合</h5>

	<a name="ch05term3"></a>
        <p class="docText">Like the other <span class="docEmphRoman"><a class="docLink" href="ch05lev1sec14.html#gloss05_13" >binary operators</a></span>, the shift operators are left associative. These operators group from left to right, which accounts for the fact that we can concatenate input and output operations into a single statement:</p>
        <p class="docText">像其他<span class="docEmphRoman"><a class="docLink" href="ch05lev1sec14.html#gloss05_13" >二元操作符</a></span>一样，移位操作符也是左结合的。这类操作符从左向右地结合，正好说明了程序员为什么可以把多个输入或输出操作连接为单个语句：</p>
        <pre>
     cout &lt;&lt; "hi" &lt;&lt; " there" &lt;&lt; endl;
</pre>

	<p class="docText">executes as:</p>
	<p class="docText">执行为：</p>
        <pre>
     ( (cout &lt;&lt; "hi") &lt;&lt; " there" ) &lt;&lt; endl;
</pre>

        <p class="docText">In this statement, the operand <tt>"hi"</tt> is grouped with the first <tt>&lt;&lt;</tt> symbol. Its result is grouped with the second, and then that result is grouped to the third.</p>
        <p class="docText">在这个语句中，操作数"hi"与第一个 <tt>&lt;&lt;</tt> 符号结合，其计算结果与第二个 <tt>&lt;&lt;</tt> 符号结合，第二个 <tt>&lt;&lt;</tt> 符号操作后，其结果再与第三个 <tt>&lt;&lt;</tt> 符号结合。</p>

	<a name="idd1e33585"></a><a name="idd1e33590"></a><a name="idd1e33596"></a><a name="idd1e33601"></a>
        <p class="docText">The shift operators have midlevel precedence: lower precedence than the arithmetic operators but higher than the relational, assignment, or conditional operators. These relative precedence levels affect how we write IO expressions involving operands that use operators with lower precedence. We often need to use parentheses to force the right grouping:</p>
        <p class="docText">移位操作符具有中等优先级：其优先级比算术操作符低，但比关系操作符、赋值操作符和条件操作符优先级高。若 IO 表达式的操作数包含了比IO操作符优先级低的操作符，相关的优先级别将影响书写该表达式的方式。通常需使用圆括号强制先实现右结合：</p>
        <pre>
     cout &lt;&lt; 42 + 10;   // <span class="docEmphItalicAlt">ok, + has higher precedence, so the sum is printed</span>
     cout &lt;&lt; (10 &lt; 42); // <span class="docEmphItalicAlt">ok: parentheses force intended grouping; prints</span> <span class="docEmphasis">1</span>
     cout &lt;&lt; 10 &lt; 42;   // <span class="docEmphItalicAlt">error: attempt to compare</span> <span class="docEmphasis">cout</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">42</span>!
</pre>

        <p class="docText">The second <tt>cout</tt> is interpreted as</p>
        <p class="docText">第二个cout语句解释为：</p>
        <pre>
     (cout &lt;&lt; 10) &lt; 42;
</pre>

        <p class="docText">this expression says to "write 10 onto <tt>cout</tt> and then compare the result of that operation (e.g., <tt>cout</tt>) to 42."</p>
	<p class="docText">该表达式说“将 10 写到 <tt>cout</tt>，然后用此操作（也就是 <tt>cout</tt>）的结果与 42 做比较”。</p>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch05lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch05lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
