<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 12.4.  Constructors</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch12lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch12lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch12lev1sec4"></a>

        <h3 class="docSection1Title">12.4. Constructors</h3>

        <h3 class="docSection1Title">12.4. 构造函数</h3>

        <p class="docText">Constructors (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >Section 2.3.3</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >49</a>) are special member functions that are executed whenever we create new objects of a class type. The job of a constructor is to ensure that the data members of each object start out with sensible initial values. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24" >Section 7.7.3</a> (p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24" >262</a>) showed how we define a constructor:</p>

        <p class="docText"><a class="docLink" href="ch02lev1sec3.html#ch02lev2sec12" >构造函数</a>是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值。<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec24" >第 7.7.3 节</a>展示了如何定义构造函数：</p>
        <pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">operations on</span> <span class="docEmphasis">Sales_itemobjects</span>
         // <span class="docEmphItalicAlt">default constructor needed to initialize members of built-in type</span>
         Sales_item(): units_sold(0), revenue(0.0) { }
     private:
         std::string isbn;
         unsigned units_sold;
         double revenue;
     };
</pre><br>
        <a name="ch12term12"></a>

        <p class="docText">This constructor uses the constructor initializer list to initialize the <tt>units_sold</tt> and <tt>revenue</tt> members. The <tt>isbn</tt> member is implicitly initialized by the <tt>string</tt> <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_12" >default constructor</a></span> as an empty string.</p>

        <p class="docText">这个构造函数使用构造函数初始化列表来初始化 <tt>units_sold</tt> 和 <tt>revenue</tt> 成员。<tt>isbn</tt> 成员由 <tt>string</tt> 的<span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_12" >默认构造函数</a></span>隐式初始化为空串。</p><a name="idd1e94549"></a><a name="idd1e94554"></a><a name="idd1e94559"></a><a name="idd1e94564"></a><a name="idd1e94569"></a><a name="idd1e94574"></a><a name="idd1e94582"></a><a name="idd1e94590"></a>

        <p class="docText">Constructors have the same name as the name of the class and may not specify a return type. Like any other function, they may define zero or more parameters.</p>

        <p class="docText">构造函数的名字与类的名字相同，并且不能指定返回类型。像其他任何函数一样，它们可以没有形参，也可以定义多个形参。</p><a name="ch12lev2sec16"></a>

        <h4 class="docSection2Title">Constructors May Be Overloaded</h4>

        <h4 class="docSection2Title">构造函数可以被重载</h4>

        <p class="docText">There is no constraint on the number of constructors we may declare for a class, provided that the parameter list of each constructor is unique. How can we know which or how many constructors to define? Ordinarily, constructors differ in ways that allow the user to specify differing ways to initialize the data members.</p>

        <p class="docText">可以为一个类声明的构造函数的数量没有限制，只要每个构造函数的形参表是唯一的。我们如何才能知道应该定义哪个或多少个构造函数？一般而言，不同的构造函数允许用户指定不同的方式来初始化数据成员。</p>

        <p class="docText">For example, we might logically extend our <tt>Sales_item</tt> class by providing two additional constructors: one that would let users provide an initial value for the <tt>isbn</tt> and another that would let them initialize the object by reading an <tt>istream</tt> object:</p>

        <p class="docText">例如，逻辑上可以通过提供两个额外的构造函数来扩展 <tt>Sales_item</tt> 类：一个允许用户提供 <tt>isbn</tt> 的初始值，另一个允许用户通过读取 <tt>istream</tt> 对象来初始化对象：</p>
        <pre>
     class Sales_item;
     // <span class="docEmphItalicAlt">other members as before</span>
     public:
         // <span class="docEmphItalicAlt">added constructors to initialize from a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">or an</span> <span class="docEmphasis">istream</span>
         Sales_item(const std::string&amp;);
         Sales_item(std::istream&amp;);
         Sales_item();
     };
</pre><br>
        <a name="ch12lev2sec17"></a>

        <h4 class="docSection2Title">Arguments Determine Which Constructor to Use</h4>

        <h4 class="docSection2Title">实参决定使用哪个构造函数</h4>

        <p class="docText">Our class now defines three constructors. We could use any of these constructors when defining new objects:</p>

        <p class="docText">我们的类现在定义了三个构造函数。在定义新对象时，可以使用这些构造函数中的任意一个：</p>
        <pre>
     // <span class="docEmphItalicAlt">uses the default constructor:</span>
     // <span class="docEmphasis">isbn</span> <span class="docEmphItalicAlt">is the empty string;</span> <span class="docEmphasis">units_soldand revenue</span> <span class="docEmphItalicAlt">are 0</span>
     Sales_item empty;
     // <span class="docEmphItalicAlt">specifies an explicit</span> <span class="docEmphasis">isbn</span>; <span class="docEmphItalicAlt">units_soldand revenue</span> <span class="docEmphItalicAlt">are 0</span>
     Sales_item Primer_3rd_Ed("0-201-82470-1");
     // <span class="docEmphItalicAlt">reads values from the standard input into</span> <span class="docEmphasis">isbn,</span> <span class="docEmphItalicAlt">units_sold</span>, <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">revenue</span>
     Sales_item Primer_4th_ed(cin);
</pre><br>

        <p class="docText">The argument type(s) used to initialize an object determines which constructor is used. In the definition of <tt>empty</tt>, there is no initializer, so the default constructor is run. The constructor that takes a single <tt>string</tt> argument is used to initialize <tt>Primer_3rd_ed;</tt> the one that takes a reference to an <tt>istream</tt> initializes <tt>Primer_4th_ed</tt>.</p>

        <p class="docText">用于初始化一个对象的实参类型决定使用哪个构造函数。在 <tt>empty</tt> 的定义中，没有初始化式，所以运行默认构造函数。接受一个 <tt>string</tt> 实参的构造函数用于初始化 <tt>Primer_3rd_ed</tt>；接受一个 <tt>istream</tt> 引用的构造函数初始化 <tt>Primer_4th_ed</tt>。</p><a name="ch12lev2sec18"></a>

        <h4 class="docSection2Title">Constructors Are Executed Automatically</h4>

        <h4 class="docSection2Title">构造函数自动执行</h4>

        <p class="docText">The compiler runs a constructor whenever an object of the type is created:</p>

        <p class="docText">只要创建该类型的一个对象，编译器就运行一个构造函数：</p>
        <pre>
     // <span class="docEmphItalicAlt">constructor that takes a</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">used to create and initialize variable</span>
     Sales_item Primer_2nd_ed("0-201-54848-8");
     // <span class="docEmphItalicAlt">default constructor used to initialize unnamed object on the heap</span>
     Sales_item *p = new Sales_item();
</pre><br>
        <a name="idd1e94745"></a><a name="idd1e94750"></a><a name="idd1e94757"></a><a name="idd1e94760"></a><a name="idd1e94765"></a>

        <p class="docText">In the first case, the constructor that takes a <tt>string</tt> is run to initialize the variable named <tt>Primer_2nd_ed</tt>. In the second case, a new <tt>Sales_item</tt> object is allocated dynamically. Assuming that the allocation succeeds, then the object is initialized by running the default constructor.</p>

        <p class="docText">第一种情况下，运行接受一个 <tt>string</tt> 实参的构造函数，来初始化变量 <tt>Primer_2nd_ed</tt>。第二种情况下，动态分配一个新的 <tt>Sales_item</tt> 对象。假定分配成功，则通过运行默认构造函数初始化该对象。</p><a name="ch12lev2sec19"></a>

        <h4 class="docSection2Title">Constructors for <tt>const</tt> Objects</h4>

        <h4 class="docSection2Title">用于 <tt>const</tt> 对象的构造函数</h4>

        <p class="docText">A constructor may not be declared as <tt>const</tt> (<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22" >Section 7.7.1</a>, p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22" >260</a>):</p>

        <p class="docText">构造函数不能声明为 <tt>const</tt> <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22" >第 7.7.1 节</a>：</p>
        <pre>
     class Sales_item {
     public:
         Sales_item() const;    // <span class="docEmphItalicAlt">error</span>
     };
</pre><br>

        <p class="docText">There is no need for a <tt>const</tt> constructor. When we create a <tt>const</tt> object of a class type, an ordinary constructor is run to initialize the <tt>const</tt> object. The job of the constructor is to initialize an object. A constructor is used to initialize an object regardless of whether the object is <tt>const</tt>.</p>

        <p class="docText"><tt>const</tt> 构造函数是不必要的。创建类类型的 <tt>const</tt> 对象时，运行一个普通构造函数来初始化该 <tt>const</tt> 对象。构造函数的工作是初始化对象。不管对象是否为 <tt>const</tt>，都用一个构造函数来初始化化该对象。</p><a name="ch12sb11"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa8q1"></a><b>Exercise 12.19:</b></td>

                    <td>
                      <p class="docText">Provide one or more constructors that allows the user of this class to specify initial values for none or all of the data elements of this class:</p>

                      <p class="docText">提供一个或多个构造函数，允许该类的用户不指定数据成员的初始值或指定所有数据成员的初始值：</p>
                      <pre>
     class NoName {
     public:
         // <span class="docEmphItalicAlt">constructor(s) go here ...</span>
     private:
         std::string *pstring;
         int         ival;
         double      dval;
     };
</pre><br>

                      <p class="docText">Explain how you decided how many constructors were needed and what parameters they should take.</p>

                      <p class="docText">解释如何确定需要多少个构造函数以及它们应接受什么样的形参。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa8q2"></a><b>Exercise 12.20:</b></td>

                    <td>
                      <p class="docText">Choose one of the following abstractions (or an abstraction of your own choosing). Determine what data is needed in the class. Provide an appropriate set of constructors. Explain your decisions.</p>

                      <p class="docText">从下述抽象中选择一个（或一个自己定义的抽象），确定类中需要什么数据，并提供适当的构造函数集。解释你的决定：</p>
                      <pre>
     (a) Book        (b) Date      (c) Employee
     (d) Vehicle    (e) Object    (f) Tree
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev2sec20"></a>

        <h4 class="docSection2Title">12.4.1. The Constructor Initializer</h4>

        <h4 class="docSection2Title">12.4.1. 构造函数初始化式</h4>

        <p class="docText">Like any other function, a constructor has a name, a parameter list, and a function body. Unlike other functions, a constructor may also contain a constructor initializer list:</p>

        <p class="docText">与任何其他函数一样，构造函数具有名字、形参表和函数体。与其他函数不同的是，构造函数也可以包含一个构造函数初始化列表：</p>
        <pre>
     // <span class="docEmphItalicAlt">recommended way to write constructors using a constructor initializer</span>
     Sales_item::Sales_item(const string &amp;book):
          isbn(book), units_sold(0), revenue(0.0) { }
</pre><br>
        <a name="idd1e94894"></a><a name="idd1e94901"></a><a name="idd1e94906"></a><a name="idd1e94911"></a>

        <p class="docText">The constructor initializer starts with a colon, which is followed by a comma-separated list of data members each of which is followed by an initializer inside parentheses. This constructor initializes the <tt>isbn</tt> member to the value of its <tt>book</tt> parameter and initializes <tt>units_sold</tt> and <tt>revenue</tt> to 0. As with any member function, constructors can be defined inside or outside of the class. The constructor initializer is specified only on the constructor definition, not its declaration.</p>

        <p class="docText">构造函数初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟一个放在圆括号中的初始化式。这个构造函数将 <tt>isbn</tt> 成员初始化为 <tt>book</tt> 形参的值，将 <tt>units_sold</tt> 和 <tt>revenue</tt> 初始化为 0。与任意的成员函数一样，构造函数可以定义在类的内部或外部。构造函数初始化只在构造函数的定义中而不是声明中指定。</p><a name="ch12note15"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The constructor initializer is a feature that many reasonably experienced C++ programmers have not mastered.</p>

                <p class="docText">构造函数初始化列表是许多相当有经验的 C++ 程序员都没有掌握的一个特性。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">One reason constructor initializers are hard to understand is that it is usually legal to omit the initializer list and <span class="docEmphasis">assign</span> values to the data members inside the constructor body. For example, we could write the <tt>Sales_item</tt> constructor that takes a <tt>string</tt> as</p>

        <p class="docText">构造函数初始化列表难以理解的一个原因在于，省略初始化列表在构造函数的函数体内对数据成员<span class="docEmphasis">赋值</span>是合法的。例如，可以将接受一个 <tt>string</tt> 的 <tt>Sales_item</tt> 构造函数编写为：</p>
        <pre>
     // <span class="docEmphItalicAlt">legal but sloppier way to write the constructor:</span>
     // <span class="docEmphItalicAlt">no constructor initializer</span>
     Sales_item::Sales_item(const string &amp;book)
     {
         isbn = book;
         units_sold = 0;
         revenue = 0.0;
     }
</pre><br>

        <p class="docText">This constructor assigns, but does not explicitly initialize, the members of class <tt>Sales_item</tt>. Regardless of the lack of an explicit initializer, the <tt>isbn</tt> member is initialized before the constructor is executed. This constructor implicitly uses the default <tt>string</tt> constructor to initialize <tt>isbn</tt>. When the body of the constructor is executed, the <tt>isbn</tt> member already has a value. That value is overwritten by the assignment inside the constructor body.</p>

        <p class="docText">这个构造函数给类 <tt>Sales_item</tt> 的成员赋值，但没有进行显式初始化。不管是否有显式的初始化式，在执行构造函数之前，要初始化 <tt>isbn</tt> 成员。这个构造函数隐式使用默认的 <tt>string</tt> 构造函数来初始化 <tt>isbn</tt>。执行构造函数的函数体时，<tt>isbn</tt> 成员已经有值了。该值被构造函数函数体中的赋值所覆盖。</p>

        <p class="docText">Conceptually, we can think of a constructor as executing in two phases: (1) the initialization phase and (2) a general computation phase. The computation phase consists of all the statements within the body of the constructor.</p>

        <p class="docText">从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。</p><a name="ch12note16"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Data members of class type are <span class="docEmphasis">always</span> initialized in the initialization phase, regardless of whether the member is initialized explicitly in the constructor initializer list. Initialization happens <span class="docEmphasis">before</span> the computation phase begins.</p>

                <p class="docText">不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员<span class="docEmphasis">总是</span>在初始化阶段初始化。初始化发生在计算阶段开始之前。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Each member that is not explicitly mentioned in the constructor initializer is initialized using the same rules as those used to initialize variables (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13" >Section 2.3.4</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13" >50</a>). Data members of class type are initialized by running the type's default constructor. The initial value of members of built-in or compound type depend on the scope of the object: At local scope those members are uninitialized, at global scope they are initialized to 0.</p>

        <p class="docText">在构造函数初始化列表中没有显式提及的每个成员，使用与<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec13" >初始化变量</a>相同的规则来进行初始化。运行该类型的默认构造函数，来初始化类类型的数据成员。内置或复合类型的成员的初始值依赖于对象的作用域：在局部作用域中这些成员不被初始化，而在全局作用域中它们被初始化为 0。</p>

        <p class="docText">The two versions of the <tt>Sales_item</tt> constructor that we wrote in this section have the same effect: Whether we initialized the members in the constructor initializer list or assigned to them inside the constructor body, the end result is the same. After the constructor completes, the three data members hold the same values. The difference is that the version that uses the constructor initializer <span class="docEmphasis">initializes</span> its data members. The version that does not define a constructor initializer assigns values to the data members in the body of the constructor. How significant this distinction is depends on the type of the data member.</p>

        <p class="docText">在本节中编写的两个 <tt>Sales_item</tt> 构造函数版本具有同样的效果：无论是在构造函数初始化列表中初始化成员，还是在构造函数函数体中对它们赋值，最终结果是相同的。构造函数执行结束后，三个数据成员保存同样的值。不同之外在于，使用构造函数初始化列表的版本<span class="docEmphasis">初始化</span>数据成员，没有定义初始化列表的构造函数版本在构造函数函数体中对数据成员<span class="docEmphasis">赋值</span>。这个区别的重要性取决于数据成员的类型。</p>

        <h5 class="docSection3Title">Constructor Initializers Are Sometimes Required</h5>

        <h5 class="docSection3Title">有时需要构造函数初始化列表</h5>

        <p class="docText">If an initializer is not provided for a class member, then the compiler implicitly uses the default constructor for the member's type. If that class does not have a default constructor, then the attempt by the compiler to use it will fail. In such cases, an initializer must be provided in order to initialize the data member.</p>

        <p class="docText">如果没有为类成员提供初始化式，则编译器会隐式地使用成员类型的默认构造函数。如果那个类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。在这种情况下，为了初始化数据成员，必须提供初始化式。</p><a name="ch12note17"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Some members <span class="docEmphasis">must</span> be initialized in the constructor initializer. For such members, assigning to them in the constructor body doesn't work. Members of a class type that do not have a default constructor and members that are <tt>const</tt> or reference types <span class="docEmphasis">must</span> be initialized in the constructor initializer <span class="docEmphasis">regardless of type</span>.</p>

                <p class="docText">有些成员<span class="docEmphasis">必须</span>在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不起作用。没有默认构造函数的类类型的成员，以及 <tt>const</tt> 或引用类型的成员，不管是哪种类型，都必须在构造函数初始化列表中进行初始化。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Because members of built-in type are not implicitly initialized, it may seem that it doesn't matter whether these members are initialized or assigned. With two exceptions, using an initializer is equivalent to assigning to a nonclass data member both in result and in performance.</p>

        <p class="docText">因为内置类型的成员不进行隐式初始化，所以对这些成员是进行初始化还是赋值似乎都无关紧要。除了两个例外，对非类类型的数据成员进行赋值或使用初始化式在结果和性能上都是等价的。</p>

        <p class="docText">For example, the following constructor is in error:</p>

        <p class="docText">例如，下面的构造函数是错误的：</p>
        <pre>
     class ConstRef {
     public:
         ConstRef(int ii);
     private:
         int i;
         const int ci;
         int &amp;ri;
     };
     // <span class="docEmphItalicAlt">no explicit constructor initializer: error</span> <span class="docEmphasis">ri</span> <span class="docEmphItalicAlt">is uninitialized</span>
     ConstRef::ConstRef(int ii)
     {              // <span class="docEmphItalicAlt">assignments:</span>
          i = ii;   // <span class="docEmphItalicAlt">ok</span>
          ci = ii;  // <span class="docEmphItalicAlt">error: cannot assign to a</span> <span class="docEmphasis">const</span>
          ri = i;   // <span class="docEmphItalicAlt">assigns to</span> <span class="docEmphasis">ri</span> <span class="docEmphItalicAlt">which was not bound to an object</span>
     }
</pre><br>

        <p class="docText">Remember that we can initialize but not assign to <tt>const</tt> objects or objects of reference type. By the time the body of the constructor begins executing, initialization is complete. Our only chance to initialize <tt>const</tt> or reference data members is in the constructor initializer. The correct way to write the constructor is</p>

        <p class="docText">记住，可以初始化 <tt>const</tt> 对象或引用类型的对象，但不能对它们赋值。在开始执行构造函数的函数体之前，要完成初始化。初始化 <tt>const</tt> 或引用类型数据成员的唯一机会是构造函数初始化列表中。编写该构造函数的正确方式为</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: explicitly initialize reference and</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">members</span>
     ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }
</pre><br>
        <a name="ch12sb12"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Advice: Use Constructor Initializers</h2>

              <h2 class="docSidebarTitle">建议：使用构造函数初始化列表</h2><a name="idd1e95153"></a><a name="idd1e95156"></a><a name="idd1e95161"></a><a name="idd1e95164"></a><a name="idd1e95169"></a>

              <p class="docText"><span class="docEmphStrong">In many classes, the distinction between initialization and assignment is strictly a matter of low-level efficiency: A data member is initialized and assigned when it could have been initialized directly. More important than the efficiency issue is the fact that some data members must be initialized.</span></p>

              <p class="docText"><span class="docEmphStrong">在许多类中，初始化和赋值严格来讲都是低效率的：数据成员可能已经被直接初始化了，还要对它进行初始化和赋值。比较率问题更重要的是，某些数据成员必须要初始化，这是一个事实。</span></p><a name="ch12note18"></a>

              <p class="docText"> </p>

              <div class="docNote">
                <table width="90%" border="0" cellspacing="0" cellpadding="1">
                  <tr>
                    <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

                    <td valign="top">
                      <p class="docText"><span class="docEmphStrong">We must use an initializer for any <tt>const</tt> or reference member or for any member of a class type that does not have a default constructor.</span></p>

                      <p class="docText"><span class="docEmphStrong">必须对任何 <tt>const</tt> 或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</span></p>
                    </td>
                  </tr>
                </table><br>
              </div><br>

              <p class="docText"><span class="docEmphStrong">By routinely using constructor initializers, we can avoid being surprised by compile-time errors when we have a class with a member that requires a constructor initializer.</span></p>

              <p class="docText"><span class="docEmphStrong">当类成员需要使用初始化列表时，通过常规地使用构造函数初始化列表，就可以避免发生编译时错误。</span></p>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev3sec21"></a>

        <h5 class="docSection3Title">Order of Member Initialization</h5>

        <h5 class="docSection3Title">成员初始化的次序</h5>

        <p class="docText">Not surprisingly, each member may be named only once in the constructor initializer. After all, what might it mean to give a member two initial values? What may be more surprising is that the constructor initializer list specifies only the values used to initialize the members, not the order in which those initializations are performed. The order in which members are initialized is the order in which the members are defined. The first member is initialized first, then the next, and so on.</p>

        <p class="docText">每个成员在构造函数初始化列表中只能指定一次，这不会令人惊讶。毕竟，给一个成员两个初始值意味着什么？也许更令人惊讶的是，构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。成员被初始化的次序就是定义成员的次序。第一个成员首先被初始化，然后是第二个，依次类推。</p><a name="ch12note19"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The order of initialization often doesn't matter. However, if one member is initialized in terms of another, then the order in which members are initialized is crucially important.</p>

                <p class="docText">初始化的次序常常无关紧要。然而，如果一个成员是根据其他成员而初始化，则成员初始化的次序是至关重要的。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Consider the following class:</p>

        <p class="docText">考虑下面的类：</p>
        <pre>
     class X {
         int i;
         int j;
     public:
         // <span class="docEmphItalicAlt">run-time error: i is initialized before j</span>
         X(int val): j(val), i(j) { }
     };
</pre><br>

        <p class="docText">In this case, the constructor initializer is written to make it <span class="docEmphasis">appear</span> as if <tt>j</tt> is initialized with <tt>val</tt> and then <tt>j</tt> is used to initialize <tt>i</tt>. However, <tt>i</tt> is initialized first. The effect of this initializer is to initialize <tt>i</tt> with the as yet uninitialized value of <tt>j</tt>!</p>

        <p class="docText">在这种情况下，构造函数初始化列表<span class="docEmphasis">看起来</span>似乎是用<tt>val</tt> 初始化 <tt>j</tt>，然后再用 <tt>j</tt> 来初始化 <tt>i</tt>。然而，<tt>i</tt> 首先被初始化。这个初始化列表的效果是用尚未初始化的 <tt>j</tt> 值来初始化 <tt>i</tt>！</p>

        <p class="docText">Some compilers are kind enough to generate a warning if the data members are listed in the constructor initializer in a different order from the order in which the members are declared.</p>

        <p class="docText">如果数据成员在构造函数初始化列表中的列出次序与成员被声明的次序不同，那么有的编译器非常友好，会给出一个警告。</p><a name="ch12note20"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">It is a good idea to write constructor initializers in the same order as the members are declared. Moreover, when possible, avoid using members to initialize other members.</p>

                <p class="docText">按照与成员声明一致的次序编写构造函数初始化列表是个好主意。此外，尽可能避免使用成员来初始化其他成员。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">It is often the case that we can avoid any problems due to order of execution for initializers by (re)using the constructor's parameters rather than using the object's data members. For example, it would be better to write the constructor for <tt>X</tt> as</p>

        <p class="docText">一般情况下，通过（重复）使用构造函数的形参而不是使用对象的数据成员，可以避免由初始化式的执行次序而引起的任何问题。例如，下面这样为 <tt>X</tt> 编写构造函数可能更好：</p>
        <pre>
     X(int val): i(val), j(val) { }
</pre><br>
        <a name="idd1e95276"></a><a name="idd1e95281"></a>

        <p class="docText">In this version, the order in which <tt>i</tt> and <tt>j</tt> are initialized doesn't matter.</p>

        <p class="docText">在这个版本中，<tt>i</tt> 和 <tt>j</tt> 初始化的次序就是无关紧要的。</p><a name="ch12lev3sec22"></a>

        <h5 class="docSection3Title">Initializers May Be Any Expression</h5>

        <h5 class="docSection3Title">初始化式可以是任意表达式</h5>

        <p class="docText">An initializer may be an arbitrarily complex expression. As an example, we could give our <tt>Sales_item</tt> class a new constructor that takes a <tt>string</tt> representing the <tt>isbn</tt>, an <tt>unsigned</tt> representing the number of books sold, and a <tt>double</tt> representing the price at which each of these books was sold:</p>

        <p class="docText">一个初始化式可以是任意复杂的表达式。例如，可以给 <tt>Sales_item</tt> 类一个新的构造函数，该构造函数接受一个 <tt>string</tt> 表示 <tt>isbn</tt>，一个 <tt>usigned</tt> 表示售出书的数目，一个 <tt>double</tt> 表示每本书的售出价格：</p>
        <pre>
     Sales_item(const std::string &amp;book, int cnt, double price):
         isbn(book), units_sold(cnt), revenue(cnt * price) { }
</pre><br>

        <p class="docText">This initializer for <tt>revenue</tt> uses the parameters representing price and number sold to calculate the object's <tt>revenue</tt> member.</p>

        <p class="docText"><tt>revenue</tt> 的初始化式使用表示价格和售出数目的形参来计算对象的 <tt>revenue</tt> 成员。</p><a name="ch12lev3sec23"></a>

        <h5 class="docSection3Title">Initializers for Data Members of Class Type</h5>

        <h5 class="docSection3Title">类类型的数据成员的初始化式</h5>

        <p class="docText">When we initialize a member of class type, we are specifying arguments to be passed to one of the constructors of that member's type. We can use any of that type's constructors. For example, our <tt>Sales_item</tt> class could initialize <tt>isbn</tt> using any of the <tt>string</tt> constructors (<a class="docLink" href="ch09lev1sec6.html#ch09lev2sec18" >Section 9.6.1</a>, p. <a class="docLink" href="ch09lev1sec6.html#ch09lev2sec18" >338</a>). Instead of using the empty string, we might decide that the default value for <tt>isbn</tt> should be a value that represents an impossibly high value for an ISBN. We could initialize <tt>isbn</tt> to a string of ten 9s:</p>

        <p class="docText">初始化类类型的成员时，要指定实参并传递给成员类型的一个构造函数。可以使用该类型的任意构造函数。例如，<tt>Sales_item</tt> 类可以使用任意一个 <tt>string</tt> 构造函数来初始化 <tt>isbn</tt>（<a class="docLink" href="ch09lev1sec6.html#ch09lev2sec18" >第 9.6.1 节</a>）。也可以用 ISBN 取值的极限值来表示 <tt>isbn</tt> 的默认值，而不是用空字符串。可以将 <tt>isbn</tt> 初始化为由 10 个 9 构成的串：</p>
        <pre>
     // <span class="docEmphItalicAlt">alternative definition for</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">default constructor</span>
     Sales_item(): isbn(10, '9'), units_sold(0), revenue(0.0) {}
</pre><br>

        <p class="docText">This initializer uses the <tt>string</tt> constructor that takes a count and a character and generates a <tt>string</tt> holding that character repeated that number of times.</p>

        <p class="docText">这个初始化式使用 <tt>string</tt> 构造函数，接受一个计数值和一个字符，并生成一个 <tt>string</tt>，来保存重复指定次数的字符。</p><a name="ch12sb13"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.4.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa9q1"></a> <b>Exercise 12.21:</b></td>

                    <td>
                      <p class="docText">Write the default constructor using a constructor initializer for class that contains the following members: a <tt>const string</tt>, an <tt>int</tt>, a <tt>double*</tt>, and an <tt>ifstream&amp;</tt>. Initialize the <tt>string</tt> to hold the name of the class.</p>

                      <p class="docText">使用构造函数初始化列表编写类的默认构造函数，该类包含如下成员：一个 <tt>const string</tt>，一个 <tt>int</tt>，一个 <tt>double*</tt> 和一个 <tt>ifstream&amp;</tt>。初始化 <tt>string</tt> 来保存类的名字。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa9q2"></a><b>Exercise 12.22:</b></td>

                    <td>
                      <p class="docText">The following initializer is in error. Identify and fix the problem.</p>

                      <p class="docText">下面的初始化式有错误。找出并改正错误。</p>
                      <pre>
     struct X {
         X (int i, int j): base(i), rem(base % j) { }
         int rem, base;
     };
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa9q3"></a><b>Exercise 12.23:</b></td>

                    <td>
                      <p class="docText">Assume we have a class named <tt>NoDefault</tt> that has a constructor that takes an <tt>int</tt> but no default constructor. Define a class <tt>C</tt> that has a member of type <tt>NoDefault</tt>. Define the default constructor for <tt>C</tt>.</p>

                      <p class="docText">假定有个命名为 <tt>NoDefault</tt> 的类，该类有一个接受一个 <tt>int</tt> 的构造函数，但没有默认构造函数。定义有一个 <tt>NoDefault</tt> 类型成员的类 <tt>C</tt>。为类 <tt>C</tt> 定义默认构造函数。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev2sec21"></a>

        <h4 class="docSection2Title">12.4.2. Default Arguments and Constructors</h4>

        <h4 class="docSection2Title">12.4.2. 默认实参与构造函数</h4><a name="idd1e95474"></a><a name="idd1e95479"></a><a name="idd1e95484"></a><a name="idd1e95489"></a><a name="idd1e95492"></a>

        <p class="docText">Let's look again at our definitions for the default constructor and the constructor that takes a <tt>string</tt>:</p>

        <p class="docText">再来看看默认构造函数和接受一个 <tt>string</tt> 的构造函数的定义：</p>
        <pre>
     Sales_item(const std::string &amp;book):
               isbn(book), units_sold(0), revenue(0.0) { }
     Sales_item(): units_sold(0), revenue(0.0) { }
</pre><br>

        <p class="docText">These constructors are almost the same: The only difference is that the constructor that takes a <tt>string</tt> parameter uses the parameter to initialize <tt>isbn</tt>. The default constructor (implicitly) uses the <tt>string</tt> default constructor to initialize <tt>isbn</tt>.</p>

        <p class="docText">这两个构造函数几乎是相同的：唯一的区别在于，接受一个 <tt>string</tt> 形参的构造函数使用该形参来初始化 <tt>isbn</tt>。默认构造函数（隐式地）使用 <tt>string</tt> 的默认构造函数来初始化 <tt>isbn</tt>。</p>

        <p class="docText">We can combine these constructors by supplying a default argument for the <tt>string</tt> initializer:</p>

        <p class="docText">可以通过为 <tt>string</tt> 初始化式提供一个默认实参将这些构造函数组合起来：</p>
        <pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">default argument for book is the empty string</span>
         Sales_item(const std::string &amp;book = ""):
                   isbn(book), units_sold(0), revenue(0.0) { }
         Sales_item(std::istream &amp;is);
         // <span class="docEmphItalicAlt">as before</span>
     };
</pre><br>

        <p class="docText">Here we define only two constructors, one of which provides a default argument for its parameter. The constructor that takes a default argument for its single <tt>string</tt> parameter will be run for either of these definitions:</p>

        <p class="docText">在这里，我们只定义了两个构造函数，其中一个为其形参提供一个默认实参。对于下面的任一定义，将执行为其 <tt>string</tt> 形参接受默认实参的那个构造函数：</p>
        <pre>
     Sales_item empty;
     Sales_item Primer_3rd_Ed("0-201-82470-1");
</pre><br>

        <p class="docText">In the case of <tt>empty</tt>, the default argument is used, whereas <tt>Primer_3rd_ed</tt> supplies an explicit argument.</p>

        <p class="docText">在 <tt>empty</tt> 的情况下，使用默认实参，而 <tt>Primer_3rd_ed</tt> 提供了一个显式实参。</p>

        <p class="docText">Each version of our class provides the same interface: They both initialize a <tt>Sales_item</tt> to the same values given a <tt>string</tt> or given no initializer.</p>

        <p class="docText">类的两个版本提供同一接口：给定一个 <tt>string</tt> 或不给定初始化式，它们都将一个 <tt>Sales_item</tt> 初始化为相同的值。</p><a name="ch12note21"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">We prefer to use a default argument because it reduces code duplication.</p>

                <p class="docText">我们更喜欢使用默认实参，因为它减少代码重复。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12sb14"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.4.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa10q1"></a><b>Exercise 12.24:</b></td>

                    <td>
                      <a name="idd1e95612"></a><a name="idd1e95617"></a><a name="idd1e95622"></a><a name="idd1e95627"></a><a name="idd1e95631"></a><a name="idd1e95634"></a>

                      <p class="docText">Using the version of <tt>Sales_item</tt> from page <a class="docLink" href="ch12lev1sec4.html#ch12lev2sec21">458</a> that defined two constructors, one of which has a default argument for its single <tt>string</tt> parameter, determine which constructor is used to initialize each of the following variables and list the values of the data members in each object:</p>

                      <p class="docText">上面的 <tt>Sales_item</tt> 定义了两个构造函数，其中之一有一个默认实参对应其单个 <tt>string</tt> 形参。使用该 <tt>Sales_item</tt> 版本，确定用哪个构造函数来初始化下述的每个变量，并列出每个对象中数据成员的值：</p>
                      <pre>
     Sales_item first_item(cin);

     int main() {
         Sales_item next;
         Sales_item last("9-999-99999-9");
     }
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa10q2"></a><b>Exercise 12.25:</b></td>

                    <td>
                      <p class="docText">Logically, we might want to supply <tt>cin</tt> as a default argument to the constructor that takes an <tt>istream&amp;</tt>. Write the constructor declaration that uses <tt>cin</tt> as a default argument.</p>

                      <p class="docText">逻辑上讲，我们可能希望将 <tt>cin</tt> 作为默认实参提供给接受一个 <tt>istream&amp;</tt> 形参的构造函数。编写使用 <tt>cin</tt> 作为默认实参的构造函数声明。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa10q3"></a><b>Exercise 12.26:</b></td>

                    <td>
                      <p class="docText">Would it be legal for both the constructor that takes a <tt>string</tt> and the one that takes an <tt>istream&amp;</tt> to have default arguments? If not, why not?</p>

                      <p class="docText">对于分别接受一个 <tt>string</tt> 和接受一个 <tt>istream&amp;</tt> 的构造函数，具有默认实参都是合法的吗？如果不是，为什么？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev2sec22"></a>

        <h4 class="docSection2Title">12.4.3. The Default Constructor</h4>

        <h4 class="docSection2Title">12.4.3. 默认构造函数</h4>

        <p class="docText">The default constructor is used whenever we define an object but do not supply an initializer. A constructor that supplies default arguments for all its parameters also defines the default constructor.</p>

        <p class="docText">只要定义一个对象时没有提供初始化式，就使用默认构造函数。为所有形参提供默认实参的构造函数也定义了默认构造函数。</p><a name="ch12lev3sec24"></a>

        <h5 class="docSection3Title">The Synthesized Default Constructor</h5>

        <h5 class="docSection3Title">合成的默认构造函数</h5>

        <p class="docText">If a class defines even one constructor, then the compiler will not generate the default constructor. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.</p>

        <p class="docText">一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造函数。这条规则的根据是，如果一个类在某种情况下需要控制对象初始化，则该类很可能在所有情况下都需要控制。</p><a name="ch12note22"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The compiler generates a default constructor automatically only if a class defines <span class="docEmphasis">no</span> constructors.</p>

                <p class="docText">只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12term25"></a>

        <p class="docText">The <b><a class="docLink" href="ch12lev1sec8.html#gloss12_25" >synthesized default constructor</a></b> initializes members using the same rules as those that apply for how variables are initialized. Members that are of class type are initialized by running each member's own default constructor. Members of built-in or compound type, such as pointers and arrays, are initialized only for objects that are defined at global scope. When objects are defined at local scope, then members of built-in or compound type are <span class="docEmphasis">uninitialized</span>.</p>

        <p class="docText"><b><a class="docLink" href="ch12lev1sec8.html#gloss12_25" >合成的默认构造函数（synthesized default constructor）</a></b>使用与变量初始化相同的规则来初始化成员。具有类类型的成员通过运行各自的默认构造函数来进行初始化。内置和复合类型的成员，如指针和数组，只对定义在全局作用域中的对象才初始化。当对象定义在局部作用域中时，内置或复合类型的成员不进行初始化。</p><a name="ch12note23"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">If a class contains data members of built-in or compound type, then the class should not rely on the synthesized default constructor. It should define its own constructor to initialize these members.</p>

                <p class="docText">如果类包含内置或复合类型的成员，则该类不应该依赖于合成的默认构造函数。它应该定义自己的构造函数来初始化这些成员。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Moreover, every constructor should provide initializers for members of built-in or compound type. A constructor that does not initialize a member of built-in or compound type leaves that member in an undefined state. Using an undefined member in any way other than as the target of an assignment is an error. If every constructor sets every member to an explicit, known state, then member functions can distinguish between an empty object and one that has actual values.</p>

        <p class="docText">此外，每个构造函数应该为每个内置或复合类型的成员提供初始化式。没有初始化内置或复合类型成员的构造函数，将使那些成员处于未定义的状态。除了作为赋值的目标之外，以任何方式使用一个未定义的成员都是错误的。如果每个构造函数将每个成员设置为明确的已知状态，则成员函数可以区分空对象和具有实际值的对象。</p><a name="ch12lev3sec25"></a>

        <h5 class="docSection3Title">Classes Should Usually Define a Default Constructor</h5>

        <h5 class="docSection3Title">类通常应定义一个默认构造函数</h5><a name="idd1e95740"></a><a name="idd1e95747"></a><a name="idd1e95752"></a><a name="idd1e95757"></a>

        <p class="docText">In certain cases, the default constructor is applied implicitly by the compiler. If the class has no default constructor, then the class may not be used in these contexts. To illustrate the cases where a default constructor is required, assume we have a class named <tt>NoDefault</tt> that does not define its own default constructor but does have a constructor that takes a <tt>string</tt> argument. Because the class defines a constructor, the compiler will not synthesize the default constructor. The fact that <tt>NoDefault</tt> has no default constructor means:</p>

        <p class="docText">在某些情况下，默认构造函数是由编译器隐式应用的。如果类没有默认构造函数，则该类就不能用在这些环境中。为了例示需要默认构造函数的情况，假定有一个 <tt>NoDefault</tt> 类，它没有定义自己的默认构造函数，却有一个接受一个 <tt>string</tt> 实参的构造函数。因为该类定义了一个构造函数，因此编译器将不合成默认构造函数。<tt>NoDefault</tt> 没有默认构造函数，意味着：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">Every constructor for every class that has a <tt>NoDefault</tt> member must explicitly initialize the <tt>NoDefault</tt> member by passing an initial <tt>string</tt> value to the <tt>NoDefault</tt> constructor.</p>

                <p class="docList">具有 <tt>NoDefault</tt> 成员的每个类的每个构造函数，必须通过传递一个初始的 <tt>string</tt> 值给 <tt>NoDefault</tt> 构造函数来显式地初始化 <tt>NoDefault</tt> 成员。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">The compiler will not synthesize the default constructor for classes that have members of type <tt>NoDefault</tt>. If such classes want to provide a default, they must define one explicitly, and that constructor must explicitly initialize their <tt>NoDefault</tt> member.</p>

                <p class="docList">编译器将不会为具有 <tt>NoDefault</tt> 类型成员的类合成默认构造函数。如果这样的类希望提供默认构造函数，就必须显式地定义，并且默认构造函数必须显式地初始化其 <tt>NoDefault</tt> 成员。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">The <tt>NoDefault</tt> type may not be used as the element type for a dynamically allocated array.</p>

                <p class="docList"><tt>NoDefault</tt> 类型不能用作动态分配数组的元素类型。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Statically allocated arrays of type <tt>NoDefault</tt> must provide an explicit initializer for each element.</p>

                <p class="docList"><tt>NoDefault</tt> 类型的静态分配数组必须为每个元素提供一个显式的初始化式。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">If we have a container such as <tt>vector</tt> that holds <tt>NoDefault</tt> objects, we cannot use the constructor that takes a size without also supplying an element initializer.</p>

                <p class="docList">如果有一个保存 <tt>NoDefault</tt> 对象的容器，例如 <tt>vector</tt>，就不能使用接受容器大小而没有同时提供一个元素初始化式的构造函数。</p>
              </div>
            </li>
          </ol>
        </div><a name="ch12note24"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">In practice, it is almost always right to provide a default constructor if other constructors are being defined. Ordinarily the initial values given to the members in the default constructor should indicate that the object is "empty."</p>

                <p class="docText">实际上，如果定义了其他构造函数，则提供一个默认构造函数几乎总是对的。通常，在默认构造函数中给成员提供的初始值应该指出该对象是“空”的。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12lev3sec26"></a>

        <h5 class="docSection3Title">Using the Default Constructor</h5>

        <h5 class="docSection3Title">使用默认构造函数</h5><a name="ch12note25"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A common mistake among programmers new to C++ is to declare an object initialized with the default constructor as follows:</p>

                <p class="docText">初级 C++ 程序员常犯的一个错误是，采用以下方式声明一个用默认构造函数初始化的对象：</p>
              </td>
            </tr>
          </table><br>
          <pre>
     // <span class="docEmphItalicAlt">oops! declares a function, not an object</span>
     Sales_item myobj();
</pre><br>
        </div><br>

        <p class="docText">The declaration of <tt>myobj</tt> compiles without complaint. However, when we try to use <tt>myobj</tt></p>

        <p class="docText">编译 <tt>myobj</tt> 的声明没有问题。然而，当我们试图使用 <tt>myobj</tt> 时</p>
        <pre>
     Sales_item myobj();   // <span class="docEmphItalicAlt">ok: but defines a function, not an object</span>
     if (myobj.same_isbn(Primer_3rd_ed))   // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">myobj</span> <span class="docEmphItalicAlt">is a function</span>
</pre><br>

        <p class="docText">the compiler complains that we cannot apply member access notation to a function! The problem is that our definition of <tt>myobj</tt> is interpreted by the compiler as a declaration of a function taking no parameters and returning an object of type <tt>Sales_item</tt>hardly what we intended! The correct way to define an object using the default constructor is to leave off the trailing, empty parentheses:</p>

        <p class="docText">编译器会指出不能将成员访问符号用于一个函数！问题在于 <tt>myobj</tt> 的定义被编译器解释为一个函数的声明，该函数不接受参数并返回一个 <tt>Sales_item</tt> 类型的对象——与我们的意图大相径庭！使用默认构造函数定义一个对象的正确方式是去掉最后的空括号：</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: defines a class object ...</span>
     Sales_item myobj;
</pre><br>
        <a name="idd1e95908"></a><a name="idd1e95913"></a><a name="idd1e95918"></a><a name="idd1e95921"></a>

        <p class="docText">On the other hand, this code is fine:</p>

        <p class="docText">另一方面，下面这段代码也是正确的：</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: create an unnamed, empty</span> <span class="docEmphasis">Sales_itemand</span> <span class="docEmphItalicAlt">use to initialize</span> <span class="docEmphasis">myobj</span>
     Sales_item myobj = Sales_item();
</pre><br>

        <p class="docText">Here we create and value-initialize a <tt>Sales_item</tt> object and to use it to initialize <tt>myobj</tt>. The compiler value-initializes a <tt>Sales_item</tt> by running its default constructor.</p>

        <p class="docText">在这里，我们创建并初始化一个 <tt>Sales_item</tt> 对象，然后用它来按值初始化 <tt>myobj</tt>。编译器通过运行 <tt>Sales_item</tt> 的默认构造函数来按值初始化一个 <tt>Sales_item</tt>。</p><a name="ch12sb15"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.4.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa11q1"></a><b>Exercise 12.27:</b></td>

                    <td>
                      <p class="docText">Which, if any, of the following statements are untrue? Why?</p>

                      <p class="docText">下面的陈述中哪个是不正确的（如果有的话）？为什么？</p>

                      <div style="font-weight:bold">
                        <ol class="docList" type="a">
                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">A class must provide at least one constructor.</p>

                              <p class="docList">类必须提供至少一个构造函数。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">A default constructor is a constructor with no parameters for its parameter list.</p>

                              <p class="docList">默认构造函数的形参列表中没有形参。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">If there are no meaningful default values for a class, the class should not provide a default constructor.</p>

                              <p class="docList">如果一个类没有有意义的默认值，则该类不应该提供默认构造函数。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">If a class does not define a default constructor, the compiler generates one automatically, initializing each data member to the default value of its associated type.</p>

                              <p class="docList">如果一个类没有定义默认构造函数，则编译器会自动生成一个，同时将每个数据成员初始化为相关类型的默认值。</p>
                            </div>
                          </li>
                        </ol>
                      </div>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev2sec23"></a>

        <h4 class="docSection2Title">12.4.4. Implicit Class-Type Conversions</h4>

        <h4 class="docSection2Title">12.4.4. 隐式类类型转换</h4>

        <p class="docText">As we saw in <a class="docLink" href="ch05lev1sec12.html#ch05lev1sec12" >Section 5.12</a> (p. <a class="docLink" href="ch05lev1sec12.html#ch05lev1sec12" >178</a>), the language defines several automatic conversions among the built-in types. We can also define how to implicitly convert an object from another type to our class type or to convert from our class type to another type. We'll see in <a class="docLink" href="ch14lev1sec9.html#ch14lev1sec9" >Section 14.9</a> (p. <a class="docLink" href="ch14lev1sec9.html#ch14lev1sec9" >535</a>) how to define conversions <span class="docEmphasis">from</span> a class type to another type. To define an implicit conversion <span class="docEmphasis">to</span> a class type, we need to define an appropriate constructor.</p><a name="ch12note26"></a>

        <p class="docText">在<a class="docLink" href="ch05lev1sec12.html#ch05lev1sec12" >第 5.12 节</a>介绍过，C++ 语言定义了内置类型之间的几个自动转换。也可以定义如何将其他类型的对象隐式转换为我们的类类型，或将我们的类类型的对象隐式转换为其他类型。在<a class="docLink" href="ch14lev1sec9.html#ch14lev1sec9" >第 14.9 节</a>将会看到如何定义从类类型到其他类型的转换。为了定义到类类型的隐式转换，需要定义合适的构造函数。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">A constructor that can be called with a single argument defines an implicit conversion from the parameter type to the class type.</p>

                <p class="docText">可以用单个实参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Let's look again at the version of <tt>Sales_item</tt> that defined two constructors:</p>

        <p class="docText">让我们再看看定义了两个构造函数的 <tt>Sales_item</tt> 版本：</p>
        <pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">default argument for book is the empty string</span>
         Sales_item(const std::string &amp;book = ""):
                   isbn(book), units_sold(0), revenue(0.0) { }
         Sales_item(std::istream &amp;is);
         // <span class="docEmphItalicAlt">as before</span>
      };
</pre><br>

        <p class="docText">Each of these constructors defines an implicit conversion. Accordingly, we can use a <tt>string</tt> or an <tt>istream</tt> where an object of type <tt>Sales_item</tt> is expected:</p>

        <p class="docText">这里的每个构造函数都定义了一个隐式转换。因此，在期待一个 <tt>Sales_item</tt> 类型对象的地方，可以使用一个 <tt>string</tt> 或一个 <tt>istream</tt>：</p>
        <pre>
     string null_book = "9-999-99999-9";
     // <span class="docEmphItalicAlt">ok: builds a</span> <span class="docEmphasis">Sales_itemwith</span> <span class="docEmphItalicAlt">0</span> <span class="docEmphasis">units_soldand revenue</span> <span class="docEmphItalicAlt">from</span>
     // <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">isbn</span> <span class="docEmphItalicAlt">equal to</span> <span class="docEmphasis">null_book</span>
     item.same_isbn(null_book);
</pre><br>
        <a name="idd1e96107"></a><a name="idd1e96114"></a><a name="idd1e96120"></a><a name="idd1e96125"></a>

        <p class="docText">This program uses an object of type <tt>string</tt> as the argument to the <tt>Sales_item same_isbn</tt> function. That function expects a <tt>Sales_item</tt> object as its argument. The compiler uses the <tt>Sales_item</tt> constructor that takes a <tt>string</tt> to generate a new <tt>Sales_item</tt> object from <tt>null_book</tt>. That newly generated (temporary) <tt>Sales_item</tt> is passed to <tt>same_isbn</tt>.</p>

        <p class="docText">这段程序使用一个 <tt>string</tt> 类型对象作为实参传给 <tt>Sales_item</tt> 的 <tt>same_isbn</tt> 函数。该函数期待一个 <tt>Sales_item</tt> 对象作为实参。编译器使用接受一个 <tt>string</tt> 的 <tt>Sales_item</tt> 构造函数从 <tt>null_book</tt> 生成一个新的 <tt>Sales_item</tt> 对象。新生成的（临时的）<tt>Sales_item</tt> 被传递给 <tt>same_isbn</tt>。</p>

        <p class="docText">Whether this behavior is desired depends on how we think our users will use the conversion. In this case, it might be a good idea. The <tt>string</tt> in <tt>book</tt> probably represents a nonexistent <tt>ISBN</tt>, and the call to <tt>same_isbn</tt> can detect whether the <tt>Sales_item</tt> in <tt>item</tt> represents a null <tt>Sales_item</tt>. On the other hand, our user might have mistakenly called <tt>same_isbn</tt> on <tt>null_book</tt>.</p>

        <p class="docText">这个行为是否我们想要的，依赖于我们认为用户将如何使用这个转换。在这种情况下，它可能是一个好主意。<tt>book</tt> 中的 <tt>string</tt> 可能代表一个不存在的 <tt>ISBN</tt>，对 <tt>same_isbn</tt> 的调用可以检测 <tt>item</tt> 中的 <tt>Sales_item</tt> 是否表示一个空的 <tt>Sales_item</tt>。另一方面，用户也许在 <tt>null_book</tt> 上错误地调用了 <tt>same_isbn</tt>。</p>

        <p class="docText">More problematic is the conversion from <tt>istream</tt> to <tt>Sales_item:</tt></p>

        <p class="docText">更成问题的是从 <tt>istream</tt> 到 <tt>Sales_item</tt> 的转换：</p>
        <pre>
     // <span class="docEmphItalicAlt">ok: uses the</span> <span class="docEmphasis">Sales_item istream</span> <span class="docEmphItalicAlt">constructor to build an object</span>
      // <span class="docEmphItalicAlt">to pass to</span> <span class="docEmphasis">same_isbn</span>
     item.same_isbn(cin);
</pre><br>

        <p class="docText">This code implicitly converts <tt>cin</tt> to a <tt>Sales_item</tt>. This conversion executes the <tt>Sales_item</tt> constructor that takes an <tt>istream</tt>. That constructor creates a (temporary) <tt>Sales_item</tt> object by reading the standard input. That object is then passed to <tt>same_isbn</tt>.</p>

        <p class="docText">这段代码将 <tt>cin</tt> 隐式转换为 <tt>Sales_item</tt>。这个转换执行接受一个 <tt>istream</tt> 的 <tt>Sales_item</tt> 构造函数。该构造函数通过读标准输入来创建一个（临时的）<tt>Sales_item</tt> 对象。然后该对象被传递给 <tt>same_isbn</tt>。</p>

        <p class="docText">This <tt>Sales_item</tt> object is a temporary (<a class="docLink" href="ch07lev1sec3.html#ch07lev2sec14" >Section 7.3.2</a>, p. <a class="docLink" href="ch07lev1sec3.html#ch07lev2sec14" >247</a>). We have no access to it once <tt>same_isbn</tt> finishes. Effectively, we have constructed an object that is discarded after the test is complete. This behavior is almost surely a mistake.</p>

        <p class="docText">这个 <tt>Sales_item</tt> 对象是一个临时对象（<a class="docLink" href="ch07lev1sec3.html#ch07lev2sec14" >第 7.3.2 节</a>）。一旦 <tt>same_isbn</tt> 结束，就不能再访问它。实际上，我们构造了一个在测试完成后被丢弃的对象。这个行为几乎肯定是一个错误。</p><a name="ch12lev3sec27"></a>

        <h5 class="docSection3Title">Supressing Implicit Conversions Defined by Constructors</h5>

        <h5 class="docSection3Title">抑制由构造函数定义的隐式转换</h5>

        <p class="docText">We can prevent the use of a constructor in a context that requries an implicit conversion by declaring the constructor <tt>explicit</tt>:</p>

        <p class="docText">可以通过将构造函数声明为 <tt>explicit</tt>，来防止在需要隐式转换的上下文中使用构造函数：</p>
        <pre>
     class Sales_item {
     public:
         // <span class="docEmphItalicAlt">default argument for book is the empty string</span>
         explicit Sales_item(const std::string &amp;book = ""):
                   isbn(book), units_sold(0), revenue(0.0) { }
         explicit Sales_item(std::istream &amp;is);
         // <span class="docEmphItalicAlt">as before</span>
     };
</pre><br>

        <p class="docText">The <tt>explicit</tt> keyword is used only on the constructor declaration inside the class. It is not repeated on a definition made outside the class body:</p>

        <p class="docText"><tt>explicit</tt> 关键字只能用于类内部的构造函数声明上。在类的定义体外部所做的定义上不再重复它：</p>
        <pre>
     // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">explicit</span> <span class="docEmphItalicAlt">allowed only on constructor declaration in class header</span>
     explicit Sales_item::Sales_item(istream&amp; is)
     {
         is &gt;&gt; *this; // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">Sales_iteminput</span> <span class="docEmphItalicAlt">operator to read the members</span>
     }
</pre><br>

        <p class="docText">Now, neither constructor can be used to implicitly create a <tt>Sales_item</tt> object. Neither of our previous uses will compile:</p>

        <p class="docText">现在，两个构造函数都不能用于隐式地创建对象。前两个使用都不能编译：</p>
        <pre>
     item.same_isbn(null_book); // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">string</span> <span class="docEmphItalicAlt">constructor is</span> <span class="docEmphasis">explicit</span>
     item.same_isbn(cin);       // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">istream</span> <span class="docEmphItalicAlt">constructor is</span> <span class="docEmphasis">explicit</span>
</pre><br>
        <a name="ch12note27"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">When a constructor is declared <tt>explicit</tt>, the compiler will <span class="docEmphasis">not</span> use it as a conversion operator.</p>

                <p class="docText">当构造函数被声明 <tt>explicit</tt> 时，编译器将<span class="docEmphasis">不</span>使用它作为转换操作符。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12lev3sec28"></a>

        <h5 class="docSection3Title">Explicitly Using Constructors for Conversions</h5>
        <h5 class="docSection3Title">为转换而显式地使用构造函数</h5><a name="ch12term14"></a>

        <p class="docText">An <span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_14" ><span class="docEmphRoman"><tt>explicit</tt> constructor</span></a></span> can be used to generate a conversion as long as we do so explicitly:</p>

        <p class="docText">只要显式地按下面这样做，就可以用<span class="docEmphRoman"><a class="docLink" href="ch12lev1sec8.html#gloss12_14" ><span class="docEmphRoman"><tt>显式的</tt>构造函数</span></a></span>来生成转换：</p>
        <pre>
     string null_book = "9-999-99999-9";
     // <span class="docEmphItalicAlt">ok: builds a</span> <span class="docEmphasis">Sales_itemwith</span> <span class="docEmphItalicAlt">0</span> <span class="docEmphasis">units_soldand revenue</span> <span class="docEmphItalicAlt">from</span>
     // <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">isbn</span> <span class="docEmphItalicAlt">equal to</span> <span class="docEmphasis">null_book</span>
     item.same_isbn(Sales_item(null_book));
</pre><br>

        <p class="docText">In this code, we create a <tt>Sales_item</tt> from <tt>null_book</tt>. Even though the constructor is <tt>explicit</tt>, this usage is allowed. Making a constructor <tt>explicit</tt> turns off only the use of the constructor implicitly. Any constructor can be used to explicitly create a temporary object.</p>
<p class="docText">在这段代码中，从 <tt>null_book</tt> 创建一个 <tt>Sales_item</tt>。尽管构造函数为显式的，但这个用法是允许的。显式使用构造函数只是中止了隐式地使用构造函数。任何构造函数都可以用来显式地创建临时对象。</p><a name="ch12note28"></a>

<a name="ch12note28"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Ordinarily, single-parameter constructors should be <tt>explicit</tt> unless there is an obvious reason to want to define an implicit conversion. Making constructors <tt>explicit</tt> may avoid mistakes, and a user can explicitly construct an object when a conversion is useful.</p>
<p class="docText">通常，除非有明显的理由想要定义隐式转换，否则，单形参构造函数应该为 <tt>explicit</tt>。将构造函数设置为 <tt>explicit</tt> 可以避免错误，并且当转换有用时，用户可以显式地构造对象。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12sb16"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.4.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa12q1"></a><b>Exercise 12.28:</b></td>

                    <td>
                      <p class="docText">Explain whether the <tt>Sales_item</tt> constructor that takes a <tt>string</tt> should be explicit. What would be the benefits of making the constructor explicit? What would be the drawbacks?</p>
<p class="docText">解释一下接受一个 <tt>string</tt> 的 <tt>Sales_item</tt> 构造函数是否应该为 <tt>explicit</tt>。将构造函数设置为 <tt>explicit</tt> 的好处是什么？缺点是什么？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa12q2"></a><b>Exercise 12.29:</b></td>

                    <td>
                      <p class="docText">Explain what operations happen during the following definitions:</p>
<p class="docText">解释在下面的定义中所发生的操作。</p>
                      <pre>
     string null_isbn = "9-999-99999-9";
     Sales_item null1(null_isbn);
     Sales_item null("9-999-99999-9");
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa12q3"></a><b>Exercise 12.30:</b></td>

                    <td>
                      <p class="docText">Compile the following code:</p>
  <p class="docText">编译如下代码：</p>
                      <pre>
     f(const vector&lt;int&gt;&amp;);
     int main() {
         vector&lt;int&gt; v2;
         f(v2);  // <span class="docEmphItalicAlt">should be ok</span>
         f(42);  // <span class="docEmphItalicAlt">should be an error</span>
         return 0;
     }
</pre><br>

                      <p class="docText">What can we infer about the <tt>vector</tt> constructors based on the error on the second call to <tt>f</tt>? If the call succeeded, then what would you conclude?</p>
<p class="docText">基于对 <tt>f</tt> 的第二个调用中出现的错误，我们可以对 <tt>vector</tt> 构造函数作出什么推断？如果该调用成功了，那么你能得出什么结论？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch12lev2sec24"></a>

        <h4 class="docSection2Title">12.4.5. Explicit Initialization of Class Members</h4>
<h4 class="docSection2Title">12.4.5. 类成员的显式初始化</h4><a name="idd1e96523"></a><a name="idd1e96528"></a>

        <p class="docText"><a name="idd1e96523"></a><a name="idd1e96528"></a>Although most objects are initialized by running an appropriate constructor, it is possible to initialize the data members of simple nonabstract classes directly. Members of classes that define no constructors and all of whose data members are <tt>public</tt> may be initialized in the same way that we initialize array elements:</p>
<p class="docText">尽管大多数对象可以通过运行适当的构造函数进行初始化，但是直接初始化简单的非抽象类的数据成员仍是可能的。对于没有定义构造函数并且其全体数据成员均为 <tt>public</tt> 的类，可以采用与初始化数组元素相同的方式初始化其成员：</p>
        <pre>
     struct Data {
         int ival;
         char *ptr;
     };
     // <span class="docEmphasis">val1.ival = 0; val1.ptr = 0</span>
     Data val1 = { 0, 0 };

     // <span class="docEmphasis">val2.ival = 1024;</span>
     // <span class="docEmphasis">val2.ptr = "Anna Livia Plurabelle"</span>
     Data val2 = { 1024, "Anna Livia Plurabelle" };
</pre><br>

        <p class="docText">The initializers are used in the declaration order of the data members. The following, for example, is an error because <tt>ival</tt> is declared before <tt>ptr</tt>:</p>
<p class="docText">根据数据成员的声明次序来使用初始化式。例如，因为 <tt>ival</tt> 在 <tt>ptr</tt> 之前声明，所以下面的用法是错误的：</p>
        <pre>
     // <span class="docEmphItalicAlt">error: can't use</span> "<span class="docEmphasis">Anna Livia Plurabelle</span>" <span class="docEmphItalicAlt">to initialize the</span> <span class="docEmphasis">int ival</span>
     Data val2 = { "Anna Livia Plurabelle" , 1024 };
</pre><br>

        <p class="docText">This form of initialization is inherited from C and is supported for compatibility with C programs. There are three significant drawbacks to explicitly initializing the members of an object of class type:</p>
<p class="docText">这种形式的初始化从 C 继承而来，支持与 C 程序兼容。显式初始化类类型对象的成员有三个重大的缺点。</p>
        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">It requires that all the data members of the class be <tt>public</tt>.</p>
<p class="docList">要求类的全体数据成员都是 <tt>public</tt>。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">It puts the burden on the programmer to initialize every member of every object. Such initialization is tedious and error-prone because it is easy to forget an initializer or to supply an inappropriate initializer.</p>
<p class="docList">将初始化每个对象的每个成员的负担放在程序员身上。这样的初始化是乏味且易于出错的，因为容易遗忘初始化式或提供不适当的初始化式。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">If a member is added or removed, all initializations have to be found and updated correctly.</p>
<p class="docList">如果增加或删除一个成员，必须找到所有的初始化并正确更新。</p>
              </div>
            </li>
          </ol>
        </div><a name="ch12note29"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="116" height="74" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">It is almost always better to define and use constructors. When we provide a default constructor for the types we define, we allow the compiler to automatically run that constructor, ensuring that every class object is properly initialized prior to the first use of that object.</p>
<p class="docText">定义和使用构造函数几乎总是较好的。当我们为自己定义的类型提供一个默认构造函数时，允许编译器自动运行那个构造函数，以保证每个类对象在初次使用之前正确地初始化。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch12sb17"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 12.4.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch12qa13q1"></a><b>Exercise 12.31:</b></td>

                    <td>
                      <p class="docText">The data members of <tt>pair</tt> are <tt>public</tt>, yet this code doesn't compile. Why?</p>
<p class="docText"><tt>pair</tt> 的数据成员为 <tt>public</tt>，然而下面这段代码却不能编译，为什么？</p>
                      <pre>
     pair&lt;int, int&gt; p2 = {0, 42}; // <span class="docEmphItalicAlt">doesn't compile, why?</span>
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch12lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch12lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
