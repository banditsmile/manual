<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 14.8.  Call Operator and Function Objects</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch14lev1sec7.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch14lev1sec9.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch14lev1sec8"></a>

        <h3 class="docSection1Title">14.8. Call Operator and Function Objects</h3>
        <h3 class="docSection1Title">14.8. 调用操作符和函数对象</h3>

        <p class="docText">The function-call operator can be overloaded for objects of class type. Typically, the call operator is overloaded for classes that represent an operation. For example, we could define a struct named <tt>absInt</tt> that encapsulates the operation of converting a value of type <tt>int</tt> to its absolute value:</p>
        <p class="docText">可以为类类型的对象重载函数调用操作符。一般为表示操作的类重载调用操作符。例如，可以定义名为 <tt>absInt</tt> 的结构，该结构封装将 <tt>int</tt> 类型的值转换为绝对值的操作：</p>
        <pre>
     struct absInt {
         int operator() (int val) {
             return val &lt; 0 ? -val : val;
         }
     };
</pre><br>

        <p class="docText">This class is simple. It defines a single operation: the function-call operator. That operator takes a single parameter and returns the absolute value of its parameter.</p>
        <p class="docText">这个类很简单，它定义了一个操作：函数调用操作符，该操作符有一个形参并返回形参的绝对值。</p>

        <p class="docText">We use the call operator by applying an argument list to an object of the class type, in a way that looks like a function call:</p>
        <p class="docText">通过为类类型的对象提供一个实参表而使用调用操作符，所用的方式看起来像一个函数调用：</p>
        <pre>
     int i = -42;
     absInt absObj;  // <span class="docEmphItalicAlt">object that defines function call operator</span>
     unsigned int ui = absObj(i);     // <span class="docEmphItalicAlt">calls absInt::operator(int)</span>
</pre><br>

	<a name="idd1e108228"></a><a name="idd1e108233"></a><a name="idd1e108238"></a><a name="idd1e108243"></a><a name="idd1e108246"></a><a name="idd1e108249"></a>
        <p class="docText">Even though <tt>absObj</tt> is an object and not a function, we can make a "call" on that object. The effect is to run the overloaded call operator defined by the object <tt>absObj</tt>. That operator takes an <tt>int</tt> value and returns its absolute value.</p><a name="ch14note24"></a>
        <p class="docText">尽管 <tt>absObj</tt> 是一个对象而不是函数，我们仍然可以“调用”该对象，效果是运行由 <tt>absObj</tt> 对象定义的重载调用操作符，该操作符接受一个 <tt>int</tt> 并值并返回它的绝对值。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" id="195131139046" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The function-call operator must be declared as a member function. A class may define multiple versions of the call operator, each of which differs as to the number or types of their parameters.</p>
                <p class="docText">函数调用操作符必须声明为成员函数。一个类可以定义函数调用操作符的多个版本，由形参的数目或类型加以区别。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Objects of class types that define the call operator are often referred to as <b><a name="ch14term6"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_06" >function objects</a></b>that is, they are objects that act like functions.</p><a name="ch14sb11"></a>
        <p class="docText">定义了调用操作符的类，其对象常称为<b><a class="docLink" href="ch14lev1sec11.html#gloss14_06" >函数对象</a></b>，即它们是行为类似函数的对象。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 14.8</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa10q1"></a><b>Exercise 14.31:</b></td>

                    <td>
                      <p class="docText">Define a function object to perform an if-then-else operation: The function object should take three parameters. It should test its first parameter and if that test succeeds, it should return its second parameter, otherwise, it should return its third parameter.</p>
                      <p class="docText">定义一个函数对象执行“如果－则－否则”操作：该函数对象应接受三个形参，它应该测试第一个形参，如果测试成功，就返回第二个形参，否则，就返回第三个形参。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa10q2"></a><b>Exercise 14.32:</b></td>

                    <td>
                      <p class="docText">How many operands may an overloaded function-call operator take?</p>
                      <p class="docText">一个重载的函数调用操作符可以接受多少操作数？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch14lev2sec27"></a>

        <h4 class="docSection2Title">14.8.1. Using Function Objects with Library Algorithms</h4>
        <h4 class="docSection2Title">14.8.1. 将函数对象用于标准库算法</h4>

        <p class="docText">Function objects are most often used as arguments to the generic algorithms. As an example, recall the problem we solved in <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >Section 11.2.3</a> (p. <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >400</a>). That program analyzed words in a set of stories, counting how many of them were of size six or greater. One part of that solution involved defining a function to determine whether a given <tt>string</tt> was longer than six characters in length:</p>
        <p class="docText">函数对象经常用作通用算法的实参。在<a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >第 11.2.3 节</a>解决的问题就是这样一个例子。那个程序分析一组故事中的单词，计算有多少个单词长度在 6 字符以上。该解决方案的一个部分包括定义一个函数以确定给定 <tt>string</tt> 的长度是否大于 6 字符：</p>
        <pre>
     // <span class="docEmphItalicAlt">determine whether a length of a given word is 6 or more</span>
     bool GT6(const string &amp;s)
     {
         return s.size() &gt;= 6;
     }
</pre><br>

        <p class="docText">We used GT6 as an argument to the count_if algorithm to count the number of words for which GT6 returned true:</p>
        <p class="docText">使用 GT6 作为传给 count_if 算法的实参，以计算使 GT6 返回 true 的单词的数目：</p>
        <pre>
     vector&lt;string&gt;::size_type wc =
                     count_if(words.begin(), words.end(), GT6);
</pre><br>
        <a name="ch14lev3sec13"></a>

        <h5 class="docSection3Title">Function Objects Can Be More Flexible than Functions</h5>
        <h5 class="docSection3Title">函数对象可以比函数更灵活</h5>

        <p class="docText">There was a serious problem with our implementation: It hardwired the number six into the definition of the <tt>GT6</tt> function. The <tt>count_if</tt> algorithm runs a function that takes a single parameter and returns a <tt>bool</tt>. Ideally, we'd pass both the <tt>string</tt> and the size we wanted to test. In that way, we could use the same code to count strings of differing sizes.</p>
        <p class="docText">我们的实现有个严重问题：它将 6 这个数字固化在 <tt>GT6</tt> 函数的定义中。<tt>count_if</tt> 算法运行只用一个形参且返回 <tt>bool</tt> 的函数。理想情况下，应传递 <tt>string</tt> 和我们想要的长度进行测试。通过该方式，可以使用同一代码对不同长度的字符串进行计数。</p>

        <p class="docText"><a name="idd1e108371"></a><a name="idd1e108377"></a>We could gain the flexibility we want by defining <tt>GT6</tt> as a class with a function-call member. We'll name this class <tt>GT_cls</tt> to distinguish it from the function:</p>
        <p class="docText">通过将 <tt>GT6</tt> 定义为带函数调用成员类，可以获得所需的灵活性。将这个类命名为 <tt>GT_cls</tt> 以区别于函数：</p>
        <pre>
     // <span class="docEmphItalicAlt">determine whether a length of a given word is longer than a stored bound</span>
     class GT_cls {
     public:
         GT_cls(size_t val = 0): bound(val) { }
         bool operator()(const string &amp;s)
                            { return s.size() &gt;= bound; }
     private:
         std::string::size_type bound;
     };
</pre><br>

        <p class="docText">This class has a constructor that takes an integral value and remembers that value in its member named <tt>bound</tt>. If no value is provided, the constructor sets <tt>bound</tt> to zero. The class also defines the call operator, which takes a <tt>string</tt> and returns a <tt>bool</tt>. That operator compares the length of its <tt>string</tt> argument to the value stored in its data member <tt>bound</tt>.</p><a name="ch14lev3sec14"></a>
        <p class="docText">这个类有一个构造函数，该构造函数接受一个整型值并用名为 <tt>bound</tt> 的成员记住那个值。如果没有提供值，构造函数将 <tt>bound</tt> 置 0。该类也定义了调用操作符，接受一个 <tt>string</tt> 参数并返回一个 <tt>bool</tt>。调用操作符将 <tt>string</tt> 实参的长度与数据成员 <tt>bound</tt> 中存储的值相比较。</p>

        <h5 class="docSection3Title">Using a <tt>GT_cls</tt> Function Object</h5>
        <h5 class="docSection3Title">使用 <tt>GT_cls</tt> 函数对象</h5>

        <p class="docText">We can do the same count as before but this time we'll use an object of type <tt>GT_cls</tt> rather than the <tt>GT6</tt> function:</p>
        <p class="docText">可以像前面一样进行计数，但这一次使用 <tt>GT_cls</tt> 类型的对象而不是 <tt>GT6</tt> 函数：</p>
        <pre>
     cout &lt;&lt; count_if(words.begin(), words.end(), GT_cls(6))
          &lt;&lt; " words 6 characters or longer" &lt;&lt; endl;
</pre><br>

        <p class="docText">This call to <tt>count_if</tt> passes a temporary object of type <tt>GT_cls</tt> rather than the function named <tt>GT6</tt>. We initialize that temporary using the value <tt>6</tt>, which the <tt>GT_cls</tt> constructor stores in its <tt>bound</tt> member. Now, each time <tt>count_if</tt> calls its function parameter, it uses the call operator from <tt>GT_cls</tt>. That call operator tests the size of its <tt>string</tt> argument against the value in <tt>bound</tt>.</p>
	<p class="docText">这个 <tt>count_if</tt> 调用传递一个 <tt>GT_cls</tt> 类型的临时对象而不再是名为 <tt>GT6</tt> 的函数。用整型值 <tt>6</tt> 来初始化那个临时对象，构造函数将这个值存储在 <tt>bound</tt> 成员中。现在，<tt>count_if</tt> 每次调用它的函数形参时，它都使用 <tt>GT_cls</tt> 的调用操作符，该调用操作符根据 <tt>bound</tt> 的值测试其 <tt>string</tt> 实参的长度。</p>

        <p class="docText">Using the function object, we can easily revise our program to test against another value. We need to change only the argument to the constructor for the object we pass to <tt>count_if</tt>. For example, we could count the number of words of length five or greater by revising our program as follows:</p>
        <p class="docText">使用函数对象，容易修改程序以根据其他值进行测试，只需为传给 <tt>count_if</tt> 的对象改变构造函数实参即可。例如，这样修改程序，就可以计算长度在 5 个字符以上的单词数：</p>
        <pre>
     cout &lt;&lt; count_if(words.begin(), words.end(), GT_cls(5))
          &lt;&lt; " words 5 characters or longer" &lt;&lt; endl;
</pre><br>

        <p class="docText">More usefully, we could count the number of words with lengths greater than one through ten:</p>
        <p class="docText">更为有用的是，还可以计算长度在 1 到 10 个字符的单词数：</p>
        <pre>
     for (size_t i = 0; i != 11; ++i)
         cout &lt;&lt; count_if(words.begin(), words.end(), GT(i))
              &lt;&lt; " words " &lt;&lt; i
              &lt;&lt; " characters or longer" &lt;&lt; endl;
</pre><br>

        <p class="docText">To write this program using a functioninstead of a function objectwould require that we write ten different functions, each of which would test against a different value.</p>
        <p class="docText">如果使用函数代替函数对象来编写这个程序，可能需要编写 10 个不同的函数，每个函数测试一个不同的值。</p><a name="ch14sb12"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 14.8.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa11q1"></a><b>Exercise 14.33:</b></td>

                    <td>
			<a name="idd1e108515"></a><a name="idd1e108520"></a><a name="idd1e108525"></a><a name="idd1e108528"></a><a name="idd1e108531"></a><a name="idd1e108536"></a><a name="idd1e108541"></a><a name="idd1e108546"></a><a name="idd1e108551"></a><a name="idd1e108556"></a>
                      <p class="docText">Using the library algorithms and the <tt>GT_cls</tt> class, write a program to find the first element in a sequence that is larger than a specified value.</p>
                      <p class="docText">使用标准库算法和 <tt>GT_cls</tt> 类，编写一个程序查找序列中第一个比指定值大的元素。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa11q2"></a><b>Exercise 14.34:</b></td>

                    <td>
                      <p class="docText">Write a function-object class similar to <tt>GT_cls</tt> but that tests whether two values are equal. Use that object and the library algorithms to write a program to replace all instances of a given value in a sequence.</p>
                      <p class="docText">编写类似于 <tt>GT_cls</tt> 的函数对象类，但测试两个值是否相等。使用该对象和标准库算法编写程序，替换序列中给定值的所有实例。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa11q3"></a><b>Exercise 14.35:</b></td>

                    <td>
                      <p class="docText">Write a class similar to <tt>GT_cls</tt>, but that tests whether the length of a given <tt>string</tt> matches its bound. Use that object to rewrite the program in <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >Section 11.2.3</a> (p. <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >400</a>) to report how many words in the input are of sizes 1 through 10 inclusive.</p>
                      <p class="docText">编写类似于 <tt>GT_cls</tt> 的类，但测试给定的长度是否与其边界相匹配。使用该对象重写 <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >第 11.2.3 节</a>中的程序，以便报告输入中有多少单词的长度在 1 到 10 之间（含 1 和 10）。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa11q4"></a><b>Exercise 14.36:</b></td>

                    <td>
                      <p class="docText">Revise the previous program to report the count of words that are sizes 1 through 9 and 10 or more.</p>
                      <p class="docText">修改前面程序以报告长度在 1 到 9 之间以及 10 以上的单词的数目。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch14lev2sec28"></a>

        <h4 class="docSection2Title">14.8.2. Library-Defined Function Objects</h4>
        <h4 class="docSection2Title">14.8.2. 标准库定义的函数对象</h4>

        <p class="docText">The standard library defines a set of arithmetic, relational, and logical function-object classes, which are listed in <a class="docLink" href="ch14lev1sec8.html#ch14table03">Table 14.3</a> on the following page. The library also defines a set of function adaptors that allow us to specialize or extend the function-object classes defined by the library or those that we define ourselves. The library function-object types are defined in the <tt>functional</tt> header.</p>
        <p class="docText">标准库定义了一组算术、关系与逻辑函数对象类，<a class="docLink" href="ch14lev1sec8.html#ch14table03">表 14.3</a> 列出了这些类。标准库还定义了一组函数适配器，使我们能够特化或者扩展标准库所定义的以及自定义的函数对象类。这些标准库函数对象类型是在 <tt>functional</tt> 头文件中定义的。</p>

	<a name="ch14table03"></a>
        <h5 class="docTableTitle">Table 14.3. Library Arithmetic Function Objects</h5>
        <h5 class="docTableTitle">表 14.3. 标准库函数对象</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="250">
            <col width="250">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphBoldItalic">Arithmetic Function Objects Types</span></p>
              <p class="docText"><span class="docEmphBoldItalic">算术函数对象类型</span></p>
            </td>

            <td class="docTableCell" align="left" valign="top"> </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <blockquote>
                <p class="docList"><tt>plus&lt;Type&gt;</tt></p>

                <p class="docList"><tt>minus&lt;Type&gt;</tt></p>

                <p class="docList"><tt>multiplies&lt;Type&gt;</tt></p>

                <p class="docList"><tt>divides&lt;Type&gt;</tt></p>

                <p class="docList"><tt>modulus&lt;Type&gt;</tt></p>

                <p class="docList"><tt>negate&lt;Type&gt;</tt></p>
              </blockquote>
            </td>

            <td class="docTableCell" align="left" valign="top">

              <blockquote>
                <p class="docList"><span class="docEmphasis">applies</span> <tt>+</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>-</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>*</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>/</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>%</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>-</tt></p>
              </blockquote>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphBoldItalic">Relational Function Objects Types</span></p>
              <p class="docText"><span class="docEmphBoldItalic">关系函数对象类型</span></p>
            </td>

            <td class="docTableCell" align="left" valign="top"> </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <blockquote>
                <p class="docList"><tt>equal_to&lt;Type&gt;</tt></p>

                <p class="docList"><tt>not_equal_to&lt;Type&gt;</tt></p>

                <p class="docList"><tt>greater&lt;Type&gt;</tt></p>

                <p class="docList"><tt>greater_equal&lt;Type&gt;</tt></p>

                <p class="docList"><tt>less&lt;Type&gt;</tt></p>

                <p class="docList"><tt>less_equal&lt;Type&gt;</tt></p>
              </blockquote>
            </td>

            <td class="docTableCell" align="left" valign="top">

              <blockquote>
                <p class="docList"><span class="docEmphasis">applies</span> <tt>==</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>!=</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>&gt;</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>&gt;=</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>&lt;</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>&lt;=</tt></p>
              </blockquote>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><span class="docEmphBoldItalic">Logical Function Object Types</span></p>
              <p class="docText"><span class="docEmphBoldItalic">逻辑函数对象类型</span></p>
            </td>

            <td class="docTableCell" align="left" valign="top"> </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <blockquote>
                <p class="docList"><tt>logical_and&lt;Type&gt;</tt></p>

                <p class="docList"><tt>logical_or&lt;Type&gt;</tt></p>

                <p class="docList"><tt>logical_not&lt;Type&gt;</tt></p>
              </blockquote>
            </td>

            <td class="docTableCell" align="left" valign="top">

              <blockquote>
                <p class="docList"><span class="docEmphasis">applies</span> <tt>&amp;&amp;</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>|</tt></p>

                <p class="docList"><span class="docEmphasis">applies</span> <tt>!</tt></p>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch14lev3sec15"></a>

        <h5 class="docSection3Title">Each Class Represents a Given Operator</h5>
        <h5 class="docSection3Title">每个类表示一个给定操作符</h5>

        <p class="docText">Each of the library function-object classes represents an operatorthat is, each class defines the call operator that applies the named operation. For example, <tt>plus</tt> is a template type that represents the addition operator. The call operator in the <tt>plus</tt> template applies <tt>+</tt> to a pair of operands.</p>
        <p class="docText">每个标准库函数对象类表示一个操作符，即，每个类都定义了应用命名操作的调用操作符。例如，<tt>plus</tt> 是表示加法操作符的模板类型。<tt>plus</tt> 模板中的调用操作符对一对操作数应用 <tt>+</tt> 运算。</p>

        <p class="docText">Different function-object classes define call operators that perform different operations. Just as <tt>plus</tt> defines a call operator that executes the <tt>+</tt> operator; the <tt>modulus</tt> class defines a call operator that applies the binary <tt>%</tt> operator; the <tt>equal_to</tt> class applies <tt>==</tt>; and so on.</p>
        <p class="docText">不同的函数对象定义了执行不同操作的调用操作符。正如 <tt>plus</tt> 定义了执行 <tt>+</tt> 操作符的调用操作符，<tt>modulus</tt> 类定义了应用二元操作符 <tt>%</tt> 的调用操作符，<tt>equal_to</tt> 类应用 <tt>==</tt>，等等。</p>

        <p class="docText">There are two <b><a name="ch14term9"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_09" >unary function-object</a></b> classes: unary minus (<tt>negate&lt;Type&gt;)</tt> and logical NOT (<tt>logical_not&lt;Type&gt;)</tt>. The remaining library function objects are <b><a name="ch14term1"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_01" >binary function-object</a></b> classes representing the binary operators. The call operators defined for the binary operators expect two parameters of the given type; the unary function-object types define a call operator that takes a single argument.</p><a name="ch14lev3sec16"></a>
        <p class="docText">有两个<b><a class="docLink" href="ch14lev1sec11.html#gloss14_09" >一元函数对象</a></b>类：一元减（<tt>negate&lt;Type&gt;)</tt>）和逻辑非（<tt>logical_not&lt;Type&gt;)</tt>）。其余的标准库函数对象都是表示二元操作符的<b><a class="docLink" href="ch14lev1sec11.html#gloss14_01" >二元函数对象</a></b>类。为二元操作符定义的调用操作符需要两个给定类型的形参，而一元函数对象类型定义了接受一个实参的调用操作符。</p>

        <h5 class="docSection3Title">The Template Type Represents the Operand(s) Type</h5>
        <h5 class="docSection3Title">表示操作数类型的模板类型</h5>

        <p class="docText">Each of the function-object classes is a class template to which we supply a single type. As we know from the sequential containers such as <tt>vector</tt>, a class template is a class that can be used on a variety of types. The template type for the function-object classes specifies the parameter type for the call operator.</p>
        <p class="docText">每个函数对象类都是一个类模板，我们需要为该模板提供一个类型。正如从诸如 <tt>vector</tt> 的顺序容器所了解的，类模板是可以用于不同类型的类。函数对象类的模板类型指定调用操作符的形参类型。</p>

        <p class="docText">For example, <tt>plus&lt;string&gt;</tt> applies the <tt>string</tt> addition operator to <tt>string</tt> <a name="idd1e109015"></a><a name="idd1e109019"></a><a name="idd1e109023"></a><a name="idd1e109030"></a><a name="idd1e109034"></a><a name="idd1e109038"></a><a name="idd1e109042"></a><a name="idd1e109046"></a><a name="idd1e109050"></a><a name="idd1e109054"></a><a name="idd1e109058"></a><a name="idd1e109062"></a><a name="idd1e109066"></a><a name="idd1e109071"></a><a name="idd1e109076"></a><a name="idd1e109081"></a>objects; for <tt>plus&lt;int&gt;</tt> the operands are <tt>int</tt>s; <tt>plus&lt;Sales_item&gt;</tt> applies <tt>+</tt> to <tt>Sales_items;</tt> and so on:</p>
        <p class="docText">例如，<tt>plus&lt;string&gt;</tt> 将 <tt>string</tt> 加法操作符应用于 <tt>string</tt> 对象，对于 <tt>plus&lt;int&gt;</tt>，操作数是 <tt>int</tt> 值，<tt>plus&lt;Sales_item&gt;</tt> 将 <tt>+</tt> 应用于 <tt>Sales_items;</tt> 对象，依次类推：</p>
        <pre>
     plus&lt;int&gt; intAdd;         // <span class="docEmphItalicAlt">function object that can add two int values</span>
     negate&lt;int&gt; intNegate;   //  <span class="docEmphItalicAlt">function object that can negate an int value</span>
     // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">intAdd::operator(int, int)</span> <span class="docEmphItalicAlt">to add 10 and 20</span>
     int sum = intAdd(10, 20);          // <span class="docEmphItalicAlt">sum = 30</span>
     // <span class="docEmphItalicAlt">uses</span> <span class="docEmphasis">intNegate::operator(int)</span> <span class="docEmphasis">to generate -10 as second parameter</span>
     // <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">intAdd::operator(int, int)</span>
     sum = intAdd(10, intNegate(10));    // <span class="docEmphItalicAlt">sum = 0</span>
</pre><br>
        <a name="ch14lev3sec17"></a>

        <h5 class="docSection3Title">Using a Library Function Object with the Algorithms</h5>
        <h5 class="docSection3Title">在算法中使用标准库函数</h5>

        <p class="docText">Function objects are often used to override the default operator used by an algorithm. For example, by default, <tt>sort</tt> uses <tt>operator&lt;</tt> to sort a container in ascending order. To sort the container in descending order, we could pass the function object <tt>greater</tt>. That class generates a call operator that invokes the greater-than operator of the underlying element type. If <tt>svec</tt> is a <tt>vector&lt;string&gt;</tt></p>
        <p class="docText">函数对象常用于覆盖算法使用的默认操作符。例如，<tt>sort</tt> 默认使用 <tt>operator&lt;</tt> 按升序对容器进行排序。为了按降序对容器进行排序，可以传递函数对象 <tt>greater</tt>。该类将产生一个调用操作符，调用基础对象的大于操作符。如果 <tt>svec</tt> 是一个 <tt>vector&lt;string&gt;</tt> 对象，以下代码</p>
        <pre>
     // <span class="docEmphItalicAlt">passes temporary function object that applies &gt; operator to two strings</span>
     sort(svec.begin(), svec.end(), greater&lt;string&gt;());
</pre><br>

	<a name="idd1e109182"></a><a name="idd1e109187"></a><a name="idd1e109191"></a><a name="idd1e109195"></a><a name="idd1e109198"></a><a name="idd1e109201"></a><a name="idd1e109204"></a><a name="idd1e109210"></a><a name="idd1e109216"></a><a name="idd1e109221"></a><a name="idd1e109226"></a><a name="idd1e109232"></a><a name="idd1e109238"></a><a name="idd1e109241"></a><a name="idd1e109245"></a>
        <p class="docText">sorts the <tt>vector</tt> in descending order. As usual, we pass a pair of iterators to denote the sequence that should be sorted. The third argument is used to pass a predicate (<a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >Section 11.2.3</a>, p. <a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >402</a>) function to use to compare elements. That argument is a temporary of type <tt>greater&lt;string&gt;</tt>, which is a function object that applies the <tt>&gt;</tt> operator to two <tt>string</tt> operands.</p>
        <p class="docText">将按降序对 <tt>vector</tt> 进行排序。像通常那样，传递一对迭代器以指明被排序序列。第三个实参用于传递比较元素的谓词（<a class="docLink" href="ch11lev1sec2.html#ch11lev2sec6" >第 11.2.3 节</a>）函数。该实参 <tt>greater&lt;string&gt;</tt> 类型的临时对象，是一个将 <tt>&gt;</tt> 操作符应用于两个 <tt>string</tt> 操作符的函数对象。</p><a name="ch14lev2sec29"></a>

        <h4 class="docSection2Title">14.8.3. Function Adaptors for Function Objects</h4>
        <h4 class="docSection2Title">14.8.3. 函数对象的函数适配器</h4>

        <p class="docText">The standard library provides a set of <b><a name="ch14term5"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_05" >function adaptors</a></b> with which to specialize and extend both unary and binary function objects. The function adaptors are divided into the following two categories.</p>
        <p class="docText">标准库提供了一组<b><a class="docLink" href="ch14lev1sec11.html#gloss14_05" >函数适配器</a></b>，用于特化和扩展一元和二元函数对象。函数适配器分为如下两类：</p>

        <div style="font-weight:bold">
          <ol class="docList" type="1">
            <li>
              <div style="font-weight:normal">
                <p class="docList">Binders: A <b><a name="ch14term2"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_02" >binder</a></b> is a function adaptor that converts a binary function object into a unary function object by binding one of the operands to a given value.</p>
                <p class="docList"><b><a class="docLink" href="ch14lev1sec11.html#gloss14_02" >绑定器</a></b>，是一种函数适配器，它通过将一个操作数绑定到给定值而将二元函数对象转换为一元函数对象。</p>
              </div>
            </li>

            <li>
              <div style="font-weight:normal">
                <p class="docList">Negators: A <b><a name="ch14term7"></a><a class="docLink" href="ch14lev1sec11.html#gloss14_07" >negator</a></b> is a function adaptor that reverses the truth value of a predicate function object.</p>
                <p class="docList"><b><a class="docLink" href="ch14lev1sec11.html#gloss14_07" >求反器</a></b>，是一种函数适配器，它将谓词函数对象的真值求反。</p>
              </div>
            </li>
          </ol>
        </div>

        <p class="docText">The library defines two binder adaptors: <tt>bind1st</tt> and <tt>bind2nd</tt>. Each binder takes a function object and a value. As you might expect, <tt>bind1st</tt> binds the given value to the first argument of the binary function object, and <tt>bind2nd</tt> binds the value to the second. For example, to count all the elements within a container that are less than or equal to <tt>10</tt>, we would pass <tt>count_if</tt> the following:</p>
        <p class="docText">标准库定义了两个绑定器适配器：<tt>bind1st</tt> 和 <tt>bind2nd</tt>。每个绑定器接受一个函数对象和一个值。正如你可能想到的，<tt>bind1st</tt> 将给定值绑定到二元函数对象的第一个实参，<tt>bind2nd</tt> 将给定值绑定到二元函数对象的第二个实参。例如，为了计算一个容器中所有小于或等于 <tt>10</tt> 的元素的个数，可以这样给 <tt>count_if</tt> 传递值：</p>
        <pre>
     count_if(vec.begin(), vec.end(),
              bind2nd(less_equal&lt;int&gt;(), 10));
</pre><br>

        <p class="docText">The third argument to <tt>count_if</tt> uses the <tt>bind2nd</tt> function adaptor. That adaptor returns a function object that applies the <tt>&lt;=</tt> operator using 10 as the right-hand operand. This call to <tt>count_if</tt> counts the number of elements in the input range that are less than or equal to 10.</p>
        <p class="docText">传给 <tt>count_if</tt> 的第三个实参使用 <tt>bind2nd</tt> 函数适配器，该适配器返回一个函数对象，该对象用 10 作右操作数应用 <tt>&lt;=</tt> 操作符。这个 <tt>count_if</tt> 调用计算输入范围中小于或等于 10 的元素的个数。</p>

        <p class="docText">The library also provides two negators: <tt>not1</tt> and <tt>not2</tt>. Again, as you might expect, <tt>not1</tt> reverses the truth value of a unary predicate function object, and <tt>not2</tt> reverses the truth value of a binary predicate function object.</p>
        <p class="docText">标准库还定义了两个求反器：<tt>not1</tt> 和 <tt>not2</tt>。你可能已经想到的，<tt>not1</tt> 将一元函数对象的真值求反，<tt>not2</tt> 将二元函数对象的真值求反。</p>

        <p class="docText">To negate our binding of the <tt>less_equal</tt> function object, we would write</p>
        <p class="docText">为了对 <tt>less_equal</tt> 函数对象的绑定求反，可以编写这样的代码：</p>
        <pre>
     count_if(vec.begin(), vec.end(),
             not1(bind2nd(less_equal&lt;int&gt;(), 10)));
</pre><br>

        <p class="docText">Here we first bind the second operand of the <tt>less_equal</tt> object to <tt>10</tt>, effectively transforming that binary operation into a unary operation. We then negate the return from the operation using <tt>not1</tt>. The effect is that each element will be tested to see if it is <tt>&lt;=</tt> to 10. Then, the truth value of that result will be negated. In effect, this call counts those elements that are not <tt>&lt;=</tt> to 10.</p>
	<p class="docText">这里，首先将 <tt>less_equal</tt> 对象的第二个操作数绑定到 <tt>10</tt>，实际上是将该二元操作转换为一元操作。再用 <tt>not1</tt> 对操作的返回值求反，效果是测试每个元素是否 <tt>&lt;=</tt>。然后，对结果真值求反。这个 <tt>count_if</tt> 调用的效果是对不 <tt>&lt;=</tt> 10 的那些元素进行计数。</p>
      </td>
    </tr>
  </table>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 14.8.3</h2>
              <h2 class="docSidebarTitle"></h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa12q1"></a><b>Exercise 14.37:</b></td>

                    <td>
                      <p class="docText"><a name="idd1e109421"></a>Using the library function objects and adaptors, define an object to:</p>
                      <p class="docText">使用标准库函数对象和函数适配器，定义一个对象用于：</p>

                      <div style="font-weight:bold">
                        <ol class="docList" type="1">
                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">Find all values that are greater than 1024.</p>
                              <p class="docList">查找大于 1024 的所有值。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">Find all strings that are not equal to <tt>pooh</tt>.</p>
                              <p class="docList">查找不等于 <tt>pooh</tt> 的所有字符串。</p>
                            </div>
                          </li>

                          <li>
                            <div style="font-weight:normal">
                              <p class="docList">Multiply all values by 2.</p>
                              <p class="docList">将所有值乘以 2。</p>
                            </div>
                          </li>
                        </ol>
                      </div>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa12q2"></a><b>Exercise 14.38:</b></td>

                    <td>
                      <p class="docText">In the last call to <tt>count_if</tt> we used <tt>not1</tt> to negate the result from <tt>bind2nd</tt> of <tt>(less_equal&lt;int&gt;(), 10)</tt>. Why did we use <tt>not1</tt> rather than <tt>not2</tt>.</p>
                      <p class="docText">最后一个 <tt>count_if</tt> 调用中，用 <tt>not1</tt> 将 <tt>bind2nd</tt> 的结果求反。为什么使用 <tt>not1</tt> 而不用 <tt>not2</tt>？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch14qa12q3"></a><b>Exercise 14.39:</b></td>
                    <td>
                      <p class="docText">Use library function objects in place of <tt>GT_cls</tt> to find the words of a specified length.</p>
                      <p class="docText">使用标准库函数对象代替 <tt>GT_cls</tt> 来查找指定长度的单词。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch14lev1sec7.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch14lev1sec9.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
