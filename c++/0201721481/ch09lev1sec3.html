<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 9.3.  Sequence Container Operations</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch09lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch09lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch09lev1sec3"></a>

        <h3 class="docSection1Title">9.3. Sequence Container Operations</h3>

        <h3 class="docSection1Title">9.3. 每种顺序容器都提供了一组有用的类型定义以及以下操作：</h3>

        <p class="docText">Each sequential container defines a set of useful typedefs and supports operations that let us</p>

        <p class="docText">每种顺序容器都提供了一组有用的类型定义以及以下操作：</p>

        <ul>
          <li>
            <p class="docList">Add elements to the container</p>

            <p class="docList">在容器中添加元素。</p>
          </li>

          <li>
            <p class="docList">Delete elements from the container</p>

            <p class="docList">在容器中删除元素。</p>
          </li>

          <li>
            <p class="docList">Determine the size of the container</p>

            <p class="docList">设置容器大小。</p>
          </li>

          <li>
            <p class="docList">Fetch the first and last elements from the container, if any</p>

            <p class="docList">（如果有的话）获取容器内的第一个和最后一个元素。</p>
          </li>
        </ul><a name="ch09lev2sec6"></a>

        <h4 class="docSection2Title">9.3.1. Container Typedefs</h4>
        <h4 class="docSection2Title">9.3.1. 容器定义的类型别名</h4>

        <p class="docText">We've used three of the container-defined types: <tt>size_type, iterator</tt>, and <tt>const_iterator</tt>. Each container defines these types, along with several others shown in <a class="docLink" href="ch09lev1sec3.html#ch09table05">Table 9.5</a>.</p>
	<p class="docText">在前面的章节里，我们已经使用过三种由容器定义的类型：<tt>size_type</tt>、<tt>iterator</tt> 和 <tt>const_iterator</tt>。所有容器都提供这三种类型以及<a class="docLink" href="ch09lev1sec3.html#ch09table05">表 9.5</a> 所列出的其他类型。</p>

        <h5 class="docTableTitle">Table 9.5. Container-Defined Typedefs</h5>
        <h5 class="docTableTitle">表 9.5. 容器定义的类型别名</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="200">
            <col width="300">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>size_type</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Unsigned integral type large enough to hold size of largest possible container of this container type</p>
              <p class="docText">无符号整型，足以存储此容器类型的最大可能容器长度</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>iterator</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Type of the iterator for this container type</p>
              <p class="docText">此容器类型的迭代器类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>const_iterator</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Type of the iterator that can read but not write the elements</p>
              <p class="docText">元素的只读迭代器类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>reverse_iterator</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Iterator that addresses elements in reverse order</p>
              <p class="docText">按逆序寻址元素的迭代器</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>const_reverse_iterator</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Reverse iterator that can read but not write the elements</p>
              <p class="docText">元素的只读（不能写）逆序迭代器</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>difference_type</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Signed integral type large enough to hold the difference, which might be negative, between two iterators</p>
              <p class="docText">足够存储两个迭代器差值的有符号整型，可为负数</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>value_type</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Element type</p>
              <p class="docText">元素类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>reference</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Element's lvalue type; synonym for <tt>value_type&amp;</tt></p>
              <p class="docText">元素的左值类型，是 <tt>value_type&amp;</tt> 的同义词</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>const_reference</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Element's const lvalue type; same as <tt>const value_type&amp;</tt></p>
              <p class="docText">元素的常量左值类型，等效于 <tt>const value_type&amp;</tt></p>
            </td>
          </tr>
        </table><br>

<a name="idd1e65413"></a><a name="idd1e65420"></a><a name="idd1e65426"></a><a name="idd1e65430"></a><a name="idd1e65436"></a><a name="idd1e65442"></a><a name="idd1e65448"></a><a name="idd1e65454"></a><a name="idd1e65460"></a><a name="idd1e65466"></a><a name="idd1e65473"></a><a name="idd1e65480"></a><a name="idd1e65487"></a><a name="idd1e65494"></a><a name="idd1e65501"></a><a name="idd1e65508"></a><a name="idd1e65515"></a><a name="idd1e65521"></a><a name="idd1e65528"></a><a name="idd1e65535"></a><a name="idd1e65542"></a><a name="idd1e65549"></a><a name="idd1e65556"></a><a name="idd1e65563"></a><a name="idd1e65570"></a><a name="idd1e65583"></a><a name="idd1e65588"></a><a name="idd1e65592"></a><a name="idd1e65601"></a><a name="idd1e65606"></a><a name="idd1e65614"></a><a name="idd1e65620"></a><a name="idd1e65626"></a><a name="idd1e65633"></a><a name="idd1e65640"></a><a name="idd1e65647"></a><a name="idd1e65654"></a><a name="idd1e65661"></a><a name="idd1e65668"></a>
        <p class="docText">We'll have more to say about reverse iterators in <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9" >Section 11.3.3</a> (p. <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9" >412</a>), but briefly, a reverse iterator is an iterator that goes backward through a container and inverts the iterator operations: For example, saying <tt>++</tt> on a reverse iterator yields the previous element in the container.</p>
        <p class="docText">我们将在<a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9" >第 11.3.3 节</a>中详细介绍逆序迭代器。简单地说，逆序迭代器从后向前遍历容器，并反转了某些相关的迭代器操作：例如，在逆序迭代器上做 <tt>++</tt> 运算将指向容器中的前一个元素。</p>

        <p class="docText">The last three types in <a class="docLink" href="ch09lev1sec3.html#ch09table05">Table 9.5</a> on the facing page let us use the type of the elements stored in a container without directly knowing what that type is. If we need the element type, we refer to the container's <tt>value_type</tt>. If we need a reference to that type, we use <tt>reference</tt> or <tt>const_reference</tt>. The utility of these element-related typedefs will be more apparent when we define our own generic programs in <a class="docLink" href="ch16.html#ch16" >Chapter 16</a>.</p>
        <p class="docText"><a class="docLink" href="ch09lev1sec3.html#ch09table05">表 9.5</a> 的最后三种类型使程序员无须直接知道容器元素的真正类型，就能使用它。需要使用元素类型时，只要用 <tt>value_type</tt> 即可。如果要引用该类型，则通过 <tt>reference</tt> 和 <tt>const_reference</tt> 类型实现。在程序员编写自己的泛型程序（<a class="docLink" href="ch16.html#ch16" >第十六章</a>）时，这些元素相关类型的定义非常有用。</p>

        <p class="docText">Expressions that use a container-defined type can look intimidating:</p>
        <p class="docText">使用容器定义类型的表达式看上去非常复杂：</p>
        <pre>
     // <span class="docEmphasis">iter</span> <span class="docEmphItalicAlt">is the</span> <span class="docEmphasis">iterator</span> <span class="docEmphItalicAlt">type defined by</span> <span class="docEmphasis">list&lt;string&gt;</span>
     list&lt;string&gt;::iterator iter;

     // <span class="docEmphasis">cnt</span> <span class="docEmphItalicAlt">is the</span> <span class="docEmphasis">difference_type</span> <span class="docEmphItalicAlt">type defined by</span> <span class="docEmphasis">vector&lt;int&gt;</span>
     vector&lt;int&gt;::difference_type cnt;
</pre><br>

        <p class="docText">The declaration of <tt>iter</tt> uses the scope operator to say that we want the name on the right-hand side of the <tt>::</tt> from the scope of the left-hand side. The effect is to declare that <tt>iter</tt> has whatever type is defined for the <span class="docEmphRoman"><a name="ch09term7"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_07" ><span class="docEmphRoman"><tt>iterator</tt></span></a></span> member from the <span class="docEmphRoman"><a name="ch09term10"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_10" ><span class="docEmphRoman"><tt>list</tt></span></a></span> class that holds elements of type <tt>string</tt>.</p><a name="ch09sb06"></a>
	<p class="docText"><tt>iter</tt> 所声明使用了作用域操作符，以表明此时所使用的符号 <tt>::</tt> 右边的类型名字是在符号 <tt>iter</tt> 左边指定容器的作用域内定义的。其效果是将 <tt>iter</tt> 声明为 <span class="docEmphRoman"><a name="ch09term7"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_07" ><span class="docEmphRoman"><tt>iterator</tt></span></a></span> 类型，而 <tt>iterator</tt> 是存放 <tt>string</tt> 类型元素的 <span class="docEmphRoman"><a class="docLink" href="ch09lev1sec9.html#gloss09_10" ><span class="docEmphRoman"><tt>list</tt></span></a></span> 类的成员。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 9.3.1</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa5q1"></a><b>Exercise 9.16:</b></td>

                    <td>
                      <p class="docText">What type should be used as the index into a <tt>vector</tt> of <tt>int</tt>s?</p>
                      <p class="docText"><tt>int</tt> 型的 <tt>vector</tt> 容器应该使用什么类型的索引？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa5q2"></a><b>Exercise 9.17:</b></td>

                    <td>
                      <p class="docText">What type should be used to read the elments in a <tt>list</tt> of <tt>string</tt>s?</p>
                      <p class="docText">读取存放 <tt>string</tt> 对象的 <tt>list</tt> 容器时，应该使用什么类型？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch09lev2sec7"></a>

        <h4 class="docSection2Title">9.3.2. <tt>begin</tt> and <tt>end</tt> Members</h4>
        <h4 class="docSection2Title">9.3.2. <tt>begin</tt> 和 <tt>end</tt> 成员</h4>

        <p class="docText">The <span class="docEmphRoman"><a name="ch09term2"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_02" ><span class="docEmphRoman"><tt>begin</tt></span></a></span> and <tt>end</tt> operations yield iterators that refer to the first and one past the last element in the container. These iterators are most often used to form an iterator range that encompasses all the elements in the container.</p><a name="ch09table06"></a>
        <p class="docText"><span class="docEmphRoman"><a class="docLink" href="ch09lev1sec9.html#gloss09_02" ><span class="docEmphRoman"><tt>begin</tt></span></a></span> 和 <tt>end</tt> 操作产生指向容器内第一个元素和最后一个元素的下一位置的迭代器，如<a class="docLink" href="ch09lev1sec3.html#ch09table06">表 9.6</a> 所示。这两个迭代器通常用于标记包含容器中所有元素的迭代器范围。</p>

        <h5 class="docTableTitle">Table 9.6. Container <tt>begin</tt> and <tt>end</tt> Operations</h5>
        <h5 class="docTableTitle">表 9.6. 容器的 <tt>begin</tt> 和 <tt>end</tt> 操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="200">
            <col width="300">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.begin()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Yields an iterator referring to the first element in <tt>c</tt></p>
              <p class="docText">返回一个迭代器，它指向容器 <tt>c</tt> 的第一个元素</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.end()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Yields an iterator referring to the one past the last element in <tt>c</tt></p>
              <p class="docText">返回一个迭代器，它指向容器 <tt>c</tt> 的最后一个元素的下一位置</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.rbegin()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Yields a reverse iterator referring to the last element in <tt>c</tt></p>
              <p class="docText">返回一个逆序迭代器，它指向容器 <tt>c</tt> 的最后一个元素</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.rend()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Yields a reverse iterator referring one past (i.e., before) the first element in <tt>c</tt></p>
              <p class="docText">返回一个逆序迭代器，它指向容器 <tt>c</tt> 的第一个元素前面的位置</p>
            </td>
          </tr>
        </table><br>

        <p class="docText">There are two different versions of each of these operations: One is a <tt>const</tt> member (<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22" >Section 7.7.1</a>, p. <a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22" >260</a>) and the other is non<tt>const</tt>. The return type of these operations varies on whether the container is <tt>const</tt>. In each case, if the container <a name="idd1e65933"></a><a name="idd1e65938"></a><a name="idd1e65945"></a><a name="idd1e65952"></a><a name="idd1e65959"></a><a name="idd1e65966"></a><a name="idd1e65973"></a><a name="idd1e65979"></a><a name="idd1e65985"></a><a name="idd1e65991"></a>is non<tt>const</tt>, then the result's type is <tt>iterator</tt> or <tt>reverse_iterator</tt>. If the object is <tt>const</tt>, then the type is prefixed by <tt>const_</tt>, that is, <tt>const_iterator</tt> or <tt>const_reverse_iterator</tt>. We cover reverse iterators in <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9" >Section 11.3.3</a> (p. <a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9" >412</a>).</p><a name="ch09lev2sec8"></a>
        <p class="docText">上述每个操作都有两个不同版本：一个是 <tt>const</tt> 成员（<a class="docLink" href="ch07lev1sec7.html#ch07lev2sec22" >第 7.7.1 节</a>），另一个是非 <tt>const</tt> 成员。这些操作返回什么类型取决于容器是否为 <tt>const</tt>。如果容器不是 <tt>const</tt>，则这些操作返回 <tt>iterator</tt> 或 <tt>reverse_iterator</tt> 类型。如果容器是 <tt>const</tt>，则其返回类型要加上 <tt>const_</tt> 前缀，也就是 <tt>const_iterator</tt> 和 <tt>const_reverse_iterator</tt> 类型。我们将在<a class="docLink" href="ch11lev1sec3.html#ch11lev2sec9" >第 11.3.3 节</a>中详细介绍逆序迭代器。</p>

        <h4 class="docSection2Title">9.3.3. Adding Elements to a Sequential Container</h4>
        <h4 class="docSection2Title">9.3.3. 在顺序容器中添加元素</h4>

        <p class="docText">In <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7" >Section 3.3.2</a> (p. <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7" >94</a>) we saw one way to add elements: <tt>push_back</tt>. Every sequential container supports <tt>push_back</tt>, which appends an element to the back of the container. The following loop reads one <tt>string</tt> at a time into <tt>text_word:</tt></p>
        <p class="docText"><a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7" >第 3.3.2 节</a>介绍了添加元素的一种方法：<tt>push_back</tt>。所有顺序容器都支持 <tt>push_back</tt> 操作（<a class="docLink" href="ch09lev1sec3.html#ch09table07">表 9.7</a>），提供在容器尾部插入一个元素的功能。下面的循环每次读入一个 <tt>string</tt> 类型的值，并存放在 <tt>text_word:</tt> 对象中：</p>
        <pre>
     // <span class="docEmphItalicAlt">read from standard input putting each word onto the end of container</span>
     string text_word;
     while (cin &gt;&gt; text_word)
         container.push_back(text_word);
</pre><br>

        <p class="docText">The call to <tt>push_back</tt> creates a new element at the end of <span class="docEmphRoman"><a name="ch09term3"></a><a class="docLink" href="ch09lev1sec9.html#gloss09_03" ><span class="docEmphRoman"><tt>container</tt></span></a></span>, increasing the <tt>size</tt> of <tt>container</tt> by one. The value of that element is a copy of <tt>text_word</tt>. The type of <tt>container</tt> can be any of <tt>list, vector</tt>, or <tt>deque</tt>.</p>
	<p class="docText">调用 <tt>push_back</tt> 函数会在容器 <span class="docEmphRoman"><a class="docLink" href="ch09lev1sec9.html#gloss09_03" ><span class="docEmphRoman"><tt>container</tt></span></a></span> 尾部创建一个新元素，并使容器的长度加 1。新元素的值为 <tt>text_word</tt> 对象的副本，而 <tt>container</tt> 的类型则可能是 <tt>list</tt>、<tt>vector</tt> 或 <tt>deque</tt>。</p>

        <p class="docText">In addition to <tt>push_back</tt>, the <tt>list</tt> and <tt>deque</tt> containers support an analogous operation named <tt>push_front</tt>. This operation inserts a new element at the front of the container. For example,</p>
        <p class="docText">除了 <tt>push_back</tt> 运算，<tt>list</tt> 和 <tt>deque</tt> 容器类型还提供了类似的操作：<tt>push_front</tt>。这个操作实现在容器首部插入新元素的功能。例如：</p>
        <pre>
     list&lt;int&gt; ilist;
     // <span class="docEmphItalicAlt">add elements at the end of</span> <span class="docEmphasis">ilist</span>
     for (size_t ix = 0; ix != 4; ++ix)
         ilist.push_back(ix);
</pre><br>

        <p class="docText">uses <tt>push_back</tt> to add the sequence <tt>0, 1, 2, 3</tt> to the end of <tt>ilist</tt>.</p>
        <p class="docText">使用 <tt>push_back</tt> 操作在容器 <tt>ilist</tt> 尾部依次添加元素 0、1、2、3。</p>

        <p class="docText">Alternatively, we could use <tt>push_front</tt></p>
	<p class="docText">然后，我们选择用 <tt>push_front</tt> 操作再次在 <tt>ilist</tt> 中添加元素：</p>
        <pre>
     // <span class="docEmphItalicAlt">add elements to the start of</span> <span class="docEmphasis">ilist</span>
     for (size_t ix = 0; ix != 4; ++ix)
         ilist.push_front(ix);
</pre><br>

        <p class="docText">to add the elements <tt>0, 1, 2, 3</tt> to the beginning of <tt>ilist</tt>. Because each element is inserted at the new beginning of the <tt>list</tt>, they wind up in reverse order. After executing both loops, <tt>ilist</tt> holds the sequence <tt>3,2,1,0,0,1,2,3</tt>.</p><a name="ch09sb07"></a>
        <p class="docText">此时，元素 <tt>0、1、2、3</tt> 则被依次添加在 <tt>ilist</tt> 的开始位置。由于每个元素都在 <tt>list</tt> 的新起点插入，因此它们在容器中以逆序排列，循环结束后，<tt>ilist</tt> 内的元素序列为：<tt>3、2、1、0、0、1、2、3</tt>。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Key Concept: Container Elements Are Copies</h2>
              <h2 class="docSidebarTitle">关键概念：容器元素都是副本</h2>

              <p class="docText"><span class="docEmphStrong">When we add an element to a container, we do so by copying the element value into the container. Similarly, when we initialize a container by providing a range of elements, the new container contains copies of the original range of elements. There is no relationship between the element in the container and the value from which it was copied. Subsequent changes to the element in the container have no effect on the value that was copied, and vice versa.</span></p>
              <p class="docText"><span class="docEmphStrong">在容器中添加元素时，系统是将元素值复制到容器里。类似地，使用一段元素初始化新容器时，新容器存放的是原始元素的副本。被复制的原始值与新容器中的元素各不相关，此后，容器内元素值发生变化时，被复制的原值不会受到影响，反之亦然。</span></p>
            </td>
          </tr>
        </table><br>
        <a name="ch09table07"></a>

        <h5 class="docTableTitle">Table 9.7. Operations that Add Elements to a Sequential Container</h5>
        <h5 class="docTableTitle">表 9.7 在顺序容器中添加元素的操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.push_back(t)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Adds element with value <tt>t</tt> to the end of <tt>c</tt>. Returns <tt>void</tt>.</p>
              <p class="docText">在容器 <tt>c</tt> 的尾部添加值为 <tt>t</tt> 的元素。返回 <tt>void</tt> 类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.push_front(t)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Adds element with value <tt>t</tt> to front of <tt>c</tt>. Returns <tt>void</tt>.</p>
              <p class="docText">在容器 <tt>c</tt> 的前端添加值为 <tt>t</tt> 的元素。返回 <tt>void</tt> 类型</p>

              <p class="docText"><span class="docEmphStrong">Valid only for <tt>list</tt> or <tt>deque</tt></span>.</p>
              <p class="docText"><span class="docEmphStrong">只适用于 <tt>list</tt> 和 <tt>deque</tt> 容器类型</span>.</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.insert(p,t)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Inserts element with value <tt>t</tt> before the element referred to by iterator <tt>p</tt>. Returns an iterator referring to the element that was added.</p>
              <p class="docText">在迭代器 <tt>p</tt> 所指向的元素前面插入值为 <tt>t</tt> 的新元素。返回指向新添加元素的迭代器</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.insert(p,n,t)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Inserts <tt>n</tt> elements with value <tt>t</tt> before the element referred to by iterator <tt>p</tt>. Returns <tt>void</tt>.</p>
              <p class="docText">在迭代器 <tt>p</tt> 所指向的元素前面插入 <tt>n</tt> 个值为 <tt>t</tt> 的新元素。返回 <tt>void</tt> 类型</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.insert(p,b,e)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Inserts elements in the range denoted by iterators <tt>b</tt> and <tt>e</tt> before the element referred to by iterator <tt>p</tt>. Returns <tt>void</tt>.</p>
              <p class="docText">在迭代器 <tt>p</tt> 所指向的元素前面插入由迭代器 <tt>b</tt> 和 <tt>e</tt> 标记的范围内的元素。返回 <tt>void</tt> 类型</p>
            </td>
          </tr>
        </table><br>
        <a name="ch09lev3sec7"></a>

        <h5 class="docSection3Title">Adding Elements at a Specified Point in the Container</h5>
        <h5 class="docSection3Title">在容器中指定位置添加元素</h5>

	<a name="idd1e66317"></a><a name="idd1e66323"></a><a name="idd1e66330"></a><a name="idd1e66336"></a><a name="idd1e66343"></a><a name="idd1e66349"></a>
        <p class="docText">The <tt>push_back</tt> and <tt>push_front</tt> operations provide convenient ways to insert a single element at the end or beginning of a sequential container. More generally, <tt>insert</tt> allows us to insert elements at any particular point in the container. There are three versions of <tt>insert</tt>. The first takes an iterator and an element value. The iterator refers to the position at which to insert the value. We could use this version of <tt>insert</tt> to insert an element at the beginning of a container:</p>
        <p class="docText">使用 <tt>push_back</tt> 和 <tt>push_front</tt> 操作可以非常方便地在顺序容器的尾部或首部添加单个元素。而 <tt>insert</tt> 操作则提供了一组更通用的插入方法，实现在容器的任意指定位置插入新元素。<tt>insert</tt> 操作有三个版本（<a class="docLink" href="ch09lev1sec3.html#ch09table07">表 9.7</a>）。第一个版本需要一个迭代器和一个元素值参数，迭代器指向插入新元素的位置。下面的程序就是使用了这个版本的 <tt>insert</tt> 函数在容器首部插入新元素：</p>
        <pre>
     vector&lt;string&gt; svec;
     list&lt;string&gt; slist;
     string spouse("Beth");

     // <span class="docEmphItalicAlt">equivalent to calling</span> <span class="docEmphasis">slist.push_front (spouse);</span>
     slist.insert(slist.begin(), spouse);

     // <span class="docEmphItalicAlt">no</span> <span class="docEmphasis">push_front</span> <span class="docEmphItalicAlt">on</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">but we can</span> <span class="docEmphasis">insert</span> <span class="docEmphItalicAlt">before</span> <span class="docEmphasis">begin()</span>
     // <span class="docEmphasis">warning: inserting anywhere but at the end of a</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">is an expensive operation</span>
     svec.insert(svec.begin(), spouse);
</pre><br>

        <p class="docText">The value is inserted <span class="docEmphasis">before</span> the position referred to by the iterator. The iterator can refer to any position in the container, including one past the end of the container. Because the iterator might refer to a nonexistent element off the end of the container, <tt>insert</tt> inserts before the position rather than after it. This code</p>
        <p class="docText">新元素是插入在迭代器指向的位置之前。迭代器可以指向容器的任意位置，包括超出末端的下一位置。由于迭代器可能指向超出容器末端的下一位置，这是一个不存在的元素，因此 <tt>insert</tt> 函数是在其指向位置之前而非其后插入元素。代码</p>
        <pre>
     slist.insert(iter, spouse); // <span class="docEmphItalicAlt">insert</span> <span class="docEmphasis">spouse</span> <span class="docEmphItalicAlt">just before</span> <span class="docEmphasis">iter</span>
</pre><br>

        <p class="docText">inserts a copy of <tt>spouse</tt> just before the element referred to by <tt>iter</tt>.</p>
        <p class="docText">就在 <tt>iter</tt> 指向的元素前面插入 <tt>spouse</tt> 的副本。</p>

        <p class="docText">This version of <tt>insert</tt> returns an iterator referring to the newly inserted element. We could use the return value to repeatedly insert elements at a specified position in the container:</p>
        <p class="docText">这个版本的 <tt>insert</tt> 函数返回指向新插入元素的迭代器。可使用该返回值在容器中的指定位置重复插入元素：</p>
        <pre>
     list&lt;string&gt; lst;
     list&lt;string&gt;::iterator iter = lst.begin();
     while (cin &gt;&gt; word)
        iter = lst.insert(iter, word); // <span class="docEmphItalicAlt">same as calling</span> <span class="docEmphasis">push_front</span>
</pre><br>
        <a name="ch09note09"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
		<a name="idd1e66475"></a><a name="idd1e66484"></a><a name="idd1e66490"></a><a name="idd1e66496"></a>
                <p class="docText">要彻底地理解上述循环是如何执行的，这一点非常重要——特别是要明白我们为什么说上述循环等效于调用 <tt>push_front</tt> 函数。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Before the loop, we initialize <tt>iter</tt> to <tt>lst.begin()</tt>. Because the <tt>list</tt> is empty, <tt>lst.begin()</tt> and <tt>lst.end()</tt> are equal, so <tt>iter</tt> refers one past the end of the (empty) <tt>list</tt>. The first call to <tt>insert</tt> puts the element we just read in front of the element referred to by <tt>iter</tt>. The value returned by <tt>insert</tt> is an iterator referring to this new element, which is now the first, and only, element in <tt>lst</tt>. We assign that iterator to <tt>iter</tt> and repeat the <tt>while</tt>, reading another word. As long as there are words to insert, each trip through the <tt>while</tt> inserts a new element ahead of <tt>iter</tt> and reassigns to <tt>iter</tt> the value of the newly inserted element. That element is always the first element, so each iteration inserts an element ahead of the first element in the <tt>list</tt>.</p><a name="ch09lev3sec8"></a>
        <p class="docText">循环前，将 <tt>iter</tt> 初始化为 <tt>lst.begin()</tt>。此时，由于该 <tt>list</tt> 对象是空的，因此 <tt>lst.begin()</tt> 与 <tt>lst.end()</tt> 相等，于是 <tt>iter</tt> 指向该（空）容器的超出末端的下一位置。第一次调用 <tt>insert</tt> 函数时，将刚读入的元素插入到 <tt>iter</tt> 所指向位置的前面，容器 <tt>lst</tt> 得到第一个也是唯一的元素。然后 <tt>insert</tt> 函数返回指向这个新元素的迭代器，并赋给 <tt>iter</tt>，接着重复 <tt>while</tt> 循环，读入下一个单词。只要有单词要插入，每次 <tt>while</tt> 循环都将新元素插入到 <tt>iter</tt> 前面，然后重置 <tt>iter</tt> 指向新插入元素。新插入的元素总是容器中的第一个元素，因此，每次迭代器都将元素插入在该 <tt>list</tt> 对象的第一元素前面。</p>

        <h5 class="docSection3Title">Inserting a Range of Elements</h5>
        <h5 class="docSection3Title">插入一段元素</h5>

        <p class="docText">A second form of <tt>insert</tt> adds a specified number of identical elements at an indicated position:</p>
        <p class="docText"><tt>insert</tt> 函数的第二个版本提供在指定位置插入指定数量的相同元素的功能：</p>
        <pre>
     svec.insert(svec.end(), 10, "Anna");
</pre><br>

        <p class="docText">This code inserts ten elements at the end of <tt>svec</tt> and initializes each of those elements to the <tt>string "Anna"</tt>.</p>
        <p class="docText">上述代码在容器 <tt>svec</tt> 的尾部插入 10 个元素，每个新元素都初始化为 <tt>"Anna"</tt>。</p>

        <p class="docText">The final form of <tt>insert</tt> adds a range of elements denoted by an iterator pair into the container. For example, given the following array of <tt>string</tt>s</p>
        <p class="docText"><tt>insert</tt> 函数的最后一个版本实现在容器中插入由一对迭代器标记的一段范围内的元素。例如，给出以下 <tt>string</tt> 类型的数组：</p>
        <pre>
     string sarray[4] = {"quasi", "simba", "frollo", "scar"};
</pre><br>

        <p class="docText">we can insert all or a subset of the array elements into our <tt>list</tt> of <tt>string</tt>s:</p>
        <p class="docText">可将该数组中所有的或其中一部分元素插入到 <tt>string</tt> 类型的 <tt>list</tt> 容器中：</p>
        <pre>
     // <span class="docEmphItalicAlt">insert all the elements in</span> <span class="docEmphasis">sarray</span> <span class="docEmphItalicAlt">at end of</span> <span class="docEmphasis">slist</span>
     slist.insert(slist.end(), sarray, sarray+4);
     list&lt;string&gt;::iterator slist_iter = slist.begin();
     // <span class="docEmphItalicAlt">insert last two elements of</span> <span class="docEmphasis">sarray</span> <span class="docEmphItalicAlt">before</span> <span class="docEmphasis">slist_iter</span>
     slist.insert(slist_iter, sarray+2, sarray+4);
</pre><br>
        <a name="ch09lev3sec9"></a>

        <h5 class="docSection3Title">Inserting Elements Can Invalidate Iterators</h5>
        <h5 class="docSection3Title">添加元素可能会使迭代器失效</h5>

        <p class="docText">As we'll see in <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4" >Section 9.4</a> (p. <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4" >330</a>), adding elements to a <tt>vector</tt> can cause the entire container to be relocated. If the container is relocated, then all iterators into the container are invalidated. Even if the <tt>vector</tt> does not have to be relocated, any iterator to an element after the one inserted is invalidated.</p><a name="ch09note10"></a>
        <p class="docText">正如我们在<a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4" >第 9.4 节</a>中了解的一样，在 <tt>vector</tt> 容器中添加元素可能会导致整个容器的重新加载，这样的话，该容器涉及的所有迭代器都会失效。即使需要重新加载整个容器，指向新插入元素后面的那个元素的迭代器也会失效。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Iterators may be invalidated after doing any <tt>insert</tt> or <tt>push</tt> operation on a <tt>vector</tt> or <tt>deque</tt>. When writing loops that <tt>insert</tt> elements into a <tt>vector</tt> or a <tt>deque</tt>, the program must ensure that the iterator is refreshed on each trip through the loop.</p>
                <p class="docText">任何 <tt>insert</tt> 或 <tt>push</tt> 操作都可能导致迭代器失效。当编写循环将元素插入到 <tt>vector</tt> 或 <tt>deque</tt> 容器中时，程序必须确保迭代器在每次循环后都得到更新。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch09lev3sec10"></a>

        <h5 class="docSection3Title">Avoid Storing the Iterator Returned from <tt>end</tt></h5>
        <h5 class="docSection3Title">避免存储 <tt>end</tt> 操作返回的迭代器</h5>

	<a name="idd1e66710"></a><a name="idd1e66715"></a><a name="idd1e66724"></a><a name="idd1e66733"></a><a name="idd1e66739"></a><a name="idd1e66747"></a><a name="idd1e66755"></a><a name="idd1e66763"></a><a name="idd1e66769"></a><a name="idd1e66774"></a><a name="idd1e66779"></a><a name="idd1e66788"></a>
        <p class="docText">When we add elements to a <tt>vector</tt> or <tt>deque</tt>, some or all of the iterators may be invalidated. It is safest to assume that all iterators are invalid. This advice is particularly true for the iterator returned by <tt>end</tt>. That iterator is <span class="docEmphasis">always</span> invalidated by any insertion anywhere in the container.</p>
        <p class="docText">在 <tt>vector</tt> 或 <tt>deque</tt> 容器中添加元素时，可能会导致某些或全部迭代器失效。假设所有迭代器失效是最安全的做法。这个建议特别适用于由 <tt>end</tt> 操作返回的迭代器。在容器的任何位置插入任何元素都会使该迭代器失效。</p>

        <p class="docText">As an example, consider a loop that reads each element, processes it and adds a new element following the original. We want the loop to process each original element. We'll use the form of <tt>insert</tt> that takes a single value and returns an iterator to the element that was just inserted. After each insertion, we'll increment the iterator that is returned so that the loop is positioned to operate on the next original element. If we attempt to "optimize" the loop, by storing an iterator to the <tt>end()</tt>, we'll have a disaster:</p>
        <p class="docText">例如，考虑一个读取容器中每个元素的循环，对读出元素做完处理后，在原始元素后面插入一个新元素。我们希望该循环可以处理每个原始元素，然后使用 <tt>insert</tt> 函数插入新元素，并返回指向刚插入元素的迭代器。在每次插入操作完成后，给返回的迭代器自增 1，以使循环定位在下一个要处理的原始元素。如果我们尝试通过存储 <tt>end()</tt> 操作返回的迭代器来“优化”该循环，将导致灾难性错误：</p>
        <pre>
     vector&lt;int&gt;::iterator first = v.begin(),
                           last = v.end(); // <span class="docEmphItalicAlt">cache end iterator</span>
     // <span class="docEmphItalicAlt">diaster: behavior of this loop is undefined</span>
     while (first != last) {
         // <span class="docEmphItalicAlt">do some processing</span>
         // <span class="docEmphItalicAlt">insert new value and reassign</span> <span class="docEmphasis">first</span>, <span class="docEmphItalicAlt">which otherwise would be invalid</span>
         first = v.insert(first, 42);
         ++first;  // <span class="docEmphItalicAlt">advance</span> <span class="docEmphasis">first</span> <span class="docEmphItalicAlt">just past the element we added</span>
      }
</pre><br>

        <p class="docText">The behavior of this code is undefined. On many implementations, we'll get an infinite loop. The problem is that we stored the value returned by the <tt>end</tt> operation in a local variable named <tt>last</tt>. In the body of the loop, we add an element. Adding an element invalidates the iterator stored in <tt>last</tt>. That iterator neither refers to an element in <tt>v</tt> nor any longer refers to one past the last element in <tt>v</tt>.</p><a name="ch09note11"></a>
        <p class="docText">上述代码的行为未定义。在很多实现中，该段代码将导致死循环。问题在于这个程序将 <tt>end</tt> 操作返回的迭代器值存储在名为 <tt>last</tt> 的局部变量中。循环体中实现了元素的添加运算，添加元素会使得存储在 <tt>last</tt> 中的迭代器失效。该迭代器既没有指向容器 <tt>v</tt> 的元素，也不再指向 <tt>v</tt> 的超出末端的下一位置。</p>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="84" height="51" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Don't cache the iterator returned from <tt>end</tt>. Inserting or deleting elements in a <tt>deque</tt> or <tt>vector</tt> will invalidate the cached iterator.</p>
                <p class="docText">不要存储 <tt>end</tt> 操作返回的迭代器。添加或删除 <tt>deque</tt> 或 <tt>vector</tt> 容器内的元素都会导致存储的迭代器失效。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Rather than storing the <tt>end</tt> iterator, we must recompute it after each insertion:</p>
        <p class="docText">为了避免存储 <tt>end</tt> 迭代器，可以在每次做完插入运算后重新计算 <tt>end</tt> 迭代器值：</p>

        <pre>
     // <span class="docEmphItalicAlt">safer: recalculate</span> <span class="docEmphasis">end</span> <span class="docEmphItalicAlt">on each trip whenever the loop adds/erases elements</span>
     while (first != v.end()) {
         // <span class="docEmphItalicAlt">do some processing</span>
         first = v.insert(first, 42); // <span class="docEmphItalicAlt">insert new value</span>
         ++first; // <span class="docEmphItalicAlt">advance</span> <span class="docEmphasis">first</span> <span class="docEmphItalicAlt">just past the element we added</span>
     }
</pre><br>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 9.3.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa6q1"></a><b>Exercise 9.18:</b></td>

                    <td>
			<a name="idd1e66969"></a><a name="idd1e66976"></a><a name="idd1e66983"></a><a name="idd1e66991"></a><a name="idd1e66999"></a><a name="idd1e67007"></a>
			<p class="docText">Write a program to copy elements from a <tt>list</tt> of <tt>int</tt>s into two <tt>deque</tt>s. The <tt>list</tt> elements that are even should go into one <tt>deque</tt> and those that are odd into the second.</p>
			<p class="docText">编写程序将 <tt>int</tt> 型的 <tt>list</tt> 容器的所有元素复制到两个 <tt>deque</tt> 容器中。<tt>list</tt> 容器的元素如果为偶数，则复制到一个 <tt>deque</tt> 容器中；如果为奇数，则复制到另一个 <tt>deque</tt> 容器里。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa6q2"></a><b>Exercise 9.19:</b></td>

                    <td>
                      <p class="docText">Assuming <tt>iv</tt> is a <tt>vector</tt> of <tt>int</tt>s, what is wrong with the following program? How might you correct the problem(s)?</p>
                      <p class="docText">假设 <tt>iv</tt> 是一个 <tt>int</tt> 型的 <tt>vector</tt> 容器，下列程序存在什么错误？如何改正之。</p>
                      <pre>
     vector&lt;int&gt;::iterator mid = iv.begin() + iv.size()/2;
     while (vector&lt;int&gt;::iterator iter != mid)
         if (iter == some_val)
             iv.insert(iter, 2 * some_val);
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>


        <a name="ch09lev2sec9"></a>
        <h4 class="docSection2Title">9.3.4. Relational Operators</h4>
        <h4 class="docSection2Title">9.3.4. 关系操作符</h4>

        <p class="docText">Each container supports the relational operators (<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2" >Section 5.2</a>, p. <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2" >152</a>) that can be used to compare two containers. The containers must be the same kind of container and must hold elements of the same type. We can compare a <tt>vector&lt;int&gt;</tt> only with another <tt>vector&lt;int&gt;</tt>. We cannot compare a <tt>vector&lt;int&gt;</tt> with a <tt>list&lt;int&gt;</tt> or a <tt>vector&lt;double&gt;</tt>.</p><a name="ch09sb08"></a>
	<p class="docText">所有的容器类型都支持用关系操作符（<a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2" >第 5.2 节</a>）来实现两个容器的比较。显比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。例如，<tt>vector&lt;int&gt;</tt> 容器只能与 <tt>vector&lt;int&gt;</tt> 容器比较，而不能与 <tt>list&lt;int&gt;</tt> 或 <tt>vector&lt;int&gt;</tt> 容器比较，而不能与 <tt>list&lt;int&gt;</tt> 或 <tt>vector&lt;double&gt;</tt> 类型的容器比较。</p>

        <p class="docText">Comparing two containers is based on a pairwise comparison of the elements of the containers. The comparison uses the same relational operator as defined by the element type: Comparing two containers using <tt>!=</tt> uses the <tt>!=</tt> operator for the element type. If the element type doesn't support the operator, then the containers cannot be compared using that operator.</p>
        <p class="docText">容器的比较是基于容器内元素的比较。容器的比较使用了元素类型定义的同一个关系操作符：两个容器做 <tt>!=</tt> 比较使用了其元素类型定义的 <tt>!=</tt> 操作符。如果容器的元素类型不支持某种操作符，则该容器就不能做这种比较运算。</p>

        <p class="docText">These operators work similarly to the <tt>string</tt> relationals (<a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4" >Section 3.2.3</a>, p. <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4" >85</a>):</p>
        <p class="docText">下面的操作类似于 <tt>string</tt> 类型的关系运算（<a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4" >第 3.2.3 节</a>）：</p>

        <ul>
          <li>
            <p class="docList">If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.</p>
            <p class="docList">如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相等；否则，它们就不相等。</p>
          </li>

          <li>
            <p class="docList">If the containers have different sizes but every element of the shorter one is equal to the corresponding element of the longer one, then the shorter one is considered to be less than the other.</p>
            <p class="docList">如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中对应的元素，则称较短的容器小于另一个容器。</p>
          </li>

          <li>
            <p class="docList">If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.</p>
            <p class="docList">如果两个容器都不是对文的初始子序列，则它们的比较结果取决于所比较的第一个不相等的元素。</p>
          </li>
        </ul>

        <p class="docText">The easiest way to understand these operators is by studying examples:</p>
        <p class="docText">理解上述操作的最简单方法是研究例程：</p>
        <pre>
     /*
                  ivec1: 1 3 5 7 9 12
                  ivec2: 0 2 4 6 8 10 12
                  ivec3: 1 3 9
                  ivec4: 1 3 5 7
                  ivec5: 1 3 5 7 9 12
     */
     // <span class="docEmphasis">ivec1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ivec2</span> <span class="docEmphItalicAlt">differ at</span> <span class="docEmphasis">element[0]: ivec1</span> <span class="docEmphItalicAlt">greater than</span> <span class="docEmphasis">ivec2</span>
     ivec1 &lt; ivec2 // <span class="docEmphasis">false</span>
     ivec2 &lt; ivec1 // <span class="docEmphasis">true</span>

     // <span class="docEmphasis">ivec1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ivec3</span> <span class="docEmphItalicAlt">differ at</span> <span class="docEmphasis">element[2]: ivec1</span> <span class="docEmphItalicAlt">less than</span> <span class="docEmphasis">ivec3</span>
     ivec1 &lt; ivec3 // <span class="docEmphasis">true</span>

     // <span class="docEmphItalicAlt">all elements equal, but</span> <span class="docEmphasis">ivec4</span> <span class="docEmphItalicAlt">has fewer elements, so</span> <span class="docEmphasis">ivec1</span> <span class="docEmphItalicAlt">is greater than</span> <span class="docEmphasis">ivec4</span>
     ivec1 &lt; ivec4 // <span class="docEmphasis">false</span>

     ivec1 == ivec5 // <span class="docEmphasis">true;</span> <span class="docEmphItalicAlt">each element equal and same number of elements</span>
     ivec1 == ivec4 // <span class="docEmphasis">false; ivec4</span> <span class="docEmphItalicAlt">has fewer elements than</span> <span class="docEmphasis">ivec1</span>
     ivec1 != ivec4 // <span class="docEmphasis">true; ivec4</span> <span class="docEmphItalicAlt">has fewer elements than</span> <span class="docEmphasis">ivec1</span>
</pre><br>
        <a name="ch09lev3sec11"></a>

        <h5 class="docSection3Title">Relational Operators Use Their Element's Relational Operator</h5><a name="ch09note12"></a>
        <h5 class="docSection3Title">使用元素提供的关系操作符实现容器的关系运算</h5>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
		<a name="idd1e67215"></a><a name="idd1e67220"></a><a name="idd1e67225"></a><a name="idd1e67231"></a><a name="idd1e67237"></a><a name="idd1e67243"></a><a name="idd1e67250"></a><a name="idd1e67257"></a><a name="idd1e67264"></a><a name="idd1e67270"></a><a name="idd1e67276"></a><a name="idd1e67283"></a><a name="idd1e67290"></a><a name="idd1e67297"></a><a name="idd1e67302"></a><a name="idd1e67307"></a><a name="idd1e67313"></a><a name="idd1e67319"></a><a name="idd1e67325"></a><a name="idd1e67331"></a><a name="idd1e67337"></a><a name="idd1e67344"></a><a name="idd1e67351"></a>		      
                <p class="docText">We can compare two containers only if the same relational operator defined for the element types.</p>
                <p class="docText">C++ 语言只允许两个容器做其元素类型定义的关系运算。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">Each container relational operator executes by comparing pairs of elements from the two containers:</p>
        <p class="docText">所有容器都通过比较其元素对来实现关系运算：</p>
        <pre>
     ivec1 &lt; ivec2
</pre><br>

        <p class="docText">Assuming <tt>ivec1</tt> and <tt>ivec2</tt> are <tt>vector&lt;int&gt;</tt>, then this comparison uses the built-in <tt>int</tt> less-than operator. If the <tt>vector</tt>s held <tt>strings</tt>, then the <tt>string</tt> less-than operator would be used.</p>
        <p class="docText">假设 <tt>ivec1</tt> 和 <tt>ivec2</tt> 都是 <tt>vector&lt;int&gt;</tt> 类型的容器，则上述比较使用了内置 <tt>int</tt> 型定义的小于操作符。如果这两个 <tt>vector</tt> 容器存储的是 <tt>strings</tt> 对象，则使用 <tt>string</tt> 类型的小于操作符。</p>

        <p class="docText">If the <tt>vector</tt>s held objects of the <tt>Sales_item</tt> type that we used in <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5" >Section 1.5</a> (p. <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5" >20</a>), then the comparison would be illegal. We did not define the relational operators for <tt>Sales_item</tt>. If we have two containers of <tt>Sales_items</tt>, we could not compare them:</p>
        <p class="docText">如果上述 <tt>vector</tt> 容器存储 <a class="docLink" href="ch01lev1sec5.html#ch01lev1sec5" >第 1.5 节</a>定义的 <tt>Sales_item</tt> 类型的对象，则该比较运算不合法。因为 <tt>Sales_item</tt> 类型没有定义关系运算，所以不能比较存放 <tt>Sales_items</tt> 对象的容器：</p>
        <pre>
     vector&lt;Sales_item&gt; storeA;
     vector&lt;Sales_item&gt; storeB;

     if (storeA &lt; storeB) // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">Sales_item</span> <span class="docEmphItalicAlt">has no less-than operator</span>
</pre><br>
        <a name="ch09sb09"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 9.3.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa7q3"></a><b>Exercise 9.20:</b></td>

                    <td>
                      <p class="docText">Write a program to compare whether a <tt>vector&lt;int&gt;</tt> contains the same elements as a <tt>list&lt;int&gt;</tt>.</p>
                      <p class="docText">编写程序判断一个 <tt>vector&lt;int&gt;</tt> 容器所包含的元素是否与一个 <tt>list&lt;int&gt;</tt> 容器的完全相同。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa7q4"></a><b>Exercise 9.21:</b></td>

                    <td>
                      <p class="docText">Assuming <tt>c1</tt> and <tt>c2</tt> are containers, what constraints does the following usage place on the element types in <tt>c1</tt> and <tt>c2</tt>?</p>
                      <p class="docText">假设 <tt>c1</tt> 和 <tt>c2</tt> 都是容器，下列用法给 <tt>c1</tt> 和 <tt>c2</tt> 的元素类型带来什么约束？</p>
                      <pre>
     if (c1 &lt; c2)
</pre><br>

                      <p class="docText">What, if any, constraints are there on <tt>c1</tt> and <tt>c2</tt>?</p>
                      <p class="docText">（如果有的话）对 <tt>c1</tt> 和 <tt>c2</tt> 的约束又是什么？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch09lev2sec10"></a>

        <h4 class="docSection2Title">9.3.5. Container Size Operations</h4>
        <h4 class="docSection2Title">9.3.5. 容器大小的操作</h4>

        <p class="docText">Each container type supports four size-related operations. We used <tt>size</tt> and <tt>empty</tt> in <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4" >Section 3.2.3</a> (p. <a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4" >83</a>): <tt>size</tt> returns the number of elements in the container; <tt>empty</tt> returns a <tt>bool</tt> that is <tt>true</tt> if <tt>size</tt> is zero and <tt>false</tt> otherwise.</p>
	<p class="docText">所有容器类型都提供四种与容器大小相关的操作（<a class="docLink" href="ch09lev1sec3.html#ch09table08" >表 9.8</a>）<a class="docLink" href="ch03lev1sec2.html#ch03lev2sec4" >第 3.2.3 节</a>已经使用了 <tt>size</tt> 和 <tt>empty</tt> 函数：<tt>size</tt> 操作返回容器内元素的个数：<tt>empty</tt> 操作则返回一个布尔值，当容器的大小为 0 时，返回值为 <tt>true</tt>，否则为 <tt>false</tt>。</p>

        <a name="ch09table08"></a>
        <h5 class="docTableTitle">Table 9.8. Sequential Container Size Operations</h5>
        <h5 class="docTableTitle">表 9.8. 顺序容器的大小操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.size()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns the number of elements in <tt>c</tt>. Return type is <tt>c::size_type</tt>.</p>
              <p class="docText">返回容器 <tt>c</tt> 中的元素个数。返回类型为 <tt>c::size_type</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.max_size()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns maximum number of elements <tt>c</tt> can contain. Return type is <tt>c::size_type</tt>.</p>
              <p class="docText">返回容器 <tt>c</tt> 可容纳的最多元素个数，返回类型为 <tt>c::size_type</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.empty()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns a <tt>bool</tt> that indicates whether <tt>size</tt> is 0 or not.</p>
              <p class="docText">返回标记容器大小是否为 0 的布尔值</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.resize(n)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Resize <tt>c</tt> so that it has <tt>n</tt> elements. If <tt>N &lt; c.size()</tt>, the excess elements are discarded. If new elements must be added, they are value initialized.</p>
              <p class="docText">调整容器 <tt>c</tt> 的长度大小，使其能容纳 <tt>n</tt> 个元素，如果 <tt>n &lt; c.size()</tt>，则删除多出来的元素；否则，添加采用值初始化的新元素</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.resize(n,t)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Resize <tt>c</tt> to have <tt>n</tt> elements. Any elements added have value <tt>t</tt>.</p>
              <p class="docText">调整容器 <tt>c</tt> 的长度大小，使其能容纳 <tt>n</tt> 个元素。所有新添加的元素值都为 <tt>t</tt></p>
            </td>
          </tr>
  </table><br>

	<p class="docText">The <tt>resize</tt> operation changes the number of elements in the container. If the current size is greater than the new size, then elements are deleted from the back of the container. If the current size is less than the new size, then elements are added to the back of the container:</p>
        <p class="docText">容器类型提供 <tt>resize</tt> 操作来改变容器所包含的元素个数。如果当前的容器长度大于新的长度值，则该容器后部的元素会被删除；如果当前的容器长度小于新的长度值，则系统会在该容器后部添加新元素：</p>
        <pre>
     list&lt;int&gt; ilist(10, 42);   // <span class="docEmphItalicAlt">10</span> <span class="docEmphasis">ints:</span> <span class="docEmphItalicAlt">each has value</span> <span class="docEmphasis">42</span>

     ilist.resize(15);          // <span class="docEmphItalicAlt">adds 5 elements of value</span> <span class="docEmphasis">0</span> <span class="docEmphItalicAlt">to back of</span> <span class="docEmphasis">ilist</span>

     ilist.resize(25, -1);      // <span class="docEmphItalicAlt">adds 10 elements of value</span> <span class="docEmphasis">-1</span> <span class="docEmphItalicAlt">to back of</span> <span class="docEmphasis">ilist</span>

     ilist.resize(5);           // <span class="docEmphItalicAlt">erases 20 elements from the back of</span> <span class="docEmphasis">ilist</span>
</pre><br>
	<a name="idd1e67595"></a><a name="idd1e67601"></a><a name="idd1e67608"></a><a name="idd1e67615"></a><a name="idd1e67621"></a><a name="idd1e67629"></a><a name="idd1e67636"></a><a name="idd1e67643"></a><a name="idd1e67649"></a><a name="idd1e67655"></a><a name="idd1e67662"></a><a name="idd1e67669"></a>
        <p class="docText">The <tt>resize</tt> operation takes an optional element-value argument. If this argument is present, then any newly added elements receive this value. If this argument is absent, then any new elements are value initialized (<a class="docLink" href="ch03lev1sec3.html#ch03lev2sec6" >Section 3.3.1</a>, p. <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec6" >92</a>).</p><a name="ch09note13"></a>
	<p class="docText"><tt>resize</tt> 操作可带有一个可选的元素值形参。如果在调用该函数时提供了这个参数，则所有新添加的元素都初始化为这个值。如果没有这个参数，则新添加的元素采用值初始化（<a class="docLink" href="ch03lev1sec3.html#ch03lev2sec6" >第 3.3.1 节</a>）。</p>
        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText"><tt>resize</tt> can invalidate iterators. A <tt>resize</tt> operation on a <tt>vector</tt> or <tt>deque</tt> potentially invalidates all iterators.</p>
		<p class="docText"><tt>resize</tt> 操作可能会使迭代器失效。在 <tt>vector</tt> 或 <tt>deque</tt> 容器上做 <tt>resize</tt> 操作有可能会使其所有的迭代器都失效。</p>
              </td>
            </tr>
          </table><br>

          <p class="docText">For any container type, if <tt>resize</tt> shrinks the container, then any iterator to an element that is deleted is invalidated.</p>
	  <p class="docText">对于所有的容器类型，如果 <tt>resize</tt> 操作压缩了容器，则指向已删除的元素迭代器失效。</p>
        </div><br>

        <a name="ch09sb10"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 9.3.5</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa8q1"></a><b>Exercise 9.22:</b></td>

                    <td>
                      <p class="docText">Given that <tt>vec</tt> holds 25 elements, what does <tt>vec.resize(100)</tt> do? What if we next wrote <tt>vec.resize(10)?</tt></p>
                      <p class="docText">已知容器 <tt>vec</tt> 存放了 25 个元素，那么 <tt>vec.resize(100)</tt> 操作实现了什么功能？若再做操作 <tt>vec.resize(10)</tt>，实现的又是什么功能？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa8q2"></a><b>Exercise 9.23:</b></td>

                    <td>
                      <p class="docText">What, if any, restrictions does using <tt>resize</tt> with a single size argument place on the element types?</p>
                      <p class="docText">使用只带有一个长度参数的 <tt>resize</tt> 操作对元素类型有什么要求（如果有的话）？</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch09lev2sec11"></a>

        <h4 class="docSection2Title">9.3.6. Accessing Elements</h4>
        <h4 class="docSection2Title">9.3.6. 访问元素</h4>

        <p class="docText">If a container is not empty, then the <tt>front</tt> and <tt>back</tt> members return references bound to the first or last elements in the container:</p>
        <p class="docText">如果容器非空，那么容器类型的 <tt>front</tt> 和 <tt>back</tt> 成员（<a class="docLink" href="ch09lev1sec3.html#ch09table09" >表 9.9</a>）将返回容器内第一个或最后一个元素的引用：</p>
        <pre>
     // <span class="docEmphItalicAlt">check that there are elements before dereferencing an iterator</span>
     // <span class="docEmphItalicAlt">or calling</span> <span class="docEmphasis">front</span> <span class="docEmphItalicAlt">or</span> <span class="docEmphasis">back</span>
     if (!ilist.empty()) {
         // <span class="docEmphasis">val</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">val2</span> <span class="docEmphItalicAlt">refer to the same element</span>
         list&lt;int&gt;::reference val = *ilist.begin();
         list&lt;int&gt;::reference val2 = ilist.front();

         // <span class="docEmphasis">last</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">last2</span> <span class="docEmphItalicAlt">refer to the same element</span>
         list&lt;int&gt;::reference last = *--ilist.end();
         list&lt;int&gt;::reference last2 = ilist.back(); }
</pre><br>

        <a name="ch09table09"></a>

        <h5 class="docTableTitle">Table 9.9. Operations to Access Elements in a Sequential Container</h5>
        <h5 class="docTableTitle">表 9.9. 访问顺序容器内元素的操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.back()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns a reference to the last element in <tt>c</tt>. Undefined if <tt>c</tt> is empty.</p>
              <p class="docText">返回容器 <tt>c</tt> 的最后一个元素的引用。如果 <tt>c</tt> 为空，则该操作未定义</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.front()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns a reference to the first element in <tt>c</tt>. Undefined if <tt>c</tt> is empty.</p>
              <p class="docText">返回容器 <tt>c</tt> 的第一个元素的引用。如果 <tt>c</tt> 为空，则该操作未定义</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c[n]</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns a reference to the element indexed by <tt>n</tt>.</p>
              <p class="docText">返回下标为 <tt>n</tt> 的元素的引用</p>

              <p class="docText">Undefined if <tt>n &lt;0</tt> or <tt>n &gt;= c.size()</tt>.</p>
              <p class="docText">如果 <tt>n &lt;0</tt> 或 <tt>n &gt;= c.size()</tt>，则该操作未定义</p>

              <p class="docText"><span class="docEmphStrong">Valid only for <tt>vector</tt> and <tt>deque</tt></span>.</p>
              <p class="docText"><span class="docEmphStrong">只适用于 <tt>vector</tt> 和 <tt>deque</tt> 容器</span></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.at(n)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Returns a reference to the element indexed by <tt>n</tt>. If index is out of range, throws <tt>out_of_range</tt> exception.</p>
              <p class="docText">返回下标为 <tt>n</tt> 的元素的引用。如果下标越界，则该操作未定义</p>

              <p class="docText"><span class="docEmphStrong">Valid only for <tt>vector</tt> and <tt>deque</tt></span>.</p>
              <p class="docText"><span class="docEmphStrong">只适用于 <tt>vector</tt> 和 <tt>deque</tt> 容器</span></p>
            </td>
          </tr>
        </table><br>

	<a name="idd1e67931"></a><a name="idd1e67939"></a><a name="idd1e67947"></a><a name="idd1e67954"></a><a name="idd1e67961"></a><a name="idd1e67968"></a><a name="idd1e67977"></a><a name="idd1e67991"></a><a name="idd1e68005"></a><a name="idd1e68010"></a><a name="idd1e68019"></a><a name="idd1e68028"></a><a name="idd1e68035"></a>
        <p class="docText">This program uses two different approaches to fetch a reference to the first and last elements in <tt>ilist</tt>. The direct approach is to call <tt>front</tt> or <tt>back</tt>. Indirectly, we can obtain a reference to the same element by dereferencing the iterator returned by <tt>begin</tt> or the element one before the iterator returned by <tt>end</tt>. Two things are noteworthy in this program: The <tt>end</tt> iterator refers "one past the end" of the container so to fetch the last element we must first decrement that iterator. The other important point is that before calling <tt>front</tt> or <tt>back</tt> or dereferencing the iterators from <tt>begin</tt> or <tt>end</tt> we check that <tt>ilist</tt> isn't empty. If the list were empty all of the operations in the <tt>if</tt> would be undefined.</p>
	<p class="docText">这段程序使用了两种不同的方法获取时 <tt>ilist</tt> 中的第一个和最后一个元素的引用。直接的方法是调用 <tt>front</tt> 或 <tt>back</tt> 函数。间接的方法是，通过对 <tt>begin</tt> 操作返回的迭代器进行解引用，或对 <tt>end</tt> 操作返回的迭代器的前一个元素位置进行解引用，来获取对同一元素的引用。在这段程序中，有两个地方值得注意：<tt>end</tt> 迭代器指向容器的超出末端的下一位置，因此必须先对其减 1 才能获取最后一个元素；另一点是，在调用 <tt>front</tt> 或 <tt>back</tt> 函数之前，或者在对 <tt>begin</tt> 或 <tt>end</tt> 返回的迭代器进行解引用运算之前，必须保证　<tt>ilist</tt> 容器非空。如果该 <tt>list</tt> 容器为空，则 <tt>if</tt> 语句内所有的操作都没有定义。</p>

        <p class="docText">When we introduced subscripting in <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7" >Section 3.3.2</a> (p. <a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7" >94</a>), we noted that the programmer must ensure that an element exists at the indicated subscript location. The subscript operator itself does not check. The same caution applies to using the <tt>front</tt> or <tt>back</tt> operations. If the container is empty, these operations yield an undefined result. If the container has only one element, then <tt>front</tt> and <tt>back</tt> each return a reference to that element.</p><a name="ch09note14"></a>
        <p class="docText"><a class="docLink" href="ch03lev1sec3.html#ch03lev2sec7" >第 3.3.2 节</a>介绍了下标运算，我们注意到程序员必须保证在指定下标位置上的元素确实存在。下标操作符本身不会做相关的检查。使用 <tt>front</tt> 或 <tt>back</tt> 运算时，必须注意同样的问题。如果容器为空，那么这些操作将产生未定义的结果。如果容器内只有一个元素，则 <tt>front</tt> 和 <tt>back</tt> 操作都返回对该元素的引用。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Using a subscript that is out-of-range or calling <tt>front</tt> or <tt>back</tt> on an empty container are serious programming errors.</p>
                <p class="docText">使用越界的下标，或调用空容器的 <tt>front</tt> 或 <tt>back</tt> 函数，都会导致程序出现严重的错误。</p>
              </td>
            </tr>
          </table><br>
        </div><br>


        <p class="docText">An alternative to subscripting is to use the <tt>at</tt> member. This function acts like the subscript operation but if the index is invalid, <tt>at</tt> throws an <tt>out_of_range</tt> exception (<a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13" >Section 6.13</a>, p. <a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13" >215</a>):</p>
	<p class="docText">使用下标运算的另一个可选方案是 <tt>at</tt> 成员函数（<a class="docLink" href="ch09lev1sec3.html#ch09table09" >表 9.9</a>）。这个函数的行为和下标运算相似，但是如果给出的下标无效，<tt>at</tt> 函数将会抛出 <tt>out_of_range</tt> 异常（<a class="docLink" href="ch06lev1sec13.html#ch06lev1sec13" >第 6.13 节</a>）：</p>
        <pre>
     vector&lt;string&gt; svec;     // <span class="docEmphItalicAlt">empty</span> <span class="docEmphasis">vector</span>
     cout &lt;&lt; svec[0];         // <span class="docEmphItalicAlt">run-time error: There are no elements in</span> <span class="docEmphasis">svec!</span>
     cout &lt;&lt; svec.at(0);      // <span class="docEmphItalicAlt">throws</span> <span class="docEmphasis">out_of_range</span> <span class="docEmphItalicAlt">exception</span>
</pre><br>
        <a name="ch09sb11"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 9.3.6</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa9q1"></a><b>Exercise 9.24:</b></td>

                    <td>
                      <p class="docText">Write a program that fetches the first element in a <tt>vector</tt>. Do so using <tt>at</tt>, the subscript operator, <tt>front</tt>, and <tt>begin</tt>. Test the program on an empty <tt>vector</tt>.</p>
                      <p class="docText">编写程序获取 <tt>vector</tt> 容器的第一个元素。分别使用下标操作符、<tt>front</tt> 函数以及 <tt>begin</tt> 函数实现该功能，并提供空的 <tt>vector</tt> 容器测试你的程序。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch09lev2sec12"></a>

        <h4 class="docSection2Title">9.3.7. Erasing Elements</h4>
        <h4 class="docSection2Title">9.3.7. 删除元素</h4>

	<a name="idd1e68322"></a><a name="idd1e68329"></a><a name="idd1e68338"></a><a name="idd1e68345"></a><a name="idd1e68352"></a><a name="idd1e68358"></a><a name="idd1e68364"></a><a name="idd1e68372"></a><a name="idd1e68379"></a><a name="idd1e68386"></a><a name="idd1e68393"></a><a name="idd1e68398"></a><a name="idd1e68403"></a><a name="idd1e68409"></a><a name="idd1e68415"></a><a name="idd1e68421"></a><a name="idd1e68428"></a><a name="idd1e68437"></a><a name="ch09lev3sec12"></a>
        <p class="docText">Recall that there is both a general <tt>insert</tt> operation that inserts anywhere in the container and specific <tt>push_front</tt> and <tt>push_back</tt> operations to add elements only at the front or back. Similarly, there is a general <tt>erase</tt> and specific <tt>pop_front</tt> and <tt>pop_back</tt> operations to remove elements.</p>
	<p class="docText">回顾前面的章节，我们知道容器类型提供了通用的 <tt>insert</tt> 操作在容器的任何位置插入元素，并支持特定的 <tt>push_front</tt> 和 <tt>push_back</tt> 操作在容器首部或尾部插入新元素。类似地，容器类型提供了通用的 <tt>erase</tt> 操作和特定的 <tt>pop_front</tt> 和 <tt>pop_back</tt> 操作来删除容器内的元素（<a class="docLink" href="ch09lev1sec3.html#ch09table10" >表 9.10</a>）。</p>

        <a name="ch09table10"></a>
        <h5 class="docTableTitle">Table 9.10. Operations to Remove Elements from a Sequential Container</h5>
        <h5 class="docTableTitle">表 9.10. 删除顺序容器内元素的操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.erase(p)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes element referred to by the iterator <tt>p</tt>.</p>
              <p class="docText">删除迭代器 <tt>p</tt> 所指向的元素</p>

              <p class="docText">Returns an iterator referring to the element after the one deleted, or an off-the-end iterator if <tt>p</tt> referred to the last element. Undefined if <tt>p</tt> is an off-the-end iterator.</p>
              <p class="docText">返回一个迭代器，它指向被删除元素后面的元素。如果 <tt>p</tt> 指向容器内的最后一个元素，则返回的迭代器指向容器的超出末端的下一位置。如果 <tt>p</tt> 本身就是指向超出末端的下一位置的迭代器，则该函数未定义</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.erase(b,e)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes the range of elements denoted by the iterators <tt>b</tt> and <tt>e</tt>.</p>
              <p class="docText">删除迭代器 <tt>b</tt> 和 <tt>e</tt> 所标记的范围内所有的元素</p>

              <p class="docText">Returns an iterator referring after the last one in the range that was deleted, or an off-the-end iterator if <tt>e</tt> is itself an off-the-end iterator.</p>
              <p class="docText">返回一个迭代器，它指向被删除元素段后面的元素。如果 <tt>e</tt> 本身就是指向超出末端的下一位置的迭代器，则返回的迭代器也指向容器的超出末端的下一位置</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.clear()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes all the elements in <tt>c</tt>. Returns <tt>void</tt>.</p>
              <p class="docText">删除容器 <tt>c</tt> 内的所有元素。返回 <tt>void</tt></p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.pop_back()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes the last element in <tt>c</tt>. Returns <tt>void</tt>. Undefined if <tt>c</tt> is empty.</p>
              <p class="docText">删除容器 <tt>c</tt> 的最后一个元素。返回 <tt>void</tt>。如果 <tt>c</tt> 为空容器，则该函数未定义</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.pop_front()</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Removes the first element in <tt>c</tt>. Returns <tt>void</tt>. Undefined if <tt>c</tt> is empty.</p>
              <p class="docText">删除容器 <tt>c</tt> 的第一个元素。返回 <tt>void</tt>。如果 <tt>c</tt> 为空容器，则该函数未定义</p>

              <p class="docText"><span class="docEmphStrong">Valid only for <tt>list</tt> or <tt>deque</tt></span>.</p>
              <p class="docText"><span class="docEmphStrong">只适用于 <tt>list</tt> 或 <tt>deque</tt> 容器</span></p>
            </td>
          </tr>
        </table><br>

        <h5 class="docSection3Title">Removing the First or Last Element</h5>
        <h5 class="docSection3Title">删除第一个或最后一个元素</h5>

        <p class="docText">The <tt>pop_front</tt> and <tt>pop_back</tt> functions remove the first and last elements in the container. There is no <tt>pop_front</tt> operation for <tt>vector</tt>s. These operations remove the indicated element and return <tt>void</tt>.</p>
        <p class="docText"><tt>pop_front</tt> 和 <tt>pop_back</tt> 函数用于删除容器内的第一个和最后一个元素。但 <tt>vector</tt> 容器类型不支持 <tt>pop_front</tt> 操作。这些操作删除指定的元素并返回 <tt>void</tt>。</p>

        <p class="docText">One common use of <tt>pop_front</tt> is to use it together with <tt>front</tt> to process a container as a stack:</p>
        <p class="docText"><tt>pop_front</tt> 操作通常与 <tt>front</tt> 操作配套使用，实现以栈的方式处理容器：</p>
        <pre>
     while (!ilist.empty()) {
         process(ilist.front()); // <span class="docEmphItalicAlt">do something with the current top of</span> <span class="docEmphasis">ilist</span>
         ilist.pop_front();      // <span class="docEmphItalicAlt">done; remove first element</span>
     }
</pre><br>

        <p class="docText">This loop is pretty simple: We use <tt>front</tt> to get a value to operate on and then call <tt>pop_front</tt> to remove that element from the <tt>list</tt>.</p><a name="ch09note15"></a>
        <p class="docText">这个循环非常简单：使用 <tt>front</tt> 操作获取要处理的元素，然后调用 <tt>pop_front</tt> 函数从容器 <tt>list</tt> 中删除该元素。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The <tt>pop_front</tt> and <tt>pop_back</tt> return <tt>void</tt>; they do <span class="docEmphasis">not</span> return the value of the element popped. To examine that value, it is necessary to call <tt>front</tt> or <tt>back</tt> prior to popping the element.</p>
                <p class="docText"><tt>pop_front</tt> 和 <tt>pop_back</tt> 函数的返回值并不是删除的元素值，而是 <tt>void</tt>。要获取删除的元素值，则必须在删除元素之前调用 <span class="docEmphasis">not</span><tt>front</tt> 或 <tt>back</tt> 函数。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch09lev3sec13"></a>

        <h5 class="docSection3Title">Removing an Element From within the Container</h5>
        <h5 class="docSection3Title">删除容器内的一个元素</h5>

        <p class="docText">The more general way to remove an element, or range of elements, is through <tt>erase</tt>. There are two versions of <tt>erase</tt>: We can delete a single element referred to by an iterator or a range of elements marked by a pair of iterators. Both forms <a name="idd1e68698"></a><a name="idd1e68704"></a><a name="idd1e68710"></a><a name="idd1e68717"></a><a name="idd1e68723"></a><a name="idd1e68730"></a><a name="idd1e68736"></a>of <tt>erase</tt> return an iterator referring to the location after the element or range that was removed. That is, if element <tt>j</tt> is the element immediately after <tt>i</tt> and we <tt>erase</tt> element <tt>i</tt> from the container, then the iterator returned will refer to <tt>j</tt>.</p><a name="ch09note16"></a>
        <p class="docText">删除一个或一段元素更通用的方法是 <tt>erase</tt> 操作。该操作有两个版本：删除由一个迭代器指向的单个元素，或删除由一对迭代器标记的一段元素。<tt>erase</tt> 的这两种形式都返回一个迭代器，它指向被删除元素或元素段后面的元素。也就是说，如果元素 <tt>j</tt> 恰好紧跟在元素 <tt>i</tt> 后面，则将元素 <tt>i</tt> 从容器中删除后，删除操作返回指向 <tt>j</tt> 的迭代器。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">As usual, the <tt>erase</tt> operations don't check their argument(s). It is up to the programmer to ensure that the iterator or iterator range is valid.</p>
                <p class="docText">如同其他操作一样，<tt>erase</tt> 操作也不会检查它的参数。程序员必须确保用作参数的迭代器或迭代器范围是有效的。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">The <tt>erase</tt> operation is often used after finding an element that should be removed from the container. The easiest way to find a given element is to use the library <tt>find</tt> algorithm. We'll see more about <tt>find</tt> in <a class="docLink" href="ch11lev1sec1.html#ch11lev1sec1" >Section 11.1</a> (p. <a class="docLink" href="ch11lev1sec1.html#ch11lev1sec1" >392</a>). To use <tt>find</tt> or any other generic algorithm, we must include the <tt>algorithm</tt> header. The <tt>find</tt> function takes a pair of iterators that denote a range in which to look, and a value to look for within that range. <tt>find</tt> returns an iterator referring to the first element with that value or the off-the-end iterator:</p>
        <p class="docText">通常，程序员必须在容器中找出要删除的元素后，才使用 <tt>erase</tt> 操作。寻找一个指定元素的最简单方法是使用标准库的 <tt>find</tt> 算法。我们将在<a class="docLink" href="ch11lev1sec1.html#ch11lev1sec1" >第 11.1 节</a>中进一步讨论 <tt>find</tt> 算法。为了使用 <tt>find</tt> 函数或其他泛型算法，在编程时，必须将 <tt>algorithm</tt> 头文件包含进来。<tt>find</tt> 函数需要一对标记查找范围的迭代器以及一个在该范围内查找的值作参数。查找完成后，该函数返回一个迭代器，它指向具有指定值的第一个元素，或超出末端的下一位置。</p>
        <pre>
     string searchValue("Quasimodo");
     list&lt;string&gt;::iterator iter =
            find(slist.begin(), slist.end(), searchValue);

     if (iter != slist.end())
          slist.erase(iter);
</pre><br>

        <p class="docText">Note that we check that the iterator is not the <tt>end</tt> iterator before erasing the element. When we ask <tt>erase</tt> to erase a single element, the element must existthe behavior of <tt>erase</tt> is undefined if we ask it to <tt>erase</tt> an off-the-end iterator.</p><a name="ch09lev3sec14"></a>
        <p class="docText">注意，在删除元素之前，必须确保迭代器是不是 <tt>end</tt> 迭代器。使用 <tt>erase</tt> 操作删除单个必须确保元素确实存在——如果删除指向超出末端的下一位置的迭代器，那么 <tt>erase</tt> 操作的行为未定义。</p>

        <h5 class="docSection3Title">Removing All the Elements in a Container</h5>
        <h5 class="docSection3Title">删除容器内所有元素</h5>

        <p class="docText">To delete all the elements in a container, we could either call <tt>clear</tt> or pass the iterators from <tt>begin</tt> and <tt>end</tt> to <tt>erase</tt>:</p>
        <p class="docText">要删除容器内所有的元素，可以调用 <tt>clear</tt> 函数，或将 <tt>begin</tt> 和 <tt>end</tt> 迭代器传递给 <tt>erase</tt> 函数。</p>
        <pre>
     slist.clear(); // <span class="docEmphItalicAlt">delete all the elements within the container</span>
     slist.erase(slist.begin(), slist.end()); // <span class="docEmphItalicAlt">equivalent</span>
</pre><br>

        <p class="docText">The iterator-pair version of <tt>erase</tt> lets us delete a subrange of elements:</p>
        <p class="docText"><tt>erase</tt> 函数的迭代器对版本提供了删除一部分元素的功能：</p>
        <pre>
     // <span class="docEmphItalicAlt">delete range of elements between two values</span>
     list&lt;string&gt;::iterator elem1, elem2;

     // <span class="docEmphasis">elem1</span> <span class="docEmphItalicAlt">refers to</span> <span class="docEmphasis">val1</span>
     elem1 = find(slist.begin(), slist.end(), val1);

     // <span class="docEmphasis">elem2</span> <span class="docEmphItalicAlt">refers to the first occurrence of</span> <span class="docEmphasis">val2</span> <span class="docEmphItalicAlt">after</span> <span class="docEmphasis">val1</span>
     elem2 = find(elem1, slist.end(), val2);

     // <span class="docEmphItalicAlt">erase range from</span> <span class="docEmphasis">val1</span> <span class="docEmphItalicAlt">up to but not including</span> <span class="docEmphasis">val2</span>
     slist.erase(elem1, elem2);
</pre><br>

        <p class="docText">This code starts by calling <tt>find</tt> twice to obtain iterators to two elements. The iterator <tt>elem1</tt> refers to the first occurrence of <tt>val1</tt> or to the off-the-end iterator if <tt>val1</tt> is not present in the <tt>list</tt>. The iterator <tt>elem2</tt> refers to the first occurrence of <tt>val2</tt> that appears after <tt>val1</tt> if that element exists, otherwise, <tt>elem2</tt> is an off the-end iterator. The call to <tt>erase</tt> removes the elements starting from the referred to by <tt>elem1</tt> up to but not including <tt>elem2</tt>.</p><a name="ch09note17"></a>
	<p class="docText">这段代码首先调用了 <tt>find</tt> 函数两次，以获得指向特定元素的两个迭代器。迭代器 <tt>elem1</tt> 指向第一个具有 <tt>val1</tt> 值的元素，如果容器 <tt>list</tt> 中不存在值为 <tt>val1</tt> 的元素，则该迭代器指向超出末端的下一位置。如果在 <tt>val1</tt> 元素后面存在值为 <tt>val2</tt> 的元素，那么迭代器 <tt>elem2</tt> 就指向这段范围内第一个具有 <tt>val2</tt> 值的元素，否则，<tt>elem2</tt> 就是一个超出末端的迭代器。最后，调用 <tt>erase</tt> 函数删除从迭代器 <tt>elem1</tt> 开始一直到 <tt>elem2</tt> 之间的所有元素，但不包括 <tt>elem2</tt> 指向的元素。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
	      <a name="idd1e67215"></a><a name="idd1e67220"></a><a name="idd1e67225"></a><a name="idd1e67231"></a><a name="idd1e67237"></a><a name="idd1e67243"></a><a name="idd1e67250"></a><a name="idd1e67257"></a><a name="idd1e67264"></a><a name="idd1e67270"></a><a name="idd1e67276"></a><a name="idd1e67283"></a><a name="idd1e67290"></a><a name="idd1e67297"></a><a name="idd1e67302"></a><a name="idd1e67307"></a><a name="idd1e67313"></a><a name="idd1e67319"></a><a name="idd1e67325"></a><a name="idd1e67331"></a><a name="idd1e67337"></a><a name="idd1e67344"></a><a name="idd1e67351"></a>
	      <p class="docText"> The <tt>erase, pop_front</tt>, and <tt>pop_back</tt> functions invalidate any iterators that refer to the removed elements. For <tt>vector</tt>s, iterators to elements after the erasure point are also invalidated. For <tt>deque</tt>, if the <tt>erase</tt> does not include either the first or last element, all iterators into the <tt>deque</tt> are invalidated.</p>
	      <p class="docText"><tt>erase、pop_front</tt> 和 <tt>pop_back</tt> 函数使指向被删除元素的所有迭代器失效。对于 <tt>vector</tt> 容器，指向删除点后面的元素的迭代器通常也会失效。而对于 <tt>deque</tt> 容器，如果删除时不包含第一个元素或最后一个元素，那么该 <tt>deque</tt> 容器相关的所有迭代器都会失效。</p>
              </td>
            </tr>
          </table><br>
        </div><br>
        <a name="ch09sb12"></a>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 9.3.7</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa10q1"></a><b>Exercise 9.25:</b></td>

                    <td>
                      <p class="docText">What happens in the program that erased a range of elements if <tt>val1</tt> is equal to <tt>val2</tt>. What happens if either <tt>val1</tt> or <tt>val2</tt> or both are not present.</p>
                      <p class="docText">需要删除一段元素时，如果 <tt>val1</tt> 与 <tt>val2</tt> 相等，那么程序会发生什么事情？如果 <tt>val1</tt> 和 <tt>val2</tt> 中的一个不存在，或两个都不存在，程序又会怎么样？</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa10q2"></a><b>Exercise 9.26:</b></td>

                    <td>
                      <p class="docText">Using the following definition of <tt>ia</tt>, copy <tt>ia</tt> into a <tt>vector</tt> and into a <tt>list</tt>. Use the single iterator form of <tt>erase</tt> to remove the elements with odd values from your <tt>list</tt> and the even values from your <tt>vector</tt>.</p>
                      <p class="docText">假设有如下 <tt>ia</tt> 的定义，将 <tt>ia</tt> 复制到一个 <tt>vector</tt> 容器和一个 <tt>list</tt> 容器中。使用单个迭代器参数版本的 <tt>erase</tt> 函数将 <tt>list</tt> 容器中的奇数值元素删除掉，然后将 <tt>vector</tt> 容器中的偶数值元素删除掉。</p>
                      <pre>
     int ia[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89 };
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa10q3"></a><b>Exercise 9.27:</b></td>

                    <td>
                      <p class="docText">Write a program to process a <tt>list</tt> of <tt>string</tt>s. Look for a particular value and, if found, remove it. Repeat the program using a <tt>deque</tt>.</p>
                      <p class="docText">编写程序处理一个 <tt>string</tt> 类型的 <tt>list</tt> 容器。在该容器中寻找一个特殊值，如果找到，则将它删除掉。用 <tt>deque</tt> 容器重写上述程序。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch09lev2sec13"></a>

        <h4 class="docSection2Title">9.3.8. Assignment and <tt>swap</tt></h4>
        <h4 class="docSection2Title">9.3.8. 赋值与 <tt>swap</tt></h4>

        <p class="docText">The assignment-related operators act on the entire container. Except for <tt>swap</tt>, they can be expressed in terms of <tt>erase</tt> and <tt>insert</tt> operations. The assignment operator <span class="docEmphasis">erases</span> the entire range of elements in the left-hand container and then <span class="docEmphasis">inserts</span> the elements of the right-hand container object into the left-hand container:</p>
	<p class="docText">与赋值相关的操作符都作用于整个容器。除 <tt>swap</tt> 操作外，其他操作都可以用 <tt>erase</tt> 和 <tt>insert</tt> 操作实现（<a class="docLink" href="ch09lev1sec3.html#ch09table11" >表 9.11</a>）。赋值操作符首先 <span class="docEmphasis">erases</span> 其左操作数容器中的所有元素，然后将右操作数容器的所有元素 <span class="docEmphasis">inserts</span> 到左边容器中：</p>

        <pre>
     c1 = c2; // <span class="docEmphItalicAlt">replace contents of c1 with a copy of elements in c2</span>
     // <span class="docEmphItalicAlt">equivalent operation using erase and insert</span>
     c1.erase(c1.begin(), c1.end()); // <span class="docEmphItalicAlt">delete all elements in c1</span>
     c1.insert(c1.begin(), c2.begin(), c2.end()); // <span class="docEmphItalicAlt">insert c2</span>
</pre><br>

        <p class="docText">After the assignment, the left- and right-hand containers are equal: Even if the containers had been of unequal size, after the assignment both containers have the size of the right-hand operand.</p><a name="ch09note18"></a>
        <p class="docText">赋值后，左右两边的容器相等：尽管赋值前两个容器的长度可能不相等，但赋值后两个容器都具有右操作数的长度。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Assignment and the <tt>assign</tt> operations invalidate all iterators into the left-hand container. <tt>swap</tt> does <span class="docEmphasis">not</span> invalidate iterators. After <tt>swap</tt>, iterators continue to refer to the same elements, although those elements are now in a different container.</p>
                <p class="docText">赋值和 <tt>assign</tt> 操作使左操作数容器的所有迭代器失效。<tt>swap</tt> 操作则不会使迭代器失效。完成 <tt>swap</tt> 操作后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。</p>
              </td>
            </tr>
          </table><br>
  </div><br>

	<a name="ch09table11"></a>
        <h5 class="docTableTitle">Table 9.11. Sequential Container Assignment Operations</h5>
        <h5 class="docTableTitle">表 9.11. 顺序容器的赋值操作</h5>

        <table cellspacing="0" class="allBorders" border="1" rules="none" cellpadding="5">
          <colgroup>
            <col width="150">
            <col width="350">
          </colgroup>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c1 = c2</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Deletes elements in <tt>c1</tt> and copies elements from <tt>c2</tt> into <tt>c1</tt>. <tt>c1</tt> and <tt>c2</tt> must be the same type.</p>
              <p class="docText">删除容器 <tt>c1</tt> 的所有元素，然后将 <tt>c2</tt> 的元素复制给 <tt>c1</tt>。<tt>c1</tt> 和 <tt>c2</tt> 的类型（包括容器类型和元素类型）必须相同</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c1.swap(c2)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Swaps contents: After the call <tt>c1</tt> has elements that were in <tt>c2</tt>, and <tt>c2</tt> has elements that were in <tt>c1</tt>. <tt>c1</tt> and <tt>c2</tt> must be the same type. Execution time usually <span class="docEmphasis">much</span> faster than copying elements from <tt>c2</tt> to <tt>c1</tt>.</p>
              <p class="docText">交换内容：调用完该函数后，<tt>c1</tt> 中存放的是 <tt>c2</tt> 原来的元素，<tt>c2</tt> 中存放的则是 <tt>c1</tt> 原来的元素。<tt>c1</tt> 和 <tt>c2</tt> 的类型必须相同。该函数的执行速度通常要比将 <tt>c2</tt> 复制到 <tt>c1</tt> 的操作快</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.assign(b,e)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Replaces the elements in <tt>c</tt> by those in the range denoted by iterators <tt>b</tt> and <tt>e</tt>. The iterators <tt>b</tt> and <tt>e</tt> must not refer to elements in <tt>c</tt>.</p>
	      <p class="docText">重新设置 <tt>c</tt> 的元素：将迭代器 <tt>b</tt> 和 <tt>e</tt> 标记的范围内所有的元素复制到 <tt>c</tt> 中。<tt>b</tt> 和 <tt>e</tt> 必须不是指向 <tt>c</tt> 中元素的迭代器</p>
            </td>
          </tr>

          <tr>
            <td class="docTableCell" align="left" valign="top">
              <p class="docText"><tt>c.assign(n,t)</tt></p>
            </td>

            <td class="docTableCell" align="left" valign="top">
              <p class="docText">Replaces the elements in <tt>c</tt> by <tt>n</tt> elements with value <tt>t</tt>.</p>
              <p class="docText">将容器 <tt>c</tt> 重新设置为存储 <tt>n</tt> 个值为 <tt>t</tt> 的元素</p>
            </td>
          </tr>
        </table><br>

        <a name="ch09lev3sec15"></a>

        <h5 class="docSection3Title">Using <tt>assign</tt></h5>
        <h5 class="docSection3Title">使用 <tt>assign</tt></h5>

        <p class="docText">The <tt>assign</tt> operation deletes all the elements in the container and then inserts new elements as specified by the arguments. Like the constructor that copies elements from a container, the assignment operator (<tt>=</tt>) can be used to assign one <a name="idd1e69304"></a><a name="idd1e69310"></a><a name="idd1e69316"></a><a name="idd1e69323"></a><a name="idd1e69330"></a><a name="idd1e69337"></a><a name="idd1e69344"></a><a name="idd1e69351"></a><a name="idd1e69357"></a><a name="idd1e69364"></a><a name="idd1e69368"></a><a name="idd1e69374"></a>container to another only if the container and element type are the same. If we want to assign elements of a different but compatible element type and/or from a different container type, then we must use the <tt>assign</tt> operation. For example, we could use <tt>assign</tt> to assign a range of <tt>char*</tt> values from a <tt>vector</tt> into a <tt>list</tt> of <tt>string</tt>.</p>
        <p class="docText"><tt>assign</tt> 操作首先删除容器中所有的元素，然后将其参数所指定的新元素插入到该容器中。与复制容器元素的构造函数一样，如果两个容器类型相同，其元素类型也相同，就可以使用赋值操作符（<tt>=</tt>）将一个容器赋值给另一个容器。如果在不同（或相同）类型的容器内，元素类型不相同但是相互兼容，则其赋值运算必须使用 <tt>assign</tt> 函数。例如，可通过 <tt>assign</tt> 操作实现将 <tt>vector</tt> 容器中一段 <tt>char*</tt> 类型的元素赋给 <tt>string</tt> 类型 <tt>list</tt> 容器。</p>

        <a name="ch09note19"></a>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">Because the original elements are deleted, the iterators passed to <tt>assign</tt> must not refer to elements in the container on which <tt>assign</tt> is called.</p>
                <p class="docText">由于 <tt>assign</tt> 操作首先删除容器中原来存储的所有元素，因此，传递给 <tt>assign</tt> 函数的迭代器不能指向调用该函数的容器内的元素。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">The arguments to <tt>assign</tt> determine how many elements are inserted and what values the new elements will have. This statement:</p>
        <p class="docText"><tt>assign</tt> 函数的参数决定了要插入多少个元素以及新元素的值是什么。语句</p>
        <pre>
     // <span class="docEmphItalicAlt">equivalent to slist1 = slist2</span>
     slist1.assign(slist2.begin(), slist2.end());
</pre><br>

        <p class="docText">uses the version of <tt>assign</tt> that takes a pair of iterators. After deleting the elements in <tt>slist1</tt>, the function copies the elements in the range denoted by the iterators into <tt>slist2</tt>. Thus, this code is equivalent to assigning <tt>slist2</tt> to <tt>slist1</tt>.</p><a name="ch09note20"></a>
	<p class="docText">使用了带一对迭代器参数的 <tt>assign</tt> 函数版本。在删除 <tt>slist1</tt> 的元素后，该函数将 <tt>slist2</tt> 容器内一段指定的元素复制到 <tt>slist2</tt> 中。于是，这段代码行等效于将 <tt>slist1</tt> 赋给 <tt>slist1</tt>。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The <tt>assign</tt> operator that takes an iterator pair lets us assign elements of one container type to another.</p>
                <p class="docText">带有一对迭代器参数的 <tt>assign</tt> 操作允许我们将一个容器的元素赋给另一个不同类型的容器。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">A second version of assign takes an integral value and an element value. It replaces the elements in the container by the specified number of elements, each of which has the specified element value</p>
	<p class="docText"><tt>assign</tt> 运算的第二个版本需要一个整型数值和一个元素值做参数，它将容器重置为存储指定数量的元素，并且每个元素的值都为指定值：</p>
        <pre>
     // <span class="docEmphItalicAlt">equivalent to:</span> <span class="docEmphasis">slist1.clear();</span>
     // <span class="docEmphItalicAlt">followed by</span> <span class="docEmphasis">slist1.insert(slist1.begin(), 10, "Hiya!");</span>
     slist1.assign(10, "Hiya!"); // <span class="docEmphItalicAlt">10 elements; each one is</span> <span class="docEmphasis">Hiya!</span>
</pre><br>

        <p class="docText">After executing this statement, <tt>slist1</tt> has 10 elements, each of which has the value <tt>Hiya!</tt>.</p><a name="ch09lev3sec16"></a>
        <p class="docText">执行了上述语句后，容器 <tt>slist1</tt> 有 10 个元素，每个元素的值都是 <tt>Hiya!</tt>。</p>

        <h5 class="docSection3Title">Using <tt>swap</tt> to Avoid the Cost of Deleting Elements</h5>
        <h5 class="docSection3Title">使用 <tt>swap</tt> 操作以节省删除元素的成本</h5>

        <p class="docText">The <tt>swap</tt> operation swaps the values of its two operands. The types of the containers must match: The operands must be the same kind of container, and they <a name="idd1e69644"></a>must hold values of the same type. After the call to <tt>swap</tt>, the elements that had been in the right-hand operand are in the left, and vice versa:</p>
        <p class="docText"><tt>swap</tt> 操作实现交换两个容器内所有元素的功能。要交换的容器的类型必须匹配：操作数必须是相同类型的容器，而且所存储的元素类型也必须相同。调用了 <tt>swap</tt> 函数后，右操作数原来存储的元素被存放在左操作数中，反之亦然。</p>
        <pre>
     vector&lt;string&gt; svec1(10); // <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">with 10 elements</span>
     vector&lt;string&gt; svec2(24); // <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">with 24 elements</span>
     svec1.swap(svec2);
</pre><br>

        <p class="docText">After the <tt>swap, svec1</tt> contains 24 <tt>string</tt> elements and <tt>svec2</tt> contains 10.</p><a name="ch09note21"></a>
	<p class="docText">执行 <tt>swap</tt> 后，容器 <tt>svec1</tt> 中存储 24 个 <tt>string</tt> 类型的元素，而 <tt>svec2</tt> 则存储 10 个元素。</p>

        <div class="docNote">
          <table width="90%" border="0" cellspacing="0" cellpadding="1">
            <tr>
              <td width="60" valign="top"><img border="0" alt="" align="LEFT" width="50" height="54" src="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" ></td>

              <td valign="top">
                <p class="docText">The important thing about <tt>swap</tt> is that it does not delete or insert any elements and is guaranteed to run in constant time. No elements are moved, and so iterators are not invalidated.</p>
                <p class="docText">关于 <tt>swap</tt> 的一个重要问题在于：该操作不会删除或插入任何元素，而且保证在常量时间内实现交换。由于容器内没有移动任何元素，因此迭代器不会失效。</p>
              </td>
            </tr>
          </table><br>
        </div><br>

        <p class="docText">The fact that elements are not moved means that iterators are not invalidated. They refer to the same elements as they did before the swap. However, after the <tt>swap</tt>, those elements are in a different container. For example, had <tt>iter</tt> referred to the <tt>string</tt> at position <tt>svec1[3]</tt> before the <tt>swap</tt> it will refer to the element at position <tt>svec2[3]</tt> after the <tt>swap</tt>.</p><a name="ch09sb13"></a>
	<p class="docText">没有移动元素这个事实意味着迭代器不会失效。它们指向同一元素，就像没作 <tt>swap</tt> 运算之前一样。虽然，在 <tt>swap</tt> 运算后，这些元素已经被存储在不同的容器之中了。例如，在做 <tt>swap</tt> 运算之前，有一个迭代器 <tt>iter</tt> 指向 <tt>svec1[3]</tt> 字符串；实现 <tt>swap</tt> 运算后，该迭代器则指向 <tt>svec2[3]</tt> 字符串（这是同一个字符串，只是存储在不同的容器之中而已）。</p>

        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 9.3.8</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch09qa11q1"></a><b>Exercise 9.28:</b></td>

                    <td>
                      <p class="docText">Write a program to assign the elements from a <tt>list</tt> of <tt>char*</tt> pointers to C-style character strings to a <tt>vector</tt> of <tt>string</tt>s.</p>
		      <p class="docText">编写程序将一个 <tt>list</tt> 容器的所有元素赋值给一个 <tt>vector</tt> 容器，其中 <tt>list</tt> 容器中存储的是指向 C 风格字符串的 <tt>char*</tt> 指针，而 <tt>vector</tt> 容器的元素则是 <tt>string</tt> 类型。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch09lev1sec2.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch09lev1sec4.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
