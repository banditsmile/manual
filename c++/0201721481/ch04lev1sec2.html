<html>
	<META http-equiv="Content-Type" content="text/html; charset=utf-8">
	<head>
		<title>Section 4.2.&nbsp; Introducing Pointers</title>
		<link rel="STYLESHEET" type="text/css" href="images/style.css" >
		<link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
	</head>
	<body>
		<table width="100%" border="0" cellspacing="0" cellpadding="0">
			<tr>
				<td>
					<div STYLE="MARGIN-LEFT: 0.15in;">
						<a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a>
					</div>
				</td>
				<td align="right">
					<div STYLE="MARGIN-LEFT: 0.15in;">
						<a href="ch04lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
						<a href="ch04lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
					</div>
				</td>
			</tr>
		</table>
		<br>
		<table width="100%" border="0" cellspacing="0" cellpadding="0">
			<tr>
				<td valign="top">
					<a name="ch04lev1sec2"></a>
					<h3 class="docSection1Title">4.2. Introducing Pointers</h3>
					<h3 class="docSection1Title">4.2. 指针的引入</h3>
					
<a name="ch04term11"></a>
<a name="idd1e24228"></a><a name="idd1e24233"></a><a name="idd1e24239"></a><a name="idd1e24244"></a><a name="idd1e24252"></a>
					<p class="docText">Just as we can traverse a <tt>vector</tt> either by using a subscript or an iterator, we can also traverse an array by using either a subscript or a <B><a class="docLink" href="ch04lev1sec6.html#gloss04_11" >pointer</a></b>. A pointer is a compound type; a pointer points to an object of some other type. Pointers are iterators for arrays: A pointer can point to an element in an array. The dereference and increment operators, when applied to a pointer that points to an array element, have similar behavior as when applied to an iterator. When we dereference a pointer, we obtain the object to which the pointer points. When we increment a pointer, we advance the pointer to denote the next element in the array. Before we write programs using pointers, we need to know a bit more about them.</P>
					<p class="docText"><tt>vector</tt> 的遍历可使用下标或迭代器实现，同理，也可用下标或<B><a class="docLink" href="ch04lev1sec6.html#gloss04_11" >指针</a></b>来遍历数组。指针是指向某种类型对象的复合数据类型，是用于数组的迭代器：指向数组中的一个元素。在指向数组元素的指针上使用解引用操作符 <tt>*</tt>（dereference operator）和自增操作符 ++（increment operator），与在迭代器上的用法类似。对指针进行解引用操作，可获得该指针所指对象的值。而当指针做自增操作时，则移动指针使其指向数组中的下一个元素。在使用指针编写程序之前，我们需进一步了解一下指针。</P>

					
					<a name="ch04lev2sec3"></a>
					<h4 class="docSection2Title">4.2.1. What Is a Pointer?</h4>
					<h4 class="docSection2Title">4.2.1. 什么是指针</h4>
					
					<p class="docText">For newcomers, pointers are often hard to understand. Debugging problems due to pointer errors bedevil even experienced programmers. However, pointers are an important part of most C programs and to a much lesser extent remain important in many C++ programs.</P>
					<p class="docText">对初学者来说，指针通常比较难理解。而由指针错误引起的调试问题连富有经验的程序员都感到头疼。然而，指针是大多数C程序的重要部分，而且在许多 C++ 程序中仍然受到重用。</P>
					
					<p class="docText">Conceptually, pointers are simple: A pointer points at an object. Like an iterator, a pointer offers indirect access to the object to which it points. However, pointers are a much more general construct. Unlike iterators, pointers can be used to point at single objects. Iterators are used only to access elements in a container.</P>
					<p class="docText">指针的概念很简单：指针用于指向对象。与迭代器一样，指针提供对其所指对象的间接访问，只是指针结构更通用一些。与迭代器不同的是，指针用于指向单个对象，而迭代器只能用于访问容器内的元素。</P>

					<p class="docText">Specifically, a pointer holds the address of another object:</p>
					<p class="docText">具体来说，指针保存的是另一个对象的地址：</P>

<pre>
          string s("hello world");
          string *sp = &amp;s; // <span class="docEmphasis">sp</span> <span class="docEmphItalicAlt">holds the address of</span> <span class="docEmphasis">s</span>
</pre>

					<p class="docText">The second statement defines <tt>sp</tt> as a pointer to <tt>string</tt> and initializes <tt>sp</tt> to point to the <tt>string</tt> object named <tt>s</tt>. The <tt>*</tt> in <tt>*sp</tt> indicates that <tt>sp</tt> is a pointer. The <tt>&amp;</tt> operator in <tt>&amp;s</tt> is the <span class="docEmphStrong">address-of</span> operator. It returns a value that when dereferenced yields the original object. The address-of operator may be applied only to an lvalue (<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10" >Section 2.3.1</a>, p. <a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10" >45</a>). Because a variable is an lvalue, we may take its address. Similarly, the subscript and dereference operators, when applied to a <tt>vector, string</tt>, or built-in array, yield lvalues. Because these operators yield lvalues, we may apply the address-of to the result of the subscript or dereference operator. Doing so gives us the address of a particular element.</p>
					<p class="docText">第二条语句定义了一个指向 <tt>string</tt> 类型的指针 <tt>sp</tt>，并初始化 <tt>sp</tt> 使其指向 <tt>string</tt> 类型的对象s。<tt>*sp</tt> 中的 <tt>*</tt> 操作符表明 <tt>sp</tt> 是一个指针变量，<tt>&amp;s</tt> 中的 <tt>&amp;</tt> 符号是<span class="docEmphStrong">取地址</span>操作符，当此操作符用于一个对象上时，返回的是该对象的存储地址。取地址操作符只能用于左值（<a class="docLink" href="ch02lev1sec3.html#ch02lev2sec10" >第 2.3.1 节</a>），因为只有当变量用作左值时，才能取其地址。同样地，由于用于 <tt>vector</tt> 类型、<tt>string</tt> 类型或内置数组的下标操作和解引用操作生成左值，因此可对这两种操作的结果做取地址操作，这样即可获取某一特定对象的存储地址。</P>
					
					<a name="ch04sb04"></a>
					<p>
					<table cellspacing="0" width="90%" border="1" cellpadding="5">
						<tr>
							<td>
								<h2 class="docSidebarTitle">Advice: Avoid Pointers and Arrays</h2>
								<h2 class="docSidebarTitle">建议：尽量避免使用指针和数组  </h2>
								<a name="idd1e24410"></a>
								<p class="docText"><span class="docEmphStrong">Pointers and arrays are surprisingly error-prone. Part of the problem is conceptual: Pointers are used for low-level manipulations and it is easy to make bookkeeping mistakes. Other problems arise because of the syntax, particularly the declaration syntax used with pointers.</span></p>
								<p class="docText"><span class="docEmphStrong">指针和数组容易产生不可预料的错误。其中一部分是概念上的问题：指针用于低级操作，容易产生与繁琐细节相关的（bookkeeping）错误。其他错误则源于使用指针的语法规则，特别是声明指针的语法。</span></p>
								<p class="docText"><span class="docEmphStrong">Many useful programs can be written without needing to use arrays or pointers. Instead, modern C++ programs should use <tt>vector</tt>s and iterators to replace general arrays and <tt>string</tt>s to replace C-style array-based character strings.</span></p>
								<p class="docText"><span class="docEmphStrong">许多有用的程序都可不使用数组或指针实现，现代C++程序采用vector类型和迭代器取代一般的数组、采用string类型取代C风格字符串。</span></p>
							</td>
						</tr>
					</table>
					</p>
					<BR>

					<a name="ch04lev2sec4"></a>
					<H4 class="docSection2Title">4.2.2. Defining and Initializing Pointers</h4>
					<H4 class="docSection2Title">4.2.2. 指针的定义和初始化</h4>
					
					<p class="docText">Every pointer has an associated type. The type of a pointer determines the type of the objects to which the pointer may point. A pointer to <tt>int</tt>, for example, may only point to an object of type <tt>int</tt>.</p>
					<p class="docText">每个指针都有一个与之关联的数据类型，该数据类型决定了指针所指向的对象的类型。例如，一个 <tt>int</tt> 型指针只能指向 <tt>int</tt> 型对象。</p>
					
					<a name="ch04lev3sec5"></a>
					<h5 class="docSection3Title">Defining Pointer Variables</H5>
					<h5 class="docSection3Title">指针变量的定义</H5>

					<p class="docText">We use the <tt>*</tt> symbol in a declaration to indicate that an identifier is a pointer:</P>
					<p class="docText">C++ 语言使用 <tt>*</tt> 符号把一个标识符声明为指针：</p>
<pre>
          vector&lt;int&gt;   *pvec;      // <span class="docEmphasis">pvec</span> <span class="docEmphItalicAlt">can point to a</span> <span class="docEmphasis">vector&lt;int&gt;</span>
          int           *ip1, *ip2; // <span class="docEmphasis">ip1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ip2</span> <span class="docEmphItalicAlt">can point to an</span> <span class="docEmphasis">int</span>
          string        *pstring;   // <span class="docEmphasis">pstring</span> <span class="docEmphItalicAlt">can point to a</span> <span class="docEmphasis">string</span>
          double        *dp;        // <span class="docEmphasis">dp</span> <span class="docEmphItalicAlt">can point to a</span> <span class="docEmphasis">double</span>
</pre>

					<a name="ch04note06"></a>
					<div class="docNote">
						<p>
						<table width="90%" border="0" cellspacing="0" cellpadding="1">
							<tr>
								<td width="60" valign="top">
									<img border="0" alt="" align="LEFT" width="84" height="51" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" >
								</td>
								<td valign="top">
									<p class="docText">When attempting to understand pointer declarations, read them from right to left.</p>
									<p class="docText">理解指针声明语句时，请从右向左阅读。</p>
								</td>
							</tr>
						</table><br>
						</p>
					</div>
					<br>
					<p class="docText">Reading the definition of <tt>pstring</tt> from right to left, we see that</P>
					<p class="docText">从右向左阅读 <tt>pstring</tt> 变量的定义，可以看到</P>
<pre>
          string *pstring;
</pre>
					<p class="docText">defines <tt>pstring</tt> as a pointer that can point to <tt>string</tt> objects. Similarly,</p>
					<p class="docText">语句把 <tt>pstring</tt> 定义为一个指向 <tt>string</tt> 类型对象的指针变量。类似地，语句</P>
<pre>
          int *ip1, *ip2; // <span class="docEmphasis">ip1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ip2</span> <span class="docEmphItalicAlt">can point to an</span> <span class="docEmphasis">int</span>
</pre>
					<p class="docText">defines <tt>ip2</tt> as a pointer and <tt>ip1</tt> as a pointer. Both pointers point to <tt>int</tt>s.</p>
					<p class="docText">把 <tt>ip1</tt> 和 <tt>ip2</tt> 都定义为指向 <tt>int</tt> 型对象的指针。</p>

					<p class="docText">The <tt>*</tt> can come anywhere in a list of objects of a given type:</p>
					<p class="docText">在声明语句中，符号 <tt>*</tt> 可用在指定类型的对象列表的任何位置：</p>
<pre>
          double dp, *dp2; // <span class="docEmphasis">dp2</span> <span class="docEmphItalicAlt">is a ponter,</span> <span class="docEmphasis">dp</span> <span class="docEmphItalicAlt">is an object: both type</span> <span class="docEmphasis">double</span>
</pre><br>
<p class="docText">defines <tt>dp2</tt> as a pointer and <tt>dp</tt> as an object, both of type <tt>double</tt>.</p>
<p class="docText">该语句定义了一个 <tt>double</tt> 类型的 <tt>dp</tt> 对象以及一个指向 <tt>double</tt> 类型对象的指针dp2。</p>

<a name="ch04lev3sec6"></a>
<h5 class="docSection3Title">A Different Pointer Declaration Style</h5>
<h5 class="docSection3Title">另一种声明指针的风格</h5>

<p class="docText">The <tt>*</tt> symbol may be separated from its identifier by a space. It is legal to write:</p>
<p class="docText">在定义指针变量时，可用空格将符号 <tt>*</tt> 与其后的标识符分隔开来。下面的写法是合法的：</p>

<pre>
          string* ps; // <span class="docEmphItalicAlt">legal but can be misleading</span>
</pre>

<p class="docText">which says that <tt>ps</tt> is a pointer to <tt>string</tt>.</p>
<p class="docText">也就是说，该语句把 <tt>ps</tt> 定义为一个指向 <tt>string</tt> 类型对象的指针。</p>

<p class="docText">We say that this definition can be misleading because it encourages the belief that <tt>string*</tt> is the type and any variable defined in the same definition is a pointer to <tt>string</tt>. However,</p>
<p class="docText">这种指针声明风格容易引起这样的误解：把 <tt>string*</tt> 理解为一种数据类型，认为在同一声明语句中定义的其他变量也是指向 <tt>string</tt> 类型对象的指针。然而，语句</p>

<pre>
          string* ps1, ps2; // <span class="docEmphasis">ps1</span> <span class="docEmphItalicAlt">is a pointer to</span> <span class="docEmphasis">string,  ps2</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">string</span>
</pre>

<a name="idd1e24666"></a><a name="idd1e24671"></a><a name="idd1e24676"></a><a name="idd1e24681"></a><a name="idd1e24686"></a>
<p class="docText">defines <tt>ps1</tt> as a pointer, but <tt>ps2</tt> is a plain <tt>string</tt>. If we want to define two pointers in a single definition, we must repeat the <tt>*</tt> on each identifier:</P>
<p class="docText">实际上只把 <tt>ps1</tt> 定义为指针，而 <tt>ps2</tt> 并非指针，只是一个普通的 <tt>string</tt> 对象而已。如果需要在一个声明语句中定义两个指针，必须在每个变量标识符前再加符号 <tt>*</tt> 声明：</p>

<pre>
          string* ps1, *ps2; // <span class="docEmphItalicAlt">both</span> <span class="docEmphasis">ps1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">ps2</span> <span class="docEmphItalicAlt">are pointers to</span> <span class="docEmphasis">string</span>
</pre>

<a name="ch04lev3sec7"></a>
<H5 class="docSection3Title">Multiple Pointer Declarations Can Be Confusing</h5>
<H5 class="docSection3Title">连续声明多个指针易导致混淆</h5>

<p class="docText">There are two common styles for declaring multiple pointers of the same type. One style requires that a declaration introduce only a single name. In this style, the <tt>*</tt> is placed with the type to emphasize that the declaration is declaring a pointer:</p>
<p class="docText">连续声明同一类型的多个指针有两种通用的声明风格。其中一种风格是一个声明语句只声明一个变量，此时，符号 <tt>*</tt> 紧挨着类型名放置，强调这个声明语句定义的是一个指针：</p>

<pre>
          string* ps1;
          string* ps2;
</pre>

<p class="docText">The other style permits multiple declarations in a single statement but places the <tt>*</tt> adjacent to the identifier. This style emphasizes that the object is a pointer:</P>
<p class="docText">另一种风格则允许在一条声明语句中声明多个指针，声明时把符号 <tt>*</tt> 靠近标识符放置。这种风格强调对象是一个指针：</p>

<pre>
          string *ps1, *ps2;
</pre>

<a name="ch04note07"></a>
<div class="docNote">
	<p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1">
		<tr>
			<td width="60" valign="top">
				<img border="0" alt="" align="LEFT" width="84" height="51" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" >
			</td>
			<TD valign="top">
				<p class="docText">As with all questions of style, there is no single right way to declare pointers. The important thing is to choose a style and stick with it.</p>
				<p class="docText">关于指针的声明，不能说哪种声明风格是唯一正确的方式，重要的是选择一种风格并持续使用。</p>
			</td>
		</tr></table><br>
</p></div><br>

<p class="docText">In this book we use the second style and place the <tt>*</tt> with the pointer variable name.</P>
<p class="docText">在本书中，我们将采用第二种声明风格：将符号 <tt>*</tt> 紧贴着指针变量名放置。</P>

<a name="ch04lev3sec8"></a>
<H5 class="docSection3Title">Possible Pointer Values</h5>
<H5 class="docSection3Title">指针可能的取值</h5>

<p class="docText">A valid pointer has one of three states: It can hold the address of a specific object, it can point one past the end of an object, or it can be zero. A zero-valued pointer points to no object. An uninitialized pointer is invalid until it is assigned a value. The following definitions and assignments are all legal:</p>
<p class="docText">一个有效的指针必然是以下三种状态之一：保存一个特定对象的地址；指向某个对象后面的另一对象；或者是0值。若指针保存0值，表明它不指向任何对象。未初始化的指针是无效的，直到给该指针赋值后，才可使用它。下列定义和赋值都是合法的：</P>
<pre>
          int ival = 1024;
          int *pi = 0;       // <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">initialized to address no object</span>
          int *pi2 = &amp; ival; // <span class="docEmphasis">pi2</span> <span class="docEmphItalicAlt">initialized to address of</span> <span class="docEmphasis">ival</span>
          int *pi3;          // <span class="docEmphItalicAlt">ok, but dangerous,</span> <span class="docEmphasis">pi3</span> <span class="docEmphItalicAlt">is uninitialized</span>
          pi = pi2;          // <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">pi2</span> <span class="docEmphItalicAlt">address the same object, e.g.</span> <span class="docEmphasis">ival</span>
          pi2 = 0;           // <span class="docEmphasis">pi2</span> <span class="docEmphItalicAlt">now addresses no object</span>
</pre>

<a name="ch04lev3sec9"></a>
<h5 class="docSection3Title">Avoid Uninitialized Pointers</H5>
<h5 class="docSection3Title">避免使用未初始化的指针</H5>

<a name="ch04note08"></a>
<div class="docNote"><p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><TD width="60" valign="top"><img border="0" alt="" align="LEFT" width="57" height="96" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/beware.jpg;400478" ></td><td valign="top">
				<p class="docText">Uninitialized pointers are a common source of run-time errors.</P>
				<p class="docText">很多运行时错误都源于使用了未初始化的指针。</P>
	</td></TR></table>
</p></div>

<p class="docText">As with any other uninitialized variable, what happens when we use an uninitialized pointer is undefined. Using an uninitialized pointer almost always results in a run-time crash. However, the fact that the crash results from using an uninitialized pointer can be quite hard to track down.</p>
<p class="docText">就像使用其他没有初始化的变量一样，使用未初始化的指针时的行为C++标准中并没有定义使用未初始化的指针，它几乎总会导致运行时崩溃。然而，导致崩溃的这一原因很难发现。</P>

<a name="idd1e24851"></a><a name="idd1e24855"></a><a name="idd1e24858"></a>
<p class="docText">Under most compilers, if we use an uninitialized pointer the effect will be to use whatever bits are in the memory in which the pointer resides as if it were an address. Using an uninitialized pointer uses this supposed address to manipulate the underlying data at that supposed location. Doing so usually leads to a crash as soon as we attempt to dereference the uninitialized pointer.</p>
<p class="docText">对大多数的编译器来说，如果使用未初始化的指针，会将指针中存放的不确定值视为地址，然后操纵该内存地址中存放的位内容。使用未初始化的指针相当于操纵这个不确定地址中存储的基础数据。因此，在对未初始化的指针进行解引用时，通常会导致程序崩溃。</P>

<p class="docText">It is not possible to detect whether a pointer is uninitialized. There is no way to distinguish a valid address from an address formed from the bits that are in the memory in which the pointer was allocated. Our recommendation to initialize all variables is particularly important for pointers.</p>
<p class="docText">C++ 语言无法检测指针是否未被初始化，也无法区分有效地址和由指针分配到的存储空间中存放的二进制位形成的地址。建议程序员在使用之前初始化所有的变量，尤其是指针。</P>

<a name="ch04note09"></a>
<div class="docNote"><p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1"><tr><td width="60" valign="top"><img border="0" alt="" align="LEFT" width="116" height="74" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/bestpractices.jpg;400478" ></td><td valign="top">
				<p class="docText">If possible, do not define a pointer until the object to which it should point has been defined. That way, there is no need to define an uninitialized pointer.</p>
				<p class="docText">如果可能的话，除非所指向的对象已经存在，否则不要先定义指针，这样可避免定义一个未初始化的指针。</p>
	</td></TR></table><BR>

<p class="docText">If you must define a pointer separately from pointing it at an object, then initialize the pointer to zero. The reason is that a zero-valued pointer can be tested and the program can detect that the pointer does not point to an object.</p>
<p class="docText">如果必须分开定义指针和其所指向的对象，则将指针初始化为 0。因为编译器可检测出 0 值的指针，程序可判断该指针并未指向一个对象。</P>

</P></div><br>

<a name="ch04lev3sec10"></a>
<h5 class="docSection3Title">Constraints on Initialization of and Assignment to Pointers</H5>
<h5 class="docSection3Title">指针初始化和赋值操作的约束</H5>

<p class="docText">There are only four kinds of values that may be used to initialize or assign to a pointer:</P>
<p class="docText">对指针进行初始化或赋值只能使用以下四种类型的值：</P>

<div style="font-weight:bold">
	<ol class="docList" type="1">
		<li>
		<div style="font-weight:normal">
			<p class="docList">A constant expression (<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >Section 2.7</a>, p. <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >62</a>) with value 0 (e.g., a <tt>const</tt> integral object whose value is zero at compile time or a literal constant 0)</p>
			<p class="docList">0 值常量表达式（<a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7" >第 2.7 节</a>），例如，在编译时可获得 0 值的整型 <tt>const</tt> 对象或字面值常量 0。</p>
		</div>
		</li>
		<li>
		<div style="font-weight:normal">
			<p class="docList">An address of an object of an appropriate type</p>
			<p class="docList">类型匹配的对象的地址。</p>
		</div>
		</LI>
		<li>
		<div style="font-weight:normal">
			<p class="docList">The address one past the end of another object</P>
			<p class="docList">另一对象末的下一地址。</p>
		</div>
		</LI>
		<li>
		<div style="font-weight:normal">
			<p class="docList">Another valid pointer of the same type</p>
			<p class="docList">同类型的另一个有效指针。</p>
		</div>
		</li>
	</ol>
</div>

<p class="docText">It is illegal to assign an <tt>int</tt> to a pointer, even if the value of the <tt>int</tt> happens to be 0. It is okay to assign the literal 0 or a <tt>const</tt> whose value is known to be <tt>0</tt> at compile time:</P>
<p class="docText">把 <tt>int</tt> 型变量赋给指针是非法的，尽管此 <tt>int</tt> 型变量的值可能为 0。但允许把数值 0 或在编译时可获得 0 值的 <tt>const</tt> 量赋给指针：</P>

<pre>
          int ival;
          int zero = 0;
          const int c_ival = 0;
          int *pi = ival; // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">initialized from int value of</span> <span class="docEmphasis">ival</span>
          pi = zero;      // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">assigned int value of zero</span>
          pi = c_ival;    // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">c_ival</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">with compile-time value of 0</span>
          pi = 0;         // <span class="docEmphItalicAlt">ok: directly initialize to literal constant 0</span>
</pre>

<p class="docText">In addition to using a literal 0 or a <tt>const</tt> with a compile-time value of 0, we can also use a facility that C++ inherits from C. The <tt>cstdlib</tt> header defines a preprocessor variable (<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >Section 2.9.2</a>, p. <a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >69</a>) named <tt>NULL</tt>, which is defined as 0. When we use a preprocessor variable in our code, it is automatically replaced by its value. Hence, initializing a pointer to <tt>NULL</tt> is equivalent to initializing it to 0:</p>
<p class="docText">除了使用数值0或在编译时值为 0 的 <tt>const</tt> 量外，还可以使用 C++ 语言从 C 语言中继承下来的预处理器变量 <tt>NULL</tt>（<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >第 2.9.2 节</a>），该变量在 cstdlib 头文件中定义，其值为 0。如果在代码中使用了这个预处理器变量，则编译时会自动被数值 0 替换。因此，把指针初始化为 <tt>NULL</tt> 等效于初始化为 0 值：</P>

<pre>
          // <span class="docEmphasis">cstdlib #defines NULL</span> <span class="docEmphItalicAlt">to 0</span>
          int *pi = NULL; // <span class="docEmphItalicAlt">ok: equivalent to</span> <span class="docEmphasis">int *pi = 0;</span>
</pre>

<a name="idd1e25023"></a><a name="idd1e25030"></a><a name="idd1e25038"></a><a name="idd1e25043"></a>
<p class="docText">As with any preprocessor variable (<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >Section 2.9.2</a>, p. <a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >71</a>) we should not use the name <tt>NULL</tt> for our own variables.</p>
<p class="docText">正如其他的预处理器变量一样（<a class="docLink" href="ch02lev1sec9.html#ch02lev2sec31" >第 2.9.2 节</a>），不可以使用 <tt>NULL</tt> 这个标识符给自定义的变量命名。</P>

<a name="ch04note10"></a>
<div class="docNote">
	<p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1">
		<TR>
			<td width="60" valign="top">
				<img border="0" alt="" align="LEFT" width="50" height="54" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" >
			</td>
			<TD valign="top">
				<p class="docText">Preprocessor variables are not defined in the <tt>std</tt> namespace and hence the name is <tt>NULL</tt>, not <tt>std::NULL</tt>.</p>
				<p class="docText">预处理器变量不是在 <tt>std</tt> 命名空间中定义的，因此其名字应为 <tt>NULL</tt>，而非 <tt>std::NULL</tt>。</p>
			</td>
		</TR>
	</table>
	<br>
	</P>
</div>
<br>

<p class="docText">With two exceptions, which we cover in <a class="docLink" href="ch04lev1sec2.html#ch04lev2sec7">Sections 4.2.5</a> and <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3" >15.3</a>, we may only initialize or assign a pointer from an address or another pointer that has the same type as the target pointer:</p>
<p class="docText">除了将在<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec7">第 4.2.5 节</a>和<a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3" >第 15.3 节</a>介绍的两种例外情况之外，指针只能初始化或赋值为同类型的变量地址或另一指针：</P>

<pre>
          double dval;
          double *pd = &amp;dval;   // <span class="docEmphItalicAlt">ok: initializer is address of a</span> <span class="docEmphasis">double</span>
          double *pd2 = pd;     // <span class="docEmphItalicAlt">ok: initializer is a pointer to</span> <span class="docEmphasis">double</span>

          int *pi = pd;   // <span class="docEmphItalicAlt">error: types of</span> <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">pd</span> <span class="docEmphItalicAlt">differ</span>
          pi = &amp;dval;     // <span class="docEmphItalicAlt">error: attempt to assign address of a</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">int *</span>
</pre>

<p class="docText">The reason the types must match is that the type of the pointer is used to determine the type of the object that it addresses. Pointers are used to indirectly access an object. The operations that the pointer can perform are based on the type of the pointer: A pointer to <tt>int</tt> treats the underlying object as if it were an <tt>int</tt>. If that pointer actually addressed an object of some other type, such as <tt>double</tt>, then any operations performed by the pointer would be in error.</p>
<p class="docText">由于指针的类型用于确定指针所指对象的类型，因此初始化或赋值时必须保证类型匹配。指针用于间接访问对象，并基于指针的类型提供可执行的操作，例如，<tt>int</tt> 型指针只能把其指向的对象当作 <tt>int</tt> 型数据来处理，如果该指针确实指向了其他类型（如 <tt>double</tt> 类型）的对象，则在指针上执行的任何操作都有可能出错。</P>

<a name="ch04lev3sec11"></a>
<h5 class="docSection3Title"><tt>void*</tt> Pointers</h5>
<h5 class="docSection3Title"><tt>void*</tt> 指针</h5>

<a name="ch04term20"></a>
<p class="docText">The type <b><a class="docLink" href="ch04lev1sec6.html#gloss04_20" ><span class="docEmphStrong"><tt>void*</tt></span></a></b> is a special pointer type that can hold an address of any object:</p>
<p class="docText">C++ 提供了一种特殊的指针类型 <b><a class="docLink" href="ch04lev1sec6.html#gloss04_20" ><span class="docEmphStrong"><tt>void*</tt></span></a></b>，它可以保存任何类型对象的地址：</P>

<pre>
          double obj = 3.14;
          double *pd = &amp;obj;
          // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">void*</span> <span class="docEmphItalicAlt">can hold the address value of any data pointer type</span>
          void *pv = &amp;obj;       // <span class="docEmphasis">obj</span> <span class="docEmphItalicAlt">can be an object of any type</span>
          pv = pd;               // <span class="docEmphasis">pd</span> <span class="docEmphItalicAlt">can be a pointer to any type</span>
</pre>

<p class="docText">A <tt>void*</tt> indicates that the associated value is an address but that the type of the object at that address is unknown.</p>
<p class="docText"><tt>void*</tt> 表明该指针与一地址值相关，但不清楚存储在此地址上的对象的类型。</P>

<p class="docText">There are only a limited number of actions we can perform on a <tt>void*</tt> pointer: We can compare it to another pointer, we can pass or return it from a function, and we can assign it to another <tt>void*</tt> pointer. We cannot use the pointer to operate on the object it addresses. We'll see in <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28" >Section 5.12.4</a> (p. <a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28" >183</a>) how we can retrieve the address stored in a <tt>void*</tt> pointer.</p>
<p class="docText"><tt>void*</tt> 指针只支持几种有限的操作：与另一个指针进行比较；向函数传递 <tt>void*</tt> 指针或从函数返回 <tt>void*</tt> 指针；给另一个 <tt>void*</tt> 指针赋值。不允许使用 <tt>void*</tt> 指针操纵它所指向的对象。我们将在<a class="docLink" href="ch05lev1sec12.html#ch05lev2sec28" >第 5.12.4 节</a>讨论如何重新获取存储在 <tt>void*</tt> 指针中的地址。</P>

<a name="ch04sb05"></a>
<P>
<table cellspacing="0" width="90%" border="1" cellpadding="5">
	<tr>
		<td>
			<H2 class="docSidebarTitle">Exercises Section 4.2.2</H2>
			<blockquote>
				<p>
				<table border="0" cellspacing="16" cellpadding="0">
					<tr valign="top">
						<td align="right" class="docText" width="50">
							<a name="ch04qa3q1"></a>
							<b>Exercise 4.10:</b>
						</td>
						<TD>
							<a name="idd1e25268"></a><a name="idd1e25275"></a><a name="idd1e25282"></a><a name="idd1e25290"></a><a name="idd1e25298"></a><a name="idd1e25308"></a><a name="idd1e25313"></a>
							<p class="docText">Explain the rationale for preferring the first form of pointer declaration:</p>
							<p class="docText">下面提供了两种指针声明的形式，解释宁愿使用第一种形式的原因：</p>
<pre>
          int *ip; // <span class="docEmphItalicAlt">good practice</span>
          int* ip; // <span class="docEmphItalicAlt">legal but misleading</span>
</pre>
							</TD>
					</tr>
					<tr valign="top">
						<td align="right" class="docText" width="50">
							<B>Exercise 4.11:</b>
						</TD>
						<td>
							<p class="docText">Explain each of the following definitions. Indicate whether any are illegal and if so why.</p>
							<p class="docText">解释下列声明语句，并指出哪些是非法的，为什么？</p>
<pre>
          (a) int* ip;
          (b) string s, *sp = 0;
          (c) int i; double* dp = &amp;i;
          (d) int* ip, ip2;
          (e) const int i = 0, *p = i;
          (f) string *p = NULL;
</pre>
						</td>
					</tr>
					<tr valign="top">
						<td align="right" class="docText" width="50">
							<a name="ch04qa3q3"></a>
							<B>Exercise 4.12:</b>
						</td>
						<td>
							<p class="docText">Given a pointer, <tt>p</tt>, can you determine whether <tt>p</tt> points to a valid object? If so, how? If not, why not?</P>
							<p class="docText">已知一指针 <tt>p</tt>，你可以确定该指针是否指向一个有效的对象吗？如果可以，如何确定？如果不可以，请说明原因。</p>
						</td>
					</tr>
					<tr valign="top">
						<td align="right" class="docText" width="50">
							<a name="ch04qa3q4"></a>
							<b>Exercise 4.13:</b>
						</td>
						<td>
							<p class="docText">Why is the first pointer initialization legal and the second illegal?</p>
							<p class="docText">下列代码中，为什么第一个指针的初始化是合法的，而第二个则不合法？</p>
<pre>
          int i = 42;
          void *p = &amp;i;
          long *lp = &amp;i;
</pre>
						</td>
					</tr>
				</table>
				</p>
			</blockquote>
		</td>
	</tr>
</table>
</p>
<BR>

<a name="ch04lev2sec5"></a>
<h4 class="docSection2Title">4.2.3. Operations on Pointers</H4>
<h4 class="docSection2Title">4.2.3. 指针操作</H4>

<p class="docText">Pointers allow indirect manipulation of the object to which the pointer points. We can access the object by dereferencing the pointer. Dereferencing a pointer is similar to dereferencing an iterator (<a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4" >Section 3.4</a>, p. <a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4" >98</a>). The <tt>*</tt> operator (the dereference operator) returns the object to which the pointer points:</P>
<p class="docText">指针提供间接操纵其所指对象的功能。与对迭代器进行解引用操作（<a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4" >第 3.4 节</a>）一样，对指针进行解引用可访问它所指的对象，<tt>*</tt> 操作符（解引用操作符）将获取指针所指的对象：</P>

<pre>
          string s("hello world");
          string *sp = &amp;s; // <span class="docEmphasis">sp</span> <span class="docEmphItalicAlt">holds the address of</span> <span class="docEmphasis">s</span>
          cout  &lt;&lt;*sp;     // <span class="docEmphItalicAlt">prints</span> <span class="docEmphasis">hello world</span>
</pre>

<p class="docText">When we dereference <tt>sp</tt>, we fetch the value of <tt>s</tt>. We hand that value to the output operator. The last statement, therefore, prints the contents of <tt>s</tt>that is, <tt>hello world</tt>.</P>
<p class="docText">对 <tt>sp</tt> 进行解引用将获得 <tt>s</tt> 的值，然后用输出操作符输出该值，于是最后一条语句输出了 <tt>s</tt> 的内容 <tt>hello world</tt>。</P>

<a name="ch04lev3sec12"></a>
<h5 class="docSection3Title">Dereference Yields an Lvalue</H5>
<h5 class="docSection3Title">生成左值的解引用操作</H5>

<p class="docText">The dereference operator returns the lvalue of the underlying object, so we can use it to change the value of the object to which the pointer points:</p>
<p class="docText">解引用操作符返回指定对象的左值，利用这个功能可修改指针所指对象的值：</P>

<pre>
          *sp = "goodbye"; // <span class="docEmphItalicAlt">contents of</span> <span class="docEmphasis">s</span> <span class="docEmphItalicAlt">now changed</span>
</pre>

<p class="docText">Because we assign to <tt>*sp</tt>, this statement leaves <tt>sp</tt> pointing to <tt>s</tt> and changes the value of <tt>s</tt>.</P>
<p class="docText">因为 <tt>sp</tt> 指向 <tt>s</tt>，所以给 <tt>*sp</tt> 赋值也就修改了 <tt>s</tt> 的值。</P>

<p class="docText">We can also assign a new value to <tt>sp</tt> itself. Assigning to <tt>sp</tt> causes <tt>sp</tt> to point to a different object:</P>
<p class="docText">也可以修改指针 <tt>sp</tt> 本身的值，使 <tt>sp</tt> 指向另外一个新对象：</P>

<pre>
          string s2 = "some value";
          sp = &amp;s2;  // <span class="docEmphasis">sp</span> <span class="docEmphItalicAlt">now points to</span> <span class="docEmphasis">s2</span>
</pre>

<p class="docText">We change the value of a pointer by assigning to it directlywithout dereferencing the pointer.</p>
<p class="docText">给指针直接赋值即可修改指针的值——不需要对指针进行解引用。</P>

<a name="ch04sb06"></a>
<p>
<table cellspacing="0" width="90%" border="1" cellpadding="5">
	<tr>
		<td>
			<h2 class="docSidebarTitle">Key Concept: Assigning <span class="docEmphasis">TO</span> or <span class="docEmphasis">THROUGH</span> a Pointer</h2>
			<h2 class="docSidebarTitle">关键概念：给指针赋值或通过指针进行赋值</h2>

			<a name="idd1e25480"></a><a name="idd1e25485"></a>
			<p class="docText"><span class="docEmphStrong">When first using pointers, the difference in whether an assignment is to the pointer or through the pointer to the value pointed to can be confusing. The important thing to keep in mind is that if the left-hand operand is dereferenced, then the value pointed to is changed. If there is no dereference, then the pointer itself is being changed. A picture can sometimes help:</span></P>
			<p class="docText"><span class="docEmphStrong">对于初学指针者，给指针赋值和通过指针进行赋值这两种操作的差别确实让人费解。谨记区分的重要方法是：如果对左操作数进行解引用，则修改的是指针所指对象的值；如果没有使用解引用操作，则修改的是指针本身的值。如图所示，帮助理解下列例子：</span></P>

			<p class="docText"><img border="0" alt="" width="500" height="269" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/121fig01.gif;400478" ></P></p>
		</td>
	</tr>
</table><BR>

<a name="ch04lev3sec13"></a>
<H5 class="docSection3Title">Comparing Pointers and References</h5>
<H5 class="docSection3Title">指针和引用的比较</h5>

<p class="docText">While both references and pointers are used to indirectly access another value, there are two important differences between references and pointers. The first is that a reference always refers to an object: It is an error to define a reference without initializing it. The behavior of assignment is the second important difference: Assigning to a reference changes the object to which the reference is bound; it does not rebind the reference to another object. Once initialized, a reference <span class="docEmphasis">always</span> refers to the same underlying object.</p>
<p class="docText">虽然使用引用（reference）和指针都可间接访问另一个值，但它们之间有两个重要区别。第一个区别在于引用总是指向某个对象：定义引用时没有初始化是错误的。第二个重要区别则是赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。引用一经初始化，就<span class="docEmphasis">始终</span>指向同一个特定对象（这就是为什么引用必须在定义时初始化的原因）。</p>

<p class="docText">Consider these two program fragments. In the first, we assign one pointer to another:</p>
<p class="docText">考虑以下两个程序段。第一个程序段将一个指针赋给另一指针：</p>

<pre>
          int ival = 1024, ival2 = 2048;
          int *pi = &amp;ival, *pi2 = &amp;ival2;
          pi = pi2;    // <span class="docEmphasis">pi</span> <span class="docEmphItalicAlt">now points to</span> <span class="docEmphasis">ival2</span>
</pre>

<p class="docText">After the assignment, <tt>ival</tt>, the object addressed by <tt>pi</tt> remains unchanged. The assignment changes the value of <tt>pi</tt>, making it point to a different object. Now consider a similar program that assigns two references:</P>
<p class="docText">赋值结束后，<tt>pi</tt> 所指向的 <tt>ival</tt> 对象值保持不变，赋值操作修改了 <tt>pi</tt> 指针的值，使其指向另一个不同的对象。现在考虑另一段相似的程序，使用两个引用赋值：</p>

<pre>
          int &amp;ri = ival, &amp;ri2 = ival2;
          ri = ri2;    // <span class="docEmphItalicAlt">assigns</span> <span class="docEmphasis">ival2</span> <span class="docEmphItalicAlt">to</span> <span class="docEmphasis">ival</span>
</pre>

<p class="docText">This assignment changes <tt>ival</tt>, the value referenced by <tt>ri</tt>, and not the reference itself. After the assignment, the two references still refer to their original objects, and the value of those objects is now the same as well.</p>
<p class="docText">这个赋值操作修改了 <tt>ri</tt> 引用的值 <tt>ival</tt> 对象，而并非引用本身。赋值后，这两个引用还是分别指向原来关联的对象，此时这两个对象的值相等。</p>

<a name="ch04lev3sec14"></a>
<H5 class="docSection3Title">Pointers to Pointers</h5>
<H5 class="docSection3Title">指向指针的指针</h5>

<a name="idd1e25577"></a><a name="idd1e25582"></a><a name="idd1e25587"></a><a name="idd1e25592"></a><a name="idd1e25597"></a>
<p class="docText">Pointers are themselves objects in memory. They, therefore, have addresses that we can store in a pointer:</p>
<p class="docText">指针本身也是可用指针指向的内存对象。指针占用内存空间存放其值，因此指针的存储地址可存放在指针中。下面程序段：</p>

<pre>
          int ival = 1024;
          int *pi = &amp;ival; // <span class="docEmphItalicAlt">pi points to an int</span>
          int **ppi = &amp;pi; // <span class="docEmphItalicAlt">ppi points to a pointer to int</span>
</pre>

<p class="docText">which yields a pointer to a pointer. We designate a pointer to a pointer by using <tt>**</tt>. We might represent these objects as</p>
<p class="docText">定义了指向指针的指针。C++ 使用 <tt>**</tt> 操作符指派一个指针指向另一指针。这些对象可表示为：</p>

<p class="docText"><img border="0" alt="" width="303" height="53" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/122fig01.gif;400478" ></P>

<p class="docText">As usual, dereferencing <tt>ppi</tt> yields the object to which <tt>ppi</tt> points. In this case, that object is a pointer to an <tt>int</tt>:</p>
<p class="docText">对 <tt>ppi</tt> 进行解引用照常获得 <tt>ppi</tt> 所指的对象，在本例中，所获得的对象是指向 <tt>int</tt> 型变量的指针 <tt>pi</tt>：</p>

<pre>
          int *pi2 = *ppi; // <span class="docEmphasis">ppi</span> <span class="docEmphItalicAlt">points to a pointer</span>
</pre>

<p class="docText">To actually access <tt>ival</tt>, we need to dereference <tt>ppi</tt> twice:</p>
<p class="docText">为了真正地访问到 <tt>ival</tt> 对象，必须对 <tt>ppi</tt> 进行两次解引用：</p>

<pre>
          cout &lt;&lt; "The value of ival\n"
               &lt;&lt; "direct value: " &lt;&lt; ival &lt;&lt; "\n"
               &lt;&lt; "indirect value: " &lt;&lt; *pi &lt;&lt; "\n"
               &lt;&lt; "doubly indirect value: " &lt;&lt; **ppi
               &lt;&lt; endl;
</pre>

<p class="docText">This program prints the value of <tt>ival</tt> three different ways. First, by direct reference to the variable. Then, through the pointer to <tt>int</tt> in <tt>pi</tt>, and finally, by dereferencing <tt>ppi</tt> twice to get to the underlying value in <tt>ival</tt>.</p>
<p class="docText">这段程序用三种不同的方式输出 <tt>ival</tt> 的值。首先，采用直接引用变量的方式输出；然后使用指向 <tt>int</tt> 型对象的指针 <tt>pi</tt> 输出；最后，通过对 <tt>ppi</tt> 进行两次解引用获得 <tt>ival</tt> 的特定值。</p>

<a name="ch04sb07"></a>
<p>
<table cellspacing="0" width="90%" border="1" cellpadding="5">
	<tr>
		<td>
			<h2 class="docSidebarTitle">Exercises Section 4.2.3</h2>
			<blockquote>
				<p>
				<table border="0" cellspacing="16" cellpadding="0">
					<tr valign="top">
						<TD align="right" class="docText" width="50">
							<a name="ch04qa4q1"></a>
							<B>Exercise 4.14:</b>
						</td>
						<TD>
							<p class="docText">Write code to change the value of a pointer. Write code to change the value to which the pointer points.</p>
							<p class="docText">编写代码修改指针的值；然后再编写代码修改指针所指对象的值。</p>
						</td>
					</tr>
					<tr valign="top">
						<td align="right" class="docText" width="50">
							<a name="ch04qa4q2"></a>
							<b>Exercise 4.15:</b>
						</td>
						<td>
							<p class="docText">Explain the key differences between pointers and references.</p>
							<p class="docText">解释指针和引用的主要区别。</p>
						</td>
					</tr>
					<tr valign="top">
						<td align="right" class="docText" width="50">
							<a name="ch04qa4q3"></a>
							<b>Exercise 4.16:</b>
						</td>
						<td>
							<p class="docText">What does the following program do?</P>
							<p class="docText">下列程序段实现什么功能？</p>
<pre>
          int i = 42, j = 1024;
          int *p1 = &amp;i, *p2 = &amp;j;
          *p2 = *p1 * *p2;
          *p1 *= *p1;
</pre>
						</td>
					</tr>
				</table>
				</p>
			</blockquote>
		</td>
	</TR>
</table>
</p>
<br>


<a name="ch04lev2sec6"></a>
<H4 class="docSection2Title">4.2.4. Using Pointers to Access Array Elements</h4>
<H4 class="docSection2Title">4.2.4. 使用指针访问数组元素</h4>

<p class="docText">Pointers and arrays are closely intertwined in C++. In particular, when we use the name of an array in an expression, that name is automatically converted into a pointer to the first element of the array:</p>
<p class="docText">C++ 语言中，指针和数组密切相关。特别是在表达式中使用数组名时，该名字会自动转换为指向数组第一个元素的指针：</p>

<pre>
          int ia[] = {0,2,4,6,8};
          int *ip = ia; // <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">ia[0]</span>
</pre>

<a name="idd1e25760"></a><a name="idd1e25767"></a><a name="idd1e25774"></a><a name="idd1e25782"></a><a name="idd1e25787"></a><a name="idd1e25792"></a><a name="idd1e25798"></a><a name="idd1e25808"></a><a name="idd1e25821"></a><a name="idd1e25824"></a><a name="idd1e25829"></a>
<p class="docText">If we want to point to another element in the array, we could do so by using the subscript operator to locate the element and then applying the address-of operator to find its location:</p>
<p class="docText">如果希望使指针指向数组中的另一个元素，则可使用下标操作符给某个元素定位，然后用取地址操作符 <tt>&amp;</tt> 获取该元素的存储地址：</p>

<pre>
          ip = &amp;ia[4];    // <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">points to last element in</span> <span class="docEmphasis">ia</span>
</pre>

<a name="ch04lev3sec15"></a>
<h5 class="docSection3Title">Pointer Arithmetic</h5>
<h5 class="docSection3Title">指针的算术操作</h5>

<a name="ch04term12"></a>
<p class="docText">Rather than taking the address of the value returned by subscripting, we could use <b><a class="docLink" href="ch04lev1sec6.html#gloss04_12" >pointer arithmetic</a></b>. Pointer arithmetic works the same way (and has the same constraints) as iterator arithmetic (<a class="docLink" href="ch03lev1sec4.html#ch03lev2sec14" >Section 3.4.1</a>, p. <a class="docLink" href="ch03lev1sec4.html#ch03lev2sec14" >100</a>). Using pointer arithmetic, we can compute a pointer to an element by adding (or subtracting) an integral value to (or from) a pointer to another element in the array:</p>
<p class="docText">与其使用下标操作，倒不如通过<b><a class="docLink" href="ch04lev1sec6.html#gloss04_12" >指针的算术操作</a></b>来获取指定内容的存储地址。指针的算术操作和迭代器的算术操作（<a class="docLink" href="ch03lev1sec4.html#ch03lev2sec14" >第 3.4.1 节</a>）以相同的方式实现（也具有相同的约束）。使用指针的算术操作在指向数组某个元素的指针上加上（或减去）一个整型数值，就可以计算出指向数组另一元素的指针值：</p>

<pre>
          ip = ia;            // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ip</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">ia[0]</span>
          int *ip2 = ip + 4;  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ip2</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">ia[4]</span>, <span class="docEmphItalicAlt">the last element in</span> <span class="docEmphasis">ia</span>
</pre>

<p class="docText">When we add <tt>4</tt> to the pointer <tt>ip</tt>, we are computing a new pointer. That new pointer points to the element four elements further on in the array from the one to which <tt>ip</tt> currently points.</p>
<p class="docText">在指针 <tt>ip</tt> 上加 <tt>4</tt> 得到一个新的指针，指向数组中 <tt>ip</tt> 当前指向的元素后的第 <tt>4</tt> 个元素。</p>

<p class="docText">More generally, when we add (or subtract) an integral value to a pointer, the effect is to compute a new pointer. The new pointer points to the element as many elements as that integral value ahead of (or behind) the original pointer.</p>
<p class="docText">通常，在指针上加上（或减去）一个整型数值 n 等效于获得一个新指针，该新指针指向指针原来指向的元素之后（或之前）的第 n 个元素。</p>

<a name="ch04note11"></a>
<div class="docNote">
	<p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1">
		<tr>
			<td width="60" valign="top">
				<img border="0" alt="" align="LEFT" width="50" height="54" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" >
			</td>
			<td valign="top">
				<p class="docText"> Pointer arithmetic is legal only if the original pointer and the newly calculated pointer address elements of the same array or an element one past the end of that array. If we have a pointer to an object, we can also compute a pointer that points just after that object by adding one to the pointer.</p>
				<p class="docText">指针的算术操作只有在原指针和计算出来的新指针都指向同一个数组的元素，或指向该数组存储空间的下一单元时才是合法的。如果指针指向一对象，我们还可以在指针上加1从而获取指向相邻的下一个对象的指针。</p>
			</td>
		</tr>
	</table>
	<br>
	</p>
</div>
<br>

<p class="docText">Given that <tt>ia</tt> has 4 elements, adding 10 to <tt>ia</tt> would be an error:</p>
<p class="docText">假设数组 <tt>ia</tt> 只有 4 个元素，则在 <tt>ia</tt> 上加 10 是错误的：</p>

<pre>
          // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">ia</span> <span class="docEmphItalicAlt">has only 4 elements,</span> <span class="docEmphasis">ia</span> <span class="docEmphItalicAlt">+ 10 is an invalid address</span>
          int *ip3 = ia + 10;
</pre>

<p class="docText">We can also subtract two pointers as long as they point into the same array or to an element one past the end of the array:</P>
<p class="docText">只要两个指针指向同一数组或有一个指向该数组末端的下一单元，C++ 还支持对这两个指针做减法操作：</p>

<pre>
          ptrdiff_t n = ip2 - ip; // <span class="docEmphItalicAlt">ok: distance between the pointers</span>
</pre>

<a name="ch04term14"></a>
<p class="docText">The result is four, the distance between the two pointers, measured in objects. The result of subtracting two pointers is a library type named <b><a class="docLink" href="ch04lev1sec6.html#gloss04_14" ><span class="docEmphStrong"><tt>ptrdiff_t</tt>.</span></a></b> Like <tt>size_t</tt>, the <tt>ptrdiff_t</tt> type is a machine-specific type and is defined in the <tt>cstddef</tt> header. The <tt>size_t</tt> type is an <tt>unsigned</tt> type, whereas <tt>ptrdiff_t</tt> is a <tt>signed</tt> integral type.</p>
<p class="docText">结果是 4，这两个指针所指向的元素间隔为 4 个对象。两个指针减法操作的结果是标准库类型（library type）<b><a class="docLink" href="ch04lev1sec6.html#gloss04_14" ><span class="docEmphStrong"><tt>ptrdiff_t</tt></span></a></b> 的数据。与 <tt>size_t</tt> 类型一样，<tt>ptrdiff_t</tt> 也是一种与机器相关的类型，在 <tt>cstddef</tt> 头文件中定义。<tt>size_t</tt> 是 <tt>unsigned</tt> 类型，而 <tt>ptrdiff_t</tt> 则是 <tt>signed</tt> 整型。</p>

<a name="idd1e26012"></a><a name="idd1e26019"></a><a name="idd1e26032"></a><a name="idd1e26037"></a><a name="idd1e26040"></a>
<p class="docText">The difference in type reflects how these two types are used: <tt>size_t</tt> is used to hold the size of an array, which must be a positive value. The <tt>ptrdiff_t</tt> type is guaranteed to be large enough to hold the difference between any two pointers into the same array, which might be a negative value. For example, had we subtracted <tt>ip2</tt> from <tt>ip</tt>, the result would be <tt>-4</tt>.</p>
<p class="docText">这两种类型的差别体现了它们各自的用途：<tt>size_t</tt> 类型用于指明数组长度，它必须是一个正数；<tt>ptrdiff_t</tt> 类型则应保证足以存放同一数组中两个指针之间的差距，它有可能是负数。例如，<tt>ip</tt> 减去 <tt>ip2</tt>，结果为 <tt>-4</tt>。</p>

<p class="docText">It is always possible to add or subtract zero to a pointer, which leaves the pointer unchanged. More interestingly, given a pointer that has a value of zero, it is also legal to add zero to that pointer. The result is another zero-valued pointer. We can also subtract two pointers that have a value of zero. The result of subtracting two zero-valued pointers is zero.</p>
<p class="docText">允许在指针上加减 0，使指针保持不变。更有趣的是，如果一指针具有 0 值（空指针），则在该指针上加 0 仍然是合法的，结果得到另一个值为 0 的指针。也可以对两个空指针做减法操作，得到的结果仍是 0。</p>

<a name="ch04lev3sec16"></a>
<H5 class="docSection3Title">Interaction between Dereference and Pointer Arithmetic</h5>
<H5 class="docSection3Title">解引用和指针算术操作之间的相互作用</h5>

<p class="docText">The result of adding an integral value to a pointer is itself a pointer. We can dereference the resulting pointer directly without first assigning it to another pointer:</P>
<p class="docText">在指针上加一个整型数值，其结果仍然是指针。允许在这个结果上直接进行解引用操作，而不必先把它赋给一个新指针：</p>

<pre>
          int last = *(ia + 4); // <span class="docEmphItalicAlt">ok: initializes</span> <span class="docEmphasis">last</span> <span class="docEmphItalicAlt">to 8, the value of</span> <span class="docEmphasis">ia[4]</span>
</pre>

<p class="docText">This expression calculates the address four elements past <tt>ia</tt> and dereferences that pointer. It is equivalent to writing <tt>ia[4]</tt>.</p>
<p class="docText">这个表达式计算出 <tt>ia</tt> 所指向元素后面的第 4 个元素的地址，然后对该地址进行解引用操作，等价于 <tt>ia[4]</tt>。</p>

<a name="ch04note12"></a>
<div class="docNote">
	<p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1">
		<tr>
			<TD width="60" valign="top">
				<img border="0" alt="" align="LEFT" width="50" height="54" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" >
			</td>
			<td valign="top">
				<p class="docText"> The parentheses around the addition are essential. Writing</p>
				<p class="docText">加法操作两边用圆括号括起来是必要的。如果写为：</p>
			</td>
		</tr>
	</table><BR>

<pre>
          last = *ia + 4;     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">last</span> <span class="docEmphItalicAlt">= 4, equivalent to</span> <span class="docEmphasis">ia[0]+4</span>
</pre>

<p class="docText">means dereference <tt>ia</tt> and add four to the dereferenced value.</p>
<p class="docText">意味着对 <tt>ia</tt> 进行解引用，获得 <tt>ia</tt> 所指元素的值 <tt>ia[0]</tt>，然后加 4。</p>

</div>
</P><br>

<a name="ch04term13"></a>
<p class="docText">The parentheses are required due to the <b><a class="docLink" href="ch04lev1sec6.html#gloss04_13" >precedence</a></b> of the addition and dereference operators. We'll learn more about precedence in <a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14" >Section 5.10.1</a> (p. <a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14" >168</a>). Simply put, precedence stipulates how operands are grouped in expressions with multiple operators. The dereference operator has a higher precedence than the addition operator.</P>
<p class="docText">由于加法操作和解引用操作的<b><a class="docLink" href="ch04lev1sec6.html#gloss04_13" >优先级</a></b>不同，上述表达式中的圆括号是必要的。我们将在<a class="docLink" href="ch05lev1sec10.html#ch05lev2sec14" >第 5.10.1 节</a>讨论操作符的优先级。简单地说，优先级决定了有多个操作符的表达式如何对操作数分组。解引用操作符的优先级比加法操作符高。</p>

<p class="docText">The operands to operators with higher precedence are grouped more tightly than those of lower precedence. Without the parentheses, the dereference operator would use <tt>ia</tt> as its operand. The expression would be evaluated by dereferencing <tt>ia</tt> and adding four to the value of the element at the beginning of <tt>ia</tt>.</p>
<p class="docText">与低优先级的操作符相比，优先级高的操作符的操作数先被组合起来操作。如果没有圆括号，解引用操作符的操作数是 <tt>ia</tt>，该表达式先对 <tt>ia</tt> 解引用，获得 <tt>ia</tt> 数组中的第一个元素，并将该值与 4 相加。</p>

<p class="docText">By parenthesizing the expression, we override the normal precedence rules and effectively treat <tt>(ia + 4)</tt> as a single operand. That operand is an address of an element four past the one to which <tt>ia</tt> points. That new address is dereferenced.</P>
<p class="docText">如果表达式加上圆括号，则不管一般的优先级规则，将 <tt>(ia + 4)</tt> 作为单个操作数，这是 <tt>ia</tt> 所指向的元素后面第4个元素的地址，然后对这个新地址进行解引用。</p>

<a name="ch04lev3sec17"></a>
<h5 class="docSection3Title">Subscripts and Pointers</h5>
<h5 class="docSection3Title">下标和指针</h5>

<p class="docText">We have already seen that when we use an array name in an expression, we are actually using a pointer to the first element in the array. This fact has a number of implications, which we shall point out as they arise.</p>
<p class="docText">我们已经看到，在表达式中使用数组名时，实际上使用的是指向数组第一个元素的指针。这种用法涉及很多方面，当它们出现时我们会逐一指出来。</p>

<p class="docText">One important implication is that when we subscript an array, we are really subscripting a pointer:</p>
<p class="docText">其中一个重要的应用是使用下标访问数组时，实际上是使用下标访问指针：</p>

<pre>
          int ia[] = {0,2,4,6,8};
          int i = ia[0]; // <span class="docEmphasis">ia</span> <span class="docEmphItalicAlt">points to the first element in</span> <span class="docEmphasis">ia</span>
</pre>

<p class="docText">When we write <tt>ia[0]</tt>, that is an expression that uses the name of an array. When we subscript an array, we are really subscripting a pointer to an element in that array. We can use the subscript operator on any pointer, as long as that pointer points to an element in an array:</p>
<p class="docText"><tt>ia[0]</tt> 是一个使用数组名的表达式。在使用下标访问数组时，实际上是对指向数组元素的指针做下标操作。只要指针指向数组元素，就可以对它进行下标操作：</p>

<pre>
          int *p = &amp;ia[2];     // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">points to the element indexed by 2</span>
          int j = p[1];        // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p[1]</span> <span class="docEmphItalicAlt">equivalent to</span> <span class="docEmphasis">*(p + 1)</span>,
                               //    <span class="docEmphasis">p[1]</span> <span class="docEmphItalicAlt">is the same element as</span> <span class="docEmphasis">ia[3]</span>
          int k = p[-2];       // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p[-2]</span> <span class="docEmphItalicAlt">is the same element as</span> <span class="docEmphasis">ia[0]</span>
</pre>

<a name="ch04lev3sec18"></a>
<h5 class="docSection3Title">Computing an Off-the-End Pointer</h5>
<h5 class="docSection3Title">计算数组的超出末端指针</h5>

<a name="idd1e26253"></a><a name="idd1e26256"></a>
<p class="docText">When we use a <tt>vector</tt>, the <tt>end</tt> operation returns an iterator that refers just past the end of the <tt>vector</tt>. We often use this iterator as a sentinel to control loops that process the elements in the <tt>vector</tt>. Similarly, we can compute an off-the-end pointer value:</p>
<p class="docText"><tt>vector</tt> 类型提供的 <tt>end</tt> 操作将返回指向超出 <tt>vector</tt> 末端位置的一个迭代器。这个迭代器常用作哨兵，来控制处理 <tt>vector</tt> 中元素的循环。类似地，可以计算数组的超出末端指针的值：</p>

<pre>
          const size_t arr_size = 5;
          int arr[arr_size] = {1,2,3,4,5};
          int *p = arr;           // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p</span> <span class="docEmphItalicAlt">points to</span> <span class="docEmphasis">arr[0]</span>
          int *p2 = p + arr_size; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">p2</span> <span class="docEmphItalicAlt">points one past the end of</span> <span class="docEmphasis">arr</span>
                                  //    <span class="docEmphItalicAlt">use caution -- do not dereference!</span>
</pre>

<p class="docText">In this case, we set <tt>p</tt> to point to the first element in <tt>arr</tt>. We then calculate a pointer one past the end of <tt>arr</tt> by adding the size of <tt>arr</tt> to the pointer value in <tt>p</tt>. When we add <tt>5</tt> to <tt>p</tt>, the effect is to calculate the address of that is five <tt>int</tt>s away from <tt>p</tt>in other words, <tt>p + 5</tt> points just past the end of <tt>arr</tt>.</p>
<p class="docText">本例中，<tt>p</tt> 指向数组 <tt>arr</tt> 的第一个元素，在指针 <tt>p</tt> 上加数组长度即可计算出数组 <tt>arr</tt> 的超出末端指针。<tt>p</tt> 加 5 即得 <tt>p</tt> 所指向的元素后面的第五个 <tt>int</tt> 元素的地址——换句话说，<tt>p + 5</tt>指向数组的超出末端的位置。</p>

<a name="ch04note13"></a>
<div class="docNote">
	<p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1">
		<TR>
			<TD width="60" valign="top">
				<img border="0" alt="" align="LEFT" width="50" height="54" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" >
			</td>
			<TD valign="top">
				<p class="docText">It is legal to compute an address one past the end of an array or object. It is not legal to dereference a pointer that holds such an address. Nor is it legal to compute an address more than one past the end of an array or an address before the beginning of an array.</p>
				<p class="docText">C++ 允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端位置之后或数组首地址之前的地址都是不合法的。</p>
			</td>
		</TR>
	</table><BR>
	</p>
</div><br>

<p class="docText">The address we calculated and stored in <tt>p2</tt> acts much like the iterator returned from the <tt>end</tt> operation on <tt>vector</tt>s. The iterator we obtain from <tt>end</tt> denotes &quot;one past the end&quot; of the <tt>vector</tt>. We may not dereference that iterator, but we may compare it to another iterator value to see whether we have processed all the elements in the <tt>vector</tt>. Similarly, the value we calculated for <tt>p2</tt> can be used <span class="docEmphasis">only</span> to compare to another pointer value or as an operand in a pointer arithmetic expression. If we attempt to dereference <tt>p2</tt>, the most likely result is that it would yield some garbage value. Most compilers, would treat the result of dereferencing <tt>p2</tt> as an <tt>int</tt>, using whatever bits happened to be in memory at the location just after the last element in <tt>arr</tt>.</p>
<p class="docText">计算并存储在p2中的地址，与在 <tt>vector</tt> 上做 <tt>end</tt> 操作所返回的迭代器具有相同的功能。由 <tt>end</tt> 返回的迭代器标志了该 <tt>vector</tt> 对象的“超出末端位置”，不能进行解引用运算，但是可将它与别的迭代器比较，从而判断是否已经处理完 <tt>vector</tt> 中所有的元素。同理，<tt>p2</tt> 也只能用来与其他指针比较，或者用做指针算术操作表达式的操作数。对 <tt>p2</tt> 进行解引用将得到无效值。对大多数的编译器来说，会把对 <tt>p2</tt> 进行解引用的结果（恰好存储在 <tt>arr</tt> 数组的最后一个元素后面的内存中的二进制位）视为一个 <tt>int</tt> 型数据。 </p>

<a name="ch04lev3sec19"></a>
<h5 class="docSection3Title">Printing the Elements of an Array</h5>
<h5 class="docSection3Title">输出数组元素</h5>

<p class="docText">Now we are ready to write a program that uses pointers:</P>
<p class="docText">用指针编写以下程序：</p>

<pre>
          const size_t arr_sz = 5;
          int int_arr[arr_sz] = { 0, 1, 2, 3, 4 };
          // <span class="docEmphasis">pbegin</span> <span class="docEmphItalicAlt">points to first element,</span> <span class="docEmphasis">pend</span> <span class="docEmphItalicAlt">points just after the last</span>
          for (int *pbegin = int_arr, *pend = int_arr + arr_sz;
                    pbegin != pend; ++pbegin)
              cout &lt;&lt; *pbegin &lt;&lt; ' '; // <span class="docEmphItalicAlt">print the current element</span>
</pre>

<p class="docText">This program uses a feature of the <tt>for</tt> loop that we have not yet used: We may define multiple variables inside the <span class="docEmphasis">init-statement</span> (<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >Section 1.4.2</a>, p. <a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >14</a>) of a <tt>for</tt> as long as the variables are defined using the same type. In this case, we're defining two <tt>int</tt> pointers named <tt>pbegin</tt> and <tt>pend</tt>.</P>
<p class="docText">这段程序使用了一个我们以前没有用过的 <tt>for</tt> 循环性质：只要定义的多个变量具有相同的类型，就可以在 <tt>for</tt> 循环的<span class="docEmphasis">初始化语句</span>（<a class="docLink" href="ch01lev1sec4.html#ch01lev2sec6" >第 1.4.2 节</a>）中同时定义它们。本例在初始化语句中定义了两个 <tt>int</tt> 型指针 <tt>pbegin</tt> 和 <tt>pend</tt>。</p>

<p class="docText">We use these pointers to traverse the array. Like other built-in types, arrays have no member functions. Hence, there are no <tt>begin</tt> and <tt>end</tt> operations on arrays. Instead, we must position pointers to denote the first and one past the last elements ourselves. We do so in the initialization of our two pointers. We initialize <tt>pbegin</tt> to address the first element of <tt>int_arr</tt> and <tt>pend</tt> to one past the last element in the array:</P>
<p class="docText">C++ 允许使用指针遍历数组。和其他内置类型一样，数组也没有成员函数。因此，数组不提供 <tt>begin</tt> 和 <tt>end</tt> 操作，程序员只能自己给指针定位，使之分别标志数组的起始位置和超出末端位置。可在初始化中实现这两个指针的定位：初始化指针 <tt>pbegin</tt> 指向 <tt>int_arr</tt> 数组的第一个元素，而指针 <tt>pend</tt> 则指向该数组的超出末端的位置：</p>

<p class="docText">
<img border="0" alt="" width="312" height="112" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/126fig01.gif;400478" ></p>

<p class="docText">The pointer <tt>pend</tt> serves as a sentinel, allowing the <tt>for</tt> loop to know when to stop. Each iteration of the <tt>for</tt> loop increments <tt>pbegin</tt> to address the next element. On the first trip through the loop, <tt>pbegin</tt> denotes the first element, on the second iteration, the second element, and so on. After processing the last element in the array, <tt>pbegin</tt> will be incremented once more and will then equal <tt>pend</tt>. At that point we know that we have iterated across the entire array.</p>
<p class="docText">指针 <tt>pend</tt> 是标志 <tt>for</tt> 循环结束的哨兵。<tt>for</tt> 循环的每次迭代都会使 <tt>pbegin</tt> 递增 1 以指向数组的下一个元素。第一次执行 <tt>for</tt> 循环时，<tt>pbegin</tt> 指向数组中的第一个元素；第二次循环，指向第二个元素；这样依次类推。当处理完数组的最后一个元素后，<tt>pbegin</tt> 再加 1 则与 <tt>pend</tt> 值相等，表示整个数组已遍历完毕。</p>

<a name="ch04lev3sec20"></a>
<h5 class="docSection3Title">Pointers Are Iterators for Arrays</H5>
<h5 class="docSection3Title">指针是数组的迭代器</H5>

<p class="docText">Astute readers will note that this program is remarkably similar to the program on page <a class="docLink" href="ch03lev1sec4.html#ch03lev2sec13" >99</a>, which traversed and printed the contents of a <tt>vector</tt> of <tt>string</tt>s. The loop in that program</P>
<p class="docText">聪明的读者可能已经注意到这段程序与<a class="docLink" href="ch03lev1sec4.html#ch03lev2sec13" >第 3.4 节</a>的一段程序非常相像，该程序使用下面的循环遍历并输出一个 <tt>string</tt> 类型的 <tt>vector</tt> 的内容：</p>

<pre>
          // <span class="docEmphItalicAlt">equivalent loop using iterators to reset all the elements in</span> <span class="docEmphasis">ivec</span> <span class="docEmphItalicAlt">to 0</span>
          for (vector&lt;int&gt;::iterator iter = ivec.begin();
                                     iter != ivec.end(); ++iter)
              *iter = 0; // <span class="docEmphItalicAlt">set element to which</span> <span class="docEmphasis">iter</span> <span class="docEmphItalicAlt">refers to 0</span>
</pre>

<p class="docText">used iterators in much the same way that pointers are used in the program to print the contents of the array. This similarity is not a coincidence. In fact, the built-in array type has many of the properties of a library container, and pointers, when we use them in conjunction with arrays, are themselves iterators. We'll have much more to say about containers and iterators in <a class="docLink" href="part02.html#part02" >Part II</a>.</p>
<p class="docText">这段程序使用迭代器的方式就像上个程序使用指针实现输出数组内容一样。指针和迭代器的这个相似之处并不是巧合。实际上，内置数组类型具有标准库容器的许多性质，与数组联合使用的指针本身就是迭代器。在第二部分中，我们还会详细介绍容器和迭代器类型。</p>

<a name="ch04sb08"></a>
<p>
<table cellspacing="0" width="90%" border="1" cellpadding="5">
	<TR>
		<td>
			<H2 class="docSidebarTitle">Exercises Section 4.2.4</h2>
			<blockquote>
				<p>
				<table border="0" cellspacing="16" cellpadding="0">
					<tr valign="top">
						<td align="right" class="docText" width="50">
							<a name="ch04qa5q1"></a>
							<b>Exercise 4.17:</b>
						</td>
						<td>
							<p class="docText">Given that p1 and p2 point to elements in the same array, what does the following statement do?</p>
							<p class="docText">已知 <tt>p1</tt> 和 <tt>p2</tt> 指向同一个数组中的元素，下面语句实现什么功能？</p>
<pre>
          p1 += p2 - p1;
</pre>
							<p class="docText">Are there any values of <tt>p1</tt> or <tt>p2</tt> that could make this code illegal?</p>
							<p class="docText">当 <tt>p1</tt> 和 <tt>p2</tt> 具有什么值时这个语句是非法的？</p>
						</td>
					</tr>
					<tr valign="top">
						<TD align="right" class="docText" width="50">
							<a name="ch04qa5q2"></a>
							<B>Exercise 4.18:</b>
						</td>
						<TD>
							<p class="docText">Write a program that uses pointers to set the elements in an array of <tt>int</tt>s to zero.</p>
							<p class="docText">编写程序，使用指针把一个 <tt>int</tt> 型数组的所有元素设置为0。</p>
				</td>
		</TR>
	</table>
	</P>
</blockquote>
</td>
</tr>
</table>
</p>
<br>

<a name="ch04lev2sec7"></a>
<h4 class="docSection2Title">4.2.5. Pointers and the <tt>const</tt> Qualifier</h4>
<h4 class="docSection2Title">4.2.5. 指针和 <tt>const</tt> 限定符</h4>

<p class="docText">There are two kinds of interactions between pointers and the <tt>const</tt> qualifier discussed in <a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4" >Section 2.4</a> (p. <a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4" >56</a>): We can have pointers to <tt>const</tt> objects and pointers that are themselves <tt>const</tt>. This section discusses both kinds of pointers.</P>
<p class="docText"><a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4" >第 2.4 节</a>介绍了指针和 <tt>const</tt> 限定符之间的两种交互类型：指向 <tt>const</tt> 对象的指针和 <tt>const</tt> 指针。我们在本节中详细讨论这两类指针。</p>

<a name="ch04lev3sec21"></a>
<h5 class="docSection3Title">Pointers to <tt>const</tt> Objects</h5>
<h5 class="docSection3Title">指向 <tt>const</tt> 对象的指针</h5>

<a name="idd1e26590"></a><a name="idd1e26599"></a><a name="idd1e26603"></a><a name="idd1e26611"></a><a name="idd1e26616"></a><a name="idd1e26626"></a>
<p class="docText">The pointers we've seen so far can be used to change the value of the objects to which they point. But if we have a pointer to a <tt>const</tt> object, we do not want to allow that pointer to change the underlying, <tt>const</tt> value. The language enforces this property by requiring that pointers to <tt>const</tt> objects must take the <tt>const</tt>ness of their target into account:</P>
<p class="docText">到目前为止，我们使用指针来修改其所指对象的值。但是如果指针指向 <tt>const</tt> 对象，则不允许用指针来改变其所指的 <tt>const</tt> 值。为了保证这个特性，C++ 语言强制要求指向 <tt>const</tt> 对象的指针也必须具有 <tt>const</tt> 特性：</p>

<pre>
          const double *cptr;  // <span class="docEmphasis">cptr</span> <span class="docEmphItalicAlt">may point to a</span> <span class="docEmphasis">double</span> <span class="docEmphItalicAlt">that is</span> <span class="docEmphasis">const</span>
</pre>

<p class="docText">Here <tt>cptr</tt> is a pointer to an object of type <tt>const double</tt>. The <tt>const</tt> qualifies the type of the object to which <tt>cptr</tt> points, not <tt>cptr</tt> itself. That is, <tt>cptr</tt> itself is not <tt>const</tt>. We need not initialize it and can assign a new value to it if we so desire. What we cannot do is use <tt>cptr</tt> to change the value to which it points:</p>
<p class="docText">这里的 <tt>cptr</tt> 是一个指向 <tt>double</tt> 类型 <tt>const</tt> 对象的指针，<tt>const</tt> 限定了 <tt>cptr</tt> 指针所指向的对象类型，而并非 <tt>cptr</tt> 本身。也就是说，<tt>cptr</tt> 本身并不是 <tt>const</tt>。在定义时不需要对它进行初始化，如果需要的话，允许给 <tt>cptr</tt> 重新赋值，使其指向另一个 <tt>const</tt> 对象。但不能通过 <tt>cptr</tt> 修改其所指对象的值：</p>

<pre>
          *cptr = 42;   // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">*cptr</span> <span class="docEmphItalicAlt">might be</span> <span class="docEmphasis">const</span>
</pre>

<p class="docText">It is also a compile-time error to assign the address of a <tt>const</tt> object to a plain, non<tt>const</tt> pointer:</p>
<p class="docText">把一个 <tt>const</tt> 对象的地址赋给一个普通的、非 <tt>const</tt> 对象的指针也会导致编译时的错误：</p>

<pre>
          const double pi = 3.14;
          double *ptr = &amp;pi;        // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">ptr</span> <span class="docEmphItalicAlt">is a plain pointer</span>
          const double *cptr = &amp;pi; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">cptr</span> <span class="docEmphItalicAlt">is a pointer to</span> <span class="docEmphasis">const</span>
</pre>

<a name="ch04term4"></a>
<p class="docText">We cannot use a <tt>void*</tt> pointer (<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec4">Section 4.2.2</a>, p. <a class="docLink" href="ch04lev1sec2.html#ch04lev2sec4">119</a>) to hold the address of a <tt>const</tt> object. Instead, we must use the type <B><a class="docLink" href="ch04lev1sec6.html#gloss04_04" ><span class="docEmphStrong"><tt>const void*</tt></span></a></b> to hold the address of a <tt>const</tt> object:</p>
<p class="docText">不能使用 <tt>void*</tt> 指针（<a class="docLink" href="ch04lev1sec2.html#ch04lev2sec4">第 4.2.2 节</a>）保存 <tt>const</tt> 对象的地址，而必须使用 <B><a class="docLink" href="ch04lev1sec6.html#gloss04_04" ><span class="docEmphStrong"><tt>const void*</tt></span></a></b> 类型的指针保存 <tt>const</tt> 对象的地址：</p>

<pre>
          const int universe = 42;
          const void *cpv = &amp;universe; // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">cpv</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span>
          void *pv = &amp;universe;        // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">universe</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span>
</pre>

<p class="docText">A pointer to a <tt>const</tt> object can be assigned the address of a non<tt>const</tt> object, such as</p>
<p class="docText">允许把非 <tt>const</tt> 对象的地址赋给指向 <tt>const</tt> 对象的指针，例如：</p>

<pre>
          double dval = 3.14; // <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">is a</span> <span class="docEmphasis">double;</span> <span class="docEmphItalicAlt">its value can be changed</span>
          cptr = &amp;dval;       // <span class="docEmphItalicAlt">ok: but can't change</span> <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">through</span> <span class="docEmphasis">cptr</span>
</pre>

<p class="docText">Although <tt>dval</tt> is not a <tt>const</tt>, any attempt to modify its value through <tt>cptr</tt> results in a compile-time error. When we declared <tt>cptr</tt>, we said that it would not change the value to which it points. The fact that it happens to point to a non<tt>const</tt> object is irrelevant.</P>
<p class="docText">尽管 <tt>dval</tt> 不是 <tt>const</tt> 对象，但任何企图通过指针 <tt>cptr</tt> 修改其值的行为都会导致编译时的错误。<tt>cptr</tt> 一经定义，就不允许修改其所指对象的值。如果该指针恰好指向非 <tt>const</tt> 对象时，同样必须遵循这个规则。</p>

<a name="ch04note14"></a>
<div class="docNote">
	<p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1">
		<tr>
			<td width="60" valign="top">
				<img border="0" alt="" align="LEFT" width="50" height="54" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/note.jpg;400478" >
			</td>
			<TD valign="top">
				<a name="idd1e26911"></a><a name="idd1e26917"></a>
				<p class="docText">We cannot use a pointer to <tt>const</tt> to change the underlying object. However, if the pointer addresses a non<tt>const</tt> object, it is possible that some other action will change the object to which the pointer points.</p>
				<p class="docText">不能使用指向 <tt>const</tt> 对象的指针修改基础对象，然而如果该指针指向的是一个非 <tt>const</tt> 对象，可用其他方法修改其所指的对象。</p>
			</td>
		</tr>
	</table><br>
	</p>
</div>

<p class="docText">The fact that values to which a <tt>const</tt> pointer points can be changed is subtle and can be confusing. Consider:</p>
<p class="docText">事实是，可以修改 <tt>const</tt> 指针所指向的值，这一点常常容易引起误会。考虑：</p>

<pre>
          dval = 3.14159;       // <span class="docEmphasis">dval</span> <span class="docEmphItalicAlt">is not</span> <span class="docEmphasis">const</span>
          *cptr = 3.14159;      // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">cptr</span> <span class="docEmphItalicAlt">is a pointer to</span> <span class="docEmphasis">const</span>
          double *ptr = &amp;dval;  // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ptr</span> <span class="docEmphItalicAlt">points at non-</span><span class="docEmphasis">const double</span>
          *ptr = 2.72;          // <span class="docEmphItalicAlt">ok:</span> <span class="docEmphasis">ptr</span> <span class="docEmphItalicAlt">is plain pointer</span>
          cout &lt;&lt; *cptr;        // <span class="docEmphItalicAlt">ok: prints 2.72</span>
</pre><BR>

<p class="docText">In this case, <tt>cptr</tt> is defined as a pointer to <tt>const</tt> but it actually points at a non<tt>const</tt> object. Even though the object to which it points is non<tt>const</tt>, we cannot use <tt>cptr</tt> to change the object's value. Essentially, there is no way for <tt>cptr</tt> to know whether the object it points to is <tt>const</tt>, and so it treats all objects to which it might point as <tt>const</tt>.</p>
<p class="docText">在此例题中，指向 <tt>const</tt> 的指针 <tt>cptr</tt> 实际上指向了一个非 <tt>const</tt> 对象。尽管它所指的对象并非 <tt>const</tt>，但仍不能使用 <tt>cptr</tt> 修改该对象的值。本质上来说，由于没有方法分辩 <tt>cptr</tt> 所指的对象是否为 <tt>const</tt>，系统会把它所指的所有对象都视为 <tt>const</tt>。</p>

<p class="docText">When a pointer to <tt>const</tt> does point to a non<tt>const</tt>, it is possible that the value of the object might change: After all, that value is not <tt>const</tt>. We could either assign to it directly or, as here, indirectly through another, plain non<tt>const</tt> pointer. It is important to remember that there is no guarantee that an object pointed to by a pointer to <tt>const</tt> won't change.</p>
<p class="docText">如果指向 <tt>const</tt> 的指针所指的对象并非 <tt>const</tt>，则可直接给该对象赋值或间接地利用普通的非 <tt>const</tt> 指针修改其值：毕竟这个值不是 <tt>const</tt>。重要的是要记住：不能保证指向 <tt>const</tt> 的指针所指对象的值一定不可修改。</p>

<a name="ch04note15"></a>
<div class="docNote">
	<p>
	<table width="90%" border="0" cellspacing="0" cellpadding="1">
		<tr>
			<td width="60" valign="top">
				<img border="0" alt="" align="LEFT" width="84" height="51" SRC="http://shouce.jb51.net/c++/0201721481/images/0201721481/graphics/tip.jpg;400478" >
			</td>
			<td valign="top">
				<p class="docText">It may be helpful to think of pointers to <tt>const</tt> as &quot;pointers that <span class="docEmphasis">think</span> they point to <tt>const</tt>.&quot;</p>
				<p class="docText">如果把指向 <tt>const</tt> 的指针理解为“自以为指向 <tt>const</tt> 的指针”，这可能会对理解有所帮助。</p>
			</td>
		</tr>
	</table>
	</p>
</div><br>

<p class="docText">In real-world programs, pointers to <tt>const</tt> occur most often as formal parameters of functions. Defining a parameter as a pointer to <tt>const</tt> serves as a contract guaranteeing that the actual object being passed into the function will not be modified through that parameter.</P>
<p class="docText">在实际的程序中，指向 <tt>const</tt> 的指针常用作函数的形参。将形参定义为指向 <tt>const</tt> 的指针，以此确保传递给函数的实际对象在函数中不因为形参而被修改。</p>

<a name="ch04lev3sec22"></a>
<H5 class="docSection3Title"><tt>const</tt> Pointers</h5>
<H5 class="docSection3Title"><tt>const</tt> 指针</h5>

<p class="docText">In addition to pointers to <tt>const</tt>, we can also have <tt>const</tt> pointersthat is, pointers whose own value we may not change:</P>
<p class="docText">除指向 <tt>const</tt> 对象的指针外，C++ 语言还提供了 <tt>const</tt> 指针——本身的值不能修改：</p>
<pre>
          int errNumb = 0;
          int *const curErr = &amp;errNumb; // <span class="docEmphasis">curErr</span> <span class="docEmphItalicAlt">is a constant pointer</span>
</pre>

<p class="docText">Reading this definition from right to left, we see that &quot;<tt>curErr</tt> is a constant pointer to an object of type <tt>int</tt>.&quot; As with any <tt>const</tt>, we may not change the value of the pointerthat is, we may not make it point to any other object. Any attempt to assign to a constant pointereven assigning the same value back to <tt>curErr</tt>is flagged as an error during compilation:</p>
<p class="docText">我们可以从右向左把上述定义语句读作“<tt>curErr</tt> 是指向 <tt>int</tt> 型对象的 <tt>const</tt> 指针”。与其他 <tt>const</tt> 量一样，<tt>const</tt> 指针的值不能修改，这就意味着不能使 <tt>curErr</tt> 指向其他对象。任何企图给 <tt>const</tt> 指针赋值的行为（即使给 <tt>curErr</tt> 赋回同样的值）都会导致编译时的错误：</p>

<pre>
          curErr = curErr; // <span class="docEmphItalicAlt">error:</span> <span class="docEmphasis">curErr</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span>
</pre>

<p class="docText">As with any <tt>const</tt>, we must initialize a <tt>const</tt> pointer when we create it.</P>
<p class="docText">与任何 <tt>const</tt> 量一样，<tt>const</tt> 指针也必须在定义时初始化。</p>

<a name="idd1e27135"></a><a name="idd1e27144"></a><a name="idd1e27149"></a>
<p class="docText">The fact that a pointer is itself <tt>const</tt> says nothing about whether we can use the pointer to change the value to which it points. Whether we can change the value pointed to depends entirely on the type to which the pointer points. For example, <tt>curErr</tt> addresses a plain, non<tt>const int</tt>. We can use <tt>curErr</tt> to change the value of <tt>errNumb</tt>:</p>
<p class="docText">指针本身是 <tt>const</tt> 的事实并没有说明是否能使用该指针修改它所指向对象的值。指针所指对象的值能否修改完全取决于该对象的类型。例如，<tt>curErr</tt> 指向一个普通的非常量 <tt>int</tt> 型对象 <tt>errNumb</tt>，则可使用 <tt>curErr</tt> 修改该对象的值：</p>

<pre>
          if (*curErr) {
              errorHandler();
              *curErr = 0; // <span class="docEmphItalicAlt">ok: reset value of the object to which</span> <span class="docEmphasis">curErr</span> <span class="docEmphItalicAlt">is bound</span>
          }
</pre>

<a name="ch04lev3sec23"></a>
<h5 class="docSection3Title"><tt>const</tt> Pointer to a <tt>const</tt> Object</h5>
<h5 class="docSection3Title">指向 <tt>const</tt> 对象的 <tt>const</tt> 指针</h5>

<p class="docText">We can also define a constant pointer to a constant object as follows:</p>
<p class="docText">还可以如下定义指向 <tt>const</tt> 对象的 <tt>const</tt> 指针：</p>

<pre>
          const double pi = 3.14159;
          // <span class="docEmphasis">pi_ptr</span> <span class="docEmphItalicAlt">is</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">and points to a</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">object</span>
          const double *const pi_ptr = &amp;pi;
</pre>

<p class="docText">In this case, neither the value of the object addressed by <tt>pi_ptr</tt> nor the address itself can be changed. We can read its definition from right to left as &quot;<tt>pi_ptr</tt> is a constant pointer to an object of type <tt>double</tt> defined as <tt>const</tt>.&quot;</p>
<p class="docText">本例中，既不能修改 <tt>pi_ptr</tt> 所指向对象的值，也不允许修改该指针的指向（即 <tt>pi_ptr</tt> 中存放的地址值）。可从右向左阅读上述声明语句：“<tt>pi_ptr</tt> 首先是一个 <tt>const</tt> 指针，指向 <tt>double</tt> 类型的 <tt>const</tt> 对象”。</p>

<a name="ch04lev3sec24"></a>
<H5 class="docSection3Title">Pointers and Typedefs</H5>
<H5 class="docSection3Title">指针和 typedef</H5>

<p class="docText">The use of pointers in typedefs (<a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6" >Section 2.6</a>, p. <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6" >61</a>) often leads to surprising results. Here is a question almost everyone answers incorrectly at least once. Given the following,</p>
<p class="docText">在 typedef（<a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6" >第 2.6 节</a>）中使用指针往往会带来意外的结果。下面是一个几乎所有人刚开始时都会答错的问题。假设给出以下语句：</p>

<pre>
          typedef string *pstring;
          const pstring cstr;
</pre>

<p class="docText">what is the type of <tt>cstr</tt>? The simple answer is that it is a pointer to <tt>const pstring</tt>. The deeper question is: what underlying type does a pointer to <tt>const pstring</tt> represent? Many think that the actual type is</p>
<p class="docText">请问 <tt>cstr</tt> 变量是什么类型？简单的回答是 <tt>const pstring</tt> 类型的指针。进一步问：<tt>const pstring</tt> 指针所表示的真实类型是什么？很多人都认为真正的类型是：</p>

<pre>
          const string *cstr; // <span class="docEmphItalicAlt">wrong interpretation of const pstring cstr</span>
</pre>

<p class="docText">That is, that a <tt>const pstring</tt> would be a pointer to a constant <tt>string</tt>. But that is incorrect.</P>
<p class="docText">也就是说，<tt>const pstring</tt> 是一种指针，指向 <tt>string</tt> 类型的 <tt>const</tt> 对象，但这是错误的。</p>

<p class="docText">The mistake is in thinking of a typedef as a textual expansion. When we declare a <tt>const pstring</tt>, the <tt>const</tt> modifies the type of <tt>pstring</tt>, which is a pointer. Therefore, this definition declares <tt>cstr</tt> to be a <tt>const</tt> pointer to <tt>string</tt>. The definition is equivalent to</p>
<p class="docText">错误的原因在于将 <tt>typedef</tt> 当做文本扩展了。声明 <tt>const pstring</tt> 时，<tt>const</tt> 修饰的是 <tt>pstring</tt> 的类型，这是一个指针。因此，该声明语句应该是把 <tt>cstr</tt> 定义为指向 <tt>string</tt> 类型对象的 <tt>const</tt> 指针，这个定义等价于：</p>

<pre>
          // <span class="docEmphItalicAlt">cstr is a const pointer to string</span>
          string *const cstr; // <span class="docEmphItalicAlt">equivalent to const pstring cstr</span>
</pre>

<a name="ch04sb09"></a>
<p>
<table cellspacing="0" width="90%" border="1" cellpadding="5">
	<tr>
		<TD>
			<h2 class="docSidebarTitle">Advice: Understanding Complicated <tt>const</tt> Type Declarations</h2>
			<h2 class="docSidebarTitle">建议：理解复杂的 <tt>const</tt> 类型的声明</h2>

			<a name="idd1e27333"></a><a name="idd1e27336"></a><a name="idd1e27339"></a><a name="idd1e27344"></a><a name="idd1e27349"></a><a name="idd1e27354"></a>
			<p class="docText"><span class="docEmphStrong">Part of the problem in reading <tt>const</tt> declarations arises because the <tt>const</tt> can go either before or after the type:</span></P>
			<p class="docText"><span class="docEmphStrong">阅读 <tt>const</tt> 声明语句产生的部分问题，源于 <tt>const</tt> 限定符既可以放在类型前也可以放在类型后：</span></P>
<pre>
          string const s1;   // <span class="docEmphasis">s1</span> <span class="docEmphItalicAlt">and</span> <span class="docEmphasis">s2</span> <span class="docEmphItalicAlt">have same type</span>,
          const string s2;   // <span class="docEmphItalicAlt">they're both</span> <span class="docEmphasis">string</span><span class="docEmphItalicAlt">s that are</span> <span class="docEmphasis">const</span>
</pre>
			<p class="docText"><span class="docEmphStrong">When writing <tt>const</tt> definitions using typedefs, the fact that the <tt>const</tt> can precede the type can lead to confusion as to the actual type being defined:</span></p>
			<p class="docText"><span class="docEmphStrong">用 <tt>typedef</tt> 写 <tt>const</tt> 类型定义时，<tt>const</tt> 限定符加在类型名前面容易引起对所定义的真正类型的误解：</span></P>
<a name="PLID55"></a>
<pre>
<div class="v1"><a href="ch04lev1sec2.html#PLID55" >[View full width]</a></div>
          string s;
          typedef string *pstring;
          const pstring cstr1 = &amp;s; // <span class="docEmphItalicAlt">written this way the type
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif" > is obscured</span>
          pstring const cstr2 = &amp;s; // <span class="docEmphItalicAlt">all three decreations are
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif" > the same type</span>
          string *const cstr3 = &amp;s; // <span class="docEmphItalicAlt">they're all</span> <span class="docEmphasis">const</span> <span class="docEmphItalicAlt">pointers
<img border="0" width="14" height="9" alt="" align="left" src="images/ccc.gif" > to</span> <span class="docEmphasis">string</span>
</pre><BR>

<p class="docText"><span class="docEmphStrong">Putting the <tt>const</tt> after <tt>pstring</tt> and reading the declaration from right to left makes it clearer that <tt>cstr2</tt> is a <tt>const pstring</tt>, which in turn is a <tt>const</tt> pointer to <tt>string</tt>.</span></p>
<p class="docText"><span class="docEmphStrong">把 <tt>const</tt> 放在类型 <tt>pstring</tt> 之后，然后从右向左阅读该声明语句就会非常清楚地知道 <tt>cstr2</tt> 是 <tt>const pstring</tt> 类型，即指向 <tt>string</tt> 对象的 <tt>const</tt> 指针。</span></p>

<p class="docText"><span class="docEmphStrong">Unfortunately, most readers of C++ programs expect to see the <tt>const</tt> before the type. As a result, it is probably a good idea to put the <tt>const</tt> first, respecting common practice. But it can be helpful in understanding declarations to rewrite them to put the <tt>const</tt> after the type.</span></P>
<p class="docText"><span class="docEmphStrong">不幸的是，大多数人在阅读 C++ 程序时都习惯看到 <tt>const</tt> 放在类型前面。于是为了遵照惯例，只好建议编程时把 <tt>const</tt> 放在类型前面。但是，把声明语句重写为置 <tt>const</tt> 于类型之后更便于理解。</span></p>
</td>
</tr>
</table>
</p><br>

</td></tr></table>

<a name="ch04sb10"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 4.3</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch04qa6q1"></a><b>Exercise 4.19:</b></td>

                    <td>
<a name="idd1e27569"></a>
                      <p class="docText">Explain the meaning of the following five definitions. Identify any illegal definitions.</p>
                      <p class="docText">解释下列 5 个定义的含义，指出其中哪些定义是非法的：</p>
                      <pre>
          (a) int i;
          (b) const int ic;
          (c) const int *pic;
          (d) int *const cpi;
          (e) const int *const cpic;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch04qa6q2"></a><b>Exercise 4.20:</b></td>

                    <td>
                      <p class="docText">Which of the following initializations are legal? Explain why.</p>
                      <p class="docText">下列哪些初始化是合法的？为什么？</p>
                      <pre>
          (a) int i = -1;
          (b) const int ic = i;
          (c) const int *pic = &amp;ic;
          (d) int *const cpi = &amp;ic;
          (e) const int *const cpic = &amp;ic;
</pre><br>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch04qa6q3"></a><b>Exercise 4.21:</b></td>

                    <td>
                      <p class="docText">Based on the definitions in the previous exercise, which of the following assignments are legal? Explain why.</p>
                      <p class="docText">根据上述定义，下列哪些赋值运算是合法的？为什么？</p>
                      <pre>
          (a) i = ic;
          (b) pic = &amp;ic;
          (c) cpi = pic;
          (d) pic = cpic;
          (e) cpic = &amp;ic;
          (f) ic = *cpic;
</pre><br>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>

<table width="100%" border="0" cellspacing="0" cellpadding="0">
	<tr>
		<td>
			<div STYLE="MARGIN-LEFT: 0.15in;">
				<a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle"  alt="Team LiB"></a>
			</div>
		</td>
		<td align="right">
			<div STYLE="MARGIN-LEFT: 0.15in;">
				<a href="ch04lev1sec1.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a>
				<a href="ch04lev1sec3.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
			</div>
		</td>
	</tr>
</table>
</body>
</html>
