<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Section 10.4.  The set Type</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch10lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch10lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch10lev1sec4"></a>

        <h3 class="docSection1Title">10.4. The <tt>set</tt> Type</h3>
        <h3 class="docSection1Title">10.4. <tt>set 类型</h3>

        <p class="docText">A <tt>map</tt> is a collection of a keyvalue pairs, such as an address and phone number keyed to an individual's name. In contrast, a <tt>set</tt> is simply a collection of keys. For example, a business might define a <tt>set</tt> named <tt>bad_checks</tt>, to hold the names of individuals who have issued bad checks to the company. A <tt>set</tt> is most useful when we simply want to know whether a value is present. Before accepting a check, for example, that business would query <tt>bad_checks</tt> to see whether the customer's name was present.</p>
        <p class="docText"><tt>map</tt> 容器是键－值对的集合，好比以人名为键的地址和电话号码。相反地，<tt>set</tt> 容器只是单纯的键的集合。例如，某公司可能定义了一个名为 <tt>bad_checks</tt> 的 <tt>set</tt> 容器，用于记录曾经给本公司发空头支票的客户。当只想知道一个值是否存在时，使用 <tt>set</tt> 容器是最适合的。例如，在接收一张支票前，该公司可能想查询 <tt>bad_checks</tt> 对象，看看该客户的名字是否存在。</p>

        <p class="docText">With two exceptions, <tt>set</tt> supports the same operations as <tt>map</tt>:</p>
        <p class="docText">除了两种例外情况，<tt>set</tt> 容器支持大部分的 <tt>map</tt> 操作，包括下面几种：</p>

        <ul>
          <li>
            <p class="docList">All the common container operations listed in <a class="docLink" href="ch10lev1sec2.html#ch10lev1sec2" >Section 10.2</a> (p. <a class="docLink" href="ch10lev1sec2.html#ch10lev1sec2" >358</a>).</p>
            <p class="docList"><a class="docLink" href="ch10lev1sec2.html#ch10lev1sec2" >第 10.2 节</a>列出的所有通用的容器操作。</p>
          </li>

          <li>
            <p class="docList">The constructors described in <a class="docLink" href="ch10lev1sec3.html#ch10table03" >Table 10.3</a> (p. <a class="docLink" href="ch10lev1sec3.html#ch10table03" >360</a>).</p>
            <p class="docList"><a class="docLink" href="ch10lev1sec3.html#ch10table03" >表 10.3</a> 描述的构造函数。</p>
          </li>

          <li>
            <p class="docList">The <tt>insert</tt> operations described in <a class="docLink" href="ch10lev1sec3.html#ch10table05" >Table 10.5</a> (p. <a class="docLink" href="ch10lev1sec3.html#ch10table05" >365</a>).</p>
            <p class="docList"><a class="docLink" href="ch10lev1sec3.html#ch10table05" >表 10.5</a> 描述的 <tt>insert</tt> 操作。</p>
          </li>

          <li>
            <p class="docList">The <tt>count</tt> and <tt>find</tt> operations described in <a class="docLink" href="ch10lev1sec3.html#ch10table06" >Table 10.6</a> (p. <a class="docLink" href="ch10lev1sec3.html#ch10table06" >367</a>).</p>
            <p class="docList"><a class="docLink" href="ch10lev1sec3.html#ch10table06" >表 10.6</a> 描述的 <tt>count</tt> 和 <tt>find</tt> 操作。</p>
          </li>

          <li>
            <p class="docList">The <tt>erase</tt> operations described in <a class="docLink" href="ch10lev1sec3.html#ch10table07" >Table 10.7</a> (p. <a class="docLink" href="ch10lev1sec3.html#ch10table07" >369</a>).</p>
            <p class="docList"><a class="docLink" href="ch10lev1sec3.html#ch10table07" >表 10.7</a> 描述的 <tt>erase</tt> 操作。</p>
          </li>
        </ul>

        <p class="docText">The exceptions are that <tt>set</tt> does not provide a subscript operator and does not define <tt>mapped_type</tt>. In a <tt>set</tt>, the <tt>value_type</tt> is not a <tt>pair</tt>; instead it and <tt>key_type</tt> are the same type. They are each the type of the elements stored in the <tt>set</tt>. These differences reflect the fact that <tt>set</tt> holds only keys; there is no value associated with the key. As with <tt>map</tt>, the keys of a <tt>set</tt> must be unique and may not be changed.</p>
        <p class="docText">两种例外包括：<tt>set</tt> 不支持下标操作符，而且没有定义 <tt>mapped_type</tt> 类型。在 <tt>set</tt> 容器中，<tt>value_type</tt> 不是 <tt>pair</tt> 类型，而是与 <tt>key_type</tt> 相同的类型。它们指的都是 <tt>set</tt> 中存储的元素类型。这一差别也体现了 <tt>set</tt> 存储的元素仅仅是键，而没有所关联的值。与 <tt>map</tt> 一样，<tt>set</tt> 容器存储的键也必须唯一，而且不能修改。</p>
	
	<a name="ch10sb09"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.4</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa9q1"></a><b>Exercise 10.21:</b></td>

                    <td>
                      <p class="docText"><a name="idd1e80584"></a><a name="idd1e80590"></a><a name="idd1e80596"></a><a name="idd1e80602"></a><a name="idd1e80610"></a><a name="idd1e80617"></a><a name="idd1e80625"></a><a name="idd1e80634"></a><a name="idd1e80641"></a>Explain the difference between a <tt>map</tt> and a <tt>set</tt>. When might you use one or the other?</p>
        <p class="docText">解释 <tt>map</tt> 和 <tt>set</tt> 容器的差别，以及它们各自适用的情况。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa9q2"></a><b>Exercise 10.22:</b></td>

                    <td>
                      <p class="docText">Explain the difference between a <tt>set</tt> and a <tt>list</tt>. When might you use one or the other?</p>
        <p class="docText">解释 <tt>set</tt> 和 <tt>list</tt> 容器的差别，以及它们各自适用的情况。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a name="ch10lev2sec14"></a>

        <h4 class="docSection2Title">10.4.1. Defining and Using <tt>set</tt>s</h4>
        <h4 class="docSection2Title">10.4.1. <tt>set</tt> 容器的定义和使用</h4>

        <p class="docText">To use a <tt>set</tt>, we must include the <tt>set</tt> header. The operations on <tt>set</tt>s are essentially identical to those on <tt>map</tt>s.</p>
        <p class="docText">为了使用 <tt>set</tt> 容器，必须包含 <tt>set</tt> 头文件。<tt>set</tt> 支持的操作基本上与 <tt>map</tt> 提供的相同。</p>

        <p class="docText">As with <tt>map</tt>, there can be only one element with a given key in a <tt>set</tt>. When we initialize a <tt>set</tt> from a range of elements or <tt>insert</tt> a range of elements, only one element with a given key is actually added:</p>
        <p class="docText">与 <tt>map</tt> 容器一样，<tt>set</tt> 容器的每个键都只能对应一个元素。以一段范围的元素初始化 <tt>set</tt> 对象，或在 <tt>set</tt> 对象中插入一组元素时，对于每个键，事实上都只添加了一个元素：</p>
        <pre>
     // <span class="docEmphItalicAlt">define a</span> <span class="docEmphasis">vector</span> <span class="docEmphItalicAlt">with 20 elements, holding two copies of each number from 0 to 9</span>
     vector&lt;int&gt; ivec;
     for (vector&lt;int&gt;::size_type i = 0; i != 10; ++i) {
         ivec.push_back(i);
         ivec.push_back(i); // <span class="docEmphItalicAlt">duplicate copies of each number</span>
     }
     // <span class="docEmphItalicAlt">iset holds unique elements from ivec</span>
     set&lt;int&gt; iset(ivec.begin(), ivec.end());
     cout &lt;&lt; ivec.size() &lt;&lt; endl;      // <span class="docEmphItalicAlt">prints 20</span>
     cout &lt;&lt; iset.size() &lt;&lt; endl;      // <span class="docEmphItalicAlt">prints 10</span>
</pre><br>

        <p class="docText">We first create a <tt>vector</tt> of <tt>int</tt>s named <tt>ivec</tt> that has 20 elements: two copies of each of the integers from 0 through 9 inclusive. We then use all the elements from <tt>ivec</tt> to initialize a <tt>set</tt> of <tt>int</tt>s. That <tt>set</tt> has only ten elements: one for each distinct element in <tt>ivec</tt>.</p>
        <p class="docText">首先创建了一个名为 <tt>ivec</tt> 的 <tt>int</tt> 型 <tt>vector</tt> 容器，存储 20 个元素：0-9（包括 9）中每个整数都出现了两次。然后用 <tt>ivec</tt> 中所有的元素初始化一个 <tt>int</tt> 型的 <tt>set</tt> 容器。则这个 <tt>set</tt> 容器仅有 10 个元素：<tt>ivec</tt> 中不相同的各个元素。</p>
	
	<a name="ch10lev3sec12"></a>
        <h5 class="docSection3Title">Adding Elements to a <tt>set</tt></h5>
        <h5 class="docSection3Title">在 <tt>set</tt> 中添加元素</h5>

        <p class="docText">We can add elements to a <tt>set</tt> by using the <tt>insert</tt> operation:</p>
        <p class="docText">可使用 <tt>insert</tt> 操作在 <tt>set</tt> 中添加元素：</p>
        <pre>
     set&lt;string&gt; set1;         // <span class="docEmphItalicAlt">empty set</span>
     set1.insert("the");       // <span class="docEmphItalicAlt">set1 now has one element</span>
     set1.insert("and");       // <span class="docEmphItalicAlt">set1 now has two elements</span>
</pre><br>

        <p class="docText">Alternatively, we can insert a range of elements by providing a pair of iterators to <tt>insert</tt>. This version of <tt>insert</tt> works similarly to the constructor that takes an iterator paironly one element with a given key is inserted:</p>
	<p class="docText">另一种用法是，调用 <tt>insert</tt> 函数时，提供一对迭代器实参，插入其标记范围内所有的元素。该版本的 <tt>insert</tt> 函数类似于形参为一对迭代器的构造函数——对于一个键，仅插入一个元素：</p>
        <pre>
     set&lt;int&gt;    iset2; //    <span class="docEmphItalicAlt">empty set</span>
     iset2.insert(ivec.begin(), ivec.end());     // <span class="docEmphItalicAlt">iset2 has 10 elements</span>
</pre><br>

	<p class="docText">Like the <tt>map</tt> operations, the version of <tt>insert</tt> that takes a key returns a <tt>pair</tt> containing an iterator to the element with this key and a <tt>bool</tt> indicating whether the element was added. The one that takes an iterator pair returns <tt>void</tt>.</p>
        <p class="docText">与 <tt>map</tt> 容器的操作一样，带有一个键参数的 <tt>insert</tt> 版本返回 <tt>pair</tt> 类型对象，包含一个迭代器和一个 <tt>bool</tt> 值，迭代器指向拥有该键的元素，而 <tt>bool</tt> 值表明是否添加了元素。使用迭代器对的 <tt>insert</tt> 版本返回 <tt>void</tt> 类型。</p>
	
	<a name="ch10lev3sec13"></a>
        <h5 class="docSection3Title">Fetching an Element from a <tt>set</tt></h5>
        <h5 class="docSection3Title">从 <tt>set</tt> 中获取元素</h5>

        <p class="docText"><a name="idd1e80849"></a><a name="idd1e80853"></a><a name="idd1e80858"></a><a name="idd1e80861"></a><a name="idd1e80868"></a>There is no subscript operator on <tt>set</tt>s. To fetch an element from a <tt>set</tt> by its key, we use the <tt>find</tt> operation. If we just want to know whether the element is present, we could also use <tt>count</tt>, which returns the number of elements in the <tt>set</tt> with a given key. Of course, for <tt>set</tt> that value can be only one (if the element is present) or zero (if it is not):</p>
        <p class="docText"><tt>set</tt> 容器不提供下标操作符。为了通过键从 <tt>set</tt> 中获取元素，可使用 <tt>find</tt> 运算。如果只需简单地判断某个元素是否存在，同样可以使用 <tt>count</tt> 运算，返回 <tt>set</tt> 中该键对应的元素个数。当然，对于 <tt>set</tt> 容器，<tt>count</tt> 的返回值只能是 1（该元素存在）或 0（该元素不存在）：</p>
        <pre>
     iset.find(1)     // <span class="docEmphItalicAlt">returns iterator that refers to the element with key == 1</span>
     iset.find(11)    // <span class="docEmphItalicAlt">returns iterator == iset.end()</span>

     iset.count(1)    // <span class="docEmphItalicAlt">returns 1</span>
     iset.count(11)   // <span class="docEmphItalicAlt">returns 0</span>
</pre><br>

        <p class="docText">Just as we cannot change the key part of a <tt>map</tt> element, the keys in a <tt>set</tt> are also <tt>const</tt>. If we have an iterator to an element of the <tt>set</tt>, all we can do is read it; we cannot write through it:</p>
	<p class="docText">正如不能修改 <tt>map</tt> 中元素的键部分一样，<tt>set</tt> 中的键也为 <tt>const</tt>。在获得指向 <tt>set</tt> 中某元素的迭代器后，只能对其做读操作，而不能做写操作：</p>
        <pre>
     // <span class="docEmphasis">set_it</span> <span class="docEmphasis">refers to the element with key == 1</span>
     set&lt;int&gt;::iterator set_it = iset.find(1);
     *set_it = 11;               // <span class="docEmphItalicAlt">error: keys in a set are read-only</span>
     cout &lt;&lt; *set_it &lt;&lt; endl;    // <span class="docEmphItalicAlt">ok: can read the key</span>
</pre><br>

        <a name="ch10lev2sec15"></a>
        <h4 class="docSection2Title">10.4.2. Building a Word-Exclusion Set</h4>
        <h4 class="docSection2Title">10.4.2. 创建“单词排除”集</h4>

        <p class="docText">On page <a class="docLink" href="ch10lev1sec3.html#ch10lev2sec12" >369</a> we removed a given word from our <tt>word_count map</tt>. We might want to extend this approach to remove all the words in a specified file. That is, our word-count program should count only words that are not in a set of excluded words. Using <tt>set</tt> and <tt>map</tt>, this program is fairly straightforward:</p>
        <p class="docText"><a class="docLink" href="ch10lev1sec3.html#ch10lev2sec12" >第 10.3.7 节</a>的程序从 <tt>map</tt> 对象 <tt>word_count</tt> 中删除一个指定的单词。可将这个操作扩展为删除指定文件中所有的单词（即该文件记录的是排除集）。也即，我们的单词统计程序只对那些不在排除集中的单词进行统计。使用 <tt>set</tt> 和 <tt>map</tt> 容器，可以简单而直接地实现该功能：</p>
        <pre>
     void restricted_wc(ifstream &amp;remove_file,
                        map&lt;string, int&gt; &amp;word_count)
     {
         set&lt;string&gt; excluded; // <span class="docEmphasis">set</span> <span class="docEmphItalicAlt">to hold words we'll ignore</span>
         string remove_word;
         while (remove_file &gt;&gt; remove_word)
             excluded.insert(remove_word);
         // <span class="docEmphItalicAlt">read input and keep a count for words that aren't in the exclusion</span> <span class="docEmphasis">set</span>
         string word;
         while (cin &gt;&gt; word)
            // <span class="docEmphItalicAlt">increment counter only if the word is not in</span> <span class="docEmphasis">excluded</span>
            if (!excluded.count(word))
                 ++word_count[word];
     }
</pre><br>

        <p class="docText">This program is similar to the word-count program on page <a class="docLink" href="ch10lev1sec3.html#ch10note05" >363</a>. The difference is that we do not bother to count the common words.</p>
        <p class="docText">这个程序类似<a class="docLink" href="ch10lev1sec3.html#ch10note05" >第 10.3.4 节</a>的单词统计程序。其差别在于不需要费力地统计常见的单词。</p>

        <p class="docText">The function starts by reading the file it was passed. That file contains the list of excluded words, which we store in the <tt>set</tt> named <tt>excluded</tt>. When the first <tt>while</tt> completes, that <tt>set</tt> contains an entry for each word in the input file.</p>
        <p class="docText">该函数首先读取传递进来的文件，该文件列出了所有被排除的单词。读入这些单词并存储在一个名为 <tt>excluded</tt> 的 <tt>set</tt> 容器中。第一个 <tt>while</tt> 循环完成捍，该 <tt>set</tt> 对象包含了输入文件中的所有单词。</p>

        <p class="docText"><a name="idd1e81012"></a><a name="idd1e81018"></a><a name="idd1e81024"></a><a name="idd1e81028"></a>The next part of the program looks a lot like our original word-count program. The important difference is that before counting each word, we check whether the word is in the exclusion set. We do this check in the <tt>if</tt> inside the second <tt>while</tt>:</p>
        <p class="docText">接下来的程序类似原来的单词统计程序。关键的区别在于：在统计每个单词之前，先检查该单词是否出现在排除集中。第二个 <tt>while</tt> 循环里的 <tt>if</tt> 语句实现了该功能：</p>
        <pre>
     // <span class="docEmphItalicAlt">increment counter only if the word is not in</span> <span class="docEmphasis">excluded</span>
     if (!excluded.count(word))
</pre><br>

        <p class="docText">The call to <tt>count</tt> returns one if <tt>word</tt> is in <tt>excluded</tt> and zero otherwise. We negate the return from <tt>count</tt> so that the test succeeds if <tt>word</tt> is not in <tt>excluded</tt>. If <tt>word</tt> is not in <tt>excluded</tt>, we update its value in the <tt>map</tt>.</p>
        <p class="docText">如果该单词出现在排除集 <tt>excluded</tt> 中，则调用 <tt>count</tt> 将返回 1，否则返回 0。对 <tt>count</tt> 的返回值做“非”运算，则当该 <tt>word</tt> 不在 <tt>excluded</tt> 中时，条件测试成功，此时修改该单词在 <tt>map</tt> 中对应的值。</p>

        <p class="docText">As in the previous version of our word count program, we rely on the fact that subscripting a <tt>map</tt> inserts an element if the key is not already in the <tt>map</tt>. Hence, the effect of</p>
        <p class="docText">与单词统计程序原来的版本一样，需要使用下标操作符的性质：如果某键尚未在 <tt>map</tt> 容器中出现，则将该元素插入容器。所以语句</p>
        <pre>
     ++word_count[word];
</pre><br>

	<p class="docText">is to insert <tt>word</tt> into <tt>word_count</tt> if it wasn't already there. If the element is inserted, its value is initially set to 0. Regardless of whether the element had to be created, the value is then incremented.</p>
        <p class="docText">的效果是：如果 <tt>word</tt> 还没出现过，则将它插入到 <tt>word_count</tt> 中，并在插入元素后，将它关联的值初始化为 0。然后不管是否插入了新元素，相应元素的值都加 1。</p>
	
	<a name="ch10sb10"></a>
        <table cellspacing="0" width="90%" border="1" cellpadding="5">
          <tr>
            <td>
              <h2 class="docSidebarTitle">Exercises Section 10.4.2</h2>

              <blockquote>
                <table border="0" cellspacing="16" cellpadding="0">
                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa10q1"></a><b>Exercise 10.23:</b></td>

                    <td>
                      <p class="docText">Write a program that stores the excluded words in a <tt>vector</tt> instead of in a <tt>set</tt>. What are the advantages to using a <tt>set</tt>?</p>
        <p class="docText">编写程序将被排除的单词存储在 <tt>vector</tt> 对象中，而不是存储在 <tt>set</tt> 对象中。请指出使用 <tt>set</tt> 的好处。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa10q2"></a><b>Exercise 10.24:</b></td>

                    <td>
                      <p class="docText">Write a program that generates the non-plural version of a word by stripping the <tt>'s'</tt> off the end of the word. Build an exclusion set to recognize words in which the trailing <tt>'s'</tt> should not be removed. Two examples of words to place in this set are <tt>success, class</tt>. Use this exclusion set to write a program that strips plural suffixes from its input but leaves words in the exclusion set unchanged.</p>
        <p class="docText">编写程序通过删除单词尾部的‘<tt>s</tt>’生成该单词的非复数版本。同时，建立一个单词排除集，用于识别以‘<tt>s</tt>’结尾、但这个结尾的‘<tt>s</tt>’又不能删除的单词。例如，放在该排除集中的单词可能有 <tt>success</tt> 和 <tt>class</tt>。使用这个排除集编写程序，删除输入单词的复数后缀，而如果输入的是排除集中的单词，则保持该单词不变。</p>
                    </td>
                  </tr>

                  <tr valign="top">
                    <td align="right" class="docText" width="50"><a name="ch10qa10q3"></a><b>Exercise 10.25:</b></td>

                    <td>
                      <p class="docText">Define a <tt>vector</tt> of books you'd like to read within the next six months and a set of titles that you've read. Write a program that chooses a next book for you to read from the <tt>vector</tt>, provided that you have not yet read it. When it returns the selected title to you, it should enter the title in the set of books read. If in fact you end up putting the book aside, provide support for removing the title from the set of books read. At the end of our virtual six months, print the set of books read and those books that were not read.</p>
        <p class="docText">定义一个 <tt>vector</tt> 的容器，存储你在未来六个月里要阅读的书，再定义一个 <tt>set</tt>，用于记录你已经看过的书名。编写程序从 <tt>vector</tt> 中为你选择一本没有读过而现在要读的书。当它为你返回选中的书名后，应该将该书名放入记录已读书目的 <tt>set</tt> 中。如果实际上你把这本书放在一边没有看，则本程序应该支持从已读书目的 <tt>set</tt> 中删除该书的记录。在虚拟的六个月后，输出已读书目和还没有读的书目。</p>
                    </td>
                  </tr>
                </table>
              </blockquote>
            </td>
          </tr>
        </table><br>
        <a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch10lev1sec3.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch10lev1sec5.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
