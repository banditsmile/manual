<html>
<head>
  <meta name="generator" content="HTML Tidy for Windows (vers 12 April 2005), see www.w3.org">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>Keyterm Defined Terms</title>
  <link rel="STYLESHEET" type="text/css" href="images/style.css" >
  <link rel="STYLESHEET" type="text/css" href="images/docsafari.css" >
</head>

<body>
  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch17lev1sec4.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch18.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table><br>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td valign="top">
        <a name="ch17lev1sec5"></a>

        <h3 class="docSection1Title">Defined Terms</h3>
        <h3 class="docSection1Title">术语</h3>

        <a name="gloss17_01"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term1" >abort</a></b></dt>

          <dd>
            <p class="docText">Library function that abnormally terminates a program's execution. Ordinarily, <tt>abort</tt> is called by <tt>terminate</tt>. Programs may also call <tt>abort</tt> directly. It is defined in the <tt>cstdlib</tt> header.</p>
            <p class="docText">异常终止程序执行的库函数。通常，由 <tt>terminate</tt> 调用 <tt>abort</tt>，程序也可以直接调用 <tt>abort</tt>。<tt>abort</tt> 定义在头文件 <tt>cstdlib</tt> 中。</p>
          </dd>
        </dl>

<a name="gloss17_02"></a>
        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term2" >auto_ptr</a></b></dt>

          <dd>
            <p class="docText">Library class template that provides exception-safe access to dynamically allocated objects. An <tt>auto_ptr</tt> cannot be bound to an array or a pointer to a variable. Copying and assigning an <tt>auto_ptr</tt> is a destructive operation: Ownership of the object is transferred from the right-hand operand to the left. Assigning to an <tt>auto_ptr</tt> deletes the object in the left-hand operand. As a result, <tt>auto_ptrs</tt> may not be stored in containers.</p>
            <p class="docText">一个库类模板，提供对动态分配对象的异常安全的访问。不能将 <tt>auto_ptr</tt> 对象绑定到数组或者变量指针，<tt>auto_ptr</tt> 对象的复制和赋值是破坏性操作：将对象的所有权从右操作数转到左操作数。对 <tt>auto_ptr</tt> 对象进行赋值删除左操作数中的对象，因此，不能将 <tt>auto_ptrs</tt> 对象存储在容器中。</p>
          </dd>
        </dl><a name="gloss17_03"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term3" >catch-all（捕获所有异常子句）</a></b></dt>

          <dd>
<a name="idd1e143946"></a><a name="idd1e143951"></a><a name="idd1e143954"></a><a name="idd1e143957"></a><a name="idd1e143960"></a><a name="idd1e143968"></a><a name="idd1e143973"></a><a name="idd1e143976"></a><a name="idd1e143979"></a><a name="idd1e143982"></a><a name="idd1e143987"></a><a name="idd1e143993"></a><a name="idd1e143996"></a>
            <p class="docText">A catch clause in which the exception specifier is <tt>(...)</tt>. A catch-all clause catches an exception of any type. It is typically used to catch an exception that is detected locally in order to do local cleanup. The exception is then rethrown to another part of the program to deal with the under-lying cause of the problem.</p>
	    <p class="docText">异常说明符为<tt>(...)</tt>的 <tt>catch</tt> 子句。这种子句能够捕获任意类型的异常，它通常用于捕获为进行局部清除而局部检测的异常。异常被重新抛出给程序的其他部分，以处理问题的基本原因。</p>
          </dd>
        </dl><a name="gloss17_04"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term4" >catch clause（catch 子句）</a></b></dt>

          <dd>
            <p class="docText">The part of the program that handles an exception. A catch clause consists of the keyword <tt>catch</tt> followed by an exception specifier and a block of statements. The code inside a <tt>catch</tt> does whatever is necessary to handle an exception of the type defined in its exception specifier.</p>
	    <p class="docText">程序中处理异常的部分，也称异常处理代码。<tt>catch</tt> 子句由关键字 <tt>catch</tt> 后接异常说明符和语句块构成。<tt>catch</tt> 内部的代码完成的必要工作来处理由异常说明符定义的类型的异常。</p>
          </dd>
        </dl><a name="gloss17_05"></a>

        <dl class="docList">
          <dt><b>constructor order（构造函数次序）</b></dt>

          <dd>
            <p class="docText">Ordinarily, base classes are constructed in the order in which they are named in the class derivation list. A derived constructor should explicitly initialize each base class through the constructor initializer list. The order in which base classes are named in the constructor initializer list does not affect the order in which the base classes are constructed. In a virtual inheritance, the virtual base class(es) are constructed before any other bases. They are constructed in the order in which they appear (directly or indirectly) in the derivation list of the derived type. Only the most derived type may initialize a virtual base; constructor initializers for that base that appear in the intermediate base classes are ignored.</p>
            <p class="docText">一般而言，应该按照类派生列表中指定的次序构造基类，派生类构造函数应该通过构造函数初始化列表显式初始化每个基类。构造函数初始化列表中指定基类的次序不影响构造基类的次序。在虚继承中，虚基类在任何其他基类之前构造，它们按照在派生类型的派生列表中（直接或间接地）出现在次序进行构造，只有最低层派生类型可以初始化虚基类，中间基类中出现的基类构造函数初始化列表被忽略。</p>
          </dd>
        </dl><a name="gloss17_06"></a>

        <dl class="docList">
          <dt><b>destructor order（析构函数次序）</b></dt>

          <dd>
            <p class="docText">Derived objects are destroyed in the reverse order from which they were constructedthe derived part is destroyed first, then the classes named in the class derivation list are destroyed, starting with the last base class. Classes that serve as base classes in a multiple-inheritance hierarchy ordinarily should define their destructors to be virtual.</p>
            <p class="docText">应该按照构造次序的逆序撤销派生类对象——首先撤销派生部分，然后，从最后一个基类开始，撤销类派生列表中指定的类。在多重继承层次中作为基类的类通常应该将它们的析构函数数定义为虚函数。</p>
          </dd>
        </dl><a name="gloss17_07"></a>

        <dl class="docList">
          <dt><b>exception handler（异常处理代码）</b></dt>

          <dd>
            <p class="docText">Another way to refer to a catch clause.</p>
	    <p class="docText"><tt>catch</tt> 子句的另一个名称。</p>
          </dd>
        </dl><a name="gloss17_08"></a>

        <dl class="docList">
          <dt><b>exception handling（异常处理）</b></dt>

          <dd>
            <p class="docText">Language-level support for managing run-time anomalies. One independently developed section of code can detect and "raise" an exception that another independently developed part of the program can "handle." The error-detecting part of the program <tt>throws</tt> an exception; the error-handling part handles the exception in a <tt>catch</tt> clause of a <tt>try</tt> block.</p>
            <p class="docText">管理运行时异常的语言级支持。代码中一个独立开发的部分可以检测并“引发”异常，由程序中另一个独立开发的部分“处理”该异常。也就是说，程序的错误检测部分抛出异常，错误处理部分在 <tt>try</tt> 块的 <tt>catch</tt> 子句中处理异常。</p>
          </dd>
        </dl><a name="gloss17_09"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term9" >exception object（异常对象）</a></b></dt>

          <dd>
            <p class="docText">Object used to communicate between the <tt>throw</tt> and <tt>catch</tt> sides of an exception. The object is created at the point of the throw and is a copy of the thrown expression. The exception object exists until the last handler for the exception completes. The type of the object is the type of the thrown expression.</p>
            <p class="docText">用于在异常的 <tt>throw</tt> 和 <tt>catch</tt> 方之间进行通信的对象。在抛出点创建该对象，该对象是被抛出表达式的副本。异常对象一直存在，直到该异常最后一个处理代码结束。异常对象的类型是被抛出表达式的类型。</p>
          </dd>
        </dl><a name="gloss17_10"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term10" >exception safe（异常安全的）</a></b></dt>

          <dd>
            <p class="docText">Term used to describe programs that behave correctly when exceptions are thrown.</p>
            <p class="docText">用于描述在抛出异常时表现正确的程序的术语。</p>
          </dd>
        </dl><a name="gloss17_11"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term11" >exception specification（异常说明）</a></b></dt>

          <dd>
            <p class="docText">Used on a function declaration to indicate what (if any) exception types a function throws. Exception types are named in a parenthesized, comma-separated list following the keyword <tt>throw</tt>, which appears after a function's parameter list. An empty list means that the function throws no exceptions. A function that has no exception specification may throw any exception.</p>
            <p class="docText">用于函数声明之上，指出函数抛出什么（如果有）异常类型。在用圆括号括住、以逗号分隔、跟在关键字 <tt>throw</tt> 之后的列表中指定异常类型。空列表表示函数不抛出异常，没有异常说明的函数可以抛出任何异常。</p>
          </dd>
        </dl><a name="gloss17_12"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term12" >exception specifier（异常说明符）</a></b></dt>

          <dd>
            <p class="docText">Specifies the types of exceptions that a given catch clause will handle. An exception specifier acts like a parameter list, whose single parameter is initialized by the exception object. Like parameter passing, if the exception specifier is a nonreference type, then the exception object is copied to the <tt>catch</tt>.</p>
	    <p class="docText">说明给定 <tt>catch</tt> 子句将处理的异常的炻。异常说明符的行为形参表，由异常对象初始化它的单个形参。像参数传递一样，如果异常说明符是非引用类型，就将异常对象复制到 <tt>catch</tt> 中。</p>
          </dd>
        </dl><a name="gloss17_13"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term13" >file static（文件静态）</a></b></dt>

          <dd>
            <p class="docText">Name local to a file that is declared with the <tt>static</tt> keyword. In C and pre-Standard versions of C++, file statics were used to declare objects that could be used in a single file only. File statics are deprecated in C++, having been replaced by the use of unnamed namespaces.</p>
            <p class="docText">用关键字 <tt>static</tt> 声明的局部于文件的名字。在 C 语言和标准版本之前的 C++ 中，文件中的静态声明用于声明只能在单个文件中使用的对象，C++ 不赞成文件静态，已经用未命名的命名空间代替它。</p>
          </dd>
        </dl><a name="gloss17_14"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term14" >function try block（函数测试块）</a></b></dt>

          <dd>
            <p class="docText">A <tt>try</tt> block that is a function body. The keyword <tt>try</tt> occurs before the opening curly of the function body and closes with catch clause(s) that appear after the close curly of the function body. Function try blocks are used most often to wrap constructor definitions in order to catch exceptions thrown by constructor initializers.</p>
	    <p class="docText">是函数体的 <tt>try</tt> 块。关键字 <tt>try</tt> 出现在函数体的左花括号之前，以出现在函数体的右花括号之后的 <tt>catch</tt> 子句作为结束。函数测试块最经常用于包围构造函数定义，以便捕获由构造函数初始化式抛出的异常。</p>
          </dd>
        </dl><a name="gloss17_15"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term15" >global namespace（全局命名空间）</a></b></dt>

          <dd>
<a name="idd1e144127"></a><a name="idd1e144130"></a><a name="idd1e144137"></a><a name="idd1e144143"></a><a name="idd1e144150"></a><a name="idd1e144156"></a><a name="idd1e144162"></a><a name="idd1e144165"></a><a name="idd1e144170"></a><a name="idd1e144173"></a><a name="idd1e144176"></a><a name="idd1e144179"></a><a name="idd1e144182"></a><a name="idd1e144185"></a><a name="idd1e144193"></a><a name="idd1e144196"></a><a name="idd1e144200"></a><a name="idd1e144204"></a><a name="idd1e144209"></a><a name="idd1e144213"></a><a name="idd1e144216"></a><a name="idd1e144219"></a>
            <p class="docText">The (implicit) name-space in each program that holds all global definitions.</p>
            <p class="docText">每个程序中保存所有全局定义的（隐式）命名空间。</p>
          </dd>
        </dl><a name="gloss17_16"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec3.html#ch17term16" >multiple inheritance(多重继承）</a></b></dt>

          <dd>
            <p class="docText">Inheritance in which a class has more than one immediate base class. The derived class inherits the members of all its base classes. Multiple base classes are defined by naming more than one base class in the class derivation list. A separate access label is required for each base class.</p>
            <p class="docText">类有多个直接基类的继承。派生类继承所有基类的成员，通过在类派生列表中指定多个基类而定义多个基类，每个基类需要一个单独的访问标号。</p>
          </dd>
        </dl><a name="gloss17_17"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term17" >namespace（命名空间）</a></b></dt>

          <dd>
            <p class="docText">Mechanism for gathering all the names defined by a library or other collection of programs into a single scope. Unlike other scopes in C++, a namespace scope may be defined in several parts. The namepsace may be opened and closed and reopened again in disparate parts of the program.</p>
            <p class="docText">将一个库或其他程序集合定义的所有名字聚焦到单个作用域的机制。与 C++ 中其他作用域不同，命名空间作用域可以在几个部分中定义，在程序的不同部分，命名空间可以是打开的、关闭的和重新打开的。</p>
          </dd>
        </dl><a name="gloss17_18"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term18" >namespace alias（命名空间别名）</a></b></dt>

          <dd>
            <p class="docText">Mechanism for defining a synonym for a given namespace:</p>
            <p class="docText">为给定命名空间定义同义词的机制。</p>
            <pre>
namespace N1 = N;
</pre><br>

            <p class="docText">defines <tt>N1</tt> as another name for the name-space named <tt>N</tt>. A namespace can have multiple aliases, and the namespace name or one of its aliases may be used interchangeably.</p>
            <p class="docText">将 <tt>N1</tt> 定义为名为 <tt>N</tt> 的命名空间的另一名字。一个命名空间可以有多个别名，并且命名空间名字和它的别名可以互换使用。</p>
          </dd>
        </dl><a name="gloss17_19"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term19" >namespace pollution（命名空间污染）</a></b></dt>

          <dd>
            <p class="docText">Term used to describe what happens when all the names of classes and functions are placed in the global namespace. Large programs that use code written by multiple independent parties often encounter collisions among names if these names are global.</p>
            <p class="docText">用来描述类和函数的所有名字放在全局命名空间时发生什么情况的术语。如果名字是全局的，则使用由多个独立团队编写的代码的大程序经常遇到名字冲突。</p>
          </dd>
        </dl><a name="gloss17_20"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term20" >raise（引发）</a></b></dt>

          <dd>
            <p class="docText">Often used as a synonym for throw. C++ programmers speak of "throwing" or "raising" an exception interchangably.</p>
            <p class="docText">经常用作抛出的同义词。C++ 程序员互换地使用“抛出”异常或“引发”异常。</p>
          </dd>
        </dl><a name="gloss17_21"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term21" >rethrow（重新抛出）</a></b></dt>

          <dd>
            <p class="docText">An empty <tt>throw</tt>a <tt>throw</tt> that does not specify an expression. A rethrow is valid only from inside a catch clause, or in a function called directly or indirectly from a <tt>catch</tt>. Its effect is to rethrow the exception object that it received.</p>
            <p class="docText">一个空的 <tt>throw</tt>——没有指定 <tt>throw</tt>。只有捕获子句或者从 <tt>catch</tt> 直接或间接调用的函数中的重新抛出才有效，其效果是将接到的异常对象重新抛出。</p>
          </dd>
        </dl><a name="gloss17_22"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term22" >scope operator（作用域操作符）</a></b></dt>

          <dd>
            <p class="docText">Operator used to access names from a namespace or a class.</p>
            <p class="docText">用于访问命名空间或类中名字的操作符。</p>
          </dd>
        </dl><a name="gloss17_23"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term23" >stack unwinding（栈展开）</a></b></dt>

          <dd>
            <p class="docText">Term used to describe the process whereby the functions leading to a thown exception are exited in the search for a <tt>catch</tt>. Local objects constructed before the exception are destroyed before entering the corresponding <tt>catch</tt>.</p>
            <p class="docText">用于描述在查找 <tt>catch</tt> 时退出引起被抛出异常的函数的过程。在进入相应 <tt>catch</tt> 之前，撤销在异常之前构造的局部对象。</p>
          </dd>
        </dl><a name="gloss17_24"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term24" >terminate</a></b></dt>

          <dd>
            <p class="docText">Library function that is called if an exception is not caught or if an exception occurs while a handler is in process. Usually calls <tt>abort</tt> to end the program.</p>
            <p class="docText">一个库函数。如果没有捕获到异常或者在异常处理过程中发生异常，就调用这个库函数。该函数通常调用 <tt>abort</tt> 函数来结束程序。</p>
          </dd>
        </dl><a name="gloss17_25"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term25" >throw <tt>e</tt></a></b></dt>

          <dd>
            <p class="docText">Expression that interrupts the current execution path. Each <tt>throw</tt> TRansfers control to the nearest enclosing <tt>catch</tt> clause that can handle the type of exception that is thrown. The expression <tt>e</tt> is copied into the exception object.</p>
            <p class="docText">中断当前执行路径的表达式。每个 <tt>throw</tt> 将控制转到可以处理被抛出异常类型的最近的外围 <tt>catch</tt> 子句，表达式 <tt>e</tt> 被复制到异常对象。</p>
          </dd>
        </dl><a name="gloss17_26"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term26" >try block（测试块）</a></b></dt>

          <dd>
            <p class="docText">A block of statements enclosed by the keyword <tt>try</tt> and one or more catch clauses. If the code inside the try block raises an exception and one of the catch clauses matches the type of the exception, then the exception is handled by that catch. Otherwise, the exception is passed out of the <tt>try</tt> to a catch further up the call chain.</p>
	    <p class="docText">由关键字 <tt>try</tt> 以及一个或多个 <tt>try</tt> 子句包围的语句块。如果 <tt>try</tt> 块内部的代码引发一个异常，而一个 <tt>catch</tt> 子句与异常的类型匹配，则由该 <tt>catch</tt> 处理异常；否则，将异常传出 <tt>try</tt> 之外，传给调用链中更上层的 <tt>catch</tt>。</p>
          </dd>
        </dl><a name="gloss17_27"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec1.html#ch17term27" >unexpected</a></b></dt>

          <dd>
            <p class="docText">Library function that is called if an exception is thrown that violates the exception specification of a function.</p>
            <p class="docText">一个库函数，如果被抛出异常违反函数的异常说明，就调用该函数。</p>
          </dd>
        </dl><a name="gloss17_28"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term28" >unnamed namespace（未命名的命名空间）</a></b></dt>

          <dd>
            <p class="docText">A namespace that is defined without a name. Names defined in an unnamed namespace may be accessed directly without use of the scope operator. Each file has its own unique unnamed namespace. Names in the file are not visible outside that file.</p>
            <p class="docText">没有定义名字的命名空间。未命名的命名空间中定义的名字可以无须使用作用域操作符而直接访问。每个文件都具有自己的未命名的命名空间，文件中的名字在该文件之外不可见。</p>
          </dd>
        </dl><a name="gloss17_29"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term29" >using declaration（using 声明）</a></b></dt>

          <dd>
            <p class="docText">Mechanism to inject a single name from a namespace into the current scope:</p>
            <p class="docText">将命名空间中单个名字注入当前作用域的机制。</p>
            <pre>
using std::cout;
</pre><br>

            <p class="docText">makes the name <tt>cout</tt> from the namespace <tt>std</tt> available in the current scope. The name <tt>cout</tt> can be used without the <tt>std::</tt> qualifier.</p>
	    <p class="docText">使得命名空间 <tt>std</tt> 中的名字 <tt>cout</tt> 在当前作用域中可见，可以无须限定符 <tt>std::</tt> 而使用名字 <tt>cout</tt>。</p>
          </dd>
        </dl><a name="gloss17_30"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec2.html#ch17term30" >using directive（using 指示）</a></b></dt>

          <dd>
<a name="idd1e144415"></a><a name="idd1e144422"></a><a name="idd1e144427"></a><a name="idd1e144432"></a><a name="idd1e144437"></a><a name="idd1e144442"></a><a name="idd1e144445"></a>
            <p class="docText">Mechanism for making <span class="docEmphasis">all</span> the names in a namespace available in the nearest scope containing both the using directive and the namespace itself.</p>
	    <p class="docText">使一个命名空间中的<span class="docEmphasis">所有</span>名字在 <tt>using</tt> 指示和命名空间本身的最近作用域中可见的机制。</p>
          </dd>
        </dl><a name="gloss17_31"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec3.html#ch17term31" >virtual base class（虚基类）</a></b></dt>

          <dd>
            <p class="docText">A base class that was inherited using the <tt>virtual</tt> keyword. A virtual base part occurs only once in a derived object even if the same class appears as a virtual base more than once in the hierarchy. In nonvirtual inheritance a constructor may only initialize its immediate base class(es). When a class is inherited virtually, that class is initialized by the most derived class, which therefore should include an initializer for all of its virtual parent(s).</p>
            <p class="docText">使用关键字 <tt>virtual</tt> 继承的基类。即使同一类在层次中作为虚基类出现多次，派生类对象中的虚基类部分也只出现一次。在非虚继承中，构造函数只能初始化自己的直接基类，当对一个类进行虚继承的时候，由最低层的派生类初始化那个类，因此最低层的派生类应包含用于其所有虚父类的初始化式。</p>
          </dd>
        </dl><a name="gloss17_32"></a>

        <dl class="docList">
          <dt><b><a class="docLink" href="ch17lev1sec3.html#ch17term32" >virtual inheritance（虚继承）</a></b></dt>

          <dd>
            <p class="docText">Form of multiple inheritance in which derived classes share a single copy of a base that is included in the hierarchy more than once.</p>
            <p class="docText">多重继承的形式，这种形式中，派生类共享在层次中被包含多次的基类的一个副本。</p>
          </dd>
        </dl><a href="21001535.html" ><img src="images/pixel.gif"  alt="" width="1" height="1" border="0"></a>
      </td>
    </tr>
  </table>

  <table width="100%" border="0" cellspacing="0" cellpadding="0">
    <tr>
      <td>
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="toc.html" ><img src="images/teamlib.gif"  width="62" height="15" border="0" align="absmiddle" alt="Team LiB"></a>
        </div>
      </td>

      <td align="right">
        <div style="MARGIN-LEFT: 0.15in;">
          <a href="ch17lev1sec4.html" ><img src="images/previous.gif"  width="62" height="15" border="0" align="absmiddle" alt="Previous Section"></a> <a href="ch18.html" ><img src="images/next.gif"  width="41" height="15" border="0" align="absmiddle" alt="Next Section"></a>
        </div>
      </td>
    </tr>
  </table>
</body>
</html>
