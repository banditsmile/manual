<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv=Content-Type content='text/html; charset=utf-8'>

	<title>Event.unloadCache - Prototype JavaScript 框架</title>
	<link href="../../CSS/main.css"  type='text/css' rel='Stylesheet' />
</head>
<body>
	<!-- main -->
	<div id="main" class="clearfix">
		<h2>unloadCache<div class="box">1.6</div></h2>
		<div id="excerpt">
			<pre><code class="ebnf">Event.unloadCache()</code></pre>
			<p>
				注销所有通过 <a href="event/observe.htm" >observe</a> 方法注册的事件处理程序。<strong>从 1.6 版开始该方法不再可用。</strong>
			</p>
		</div>
		<div id="abody">
			<div class="deprecated">
				后向兼容性通告：<br />
				该方法在 <b>1.6</b> 发行版中已经被移除。若要将原有的代码升级到 v1.6，请删除所有脚本中对该方法的调用。				
			</div>
			<h3>令人痛苦的 MSIE 事件处理机制和内存泄漏问题</h3>
			<p>
				MSIE 具有一个影响深远的造成人们极度困扰的问题：在大多数情形下，当页面卸载时，它不会释放事件处理程序所占用的内存。
				这些处理程序将驻留在内存中，慢慢的填满内存空间，进而妨碍浏览器的正常运行——这就是著名的内存泄漏。
			</p>
			<p>
				当然，你可以手动保留通过 <a href="observe.htm" >observe</a> 所注册的事件处理程序句柄，然后在必要的时候释放它们。
				但是这非常麻烦，并且无趣。简言之，不够酷！
			</p>
			<p>
				Prototype 早已为你考虑到了这个问题。它自动保留所有的事件处理程序句柄，当你调用 <code>unloadCache</code>
				后，它会注销所有的事件处理程序并释放相应的内存空间，就像垃圾回收机制所做的一样。
			</p>
			<h3>你甚至不需要知道这个方法：</h3>
			<p>
				Prototype 针对 MSIE 做了专门的处理，它会在页面卸载时自动调用 <code>unloadCache</code>。所以你什么都不用做，
				全都为你考虑好了。我们只是猜测大约你会想知道。去做一些有用的事情吧，例如编写一些卓有成效的 JavaScript
				代码。我们在这里并不想用那些关于程序如何进行自动化处理的细节来阻碍你前进的步伐。
			</p>
		</div>
	</div>
	<!-- /main -->
</body>
</html>
