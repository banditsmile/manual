<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv=Content-Type content='text/html; charset=utf-8'>

	<title>Enumerable.invoke - Prototype JavaScript 框架</title>
	<link href="../../CSS/main.css"  type='text/css' rel='Stylesheet' />
</head>
<body>
	<!-- main -->
	<div id="main" class="clearfix">
		<h2>invoke</h2>
		<div id="excerpt">
			<pre><code class="ebnf">invoke(methodName[, arg...]) -> Array</code></pre>
			<p>
				对 <a href="each.htm" >each</a> 或 <a href="collect.htm" >collect</a>
				的一种常见应用情形进行优化：需要使用同一个方法并具有一致的参数来处理 <code>Enumerable</code> 中的每一个元素。
				返回调用指定方法后的结果集。
			</p>
		</div>
		<div id="abody">
			<p>
				因为它避免了因使用匿名函数（如 <a href="each.htm" >each</a> 和 <a href="collect.htm" >collect</a>
				方法的做法）而产生的语法闭包的开销，因此具有较好的执行效率。
			</p>
			<p>或许更重要的是它使你的源代码变得更为简捷明了。</p>
			<h3>样例</h3>
			<pre><code class="javascript">['hello', 'world', 'cool!'].invoke('toUpperCase') 
// ['HELLO', 'WORLD', 'COOL!'] 
['hello', 'world', 'cool!'].invoke('substring', 0, 3) 
// ['hel', 'wor', 'coo'] 
// 当然，它也可以应用于 Prototype 的扩展方法 
$('navBar', 'adsBar', 'footer').invoke('hide') 
// 因为 Prototype 的扩展方法大多返回元素本身
// 因此也可以链式的调用“invoke”：
$$('#windows div.close').invoke('addClassName', 'active').invoke('show'); </code></pre>
			<h3>参见</h3>
			<p><a href="pluck.htm" >pluck</a> 方法用于获取相同的属性值集合。</p>
		</div>
	</div>
	<!-- /main -->
</body>
</html>
