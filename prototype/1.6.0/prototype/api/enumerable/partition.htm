<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv=Content-Type content='text/html; charset=utf-8'>

	<title>Enumerable.partition - Prototype JavaScript 框架</title>
	<link href="../../CSS/main.css"  type='text/css' rel='Stylesheet' />
</head>
<body>
	<!-- main -->
	<div id="main" class="clearfix">
		<h2>partition</h2>
		<div id="excerpt">
			<pre><code class="ebnf">partition([iterator = Prototype.K[, context]]) -> [TrueArray, FalseArray]</code></pre>
			<p>
				把元素分为两组：一组为 <code>true</code>，一组为 <code>false</code>。默认情形下使用 Javascript 标准规范判断元素等价的
				bool 值，如果指定了 <code>iterator</code> 参数，根据 <code>iterator</code> 定义的函数判断元素等价的 bool 值。
			</p>
		</div>
		<div id="abody">
			<p>
				相对于同时使用 <a href="findAll.htm" >findAll</a>/<code>select</code> 和 <a href="reject.htm" >reject</a>
				这两个方法来获取 <code>Enumerable</code> 的分组，<code>partition</code> 是一个更好的解决办法：它只需要对元素进行一次遍历。
			</p>
			<p>
				可选的 <code>context</code> 参数是 <code>iterator</code> 要绑定的对象，若设定该参数，<code>iterator</code>
				中的 <code>this</code> 关键字将指向 <code>context</code> 对象。
			</p>
			<h3>样例</h3>
			<pre><code class="javascript">['hello', null, 42, false, true, , 17].partition() 
// -> [['hello', 42, true, 17], [null, false, undefined]] 
$R(1, 10).partition(function(n) { 
	return 0 == n % 2; 
}) 
// -> [[2, 4, 6, 8, 10], [1, 3, 5, 7, 9]] </code></pre>
		</div>
	</div>
	<!-- /main -->
</body>
</html>
