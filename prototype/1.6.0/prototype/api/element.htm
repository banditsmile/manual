<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv=Content-Type content='text/html; charset=utf-8'>

	<title>Element - Prototype JavaScript 框架</title>
	<link href="../CSS/main.css"  type='text/css' rel='Stylesheet' />
</head>
<body>
	<!-- main -->
	<div id="main" class="clearfix">
		<h2>Element</h2>
		<div id="method-list">
			<ul>
				<li><a href="element.htm#method-absolutize">absolutize</a></li>
				<li><a href="element.htm#method-addclassname">addClassName</a></li>
				<li><a href="element.htm#method-addmethods">addMethods</a></li>
				<li><a href="element.htm#method-adjacent">adjacent</a></li>
				<li><a href="element.htm#method-ancestors">ancestors</a></li>
				<li><a href="element.htm#method-childelements">childElements</a></li>
				<li><a href="element.htm#method-classnames">classNames</a></li>
				<li><a href="element.htm#method-cleanwhitespace">cleanWhitespace</a></li>
				<li><a href="element.htm#method-cloneposition">clonePosition</a></li>
				<li><a href="element.htm#method-cumulativeoffset">cumulativeOffset</a></li>
				<li><a href="element.htm#method-cumulativescrolloffset">cumulativeScrollOffset</a></li>
				<li><a href="element.htm#method-descendantof">descendantOf</a></li>
				<li><a href="element.htm#method-descendants">descendants</a></li>
				<li><a href="element.htm#method-down">down</a></li>
				<li><a href="element.htm#method-empty">empty</a></li>
				<li><a href="element.htm#method-extend">extend</a></li>
				<li><a href="element.htm#method-fire">fire</a></li>
				<li><a href="element.htm#method-firstdescendant">firstDescendant</a></li>
				<li><a href="element.htm#method-getdimensions">getDimensions</a></li>
				<li><a href="element.htm#method-getelementsbyclassname">getElementsByClassName</a></li>
				<li><a href="element.htm#method-getelementsbyselector">getElementsBySelector</a></li>
				<li><a href="element.htm#method-getheight">getHeight</a></li>
				<li><a href="element.htm#method-getoffsetparent">getOffsetParent</a></li>
				<li><a href="element.htm#method-getstyle">getStyle</a></li>
				<li><a href="element.htm#method-getwidth">getWidth</a></li>
				<li><a href="element.htm#method-hasclassname">hasClassName</a></li>
				<li><a href="element.htm#method-hide">hide</a></li>
				<li><a href="element.htm#method-identify">identify</a></li>
				<li><a href="element.htm#method-immediatedescendants">immediateDescendants</a></li>
				<li><a href="element.htm#method-insert">insert</a></li>
				<li><a href="element.htm#method-inspect">inspect</a></li>
				<li><a href="element.htm#method-makeclipping">makeClipping</a></li>
				<li><a href="element.htm#method-makepositioned">makePositioned</a></li>
				<li><a href="element.htm#method-match">match</a></li>
				<li><a href="element.htm#method-next">next</a></li>
				<li><a href="element.htm#method-nextsiblings">nextSiblings</a></li>
				<li><a href="element.htm#method-observe">observe</a></li>
				<li><a href="element.htm#method-positionedoffset">positionedOffset</a></li>
				<li><a href="element.htm#method-previous">previous</a></li>
				<li><a href="element.htm#method-previoussiblings">previousSiblings</a></li>
				<li><a href="element.htm#method-readattribute">readAttribute</a></li>
				<li><a href="element.htm#method-recursivelycollect">recursivelyCollect</a></li>
				<li><a href="element.htm#method-relativize">relativize</a></li>
				<li><a href="element.htm#method-remove">remove</a></li>
				<li><a href="element.htm#method-removeclassname">removeClassName</a></li>
				<li><a href="element.htm#method-replace">replace</a></li>
				<li><a href="element.htm#method-scrollto">scrollTo</a></li>
				<li><a href="element.htm#method-select">select</a></li>
				<li><a href="element.htm#method-setopacity">setOpacity</a></li>
				<li><a href="element.htm#method-setstyle">setStyle</a></li>
				<li><a href="element.htm#method-show">show</a></li>
				<li><a href="element.htm#method-siblings">siblings</a></li>
				<li><a href="element.htm#method-stopobserving">stopObserving</a></li>
				<li><a href="element.htm#method-toggle">toggle</a></li>
				<li><a href="element.htm#method-toggleclassname">toggleClassName</a></li>
				<li><a href="element.htm#method-undoclipping">undoClipping</a></li>
				<li><a href="element.htm#method-undopositioned">undoPositioned</a></li>
				<li><a href="element.htm#method-up">up</a></li>
				<li><a href="element.htm#method-update">update</a></li>
				<li><a href="element.htm#method-viewportoffset">viewportOffset</a></li>
				<li><a href="element.htm#method-visible">visible</a></li>
				<li><a href="element.htm#method-wrap">wrap</a></li>
				<li><a href="element.htm#method-writeattribute">writeAttribute</a></li>
			</ul>
		</div>
		<div id="abody">
			<p>
				<code>Element</code> 对象引入了许多功能强大的方法，你既可以通过 <a href="element.htm" >Element</a> 来访问这些方法
				（不过这已经过时了），也可以通过<a href="element/extend.htm" >已扩展的</a> DOM 元素<strong>直接访问</strong>这些方法（幸亏
				<a href="element/extend.htm" >Element.extend</a> 为 DOM 元素增加了一层语法糖衣）。
			</p>
			<p>
				在继续阅读下面的文章之前，你<em>应该</em>先阅读 <a href="http://www.prototypejs.org/learn/extensions" >“Prototype 如何扩展
				DOM”</a>一文，这篇文章将会引领你深入理解 Prototype 奇妙的 DOM 扩展内部工作机制。
			</p>
			<h3>样例</h3>
			<pre><code class="html">&lt;div id="message" class=""&gt;&lt;/div&gt; </code></pre>
			<pre><code class="javascript">// 切换 div#message 的 CSS 类名
$('message').addClassName('read');
// -> div#message 
// 你也可以使用没有语法糖衣的版本：
Element.toggleClassName('message', 'read'); 
// -> div#message </code></pre>
			<p>
				因为 <code>Element</code> 大多数的方法都返回它们所应用到的元素本身，所以你可以像链条一样将这些方法连结起来，如下所示：
			</p>
			<pre><code class="javascript">$('message').addClassName('read').update('I read this message!').setStyle({opacity: 0.5}); </code></pre>
			<h3>Element 作为一个构造函数<div class="box">1.6</div></h3>
			<pre><code class="ebnf">new Element(tagName[, attributes])</code></pre>
			<p>
				<code>Element</code> 对象也可以用来创建新的元素，并且比内置的 DOM 方法更友好、更简洁。它返回一个<a href="http://www.prototypejs.org/learn/extensions" >
				已扩展</a> 的元素，因此假如要设置元素的内容，你可以链式调用 <code>Element#update</code>。
			</p>
			<p>
				在第二个参数中可提供一组“属性/值”对，它们将通过 <a href="element/writeAttribute.htm" >Element#writeAttribute</a>
				方法设置为新元素的属性。
			</p>
			<h4>过去的写法</h4>
			<pre><code class="javascript">var a = document.createElement('a');
a.setAttribute('class', 'foo'); 
a.setAttribute('href', '/foo.html'); 
a.appendChild(document.createTextNode("Next page"));</code></pre>
			<h4>新的写法</h4>
			<pre><code class="javascript">var a = new Element('a', { 'class': 'foo', href: '/foo.html' }).update("Next page");</code></pre>
		</div>
		<div id="method-excerpts">
			<h3>方法</h3>
			<div id="method-absolutize" class="mexcerpt">
				<h4><a href="element/absolutize.htm" >absolutize</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">absolutize(element) -> HTMLElement</code></pre>
					<p>
						转换元素的定位方式为绝对定位，并且不改变元素在页面中的位置。<br />
						<strong>译注：</strong>该方法使用代码 <code>element.style.position = 'absolute'</code> 改变定位方式。在改变定位方式后，
						元素左上角的坐标仍会保持原来的位置，如果元素未设置初始的 <code>width</code> 和 <code>height</code> 属性，则调用该方法后，
						元素的宽度和高度会改变为系统预设值。
					</p>
				</div>
			</div>
			<div id="method-addclassname" class="mexcerpt">
				<h4><a href="element/addClassName.htm" >addClassName</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">addClassName(element, className) -> HTMLElement </code></pre>
					<p>增加一个 CSS 类到 <code>element</code> 中。</p>
				</div>
			</div>
			<div id="method-addmethods" class="mexcerpt">
				<h4><a href="element/addMethods.htm" >addMethods</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">addMethods([methods])
addMethods(tagName, methods)</code></pre>
					<p>
						第一个参数的类型是一个 hash 列表，用于对 <code>Element</code> 对象进行扩展，hash 列表的名值对将转换为
						<code><a href="element/extend.htm" >扩展后</a></code> 的元素的方法或属性。<br />第二种用法是扩展一个指定的
						HTML 元素，tagName 指定 HTML 元素标签。
					</p>
				</div>
			</div>
			<div id="method-adjacent" class="mexcerpt">
				<h4><a href="element/adjacent.htm" >adjacent</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">Element.adjacent(element[, selectors...]) -> [HTMLElement...]
someElement.adjacent([selectors...]) -> [HTMLElement...]</code></pre>
					<p>
						查找当前元素的所有兄弟节点，若指定选择器，则这些节点必须与给定的选择器（selectors）相匹配。<br />
						<strong>译注：</strong>该方法可<em>同时</em>查询前导兄弟节点和后继兄弟节点。
					</p>
				</div>
			</div>
			<div id="method-ancestors" class="mexcerpt">
				<h4><a href="element/ancestors.htm" >ancestors</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">ancestors(element) -> [HTMLElement...]</code></pre>
					<p>
						返回 <code>element</code> 的所有先代节点（父节点、父节点的父节点...一直到最顶层节点），结果为一个数组，数组元素已经过
						<a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-childelements" class="mexcerpt">
				<h4><a href="element/childElements.htm" >childElements</a><div class="box">1.5.1</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">childElements(element) -> [HTMLElement...]</code></pre>
					<p>
						返回元素的所有子元素，结果为一个数组，数组元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-classnames" class="mexcerpt">
				<h4><a href="element/classNames.htm" >classNames</a><div class="box">不推荐</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">classNames(element) -> Enumerable</code></pre>
					<p>
						返回一个新的 <code>ClassNames</code> 的实例，该实例是一个 <code>Enumerable</code> 对象，用于读写元素的 CSS 类名称。
					</p>
				</div>
			</div>
			<div id="method-cleanwhitespace" class="mexcerpt">
				<h4><a href="element/cleanwhitespace.htm" >cleanWhitespace</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">cleanWhitespace(element) -> HTMLElement</code></pre>
					<p>
						移除元素中所有仅包含空白的文本节点，返回移除空白文本节点后的元素。<br />
						<strong>译注：</strong>所谓空白文本节点，是根据 XML 中的概念得来的，例如，有以下 HTML 代码：
					</p>
					<pre><code class='ebnf'>&lt;div&gt;
	&lt;p&gt;第一段&lt;/p&gt;
&lt;/div&gt;</code></pre>
					<p>
						&lt;div&gt; 的子节点（element.childNodes）包括 &lt;p&gt; 和空白文本节点（对于空白文本节点，各种浏览器的处理方式不一样）,
						这些空白文本节点有时对处理节点的顺序关系会造成影响，如上述 HTML 代码中我们通常认为 &lt;p&gt; 没有前导和后继兄弟节点，
						但因为空白文本节点的干扰，程序可能会认为 &lt;p&gt; 有一个前导兄弟节点和一个后继兄弟节点。为消除这些干扰因素，Prototype
						提供了 <code>cleanWhitespace</code> 方法，用于去除无用的空白文本节点。
					</p>
				</div>
			</div>
			<div id="method-cloneposition" class="mexcerpt">
				<h4><a href="element/cloneposition.htm" >clonePosition</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">clonePosition(element, source[, options]) -> HTMLElement</code></pre>
					<p>
						从 <code>source</code> 中复制参数 <code>options</code> 指定的位置和/或尺寸的相关信息到 <code>element</code>。
					</p>
				</div>
			</div>
			<div id="method-cumulativeoffset" class="mexcerpt">
				<h4><a href="element/cumulativeoffset.htm" >cumulativeOffset</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">cumulativeOffset(element) -> [Number, Number] 或 { left: Number, top: Number }</code></pre>
					<p>
						返回 <code>element</code> 相对于页面左上角的坐标。<br />
						<strong>译注：</strong>假定返回值为 offset，则 X 轴坐标可通过 <code>offset[0]</code> 获取，也可以通过
						<code>offset.left</code> 获取，Y 轴坐标可通过 <code>offset[1]</code> 获取，也可通过 <code>offset.top</code> 获取。
					</p>
				</div>
			</div>
			<div id="method-cumulativescrolloffset" class="mexcerpt">
				<h4>
					<a href="element/cumulativescrolloffset.htm" >cumulativeScrollOffset</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">cumulativeScrollOffset(element) -> [Number, Number] 或 { left: Number, top: Number }</code></pre>
					<p>
						在内含滚动条的容器中计算元素的累积滚动偏移值。<br />
						<strong>译注：</strong>假定返回值为 offset，则 X 轴坐标可通过 <code>offset[0]</code> 获取，也可以通过
						<code>offset.left</code> 获取，Y 轴坐标可通过 <code>offset[1]</code> 获取，也可通过 <code>offset.top</code> 获取。
					</p>
				</div>
			</div>
			<div id="method-descendantof" class="mexcerpt">
				<h4>
					<a href="element/descendantOf.htm" >descendantOf</a>
				</h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">descendantOf(element, ancestor) -> Boolean </code></pre>
					<p>
						判断 <code>element</code> 是否是参数 <code>ancestor</code> 指定元素的后代节点。
					</p>
				</div>
			</div>
			<div id="method-descendants" class="mexcerpt">
				<h4>
					<a href="element/descendants.htm" >descendants</a>
				</h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">descendants(element) -> [HTMLElement...]</code></pre>
					<p>
						返回 <code>element</code> 的所有后代节点，结果为一个数组，数组元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-down" class="mexcerpt">
				<h4><a href="element/down.htm" >down</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">down(element[, cssRule][, index = 0]) -> HTMLElement | undefined</code></pre>
					<p>
						返回 <code>element</code> 下与 <code>cssRule</code> 相匹配的第一个后代节点（如果指定 <code>index</code> 参数，则返回第
						<em>index</em> 个）。如果未指定	<code>cssRule</code>，则默认匹配所有后代节点。如果没有符合条件的后代节点，返回
						<code>undefined</code>。
					</p>
				</div>
			</div>
			<div id="method-empty" class="mexcerpt">
				<h4><a href="element/empty.htm" >empty</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">empty(element) -> Boolean</code></pre>
					<p>测试 <code>element</code> 是否为空（例如仅包含空白）。</p>
				</div>
			</div>
			<div id="method-extend" class="mexcerpt">
				<h4><a href="element/extend.htm" >extend</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">extend(element)</code></pre>
					<p>
						扩展 <code>element</code>，使其具有 <a href="element/methods.htm" >Element.Methods</a> 和
						<a href="element/simulated.htm" >Element.Methods.Simulated</a> 包含的所有方法。如果 <code>element</code>
						具有 <code>input</code>、<code>textarea</code> 或者 <code>select</code> 标签，扩展后也同时拥有
						<a href="form/element.htm" >Form.Element.Methods</a> 的方法，如果具有 <code>form</code> 标签，则拥有
						<a href="form.htm" >Form.Methods</a> 的方法。
					</p>
				</div>
			</div>
			<div id="method-fire" class="mexcerpt">
				<h4><a href="element/fire.htm" >fire</a><div class="box">1.6.0</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">fire(eventName[, memo]) -> Event</code></pre>
					<p>在当前元素上触发一个自定义事件。</p>
				</div>
			</div>
			<div id="method-firstdescendant" class="mexcerpt">
				<h4><a href="element/firstDescendant.htm" >firstDescendant</a><div class="box">1.5.1</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">firstDescendant(element) -> HTMLElement</code></pre>
					<p>
						返回第一个子元素。与 DOM 属性 <code>firstChild</code> 不同，<code>firstChild</code> 返回任意类型的节点（在很多情形下，
						经常是一个空白文本节点[<strong>译注：</strong>这种情况在 Firefox 中较为常见]）。
					</p>
				</div>
			</div>
			<div id="method-getdimensions" class="mexcerpt">
				<h4><a href="element/getDimensions.htm" >getDimensions</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">getDimensions(element) -> {height: Number, width: Number}</code></pre>
					<p>
						获取 <code>element</code> 的 <code>width</code> 和 <code>height</code>，并返回一个对象，包括宽高的名值对。
					</p>
				</div>
			</div>
			<div id="method-getelementsbyclassname" class="mexcerpt">
				<h4><a href="element/getElementsByClassName.htm" >getElementsByClassName</a><div class="box">不推荐</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">getElementsByClassName(element, className) -> [HTMLElement...]</code></pre>
					<p>
						查询 <code>element</code> 下所有具有参数 <code>className</code> 指定的 CSS 类名称的后代节点，并返回一个数组，
						数组中的元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-getelementsbyselector" class="mexcerpt">
				<h4><a href="element/getelementsbyselector.htm" >getElementsBySelector</a><div class="box">不推荐</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">getElementsBySelector(element, selector...) -> [HTMLElement...]</code></pre>
					<p>
						根据一个或多个指定的 CSS 选择器（字符串），在 <code>element</code> 中查找匹配其中任何一个选择器的后代节点，
						并返回一个数组，数组中的元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-getheight" class="mexcerpt">
				<h4><a href="element/getheight.htm" >getHeight</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">getHeight(element) -> Number</code></pre>
					<p>获取 <code>element</code> 的高度。</p>
				</div>
			</div>
			<div id="method-getoffsetparent" class="mexcerpt">
				<h4><a href="element/getoffsetparent.htm" >getOffsetParent</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">getOffsetParent(element) -> HTMLElement</code></pre>
					<p>
						返回 <code>element</code> 的容器块（Containing Block）（<strong>译注：</strong>距离元素最近的 CSS
						<code>position</code> 属性为 <code>relative</code> 或 <code>absolute</code>
						的先代节点）节点，如果不存在这样一个节点，则返回 <code>body</code> 元素。
					</p>
				</div>
			</div>
			<div id="method-getstyle" class="mexcerpt">
				<h4><a href="element/getStyle.htm" >getStyle</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">getStyle(element, property) -> String | null</code></pre>
					<p>
						返回 <code>element</code> 的指定 CSS 属性值。<code>property</code> 可以用标准的 CSS 名称指定，也可以使用
						camelized 命名方式指定（<strong>译注：</strong>例如 CSS 属性 border-width 可以用 border-width 指代，也可用 borderWidth 指代）。
					</p>
					<p><strong>译注：</strong>其实该方法等同于 DOM 中 <code>element.style.xxx</code> 系列属性。</p>
				</div>
			</div>
			<div id="method-getwidth" class="mexcerpt">
				<h4><a href="element/getWidth.htm" >getWidth</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">getWidth(element) -> Number</code></pre>
					<p>获取 <code>element</code> 的宽度。</p>
				</div>
			</div>
			<div id="method-hasclassname" class="mexcerpt">
				<h4>
					<a href="element/hasClassName.htm" >hasClassName</a>
				</h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">hasClassName(element, className) -> Boolean</code></pre>
					<p>判断 <code>element</code> 是否包含参数 <code>className</code> 指定的 CSS 类名称。</p>
				</div>
			</div>
			<div id="method-hide" class="mexcerpt">
				<h4><a href="element/hide.htm" >hide</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">hide(element) -> HTMLElement</code></pre>
					<p>将 <code>element</code> 隐藏，并返回该元素。</p>
				</div>
			</div>
			<div id="method-identify" class="mexcerpt">
				<h4><a href="element/identify.htm" >identify</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">identify(element) -> id</code></pre>
					<p>
						如果 <code>element</code> 存在 <code>id</code> 属性，则返回 <code>id</code> 属性值，否则自动为元素生成一个唯一的
						<code>id</code>，并返回该 <code>id</code> 值。
					</p>
				</div>
			</div>
			<div id="method-immediatedescendants" class="mexcerpt">
				<h4><a href="element/immediateDescendants.htm" >immediateDescendants</a><div class="box">不推荐</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">immediateDescendants(element) -> [HTMLElement...]</code></pre>
					<p>
						获取元素的直接后代（即子元素），返回一个数组，数组中的元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-insert" class="mexcerpt">
				<h4><a href="element/insert.htm" >insert</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">insert(element, { position: content }) -> HTMLElement
insert(element, content) -> HTMLElement</code></pre>
					<p>
						根据第二个参数 <code>position</code> 属性指定的位置，插入 <code>content</code> 到元素的前面、后面、顶部或底部。
						如果第二个参数仅包括 <code>content</code>，则将 <code>content</code> 追加到 <code>element</code> 中。<br />	
						<strong>译注：</strong><code>position</code> 取值为：<code>before</code>、<code>after</code>、<code>top</code>
						或 <code>bottom</code>。
					</p>
				</div>
			</div>
			<div id="method-inspect" class="mexcerpt">
				<h4><a href="element/inspect.htm" >inspect</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">inspect(element) -> String</code></pre>
					<p>返回 <code>element</code> 的字符描述形式，该方法主要用于调试。</p>
				</div>
			</div>
			<div id="method-makeclipping" class="mexcerpt">
				<h4><a href="element/makeClipping.htm" >makeClipping</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">makeClipping(element) -> HTMLElement</code></pre>
					<p>
						通过将超出元素边界的内容设置为 <code>'hidden'</code>，来虚拟仅有少数浏览器支持的 CSS <code>clip</code> 属性。返回
						<code>element</code>。
					</p>
				</div>
			</div>
			<div id="method-makepositioned" class="mexcerpt">
				<h4><a href="element/makePositioned.htm" >makePositioned</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">makePositioned(element) -> HTMLElement</code></pre>
					<p>
						该方法使你能够方便的创建 CSS 容器块（block），如果 <code>element</code> 的 CSS position 属性初始值为 <code>'static'</code>
						或 <code>undefined</code>，它将设置 position 属性为 <code>'relative'</code>。该方法返回元素本身。
					</p>
				</div>
			</div>
			<div id="method-match" class="mexcerpt">
				<h4><a href="element/match.htm" >match</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">match(element, selector) -> Boolean</code></pre>
					<p>判断 <code>element</code> 是否匹配参数 <code>selector</code> 指定的 CSS 选择器。</p>
				</div>
			</div>
			<div id="method-next" class="mexcerpt">
				<h4><a href="element/next.htm" >next</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">next(element[, cssRule][, index = 0]) -> HTMLElement | undefined</code></pre>
					<p>
						返回匹配 <code>cssRule</code> 指定规则的 <code>element</code> 的下一个兄弟节点（如果指定 <code>index</code>
						参数，则返回第 <em>index</em> 个）。如果未指定 <code>cssRule</code> 参数，则默认匹配所有后继兄弟节点。
						如果没有符合条件的节点，返回 <code>undefined</code>。
					</p>
				</div>
			</div>
			<div id="method-nextsiblings" class="mexcerpt">
				<h4><a href="element/nextSiblings.htm" >nextSiblings</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">nextSiblings(element) -> [HTMLElement...]</code></pre>
					<p>
						返回 <code>element</code> 的所有后继兄弟节点，结果为一个数组，数组元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-observe" class="mexcerpt">
				<h4><a href="element/observe.htm" >observe</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">observe(element, eventName, handler[, useCapture = false]) -> HTMLElement</code></pre>
					<p>为 <code>element</code> 注册一个事件处理程序，返回元素本身。</p>
				</div>
			</div>
			<div id="method-positionedoffset" class="mexcerpt">
				<h4><a href="element/positionedoffset.htm" >positionedOffset</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">positionedOffset(element) -> [Number, Number] 或 { left: Number, top: Number }</code></pre>
					<p>
						以 <code>element</code> 的容器块（Containing Block）节点（<strong>译注：</strong>距离元素最近的 CSS <code>position</code>
						属性为 <code>relative</code> 或 <code>absolute</code> 的先代节点）为坐标原点，返回 <code>element</code> 
						的坐标偏移值（元素的容器块节点可通过 <a href="element/getoffsetparent.htm" >Element#getOffsetParent</a> 方法获取）。<br />
						<strong>译注：</strong>假定返回值为 offset，则 X 轴坐标可通过 <code>offset[0]</code> 获取，也可以通过
						<code>offset.left</code> 获取，Y 轴坐标可通过 <code>offset[1]</code> 获取，也可通过 <code>offset.top</code> 获取。				
					</p>
				</div>
			</div>
			<div id="method-previous" class="mexcerpt">
				<h4><a href="element/previous.htm" >previous</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">previous(element[, cssRule][, index = 0]) -> HTMLElement | undefined</code></pre>
					<p>
						返回匹配 <code>cssRule</code> 指定规则的 <code>element</code> 的前一个兄弟节点（如果指定 <code>index</code>
						参数，则返回第 <code>index</code> 个）。如果未指定 <code>cssRule</code> 参数，则默认匹配所有前导兄弟节点。
						如果没有符合条件的节点，返回 <code>undefined</code>。						
					</p>
				</div>
			</div>
			<div id="method-previoussiblings" class="mexcerpt">
				<h4><a href="element/previousSiblings.htm" >previousSiblings</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">previousSiblings(element) -> [HTMLElement...]</code></pre>
					<p>返回 <code>element</code> 的所有前导兄弟节点，结果为一个数组，数组元素已经过 <a href="element/extend.htm" >扩展</a>。</p>
				</div>
			</div>
			<div id="method-readattribute" class="mexcerpt">
				<h4><a href="element/readAttribute.htm" >readAttribute</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">readAttribute(element, attribute) -> String | null</code></pre>
					<p>
						返回 <code>elemnet</code> 由参数 <code>attribute</code> 指定的属性值，若不存在指定的属性值，返回 <code>null</code>。
					</p>
				</div>
			</div>
			<div id="method-recursivelycollect" class="mexcerpt">
				<h4><a href="element/recursivelyCollect.htm" >recursivelyCollect</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">recursivelyCollect(element, property) -> [HTMLElement...]</code></pre>
					<p>
						通过递归获取和 <code>element</code> 相关的元素集合，元素的相关性由 <code>property</code> 参数指定，<code>property</code>
						必须是 <code>element</code> 的一个<em>属性</em>（不能为方法！），指向<em>单个</em> DOM 节点。该方法返回一个数组，数组元素已经过
						<a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-relativize" class="mexcerpt">
				<h4><a href="element/relativize.htm" >relativize</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">relativize(element) -> HTMLElement</code></pre>
					<p>
						转换元素的定位方式为相对定位，并且不改变元素在页面中的位置。<br />
						<strong>译注：</strong>该方法使用代码 <code>element.style.position = 'relative'</code> 改变定位方式。在改变定位方式后，
						元素左上角的坐标仍会保持原来的位置，如果元素未设置初始的 <code>width</code> 和 <code>height</code> 属性，则调用该方法后，
						元素的宽度和高度会改变为系统预设值。<br />
						<strong>注意：在 1.6.0.3 版本中，该方法会引发异常，需要在第 2066 行后插入代码：</strong>
						<pre><code>element._originalWidth  = element.style.width;
element._originalHeight = element.style.height;</code></pre>
						<strong>其它版本未知。</strong>
					</p>
				</div>
			</div>
			<div id="method-remove" class="mexcerpt">
				<h4><a href="element/remove.htm" >remove</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">remove(element) -> HTMLElement</code></pre>
					<p>从文档中彻底移除 <code>element</code>，返回移除的元素。</p>
				</div>
			</div>
			<div id="method-removeclassname" class="mexcerpt">
				<h4><a href="element/removeClassName.htm" >removeClassName</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">removeClassName(element, className) -> HTMLElement</code></pre>
					<p>从 <code>element</code> 中移除参数 <code>className</code> 指定的 CSS 类，返回元素本身。</p>
				</div>
			</div>
			<div id="method-replace" class="mexcerpt">
				<h4><a href="element/replace.htm" >replace</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">replace(element[, html]) -> HTMLElement</code></pre>
					<p>
						使用 <code>html</code> 参数指定的内容替换 <code>element</code>，返回被替换的 <code>element</code>。<br />
						<strong>译注：</strong>该方法类似于 IE 下的 <code>element.outerHTML = html</code>。
					</p>
				</div>
			</div>
			<div id="method-scrollto" class="mexcerpt">
				<h4><a href="element/scrollto.htm" >scrollTo</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">scrollTo(element) -> HTMLElement</code></pre>
					<p>滚动窗口以便 <code>elemnet</code> 显示在窗口可视区域的顶部，返回元素本身。</p>
				</div>
			</div>
			<div id="method-select" class="mexcerpt">
				<h4><a href="element/select.htm" >select</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">select(element, selector...) -> [HTMLElement...]</code></pre>
					<p>
						根据一个或多个指定的 CSS 选择器（字符串），在 <code>element</code> 中查找匹配其中任何一个选择器的后代节点，
						返回数组，数组元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-setopacity" class="mexcerpt">
				<h4><a href="element/setOpacity.htm" >setOpacity</a><div class="box">1.5.1</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">Element.setOpacity(element, opacity) -> [HTMLElement...]
someElement.setOpacity(opacity) -> [HTMLElement...]</code></pre>
					<p>
						设置 <code>element</code> 的透明度，该方法可在多种浏览器中正常工作。参数 <code>opacity</code> 是一个介于 0 和 1
						之间的浮点数，0	表示完全透明，1 表示完全不透明。
					</p>
				</div>
			</div>
			<div id="method-setstyle" class="mexcerpt">
				<h4><a href="element/setStyle.htm" >setStyle</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">setStyle(element, styles) -> HTMLElement</code></pre>
					<p>
						修改 <code>element</code> 的 CSS 样式属性。参数 <code>styles</code> 是一个包含属性名/值对的 Hash 对象，
						属性名必须使用 camelized 命名方式指定（<strong>译注：</strong>例如 CSS 属性 border-width 应写成
						borderWidth，而不能写成 border-width）。
					</p>
				</div>
			</div>
			<div id="method-show" class="mexcerpt">
				<h4><a href="element/show.htm" >show</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">show(element) -> HTMLElement</code></pre>
					<p>显示 <code>element</code>，并返回元素本身。</p>
				</div>
			</div>
			<div id="method-siblings" class="mexcerpt">
				<h4><a href="element/siblings.htm" >siblings</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">siblings(element) -> [HTMLElement...]</code></pre>
					<p>
						获取 <code>element</code> 的所有兄弟节点，并返回一个数组，数组元素已经过 <a href="element/extend.htm" >扩展</a>。
					</p>
				</div>
			</div>
			<div id="method-stopobserving" class="mexcerpt">
				<h4><a href="element/stopobserving.htm" >stopObserving</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">stopObserving(element, eventName, handler) -> HTMLElement</code></pre>
					<p>为 <code>element</code> 注销指定的事件处理程序。</p>
				</div>
			</div>
			<div id="method-toggle" class="mexcerpt">
				<h4><a href="element/toggle.htm" >toggle</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">toggle(element) -> HTMLElement</code></pre>
					<p>切换 <code>element</code> 的可视性（在隐藏和显示间进行切换）。</p>
				</div>
			</div>
			<div id="method-toggleclassname" class="mexcerpt">
				<h4><a href="element/toggleClassName.htm" >toggleClassName</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">toggleClassName(element, className) -> HTMLElement</code></pre>
					<p>切换 <code>element</code> 的 CSS <code>className</code>（在有和无该类名称间切换），并返回元素本身。</p>
				</div>
			</div>
			<div id="method-undoclipping" class="mexcerpt">
				<h4><a href="element/undoClipping.htm" >undoClipping</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">undoClipping(element) -> HTMLElement</code></pre>
					<p>
						设置 <code>element</code> 的 CSS <code>overflow</code> 属性，重置其值为应用 <a href="element/makeClipping.htm" >Element.makeClipping()</a>
						之前的值，返回元素本身。
					</p>
				</div>
			</div>
			<div id="method-undopositioned" class="mexcerpt">
				<h4><a href="element/undoPositioned.htm" >undoPositioned</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">undoPositioned(element) -> HTMLElement</code></pre>
					<p>
						设置 <code>element</code> 返回到在元素上应用 <a href="element/makePositioned.htm" >Element.makePositioned</a>
						方法之前的状态，返回元素本身。
					</p>
				</div>
			</div>
			<div id="method-up" class="mexcerpt">
				<h4><a href="element/up.htm" >up</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">up(element, [cssRule][, index = 0]) -> HTMLElement | undefined</code></pre>
					<p>
						返回 <code>element</code> 的与 <code>cssRule</code> 相匹配的第一个先代节点（如果指定 <code>index</code> 参数，则返回第
						<em>index</em> 个）。如果未指定	<code>cssRule</code>，则默认匹配所有先代节点。如果没有符合条件的先代节点，返回
						<code>undefined</code>。
					</p>
				</div>
			</div>
			<div id="method-update" class="mexcerpt">
				<h4><a href="element/update.htm" >update</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">update(element[, newContent]) -> HTMLElement</code></pre>
					<p>
						替换 <code>element</code> 的内容为参数 <code>newContent</code> 指定的内容，返回元素本身。<br />
						<strong>译注：</strong>该方法类似于 <code>element.innerHTML = newContent</code>。
					</p>
				</div>
			</div>
			<div id="method-viewportoffset" class="mexcerpt">
				<h4><a href="element/viewportoffset.htm" >viewportOffset</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">viewportOffset(element) -> [Number, Number] 或 { left: Number, top: Number }</code></pre>
					<p>
						返回 <code>element</code> 相对于浏览器可视区域左上角的坐标值。（<strong>译注：</strong>坐标原点以浏览器当前可见的部分为基准，
						意即当滚动条滚动后，坐标原点也随之改变，坐标原点在当前窗口中永远可见。）<br />
						<strong>译注：</strong>假定返回值为 offset，则 X 轴坐标可通过 <code>offset[0]</code> 获取，也可以通过
						<code>offset.left</code> 获取，Y 轴坐标可通过 <code>offset[1]</code> 获取，也可通过 <code>offset.top</code> 获取。
					</p>
				</div>
			</div>
			<div id="method-visible" class="mexcerpt">
				<h4><a href="element/visible.htm" >visible</a></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">visible(element) -> Boolean</code></pre>
					<p>
						返回 <code>Boolean</code> 值，指示 <code>element</code> 是否可见（即判断元素内联的 <code>style</code> 属性是否设置为
						<code>"display:none;"</code>）。
					</p>
				</div>
			</div>
			<div id="method-wrap" class="mexcerpt">
				<h4><a href="element/wrap.htm" >wrap</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">Element.wrap(element, wrapper[, attributes]) -> HTMLElement
someElement.wrap(wrapper[, attributes]) -> HTMLElement</code></pre>
					<p>将 <code>element</code> 表示的元素放入到参数 <code>wrapper</code> 指定的元素内部，返回 <code>wrapper</code>。</p>
				</div>
			</div>
			<div id="method-writeattribute" class="mexcerpt">
				<h4><a href="element/writeAttribute.htm" >writeAttribute</a><div class="box">1.6</div></h4>
				<div class="mexcerpt-cnt">
					<pre><code class="ebnf">writeAttribute(element, attribute[, value = true]) -> HTMLElement
writeAttribute(element, attributes) -> HTMLElement</code></pre>
					<p>新增、修改或移除指定的 <code>element</code> 属性。属性参数可以是一个 hash 对象，也可以是一个名/值对。</p>
				</div>
			</div>
		</div>
	</div>
	<!-- /main -->
</body>
</html>
