<html><HEAD><TITLE>Programming Ruby: The Pragmatic Programmer's Guide</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK media=screen href="122_files/pr_style[1].css"  type=text/css rel=StyleSheet></head>
<BODY bgColor=white>
<TABLE cellSpacing=0 cellPadding=3 width="100%" bgColor=#c09090 border=0>
<TBODY>
<TR>
<TD colSpan=3>
<TABLE cellPadding=20 width="100%" bgColor=#701a1a>
<TBODY>
<TR>
<TD width=6>
<H1 class=header>Programming Ruby</H1>
<H3 class=subheader>The Pragmatic Programmer's Guide</H3></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD align=left width="33%"><A class=subheader href="121.html" >Previous &lt;</A> </TD>
<TD vAlign=center align=middle width="33%"><A class=subheader href="95.html" >Contents ^</A> <BR></TD>
<TD align=right width="33%"><A class=subheader href="123.html" >Next &gt;</A> <BR></TD></TR></TBODY></TABLE><!--
Copyright (c) 2001 by Addison Wesley Longman, Inc. This material may
be distributed only subject to the terms and conditions set forth in
the Open Publication License, v1.0 or later (the latest version is
presently available at http://www.opencontent.org/openpub/).
<P></P>
Distribution of substantively modified versions of this document is
prohibited without the explicit permission of the copyright holder.
<P></P>
Distribution of the work or derivative of the work in any standard
(paper) book form is prohibited unless prior permission is obtained
from the copyright holder.
-->
<H1>Network and Web Libraries</H1>
<HR>
<BR>
<P></P>Ruby provides two levels of access to network services. At a low level, you can access the basic socket support in the underlying operating system, which allows you to implement clients and servers for both connection-oriented and connectionless protocols. These are documented in the next section. 
<P></P>Ruby also has libraries that provide higher-level access to specific application-level network protocols, such as FTP, HTTP, and so on. These are documented starting on page 482. 
<P></P>Finally, the <CODE>CGI</CODE> libraries, documented beginning on page 497, provide server-side developers with a convenient interface for developing Web applications. 
<H2><A name=S1>Socket-Level Access</A></H2>
<P></P>Sockets are the endpoints of a bidirectional communications channel. Sockets may communicate within a process, between processes on the same machine, or between processes on different continents. Sockets may be implemented over a number of different channel types: Unix domain sockets, TCP, UDP, and so on. The socket library provides specific classes for handling the common transports as well as a generic interface for handling the rest. All functionality in the socket library is accessible through a single extension library. Access it using 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'socket'
</PRE></TD></TR></TBODY></TABLE>
<P></P>Sockets have their own vocabulary: 
<P></P>
<DL>
<DT>domain 
<DD>The family of protocols that will be used as the transport mechanism. These values are constants such as <CODE>PF_INET</CODE>, <CODE>PF_UNIX</CODE>, <CODE>PF_X25</CODE>, and so on. 
<DT>type 
<DD>The type of communications between the two endpoints, typically <CODE>SOCK_STREAM</CODE> for connection-oriented protocols and <CODE>SOCK_DGRAM</CODE> for connectionless protocols. 
<DT>protocol 
<DD>Typically zero, this may be used to identify a variant of a protocol within a domain and type. 
<DT>hostName 
<DD>The identifier of a network interface: 
<UL>
<LI>a string, which can be a host name, a dotted-quad address, or an IPV6 address in colon (and possibly dot) notation, 
<LI>the string ``&lt;broadcast&gt;'', which specifies an <CODE>INADDR_BROADCAST</CODE> address, 
<LI>a zero-length string, which specifies <CODE>INADDR_ANY</CODE>, or 
<LI>an <CODE>Integer</CODE>, interpreted as a binary address in host byte order. </LI></UL>
<DT>port 
<DD>(sometimes called <B>service</B>) Each server listens for clients calling on one or more ports. A port may be a <CODE>Fixnum</CODE> port number, a string containing a port number, or the name of a service. </DD></DL>
<P></P>Sockets are children of class <CODE>IO</CODE>. Once a socket has been successfully opened, the conventional I/O methods may be used. However, greater efficiency is sometimes obtained by using socket-specific methods. As with other I/O classes, socket I/O blocks by default. The hierarchy of the socket classes is shown in Figure 26.1 on page 471. 
<P></P>For more information on the use of sockets, see your operating system documentation. You'll also find a comprehensive treatment in W. Richard Stevens, <EM>Unix Network Programming, Volumes 1 and 2</EM>&nbsp;. 
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class BasicSocket</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>IO</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#BasicSocket.do_not_reverse_lookup">do_not_reverse_lookup</A> <A href="122.html#BasicSocket.do_not_reverse_lookup_eq">do_not_reverse_lookup=</A> <A href="122.html#BasicSocket.lookup_order">lookup_order</A> <A href="122.html#BasicSocket.lookup_order_eq">lookup_order=</A> <I><A href="122.html#BasicSocket.close_read">close_read</A> </I><I><A href="122.html#BasicSocket.close_write">close_write</A> </I><I><A href="122.html#BasicSocket.getpeername">getpeername</A> </I><I><A href="122.html#BasicSocket.getsockname">getsockname</A> </I><I><A href="122.html#BasicSocket.getsockopt">getsockopt</A> </I><I><A href="122.html#BasicSocket.recv">recv</A> </I><I><A href="122.html#BasicSocket.send">send</A> </I><I><A href="122.html#BasicSocket.setsockopt">setsockopt</A> </I><I><A href="122.html#BasicSocket.shutdown">shutdown</A> </I>
<P></P>
<HR>
<CODE>BasicSocket</CODE> is an abstract base class for all other socket classes. 
<P></P>This class and its subclasses often manipulate addresses using something called a <CODE>struct sockaddr</CODE>, which is effectively an opaque binary string.<EM>[In reality, it maps onto the underlying C-language <CODE>struct sockaddr</CODE> set of structures, documented in the man pages and in the books by Stevens.]</EM> 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.do_not_reverse_lookup>do_not_reverse_lookup</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>BasicSocket.do_not_reverse_lookup -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the value of the global reverse lookup flag. If set to <CODE>true</CODE>, queries on remote addresses will return the numeric address but not the host name. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.do_not_reverse_lookup_eq>do_not_reverse_lookup=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>BasicSocket.do_not_reverse_lookup = <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets the global reverse lookup flag. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.lookup_order>lookup_order</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>BasicSocket.lookup_order -&gt; <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the global address lookup order, one of: 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 border=0>
<TBODY>
<TR bgColor=#ff9999>
<TD vAlign=top><B>Order</B> </TD>
<TD vAlign=top><B>Families Searched</B> </TD></TR>
<TR>
<TD vAlign=top><CODE>LOOKUP_UNSP</CODE> </TD>
<TD vAlign=top><CODE>AF_UNSPEC</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>LOOKUP_INET</CODE> </TD>
<TD vAlign=top><CODE>AF_INET</CODE>, <CODE>AF_INET6</CODE>, <CODE>AF_UNSPEC</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>LOOKUP_INET6</CODE> </TD>
<TD vAlign=top><CODE>AF_INET6</CODE>, <CODE>AF_INET</CODE>, <CODE>AF_UNSPEC</CODE> </TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=2><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.lookup_order_eq>lookup_order=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>BasicSocket.lookup_order = <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets the global address lookup order. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.close_read>close_read</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.close_read -&gt; <CODE>nil</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Closes the readable connection on this socket. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.close_write>close_write</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.close_write -&gt; <CODE>nil</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Closes the writable connection on this socket. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.getpeername>getpeername</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.getpeername -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the <CODE>struct sockaddr</CODE> structure associated with the other end of this socket connection. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.getsockname>getsockname</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.getsockname -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the <CODE>struct sockaddr</CODE> structure associated with <I>aSession</I>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.getsockopt>getsockopt</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.getsockopt( <I>level</I>, <I>optname</I> ) -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the value of the specified option. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.recv>recv</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.recv( <I>len</I>, <I>[</I>, <I>flags</I> <I>]</I> ) -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Receives up to <I>len</I> bytes from <I>aSession</I>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.send>send</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.send( <I>aString</I>, <I>flags</I>, <I>[</I>, <I>to</I> <I>]</I> ) -&gt; <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sends <I>aString</I> over <I>aSession</I>. If specified, <I>to</I> is a <CODE>struct sockaddr</CODE> specifying the recipient address. <I>flags</I> are the sum or one or more of the <CODE>MSG_</CODE> options (listed on page 478). Returns the number of characters sent. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.setsockopt>setsockopt</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.setsockopt( <I>level</I>, <I>optname</I>, <I>optval</I> ) -&gt; 0 </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets a socket option. <I>level</I> is one of the socket-level options (listed on page 478). <I>optname</I> and <I>optval</I> are protocol specific---see your system documentation for details. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=BasicSocket.shutdown>shutdown</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.shutdown( <I>how</I>=2 ) -&gt; 0 </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Shuts down the receive (<I>how</I> == 0), or send (<I>how</I> == 1), or both (<I>how</I> == 2), parts of this socket. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class IPSocket</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>BasicSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#IPSocket.getaddress">getaddress</A> <I><A href="122.html#IPSocket.addr">addr</A> </I><I><A href="122.html#IPSocket.peeraddr">peeraddr</A> </I>
<P></P>
<HR>
Class <CODE>IPSocket</CODE> is a base class for sockets using IP as their transport. <CODE>TCPSocket</CODE> and <CODE>UDPSocket</CODE> are based on this class. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=IPSocket.getaddress>getaddress</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>IPSocket.getaddress( <I>hostName</I> ) -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the dotted-quad IP address of <I>hostName</I>. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>a&nbsp;=&nbsp;IPSocket.getaddress('www.ruby-lang.org')</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>a</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>"210.251.121.214"</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=IPSocket.addr>addr</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.addr -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the domain, port, name, and IP address of <I>aSession</I> as a four-element array. The name will be returned as an address if the <CODE>do_not_reverse_lookup</CODE> flag is <CODE>true</CODE>. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>u&nbsp;=&nbsp;UDPSocket.new</CODE> </TD></TR>
<TR>
<TD vAlign=top colSpan=3><CODE>u.bind('localhost',&nbsp;8765)</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>u.addr</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>["AF_INET",&nbsp;8765,&nbsp;"localhost",&nbsp;"127.0.0.1"]</CODE> </TD></TR>
<TR>
<TD vAlign=top colSpan=3><CODE>BasicSocket.do_not_reverse_lookup&nbsp;=&nbsp;true</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>u.addr</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>["AF_INET",&nbsp;8765,&nbsp;"127.0.0.1",&nbsp;"127.0.0.1"]</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=IPSocket.peeraddr>peeraddr</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.peeraddr -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the domain, port, name, and IP address of the peer. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class TCPSocket</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>IPSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#TCPSocket.gethostbyname">gethostbyname</A> <A href="122.html#TCPSocket.new">new</A> <A href="122.html#TCPSocket.open">open</A> <I><A href="122.html#TCPSocket.recvfrom">recvfrom</A> </I>
<P></P>
<HR>

<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>t&nbsp;=&nbsp;TCPSocket.new('localhost',&nbsp;'ftp')</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>t.gets</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>"220&nbsp;zip.local.thomases.com&nbsp;FTP&nbsp;server&nbsp;(Version&nbsp;6.5/OpenBSD,&nbsp;linux&nbsp;port&nbsp;0.3.2)&nbsp;ready.\r\n"</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>t.close</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>nil</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=TCPSocket.gethostbyname>gethostbyname</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>TCPSocket.gethostbyname( <I>hostName</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Looks up <I>hostName</I> and returns its canonical name, an array containing any aliases, the address type (<CODE>AF_INET</CODE>), and the dotted-quad IP address. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>a&nbsp;=&nbsp;TCPSocket.gethostbyname('ns.pragprog.com')</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>a</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>["pragprog.com",&nbsp;[],&nbsp;2,&nbsp;"216.87.136.211"]</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=TCPSocket.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>TCPSocket.new( <I>hostName</I>, <I>port</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Opens a TCP connection to <I>hostName</I> on the <I>port</I>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=TCPSocket.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>TCPSocket.open( <I>hostName</I>, <I>port</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>TCPSocket.new</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=TCPSocket.recvfrom>recvfrom</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.recvfrom( <I>len</I> <I>[</I>, <I>flags</I> <I>]</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Receives up to <I>len</I> bytes on the connection. <I>flags</I> is zero or more of the <CODE>MSG_</CODE> options (listed on page 478). Returns a two-element array. The first element is the received data, the second is an array containing information about the peer. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>t&nbsp;=&nbsp;TCPSocket.new('localhost',&nbsp;'ftp')
data&nbsp;=&nbsp;t.recvfrom(30)
data
</PRE></TD></TR></TBODY></TABLE>
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class SOCKSSocket</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>TCPSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#SOCKSSocket.new">new</A> <A href="122.html#SOCKSSocket.open">open</A> <I><A href="122.html#SOCKSSocket.close">close</A> </I>
<P></P>
<HR>

<P></P>Class <CODE>SOCKSSocket</CODE> supports connections based on the SOCKS protocol. 
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=SOCKSSocket.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>SOCKSSocket.new( <I>hostName</I>, <I>port</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Opens a SOCKS connection to <I>port</I> on <I>hostName</I>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=SOCKSSocket.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>SOCKSSocket.open( <I>hostName</I>, <I>port</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>SOCKSSocket.new</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=SOCKSSocket.close>close</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.close -&gt; <CODE>nil</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Closes this SOCKS connection. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class TCPServer</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>TCPSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#TCPServer.new">new</A> <A href="122.html#TCPServer.open">open</A> <I><A href="122.html#TCPServer.accept">accept</A> </I>
<P></P>
<HR>
A <CODE>TCPServer</CODE> accepts incoming TCP connections. Here is a Web server that listens on a given port and returns the time. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'socket'
port&nbsp;=&nbsp;(ARGV[0]&nbsp;||&nbsp;80).to_i
server&nbsp;=&nbsp;TCPServer.new('localhost',&nbsp;port)
while&nbsp;(session&nbsp;=&nbsp;server.accept)
&nbsp;&nbsp;puts&nbsp;"Request:&nbsp;#{session.gets}"
&nbsp;&nbsp;session.print&nbsp;"HTTP/1.1&nbsp;200/OK\r\nContent-type:&nbsp;text/html\r\n\r\n"
&nbsp;&nbsp;session.print&nbsp;"&lt;html&gt;&lt;body&gt;&lt;h1&gt;#{Time.now}&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\r\n"
&nbsp;&nbsp;session.close
end
</PRE></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=TCPServer.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>TCPServer.new( <I>[</I> <I>hostName</I>,<I>]</I> <I>port</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>Creates a new socket on the given interface (identified by <I>hostName</I> and port). If <I>hostName</I> is omitted, the server will listen on all interfaces on the current host (equivalent to an address of 0.0.0.0). 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=TCPServer.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>TCPServer.open( <I>[</I> <I>hostName</I>,<I>]</I> <I>port</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>TCPServer.new</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=TCPServer.accept>accept</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.accept -&gt; <I>aTCPSocket</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Waits for a connection on <I>aSession</I>, and returns a new <CODE>TCPSocket</CODE> connected to the caller. See the example on page 474. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class UDPSocket</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>IPSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#UDPSocket.new">new</A> <A href="122.html#UDPSocket.open">open</A> <I><A href="122.html#UDPSocket.bind">bind</A> </I><I><A href="122.html#UDPSocket.connect">connect</A> </I><I><A href="122.html#UDPSocket.recvfrom">recvfrom</A> </I><I><A href="122.html#UDPSocket.send">send</A> </I>
<P></P>
<HR>

<P></P>UDP sockets send and receive datagrams. In order to receive data, a socket must be bound to a particular port. You have two choices when sending data: you can connect to a remote UDP socket and thereafter send datagrams to that port, or you can specify a host and port for use with every packet you send. This example is a UDP server that prints the message it receives. It is called by both connectionless and connection-based clients. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'socket'
<P></P>
$port&nbsp;=&nbsp;4321
<P></P>
sThread&nbsp;=&nbsp;Thread.start&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;run&nbsp;server&nbsp;in&nbsp;a&nbsp;thread
&nbsp;&nbsp;server&nbsp;=&nbsp;UDPSocket.open
&nbsp;&nbsp;server.bind(nil,&nbsp;$port)
&nbsp;&nbsp;2.times&nbsp;{&nbsp;p&nbsp;server.recvfrom(64)&nbsp;}
end
<P></P>
#&nbsp;Ad-hoc&nbsp;client
UDPSocket.open.send("ad&nbsp;hoc",&nbsp;0,&nbsp;'localhost',&nbsp;$port)
<P></P>
#&nbsp;Connection&nbsp;based&nbsp;client
sock&nbsp;=&nbsp;UDPSocket.open
sock.connect('localhost',&nbsp;$port)
sock.send("connection-based",&nbsp;0)
sThread.join
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>["ad&nbsp;hoc",&nbsp;["AF_INET",&nbsp;33224,&nbsp;"localhost",&nbsp;"127.0.0.1"]]
["connection-based",&nbsp;["AF_INET",&nbsp;33225,&nbsp;"localhost",&nbsp;"127.0.0.1"]]
</PRE></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UDPSocket.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>UDPSocket.new( <I>family</I> = <CODE>AF_INET</CODE> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Creates an endpoint for UDP communications, optionally specifying the address family. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UDPSocket.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>UDPSocket.open( <I>family</I> = <CODE>AF_INET</CODE> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>UDPSocket.new</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UDPSocket.bind>bind</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.bind( <I>hostName</I>, <I>port</I> ) -&gt; 0 </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Associates the local end of the UDP connection with a given <I>hostName</I> and <I>port</I>. Must be used by servers to establish an accessible endpoint. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UDPSocket.connect>connect</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.connect( <I>hostName</I>, <I>port</I> ) -&gt; 0 </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Creates a connection to the given <I>hostName</I> and <I>port</I>. Subsequent <CODE>UDPSocket#send</CODE> requests that don't override the recipient will use this connection. Multiple <CODE>connect</CODE> requests may be issued on <I>aSession</I>: the most recent will be used by <CODE>send</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UDPSocket.recvfrom>recvfrom</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.recvfrom( <I>len</I> <I>[</I>, <I>flags</I> <I>]</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Receives up to <I>len</I> bytes from <I>aSession</I>. <I>flags</I> is zero or more of the <CODE>MSG_</CODE> options (listed on page 478). The result is a two-element array containing the received data and information on the sender. See the example on page 475. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UDPSocket.send>send</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.send( <I>aString</I>, <I>flags</I> ) -&gt; <I>aFixnum</I> <BR><I>aSession</I>.send( <I>aString</I>, <I>flags</I>, <I>hostName</I>, <I>port</I> ) -&gt; <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>The two-parameter form sends <I>aString</I> on an existing connection. The four-parameter form sends <I>aString</I> to <I>port</I> on <I>hostName</I>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class UNIXSocket</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>BasicSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#UNIXSocket.new">new</A> <A href="122.html#UNIXSocket.open">open</A> <I><A href="122.html#UNIXSocket.addr">addr</A> </I><I><A href="122.html#UNIXSocket.path">path</A> </I><I><A href="122.html#UNIXSocket.peeraddr">peeraddr</A> </I><I><A href="122.html#UNIXSocket.recvfrom">recvfrom</A> </I>
<P></P>
<HR>
Class <CODE>UNIXSocket</CODE> supports interprocess communications using the Unix domain protocol. Although the underlying protocol supports both datagram and stream connections, the Ruby library provides only a stream-based connection. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'socket'
<P></P>
$path&nbsp;=&nbsp;"/tmp/sample"
<P></P>
sThread&nbsp;=&nbsp;Thread.start&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;run&nbsp;server&nbsp;in&nbsp;a&nbsp;thread
&nbsp;&nbsp;sock&nbsp;=&nbsp;UNIXServer.open($path)
&nbsp;&nbsp;s1&nbsp;=&nbsp;sock.accept
&nbsp;&nbsp;p&nbsp;s1.recvfrom(124)
end
<P></P>
client&nbsp;=&nbsp;UNIXSocket.open($path)
client.send("hello",&nbsp;0)
client.close
<P></P>
sThread.join
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>["hello",&nbsp;["AF_UNIX",&nbsp;""]]
</PRE></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXSocket.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>UNIXSocket.new( <I>path</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Opens a new domain socket on <I>path</I>, which must be a pathname. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXSocket.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>UNIXSocket.open( <I>path</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>UNIXSocket.new</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXSocket.addr>addr</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.addr -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the address family and path of this socket. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXSocket.path>path</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.path -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the path of this domain socket. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXSocket.peeraddr>peeraddr</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.peeraddr -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the address family and path of the server end of the connection. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXSocket.recvfrom>recvfrom</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.recvfrom( <I>len</I> <I>[</I>, <I>flags</I> <I>]</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Receives up to <I>len</I> bytes from <I>aSession</I>. <I>flags</I> is zero or more of the <CODE>MSG_</CODE> options (listed on page 478). The first element of the returned array is the received data, and the second contains (minimal) information on the sender. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class UNIXServer</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>UNIXSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#UNIXServer.new">new</A> <A href="122.html#UNIXServer.open">open</A> <I><A href="122.html#UNIXServer.accept">accept</A> </I>
<P></P>
<HR>

<P></P>Class <CODE>UNIXServer</CODE> provides a simple Unix domain socket server. See <CODE>UNIXSocket</CODE> for example code. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXServer.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>UNIXServer.new( <I>path</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Creates a server on the given <I>path</I>. The corresponding file must not exist at the time of the call. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXServer.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>UNIXServer.open( <I>path</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>UNIXServer.new</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=UNIXServer.accept>accept</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.accept -&gt; <I>aUnixSocket</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Waits for a connection on the server socket and returns a new socket object for that connection. See the example for <CODE>UNIXSocket</CODE> on page 476. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Socket</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>BasicSocket</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#Socket.for_fd">for_fd</A> <A href="122.html#Socket.getaddrinfo">getaddrinfo</A> <A href="122.html#Socket.gethostbyaddr">gethostbyaddr</A> <A href="122.html#Socket.gethostbyname">gethostbyname</A> <A href="122.html#Socket.gethostname">gethostname</A> <A href="122.html#Socket.getnameinfo">getnameinfo</A> <A href="122.html#Socket.getservbyname">getservbyname</A> <A href="122.html#Socket.new">new</A> <A href="122.html#Socket.open">open</A> <A href="122.html#Socket.pair">pair</A> <A href="122.html#Socket.socketpair">socketpair</A> <I><A href="122.html#Socket.accept">accept</A> </I><I><A href="122.html#Socket.bind">bind</A> </I><I><A href="122.html#Socket.connect">connect</A> </I><I><A href="122.html#Socket.listen">listen</A> </I><I><A href="122.html#Socket.recvfrom">recvfrom</A> </I>
<P></P>
<HR>

<P></P>Class <CODE>Socket</CODE> provides access to the underlying operating system socket implementation. It can be used to provide more operating system-specific functionality than the protocol-specific socket classes, but at the expense of greater complexity. In particular, the class handles addresses using <CODE>struct sockaddr</CODE> structures packed into Ruby strings, which can be a joy to manipulate. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=3><FONT color=white size=6>constants </FONT></TD></TR></TBODY></TABLE>
<P></P>Class <CODE>Socket</CODE> defines constants for use throughout the socket library. Individual constants are available only on architectures that support the related facility. 
<P></P>
<DL>
<DT>Types: 
<DD><BR><CODE>SOCK_DGRAM</CODE>, <CODE>SOCK_PACKET</CODE>, <CODE>SOCK_RAW</CODE>, <CODE>SOCK_RDM</CODE>, <CODE>SOCK_SEQPACKET</CODE>, <CODE>SOCK_STREAM</CODE>. 
<P></P>
<DT>Protocol families: 
<DD><BR><CODE>PF_APPLETALK</CODE>, <CODE>PF_AX25</CODE>, <CODE>PF_INET6</CODE>, <CODE>PF_INET</CODE>, <CODE>PF_IPX</CODE>, <CODE>PF_UNIX</CODE>, <CODE>PF_UNSPEC</CODE>. 
<P></P>
<DT>Address families: 
<DD><BR><CODE>AF_APPLETALK</CODE>, <CODE>AF_AX25</CODE>, <CODE>AF_INET6</CODE>, <CODE>AF_INET</CODE>, <CODE>AF_IPX</CODE>, <CODE>AF_UNIX</CODE>, <CODE>AF_UNSPEC</CODE>. 
<P></P>
<DT>Lookup-order options: 
<DD><BR><CODE>LOOKUP_INET6</CODE>, <CODE>LOOKUP_INET</CODE>, <CODE>LOOKUP_UNSPEC</CODE>. 
<P></P>
<DT>Send/receive options: 
<DD><BR><CODE>MSG_DONTROUTE</CODE>, <CODE>MSG_OOB</CODE>, <CODE>MSG_PEEK</CODE>. 
<P></P>
<DT>Socket-level options: 
<DD><BR><CODE>SOL_ATALK</CODE>, <CODE>SOL_AX25</CODE>, <CODE>SOL_IPX</CODE>, <CODE>SOL_IP</CODE>, <CODE>SOL_SOCKET</CODE>, <CODE>SOL_TCP</CODE>, <CODE>SOL_UDP</CODE>. 
<P></P>
<DT>Socket options: 
<DD><BR><CODE>SO_BROADCAST</CODE>, <CODE>SO_DEBUG</CODE>, <CODE>SO_DONTROUTE</CODE>, <CODE>SO_ERROR</CODE>, <CODE>SO_KEEPALIVE</CODE>, <CODE>SO_LINGER</CODE>, <CODE>SO_NO_CHECK</CODE>, <CODE>SO_OOBINLINE</CODE>, <CODE>SO_PRIORITY</CODE>, <CODE>SO_RCVBUF</CODE>, <CODE>SO_REUSEADDR</CODE>, <CODE>SO_SNDBUF</CODE>, <CODE>SO_TYPE</CODE>. 
<P></P>
<DT>QOS options: 
<DD><BR><CODE>SOPRI_BACKGROUND</CODE>, <CODE>SOPRI_INTERACTIVE</CODE>, <CODE>SOPRI_NORMAL</CODE>. 
<P></P>
<DT>Multicast options: 
<DD><BR><CODE>IP_ADD_MEMBERSHIP</CODE>, <CODE>IP_DEFAULT_MULTICAST_LOOP</CODE>, <CODE>IP_DEFAULT_MULTICAST_TTL</CODE>, <CODE>IP_MAX_MEMBERSHIPS</CODE>, <CODE>IP_MULTICAST_IF</CODE>, <CODE>IP_MULTICAST_LOOP</CODE>, <CODE>IP_MULTICAST_TTL</CODE>. 
<P></P>
<DT>TCP options: 
<DD><BR><CODE>TCP_MAXSEG</CODE>, <CODE>TCP_NODELAY</CODE>. 
<P></P>
<DT><CODE>getaddrinfo</CODE> error codes: 
<DD><BR><CODE>EAI_ADDRFAMILY</CODE>, <CODE>EAI_AGAIN</CODE>, <CODE>EAI_BADFLAGS</CODE>, <CODE>EAI_BADHINTS</CODE>, <CODE>EAI_FAIL</CODE>, <CODE>EAI_FAMILY</CODE>, <CODE>EAI_MAX</CODE>, <CODE>EAI_MEMORY</CODE>, <CODE>EAI_NODATA</CODE>, <CODE>EAI_NONAME</CODE>, <CODE>EAI_PROTOCOL</CODE>, <CODE>EAI_SERVICE</CODE>, <CODE>EAI_SOCKTYPE</CODE>, <CODE>EAI_SYSTEM</CODE>. 
<P></P>
<DT><CODE>ai_flags</CODE> values: 
<DD><BR><CODE>AI_ALL</CODE>, <CODE>AI_CANONNAME</CODE>, <CODE>AI_MASK</CODE>, <CODE>AI_NUMERICHOST</CODE>, <CODE>AI_PASSIVE</CODE>, <CODE>AI_V4MAPPED_CFG</CODE>. </DD></DL>
<P></P>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.for_fd>for_fd</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.for_fd( <I>anFD</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Wraps an already open file descriptor into a socket object. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.getaddrinfo>getaddrinfo</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.getaddrinfo( <I>hostName</I>, <I>port</I>,<BR><I>[</I> <I>family</I> <I>[</I> <I>socktype</I> <I>[</I> <I>protocol</I> <I>[</I> <I>flags</I> <I>]</I> <I>]</I> <I>]</I> <I>]</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns an array of arrays describing the given host and port (optionally qualified as shown). Each subarray contains the address family, port number, host name, host IP address, protocol family, socket type, and protocol. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>for&nbsp;line&nbsp;in&nbsp;Socket.getaddrinfo('www.microsoft.com',&nbsp;'http')
&nbsp;&nbsp;puts&nbsp;line.join(",&nbsp;")
end
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>AF_INET,&nbsp;80,&nbsp;microsoft.net,&nbsp;207.46.130.149,&nbsp;2,&nbsp;1,&nbsp;6
AF_INET,&nbsp;80,&nbsp;microsoft.net,&nbsp;207.46.131.137,&nbsp;2,&nbsp;1,&nbsp;6
AF_INET,&nbsp;80,&nbsp;microsoft.com,&nbsp;207.46.230.218,&nbsp;2,&nbsp;1,&nbsp;6
AF_INET,&nbsp;80,&nbsp;microsoft.com,&nbsp;207.46.230.219,&nbsp;2,&nbsp;1,&nbsp;6
AF_INET,&nbsp;80,&nbsp;microsoft.net,&nbsp;207.46.130.14,&nbsp;2,&nbsp;1,&nbsp;6
</PRE></TD></TR></TBODY></TABLE>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.gethostbyaddr>gethostbyaddr</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.gethostbyaddr( <I>addr</I>, <I>type</I>=<CODE>AF_INET</CODE> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>Returns the host name, address family, and <CODE>sockaddr</CODE> component for the given address. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>a&nbsp;=&nbsp;Socket.gethostbyname("216.87.136.211")</CODE> </TD></TR>
<TR>
<TD vAlign=top colSpan=3><CODE>res&nbsp;=&nbsp;Socket.gethostbyaddr(a[3],&nbsp;a[2])</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>res.join(',&nbsp;')</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>"pragprog.com,&nbsp;,&nbsp;2,&nbsp;\330W\210\323"</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.gethostbyname>gethostbyname</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.gethostbyname( <I>hostName</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a four-element array containing the canonical host name, a subarray of host aliases, the address family, and the address portion of the <CODE>sockaddr</CODE> structure. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>a&nbsp;=&nbsp;Socket.gethostbyname("216.87.136.211")</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>a.join(',&nbsp;')</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>"pragprog.com,&nbsp;,&nbsp;2,&nbsp;\330W\210\323"</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.gethostname>gethostname</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.gethostname -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the name of the current host. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.getnameinfo>getnameinfo</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.getnameinfo( <I>addr</I> <I>[</I>, <I>flags</I> <I>]</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Looks up the given address, which may be either a string containing a sockaddr or a three- or four-element array. If <I>sockaddr</I> is an array, it should contain the string address family, the port (or nil), and the host name or IP address. If a fourth element is present and not <CODE>nil</CODE>, it will be used as the host name. Returns a canonical hostname (or address) and port number as an array. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>a&nbsp;=&nbsp;Socket.getnameinfo(["AF_INET",&nbsp;'23',&nbsp;'www.ruby-lang.org'])</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>a</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>["helium.ruby-lang.org",&nbsp;"telnet"]</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.getservbyname>getservbyname</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.getservbyname( <I>service</I>, <I>proto</I>=<CODE>'tcp'</CODE> ) -&gt; <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the port corresponding to the given service and protocol. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top><CODE>Socket.getservbyname("telnet")</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>23</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.new( <I>domain</I>, <I>type</I>, <I>protocol</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Creates a socket using the given parameters. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.open( <I>domain</I>, <I>type</I>, <I>protocol</I> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>Socket.new</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.pair>pair</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.pair( <I>domain</I>, <I>type</I>, <I>protocol</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a pair of connected, anonymous sockets of the given domain, type, and protocol. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.socketpair>socketpair</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Socket.socketpair( <I>domain</I>, <I>type</I>, <I>protocol</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>Socket.pair</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.accept>accept</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.accept -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Accepts an incoming connection returning an array containing a new <CODE>Socket</CODE> object and a string holding the <CODE>struct sockaddr</CODE> information about the caller. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.bind>bind</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.bind( <I>sockaddr</I> ) -&gt; 0 </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Binds to the given <CODE>struct sockaddr</CODE>, contained in a string. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.connect>connect</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.connect( <I>sockaddr</I> ) -&gt; 0 </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Connects to the given <CODE>struct sockaddr</CODE>, contained in a string. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.listen>listen</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.listen( <I>aFixnum</I> ) -&gt; 0 </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Listens for connections, using the specified <I>aFixnum</I> as the backlog. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Socket.recvfrom>recvfrom</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.recvfrom( <I>len</I> <I>[</I>, <I>flags</I> <I>]</I> ) -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Receives up to <I>len</I> bytes from <I>aSession</I>. <I>flags</I> is zero or more of the <CODE>MSG_</CODE> options. The first element of the result is the data received. The second element contains protocol-specific information on the sender. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<H2><A name=S2>Higher-Level Access</A></H2>
<P></P>Ruby provides a set of classes to facilitate writing clients for: 
<UL>
<LI>File Transfer Protocol (FTP) 
<LI>HyperText Transfer Protocol (HTTP) 
<LI>Post Office Protocol (POP) 
<LI>Simple Mail Transfer Protocol (SMTP) 
<LI>Telnet </LI></UL>
<P></P>HTTP, POP, and SMTP are layered on top of a helper class, <CODE>lib/net/protocol</CODE>. Although we don't document the <CODE>Protocol</CODE> class here, you should probably study it if you are considering writing your own network client. 
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::FTP</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Object</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#Net::FTP.new">new</A> <A href="122.html#Net::FTP.open">open</A> <I><A href="122.html#Net::FTP.Servercommands">Server commands</A> </I><I><A href="122.html#Net::FTP.close">close</A> </I><I><A href="122.html#Net::FTP.closed_qm">closed?</A> </I><I><A href="122.html#Net::FTP.connect">connect</A> </I><I><A href="122.html#Net::FTP.debug_mode">debug_mode</A> </I><I><A href="122.html#Net::FTP.debug_mode_eq">debug_mode=</A> </I><I><A href="122.html#Net::FTP.dir">dir</A> </I><I><A href="122.html#Net::FTP.getbinaryfile">getbinaryfile</A> </I><I><A href="122.html#Net::FTP.gettextfile">gettextfile</A> </I><I><A href="122.html#Net::FTP.lastresp">lastresp</A> </I><I><A href="122.html#Net::FTP.list">list</A> </I><I><A href="122.html#Net::FTP.login">login</A> </I><I><A href="122.html#Net::FTP.ls">ls</A> </I><I><A href="122.html#Net::FTP.mtime">mtime</A> </I><I><A href="122.html#Net::FTP.passive">passive</A> </I><I><A href="122.html#Net::FTP.passive_eq">passive=</A> </I><I><A href="122.html#Net::FTP.putbinaryfile">putbinaryfile</A> </I><I><A href="122.html#Net::FTP.puttextfile">puttextfile</A> </I><I><A href="122.html#Net::FTP.resume">resume</A> </I><I><A href="122.html#Net::FTP.resume_eq">resume=</A> </I><I><A href="122.html#Net::FTP.retrbinary">retrbinary</A> </I><I><A href="122.html#Net::FTP.retrlines">retrlines</A> </I><I><A href="122.html#Net::FTP.return_code">return_code</A> </I><I><A href="122.html#Net::FTP.storbinary">storbinary</A> </I><I><A href="122.html#Net::FTP.storlines">storlines</A> </I><I><A href="122.html#Net::FTP.welcome">welcome</A> </I>
<P></P>
<HR>

<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'net/ftp'
<P></P>
ftp&nbsp;=&nbsp;Net::FTP.new('ftp.netlab.co.jp')
ftp.login
files&nbsp;=&nbsp;ftp.chdir('pub/lang/ruby/contrib')
files&nbsp;=&nbsp;ftp.list('n*')
ftp.getbinaryfile('nif.rb-0.91.gz',&nbsp;'nif.gz',&nbsp;1024)
ftp.close
</PRE></TD></TR></TBODY></TABLE>
<P></P>The <CODE>net/ftp</CODE> library implements a File Transfer Protocol (FTP) client. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=3><FONT color=white size=6>constants </FONT></TD></TR></TBODY></TABLE>
<TABLE cellPadding=5 border=2>
<TBODY>
<TR>
<TD vAlign=top>
<TR>
<TD><A name=Net::FTP.FTP_PORT><CODE>FTP_PORT</CODE> </A></TD>
<TD></TD>
<TD>Default port for FTP connections (21).</TD></TR></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>FTP.new( <I>host</I>=<CODE>nil</CODE>, <I>user</I>=<CODE>nil</CODE>, <I>passwd</I>=<CODE>nil</CODE>, <I>acct</I>=<CODE>nil</CODE>) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Creates and returns a new <CODE>FTP</CODE> object. If the host parameter is not <CODE>nil</CODE>, a connection is made to that host. Additionally, if the <I>user</I> parameter is not <CODE>nil</CODE>, the given user name, password, and (optionally) account are used to log in. See the description of <CODE>FTP#login</CODE> on page 484. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.open>open</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>FTP.open( <I>host</I>, <I>user</I>=<CODE>nil</CODE>, <I>passwd</I>=<CODE>nil</CODE>, <I>acct</I>=<CODE>nil</CODE>) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>A synonym for <CODE>FTP.new</CODE>, but with a mandatory <I>host</I> parameter. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.Servercommands>Server commands</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.acct( <I>account</I> )<BR><I>aSession</I>.chdir( <I>dir</I> )<BR><I>aSession</I>.delete( <I>remoteFile</I> )<BR><I>aSession</I>.mdtm( <I>remoteFile</I> ) -&gt; <I>aString</I> <BR><I>aSession</I>.mkdir( <I>dir</I> )<BR><I>aSession</I>.nlst( <I>dir</I>=<CODE>nil</CODE> ) -&gt; <I>anArray</I> <BR><I>aSession</I>.rename( <I>fromname</I>, <I>toname</I> )<BR><I>aSession</I>.rmdir( <I>dir</I> )<BR><I>aSession</I>.pwd -&gt; <I>aString</I> <BR><I>aSession</I>.size( <I>remoteFile</I> ) -&gt; <I>anInteger</I> <BR><I>aSession</I>.status -&gt; <I>aString</I> <BR><I>aSession</I>.system -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Issues the corresponding server command and returns the result. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.close>close</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.close </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Closes the current connection. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.closed_qm>closed?</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.closed? -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns <CODE>true</CODE> if the current connection is closed. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.connect>connect</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.connect( <I>host</I>, <I>port</I>=FTP_PORT ) </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Establishes an FTP connection to <I>host</I>, optionally overriding the default port. If the environment variable <CODE>SOCKS_SERVER</CODE> is set, sets up the connection through a SOCKS proxy. Raises an exception (typically <CODE>Errno::ECONNREFUSED</CODE>) if the connection cannot be established. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.debug_mode>debug_mode</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.debug_mode -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the current debug mode. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.debug_mode_eq>debug_mode=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.debug_mode = <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>If the debug mode is <CODE>true</CODE>, all traffic to and from the server is written to <CODE>$stdout</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.dir>dir</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.dir( <I>[</I>pattern<I>]<SUP>*</SUP> </I>) -&gt; <I>anArray</I> <BR><I>aSession</I>.dir( <I>[</I>pattern<I>]<SUP>*</SUP> </I>) {| line | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>FTP#list</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.getbinaryfile>getbinaryfile</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.getbinaryfile( <I>remotefile</I>, <I>localfile</I>, <I>blocksize</I>, <I>callback</I>=<CODE>nil</CODE>)<BR><I>aSession</I>.getbinaryfile( <I>remotefile</I>, <I>localfile</I>, <I>blocksize</I> ) {| data | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Retrieves <I>remotefile</I> in binary mode, storing the result in <I>localfile</I>. If <I>callback</I> or an associated block is supplied, calls it, passing in the retrieved data in <I>blocksize</I> chunks. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.gettextfile>gettextfile</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.gettextfile( <I>remotefile</I>, <I>localfile</I>, <I>callback</I>=<CODE>nil</CODE>)<BR><I>aSession</I>.gettextfile( <I>remotefile</I>, <I>localfile</I> ) {| data | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Retrieves <I>remotefile</I> in ASCII (text) mode, storing the result in <I>localfile</I>. If <I>callback</I> or an associated block is supplied, calls it, passing in the retrieved data one line at a time. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.lastresp>lastresp</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.lastresp -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the host's last response. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.list>list</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.list( <I>[</I>pattern<I>]<SUP>*</SUP> </I>) -&gt; <I>anArray</I> <BR><I>aSession</I>.list( <I>[</I>pattern<I>]<SUP>*</SUP> </I>) {| line | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Fetches a directory listing of files matching the given pattern(s). If a block is associated with the call, invokes it with each line of the result. Otherwise, returns the result as an array of strings. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.login>login</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.login( <I>user</I>="anonymous", <I>passwd</I>=<CODE>nil</CODE>, <I>acct</I>=<CODE>nil</CODE> ) -&gt; aString </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Logs into the remote host. <I>aSession</I> must have been previously connected. If <I>user</I> is the string ``anonymous'' and the password is <CODE>nil</CODE>, a password of <EM>user@host</EM> is synthesized. If the <I>acct</I> parameter is not <CODE>nil</CODE>, an FTP <CODE>ACCT</CODE> command is sent following the successful login. Raises an exception on error (typically <CODE>Net::FTPPermError</CODE>). 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.ls>ls</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.ls( <I>[</I>pattern<I>]<SUP>*</SUP> </I>) -&gt; <I>anArray</I> <BR><I>aSession</I>.ls( <I>[</I>pattern<I>]<SUP>*</SUP> </I>) {| line | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>FTP#list</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.mtime>mtime</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.mtime( <I>remoteFile</I>, <I>local</I>=<CODE>false</CODE> ) -&gt; <I>aTime</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the last-modified time of <I>remoteFile</I>, interpreting the server's response as a GMT time if <I>local</I> is <CODE>false</CODE>, or as a local time otherwise. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.passive>passive</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.passive -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the state of the <CODE>passive</CODE> flag. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.passive_eq>passive=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.passive = <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Puts the connection into passive mode if <CODE>true</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.putbinaryfile>putbinaryfile</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.putbinaryfile( <I>localfile</I>, <I>remotefile</I>, <I>blocksize</I>, <I>callback</I>=<CODE>nil</CODE>)<BR><I>aSession</I>.putbinaryfile( <I>localfile</I>, <I>remotefile</I>, <I>blocksize</I> ) {| data | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Transfers <I>localfile</I> to the server in binary mode, storing the result in <I>remotefile</I>. If <I>callback</I> or an associated block is supplied, calls it, passing in the transmitted data in <I>blocksize</I> chunks. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.puttextfile>puttextfile</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.puttextfile( <I>localfile</I>, <I>remotefile</I>, <I>callback</I>=<CODE>nil</CODE>)<BR><I>aSession</I>.puttextfile( <I>localfile</I>, <I>remotefile</I>, <I>blocksize</I> ) {| data | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Transfers <I>localfile</I> to the server in ASCII (text) mode, storing the result in <I>remotefile</I>. If <I>callback</I> or an associated block is supplied, calls it, passing in the transmitted data one line at a time. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.resume>resume</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.resume -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the status of the <EM>resume</EM> flag (see <CODE>FTP#resume=</CODE>). Default is <CODE>false</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.resume_eq>resume=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.resume=<I>aBoolean</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets the status of the <EM>resume</EM> flag. When <EM>resume</EM> is <CODE>true</CODE>, partially received files will resume where they left off, instead of starting from the beginning again. This is done by sending a <CODE>REST</CODE> command (<CODE>REST</CODE>art incomplete transfer) to the server. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.retrbinary>retrbinary</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.retrbinary( <I>cmd</I>, <I>blocksize</I> ) {| data | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Puts the connection into binary (image) mode, issues the given command, and fetches the data returned, passing it to the associated block in chunks of <I>blocksize</I> characters. Note that <I>cmd</I> is a server command (such as ``RETR myfile''). 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.retrlines>retrlines</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.retrlines(cmd) {| line | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Puts the connection into ASCII (text) mode, issues the given command, and passes the resulting data, one line at a time, to the associated block. If no block is given, prints the lines. Note that <I>cmd</I> is a server command (such as ``RETR myfile''). 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.return_code>return_code</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.return_code -&gt; <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the return code from the last operation. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.storbinary>storbinary</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.storbinary( <I>cmd</I>, <I>fileName</I>, <I>blocksize</I>, <I>callback</I>=<CODE>nil</CODE>) <BR><I>aSession</I>.storbinary( <I>cmd</I>, <I>fileName</I>, <I>blocksize</I> ) {| data | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Puts the connection into binary (image) mode, issues the given server-side command (such as ``STOR myfile''), and sends the contents of the file named <I>fileName</I> to the server. If the optional block is given, or if the <I>callBack</I> parameter is a <CODE>Proc</CODE>, also passes it the data, in chunks of <I>blocksize</I> characters. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.storlines>storlines</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.storlines( <I>cmd</I>, <I>fileName</I>, <I>callback</I>=<CODE>nil</CODE>) <BR><I>aSession</I>.storlines( <I>cmd</I>, <I>fileName</I> ) {| data | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Puts the connection into ASCII (text) mode, issues the given server-side command (such as ``STOR myfile''), and sends the contents of the file named <I>fileName</I> to the server, one line at a time. If the optional block is given, or if the <I>callBack</I> parameter is a <CODE>Proc</CODE>, also passes it the lines. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::FTP.welcome>welcome</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.welcome -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the host's welcome message. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::HTTP</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Net::Protocol</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#Net::HTTP.new">new</A> <A href="122.html#Net::HTTP.port">port</A> <A href="122.html#Net::HTTP.start">start</A> <I><A href="122.html#Net::HTTP.get">get</A> </I><I><A href="122.html#Net::HTTP.head">head</A> </I><I><A href="122.html#Net::HTTP.post">post</A> </I><I><A href="122.html#Net::HTTP.start">start</A> </I>
<P></P>
<HR>

<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'net/http'
<P></P>
h&nbsp;=&nbsp;Net::HTTP.new('www.pragmaticprogrammer.com',&nbsp;80)
resp,&nbsp;data&nbsp;=&nbsp;h.get('/index.html',&nbsp;nil&nbsp;)
puts&nbsp;"Code&nbsp;=&nbsp;#{resp.code}"
puts&nbsp;"Message&nbsp;=&nbsp;#{resp.message}"
resp.each&nbsp;{|key,&nbsp;val|&nbsp;printf&nbsp;"%-14s&nbsp;=&nbsp;%-40.40s\n",&nbsp;key,&nbsp;val&nbsp;}
p&nbsp;data[0..55]
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>Code&nbsp;=&nbsp;200
Message&nbsp;=&nbsp;OK
last-modified&nbsp;&nbsp;=&nbsp;Wed,&nbsp;29&nbsp;May&nbsp;2002&nbsp;11:08:01&nbsp;GMT
connection&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;close
content-type&nbsp;&nbsp;&nbsp;=&nbsp;text/html
etag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;"804d98-255c-3cf4b691"
date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;Sun,&nbsp;09&nbsp;Jun&nbsp;2002&nbsp;05:15:10&nbsp;GMT
server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;Rapidsite/Apa/1.3.20&nbsp;(Unix)&nbsp;FrontPage/4.
content-length&nbsp;=&nbsp;9564
accept-ranges&nbsp;&nbsp;=&nbsp;bytes
"&lt;!DOCTYPE&nbsp;HTML&nbsp;PUBLIC&nbsp;\"-//W3C//DTD&nbsp;HTML&nbsp;4.0&nbsp;Transitional"
</PRE></TD></TR></TBODY></TABLE>
<P></P>The <CODE>net/http</CODE> library provides a simple client to fetch headers and Web page contents using the HTTP protocol. 
<P></P>The <CODE>get</CODE>, <CODE>post</CODE>, and <CODE>head</CODE> requests raise exceptions on any error, including some HTTP status responses that would normally be considered recoverable. There are two ways of handling these. 
<P></P>
<OL>
<LI>Each method has a corresponding version <CODE>get2</CODE>, <CODE>post2</CODE>, or <CODE>head2</CODE> that does not raise an exception. These versions are documented in the source. 
<LI>Recoverable errors raise a <CODE>Net::ProtoRetriableError</CODE> exception. This exception contains a <CODE>data</CODE> attribute containing the response returned by the server. </LI></OL>
<P></P>The code below illustrates the handling of an HTTP status 301, a redirect. It uses Tomoyuki Kosimizu's URI package, available in the RAA. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>h&nbsp;=&nbsp;Net::HTTP.new(ARGV[0]&nbsp;||&nbsp;'www.ruby-lang.org',&nbsp;80)
url&nbsp;=&nbsp;ARGV[1]&nbsp;||&nbsp;'/'
<P></P>
begin
&nbsp;&nbsp;resp,&nbsp;data&nbsp;=&nbsp;h.get(url,&nbsp;nil)&nbsp;{&nbsp;|a|&nbsp;}
rescue&nbsp;Net::ProtoRetriableError&nbsp;=&gt;&nbsp;detail
&nbsp;&nbsp;head&nbsp;=&nbsp;detail.data
<P></P>
&nbsp;&nbsp;if&nbsp;head.code&nbsp;==&nbsp;"301"
&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;URI.create(head['location'])
<P></P>
&nbsp;&nbsp;&nbsp;&nbsp;host&nbsp;=&nbsp;uri['host']
&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;&nbsp;=&nbsp;uri['path']
&nbsp;&nbsp;&nbsp;&nbsp;port&nbsp;=&nbsp;uri['port']
<P></P>
&nbsp;&nbsp;&nbsp;&nbsp;h.finish
&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;Net::HTTP.new(host,&nbsp;port)
<P></P>
&nbsp;&nbsp;&nbsp;&nbsp;retry
&nbsp;&nbsp;end
end
</PRE></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTP.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Net::HTTP.new( <I>host</I>='localhost', <I>port</I>=80, <I>proxy</I>=<CODE>nil</CODE>, <I>proxy_port</I>=<CODE>nil</CODE> ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Creates and returns a new <CODE>HTTP</CODE> object. No connection is made until <CODE>HTTP#start</CODE> is called. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTP.port>port</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Net::HTTP.port -&gt; <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the default HTTP port (80). 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTP.start>start</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Net::HTTP.start( <I>host</I>=<CODE>nil</CODE>, <I>port</I>=80 )<BR>Net::HTTP.start( <I>host</I>=<CODE>nil</CODE>, <I>port</I>=80 ) {| <I>aSession</I> | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Equivalent to <CODE>Net::HTTP.new(<I>host</I>, <I>port</I>).start</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTP.get>get</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.get( <I>path</I>, <I>headers</I>=<CODE>nil</CODE>, <I>dest</I>="" ) -&gt; <I>anArray</I> <BR><I>aSession</I>.get( <I>path</I>, <I>headers</I>=<CODE>nil</CODE>) {| result | block } 
<P></P>-&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Retrieves headers and content from the specified <I>path</I> on the host specified when <I>aSession</I> was created. If specified, the <I>headers</I> parameter is a <CODE>Hash</CODE> containing additional header names and values to be sent with the request. The method returns a two-element array. The first element is an <CODE>HTTPResponse</CODE> object (documented in the next section). The second element is the page's content. The page's content is also passed to the <CODE>&lt;&lt;</CODE> method of the <I>dest</I> parameter, or to the block if specified. This result is built network block by network block, not line by line. An exception is raised if an error is encountered. Multiple <CODE>get</CODE> calls may be made on <I>aSession</I>. Unless <CODE>Protocol#finish</CODE> is explicitly called, the connection will use the HTTP/1.1 keep-alive protocol, and will not close between requests. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTP.head>head</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.head( <I>path</I>, <I>headers</I>=<CODE>nil</CODE> ) -&gt; <I>aHash</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Retrieves headers from the specified <I>path</I> on the host specified when <I>aSession</I> was created. If specified, the <I>headers</I> parameter is a hash containing additional header names and values to be sent with the request. The method returns a hash of received headers. An exception is raised if an error is encountered. Multiple <CODE>head</CODE> calls may be made on <I>aSession</I>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTP.post>post</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.post( <I>path</I>, <I>data</I>, <I>headers</I>=<CODE>nil</CODE>, <I>dest</I>="" ) -&gt; <I>anArray</I> <BR><I>aSession</I>.post( <I>path</I>, <I>data</I>, <I>headers</I>=<CODE>nil</CODE> ) {| result | block } -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sends <I>data</I> to <I>path</I> using an HTTP POST request. <I>headers</I> is a hash containing additional headers. Assigns the result to <I>data</I> or to the block, as for <CODE>Net_HTTP#get</CODE>. Returns a two-element array containing an HTTPResponse object and the reply body. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTP.start>start</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.start<BR><I>aSession</I>.start {| <I>aSession</I> | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Establishes a connection to the host associated with <I>aSession</I>. (<CODE>start</CODE> is actually a method in <CODE>Net::Protocol</CODE>, but its use is required in HTTP objects.) In the block form, closes the session at the end of the block. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::HTTPResponse</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white></FONT></TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><I><A href="122.html#Net::HTTPResponse._ob_cb">[ ]</A> </I><I><A href="122.html#Net::HTTPResponse._ob_cb_eq">[ ]=</A> </I><I><A href="122.html#Net::HTTPResponse.code">code</A> </I><I><A href="122.html#Net::HTTPResponse.each">each</A> </I><I><A href="122.html#Net::HTTPResponse.key_qm">key?</A> </I><I><A href="122.html#Net::HTTPResponse.message">message</A> </I>
<P></P>
<HR>
Represents an HTTP response to a GET or POST request. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTPResponse._ob_cb>[ ]</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>[ <I>aKey</I> ] -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the header corresponding to the case-insensitive key. For example, a key of ``Content-type'' might return ``text/html''. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTPResponse._ob_cb_eq>[ ]=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>[ <I>aKey</I> ] = <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets the header corresponding to the case-insensitive key. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTPResponse.code>code</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.code -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the result code from the request (for example, ``404''). 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTPResponse.each>each</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.each {| key, val | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Iterates over all the header key-value pairs. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTPResponse.key_qm>key?</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.key?( <I>aKey</I> ) -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns <CODE>true</CODE> only if a header with the given key exists. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::HTTPResponse.message>message</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.message -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the result message from the request (for example, ``Not found''). 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::POP</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Net::Protocol</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#Net::POP.new">new</A> <I><A href="122.html#Net::POP.each">each</A> </I><I><A href="122.html#Net::POP.finish">finish</A> </I><I><A href="122.html#Net::POP.mails">mails</A> </I><I><A href="122.html#Net::POP.start">start</A> </I>
<P></P>
<HR>

<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'net/pop'
pop&nbsp;=&nbsp;Net::POP3.new('server.ruby-stuff.com')
pop.start('user',&nbsp;'secret')&nbsp;do&nbsp;|pop|
&nbsp;&nbsp;msg&nbsp;=&nbsp;pop.mails[0]
<P></P>
&nbsp;&nbsp;#&nbsp;Print&nbsp;the&nbsp;'From:'&nbsp;header&nbsp;line
&nbsp;&nbsp;puts&nbsp;msg.header.split("\r\n").grep(/^From:&nbsp;/)
<P></P>
&nbsp;&nbsp;#&nbsp;Put&nbsp;message&nbsp;to&nbsp;$stdout&nbsp;(by&nbsp;calling&nbsp;&lt;&lt;)
&nbsp;&nbsp;puts&nbsp;"\nFull&nbsp;message:\n"
&nbsp;&nbsp;msg.all($stdout)
end
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>From:&nbsp;dummy&nbsp;msg&nbsp;for&nbsp;Andy
<P></P>
Full&nbsp;message:
From:&nbsp;dummy&nbsp;msg&nbsp;for&nbsp;Andy
looks-better:&nbsp;on&nbsp;dave's&nbsp;box
<P></P>
That's&nbsp;all&nbsp;folks!
</PRE></TD></TR></TBODY></TABLE>
<P></P>The <CODE>net/pop</CODE> library provides a simple client to fetch and delete mail on a Post Office Protocol (POP) server. 
<P></P>The class <CODE>Net::POP3</CODE> is used to access a POP server, returning a list of <CODE>Net::POPMail</CODE> objects, one per message stored on the server. These <CODE>POPMail</CODE> objects are then used to fetch and/or delete individual messages. The library also provides an alternative to the <CODE>POP3</CODE> class that performs <CODE>APOP</CODE> authentication. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POP.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>HTTP.new( <I>host</I>='localhost', <I>port</I>=110 ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Creates and returns a new <CODE>POP3</CODE> object. No connection is made until <CODE>POP3#start</CODE> is called. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POP.each>each</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.each {| popmail | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Calls the associated block once for each e-mail stored on the server, passing in the corresponding <CODE>POPMail</CODE> object. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POP.finish>finish</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.finish -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Closes the pop connection. Some servers require that a connection is closed before they honor actions such as deleting mail. Returns <CODE>false</CODE> if the connection was never used. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POP.mails>mails</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.mails -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns an array of <CODE>POPMail</CODE> objects, where each object corresponds to an e-mail message stored on the server. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POP.start>start</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.start( <I>user</I>, <I>password</I> )<BR><I>aSession</I>.start( <I>user</I>, <I>password</I> ) {| pop | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Establishes a connection to the pop server, using the supplied username and password. Fetches a list of mail held on the server, which may be accessed using the <CODE>POP3#mails</CODE> and <CODE>POP3#each</CODE> methods. In block form, passes <I>aSession</I> to the block, and closes the connection using <CODE>finish</CODE> when the block terminates. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::APOP</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Net::POP3</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><I><A href="122.html#Net::APOP.start">start</A> </I>
<P></P>
<HR>

<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::APOP.start>start</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.start( <I>user</I>, <I>password</I> ) </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Establishes a connection to the APOP server. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::POPMail</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Object</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><I><A href="122.html#Net::POPMail.all">all</A> </I><I><A href="122.html#Net::POPMail.delete">delete</A> </I><I><A href="122.html#Net::POPMail.delete_oh">delete!</A> </I><I><A href="122.html#Net::POPMail.header">header</A> </I><I><A href="122.html#Net::POPMail.size">size</A> </I><I><A href="122.html#Net::POPMail.top">top</A> </I><I><A href="122.html#Net::POPMail.uidl">uidl</A> </I>
<P></P>
<HR>

<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POPMail.all>all</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.all -&gt; <I>aString</I> <BR><I>aSession</I>.all( <I>dest</I> )<BR><I>aSession</I>.all {| aString | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Fetches the corresponding e-mail from the server. With no argument or associated block, returns the e-mail as a string. With an argument but no block, appends the e-mail to <I>dest</I> by invoking <I>dest</I> <CODE>&lt;&lt;</CODE> for each line in the e-mail. With an associated block, invokes the block once for each line in the e-mail. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POPMail.delete>delete</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.delete </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Deletes the e-mail from the server. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POPMail.delete_oh>delete!</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.delete! </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Synonym for <CODE>POPMail#delete</CODE>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POPMail.header>header</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.header -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the header lines for the corresponding e-mail message. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POPMail.size>size</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.size -&gt; <I>aFixnum</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the size in bytes of the corresponding e-mail. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POPMail.top>top</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.top( <I>lines</I> ) -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the header lines, plus <I>lines</I> message lines for the corresponding e-mail message. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::POPMail.uidl>uidl</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.uidl -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the server-specific unique identifier for the corresponding e-mail. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::SMTP</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Net::Protocol</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#Net::SMTP.new">new</A> <A href="122.html#Net::SMTP.start">start</A> <I><A href="122.html#Net::SMTP.ready">ready</A> </I><I><A href="122.html#Net::SMTP.sendmail">sendmail</A> </I><I><A href="122.html#Net::SMTP.start">start</A> </I>
<P></P>
<HR>

<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'net/smtp'
<P></P>
#&nbsp;---&nbsp;Send&nbsp;using&nbsp;class&nbsp;methods
msg&nbsp;=&nbsp;[&nbsp;"Subject:&nbsp;Test\n",&nbsp;"\n",&nbsp;"Now&nbsp;is&nbsp;the&nbsp;time\n"&nbsp;]
Net::SMTP.start&nbsp;do&nbsp;|smtp|
&nbsp;&nbsp;smtp.sendmail(&nbsp;msg,&nbsp;&nbsp;'dave@localhost',&nbsp;['dave']&nbsp;)
end
<P></P>
#&nbsp;---&nbsp;Send&nbsp;using&nbsp;SMTP&nbsp;object&nbsp;and&nbsp;an&nbsp;adaptor
smtp&nbsp;=&nbsp;Net::SMTP.new
smtp.start('pragprog.com')
smtp.ready('dave@localhost',&nbsp;'dave')&nbsp;do&nbsp;|a|
&nbsp;&nbsp;a.write&nbsp;"Subject:&nbsp;Test1\r\n"
&nbsp;&nbsp;a.write&nbsp;"\r\n"
&nbsp;&nbsp;a.write&nbsp;"And&nbsp;so&nbsp;is&nbsp;this"
end
</PRE></TD></TR></TBODY></TABLE>
<P></P>The <CODE>net/smtp</CODE> library provides a simple client to send electronic mail using the Simple Mail Transfer Protocol (SMTP). 
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::SMTP.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Net::SMTP.new( <I>server</I>='localhost', <I>port</I>=25 ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a new <CODE>SMTP</CODE> object connected to the given server and port. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::SMTP.start>start</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Net::SMTP.start( <I>server</I>='localhost', <I>port</I>=25, <I>domain</I>=ENV['HOSTNAME'], <I>acct</I>=<CODE>nil</CODE>, <I>passwd</I>=<CODE>nil</CODE>, <I>authtype</I>=:cram_md5 ) -&gt; <I>aSession</I> <BR>Net::SMTP.start( <I>server</I>='localhost', <I>port</I>=25, <I>domain</I>=ENV['HOSTNAME'], <I>acct</I>=<CODE>nil</CODE>, <I>passwd</I>=<CODE>nil</CODE>, <I>authtype</I>=:cram_md5 ) {| smtp | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Equivalent to <CODE>Net::SMTP.new(<I>server</I>, <I>port</I>).start(...)</CODE>. For an explanation of the remainder of the parameters, see the instance method <CODE>Net_SMTP#start</CODE>. Creates a new <CODE>SMTP</CODE> object. The <I>domain</I> parameter will be used in the initial <CODE>HELO</CODE> or <CODE>EHLO</CODE> transaction with the SMTP server. In the block form, the <I>smtp</I> object is passed into the block. When the block terminates, the session is closed. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::SMTP.ready>ready</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.ready( <I>from</I>, <I>to</I> ) {| anAdaptor | block } 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Equivalent to <CODE>sendmail(from, to) { ...}</CODE>. Sends header and body lines to the sendmail server. The <I>from</I> parameter is used as the sender's name in the <CODE>MAIL FROM:</CODE> command, and the <I>to</I> is either a string or an array of strings containing the recipients for the <CODE>RCPT TO:</CODE> command. The block is passed an adaptor object. Lines are sent to the server by calling the adaptor's <CODE>write</CODE> method. The terminating '.' and <CODE>QUIT</CODE> are sent automatically. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::SMTP.sendmail>sendmail</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.sendmail( <I>src</I>, <I>from</I>, <I>to</I> ) </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sends header and body lines to the sendmail server. The <I>from</I> parameter is used as the sender's name in the <CODE>MAIL FROM:</CODE> command, and <I>to</I> is either a string or an array of strings containing the recipients for the <CODE>RCPT TO:</CODE> command. Lines to be sent are fetched by invoking <I>src</I> <CODE>.each</CODE>. The terminating '.' and <CODE>QUIT</CODE> are sent automatically. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::SMTP.start>start</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.start( <I>domain</I>=ENV['HOSTNAME'], <I>acct</I>=<CODE>nil</CODE>, <I>passwd</I>=<CODE>nil</CODE>, <I>authtype</I>=:cram_md5 ) -&gt; <CODE>true</CODE> or <CODE>false</CODE> <BR><I>aSession</I>.start( <I>domain</I>=ENV['HOSTNAME'], <I>acct</I>=<CODE>nil</CODE>, <I>passwd</I>=<CODE>nil</CODE>, <I>authtype</I>=:cram_md5 ) {| smtp | block } -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Starts an SMTP session by connecting to the given domain (host). If <I>acct</I> and <I>passwd</I> are given, authentication will be attempted using the given authentication type (<CODE>:plain</CODE> or <CODE>:cram_md5</CODE>). If a block is supplied, it will be invoked with <I>aSession</I> as a parameter. The connection will be closed when the block terminates. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class Net::Telnet</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>[Socket]</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#Net::Telnet.new">new</A> <I><A href="122.html#Net::Telnet.binmode">binmode</A> </I><I><A href="122.html#Net::Telnet.binmode_eq">binmode=</A> </I><I><A href="122.html#Net::Telnet.cmd">cmd</A> </I><I><A href="122.html#Net::Telnet.login">login</A> </I><I><A href="122.html#Net::Telnet.print">print</A> </I><I><A href="122.html#Net::Telnet.telnetmode">telnetmode</A> </I><I><A href="122.html#Net::Telnet.telnetmode_eq">telnetmode=</A> </I><I><A href="122.html#Net::Telnet.waitfor">waitfor</A> </I><I><A href="122.html#Net::Telnet.write">write</A> </I>
<P></P>
<HR>

<P></P>Connect to a <CODE>localhost</CODE>, run the ``date'' command, and disconnect. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=500 border=0>
<TBODY>
<TR>
<TD vAlign=top colSpan=3><CODE>require&nbsp;'net/telnet'</CODE> </TD></TR>
<TR>
<TD vAlign=top colSpan=3><CODE></CODE></TD></TR>
<TR>
<TD vAlign=top colSpan=3><CODE>tn&nbsp;=&nbsp;Net::Telnet.new({})</CODE> </TD></TR>
<TR>
<TD vAlign=top colSpan=3><CODE>tn.login&nbsp;"guest",&nbsp;"secret"</CODE> </TD></TR>
<TR>
<TD vAlign=top><CODE>tn.cmd&nbsp;"date"</CODE> </TD>
<TD vAlign=top></TD>
<TD vAlign=top><CODE>"date\r\nSun&nbsp;Jun&nbsp;&nbsp;9&nbsp;00:15:20&nbsp;CDT&nbsp;2002\n\r&gt;&nbsp;"</CODE> </TD></TR></TBODY></TABLE>
<P></P>
<P></P>Monitor output as it occurs. We associate a block with each of the library calls; this block is called whenever data becomes available from the host. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'net/telnet'
<P></P>
tn&nbsp;=&nbsp;Net::Telnet.new({})&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;|str|&nbsp;print&nbsp;str&nbsp;}
tn.login("guest",&nbsp;"secret")&nbsp;&nbsp;{&nbsp;|str|&nbsp;print&nbsp;str&nbsp;}
tn.cmd("date")&nbsp;&nbsp;{&nbsp;|str|&nbsp;print&nbsp;str&nbsp;}
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>Trying&nbsp;localhost...
Connected&nbsp;to&nbsp;localhost.
Welcome&nbsp;to&nbsp;SuSE&nbsp;Linux&nbsp;7.1&nbsp;(i386)&nbsp;-&nbsp;Kernel&nbsp;2.4.0-64GB-SMP&nbsp;(8).
<P></P>
zip&nbsp;login:&nbsp;guest
Password:
Last&nbsp;login:&nbsp;Sun&nbsp;Jun&nbsp;&nbsp;9&nbsp;00:15:19&nbsp;from&nbsp;localhost
/etc/zshrc:&nbsp;setopt:&nbsp;no&nbsp;such&nbsp;option:&nbsp;histexpiredupsfirst&nbsp;[31]

&gt;&nbsp;date
Sun&nbsp;Jun&nbsp;&nbsp;9&nbsp;00:15:20&nbsp;CDT&nbsp;2002

&gt;
</PRE></TD></TR></TBODY></TABLE>
<P></P>Get the time from an NTP server. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;'net/telnet'
tn&nbsp;=&nbsp;Net::Telnet.new('Host'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;'time.nonexistent.org',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Port'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;'time',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Timeout'&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;60,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Telnetmode'&nbsp;=&gt;&nbsp;false)
atomicTime&nbsp;=&nbsp;tn.recv(4).unpack('N')[0]
puts&nbsp;"Atomic&nbsp;time:&nbsp;"&nbsp;+&nbsp;Time.at(atomicTime&nbsp;-&nbsp;2208988800).to_s
puts&nbsp;"Local&nbsp;time:&nbsp;&nbsp;"&nbsp;+&nbsp;Time.now.to_s
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>Atomic&nbsp;time:&nbsp;Sun&nbsp;Jun&nbsp;09&nbsp;00:15:12&nbsp;CDT&nbsp;2002
Local&nbsp;time:&nbsp;&nbsp;Sun&nbsp;Jun&nbsp;09&nbsp;00:15:20&nbsp;CDT&nbsp;2002
</PRE></TD></TR></TBODY></TABLE>
<P></P>The <CODE>net/telnet</CODE> library provides a complete implementation of a telnet client and includes features that make it a convenient mechanism for interacting with non-telnet services. 
<P></P>Although the class description that follows indicates that <CODE>Net::Telnet</CODE> is a subclass of class <CODE>Socket</CODE>, this is a lie. In reality, the class delegates to <CODE>Socket</CODE>. The net effect is the same: the methods of <CODE>Socket</CODE> and its parent, class <CODE>IO</CODE>, are available through <CODE>Net::Telnet</CODE> objects. 
<P></P>The methods <CODE>new</CODE>, <CODE>cmd</CODE>, <CODE>login</CODE>, and <CODE>waitfor</CODE> take an optional block. If present, the block is passed output from the server as it is received by the routine. This can be used to provide realtime output, rather than waiting for (for example) a login to complete before displaying the server's response. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>Net::Telnet.new( <I>options</I> ) -&gt; <I>aSession</I> <BR>Net::Telnet.new( <I>options</I> ) {| str | block } -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Connects to a server. <I>options</I> is a <CODE>Hash</CODE> with zero or more of the following: 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 border=0>
<TBODY>
<TR bgColor=#ff9999>
<TD vAlign=top><B>Option</B> </TD>
<TD vAlign=top><B>Default</B> </TD>
<TD vAlign=top><B>Meaning</B> </TD></TR>
<TR>
<TD vAlign=top><CODE>Binmode</CODE> </TD>
<TD vAlign=top><CODE>false</CODE> </TD>
<TD vAlign=top>If true, no end-of-line processing will be performed.</TD></TR>
<TR>
<TD vAlign=top><CODE>Host</CODE> </TD>
<TD vAlign=top>localhost</TD>
<TD vAlign=top>Name or address of server's host.</TD></TR>
<TR>
<TD vAlign=top><CODE>Port</CODE> </TD>
<TD vAlign=top>23</TD>
<TD vAlign=top>Name or number of service to call.</TD></TR>
<TR>
<TD vAlign=top><CODE>Prompt</CODE> </TD>
<TD vAlign=top><CODE>/[$%#&gt;]/</CODE> </TD>
<TD vAlign=top>Pattern that matches the host's prompt.</TD></TR>
<TR>
<TD vAlign=top><CODE>Telnetmode</CODE> </TD>
<TD vAlign=top><CODE>true</CODE> </TD>
<TD vAlign=top>If <CODE>false</CODE>, ignore the majority of telnet embedded escape sequences. Used when talking with a non-telnet server.</TD></TR>
<TR>
<TD vAlign=top><CODE>Timeout</CODE> </TD>
<TD vAlign=top>10</TD>
<TD vAlign=top>Time in seconds to wait for a server response (both during connection and during regular data transmission).</TD></TR>
<TR>
<TD vAlign=top><CODE>Waittime</CODE> </TD>
<TD vAlign=top>0</TD>
<TD vAlign=top>Time to wait for prompt to appear in received data stream.</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=2><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.binmode>binmode</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.binmode -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the current value of the <CODE>Binmode</CODE> flag. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.binmode_eq>binmode=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.binmode = <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets the <CODE>Binmode</CODE> flag, returning the new value. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.cmd>cmd</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.cmd( <I>options</I> ) -&gt; <I>aString</I> <BR><I>aSession</I>.cmd( <I>options</I> ) {| str | block } -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sends a string to the server and waits (using a timeout) for a string that matches a pattern to be returned by the server. If the parameter is not a <CODE>Hash</CODE>, it is sent as a string to the server, and the pattern to match and the timeout are the <CODE>Prompt</CODE> and <CODE>Timeout</CODE> options given when <I>aSession</I> was created. If <I>options</I> is a <CODE>Hash</CODE>, then <I>options['String']</I> is sent to the server. <I>options['Match']</I> may be used to override the class <CODE>Prompt</CODE> parameter, and <I>options['Timeout']</I> the timeout. The method returns the complete server response. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.login>login</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.login( <I>options</I>, <I>password</I>=nil ) -&gt; <I>aString</I> <BR><I>aSession</I>.login( <I>options</I>, <I>password</I>=nil ) {| str | block } -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>If <I>options</I> is a <CODE>Hash</CODE>, a username is taken from <I>options['Name']</I> and a password from <I>options['Password']</I>; otherwise, <I>options</I> is assumed to be the username, and <I>password</I> the password. The method waits for the server to send the string matching the pattern <CODE>/login[:<IMG height=10 alt="[visible space]" src="97_files/visible_space[1].gif"  width=15 align=bottom>]*\z/</CODE> and sends the username. If a password is given, it then waits for the server to send <CODE>/Password[:<IMG height=10 alt="[visible space]" src="97_files/visible_space[1].gif"  width=15 align=bottom>]*\z/</CODE> and sends the password. The method returns the full server response. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.print>print</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.print( <I>aString</I> ) </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sends <I>aString</I> to the server, honoring <CODE>Telnetmode</CODE>, <CODE>Binarymode</CODE>, and any additional modes negotiated with the server. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.telnetmode>telnetmode</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.telnetmode -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the current value of the <CODE>Telnetmode</CODE> flag. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.telnetmode_eq>telnetmode=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.telnetmode= <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets the <CODE>Telnetmode</CODE> flag, returning the new value. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.waitfor>waitfor</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.waitfor( <I>options</I> ) -&gt; <I>aString</I> <BR><I>aSession</I>.waitfor( <I>options</I> ) {| str | block } -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Waits for the server to respond with a string that matches a string or pattern. If <I>options</I> is not a <CODE>Hash</CODE>, it is compared against the cumulative server output as that output is received using <I>options.</I> <CODE>===</CODE>. It is likely that you will want to use a regular expression in this case. 
<P></P>If <I>options</I> is a <CODE>Hash</CODE>, then <I>options['Match']</I>, <I>options['Prompt']</I>, or <I>options['String']</I> provides the match. In the latter case, the string will be converted to a regular expression before being used. <I>options</I> may also include the keys ``Timeout'' and ``Waittime'' to override the class options of the same names. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=Net::Telnet.write>write</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.write( <I>aString</I> ) </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Writes <I>aString</I> to the server with no translation. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<H2><A name=S3>CGI Development</A></H2>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class CGI</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Object</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#CGI.escape">escape</A> <A href="122.html#CGI.escapeElement">escapeElement</A> <A href="122.html#CGI.escapeHTML">escapeHTML</A> <A href="122.html#CGI.new">new</A> <A href="122.html#CGI.parse">parse</A> <A href="122.html#CGI.pretty">pretty</A> <A href="122.html#CGI.rfc1123_date">rfc1123_date</A> <A href="122.html#CGI.unescape">unescape</A> <A href="122.html#CGI.unescapeElement">unescapeElement</A> <A href="122.html#CGI.unescapeHTML">unescapeHTML</A> <I><A href="122.html#CGI._ob_cb">[ ]</A> </I><I><A href="122.html#CGI.cookies">cookies</A> </I><I><A href="122.html#CGI.has_key_qm">has_key?</A> </I><I><A href="122.html#CGI.header">header</A> </I><I><A href="122.html#CGI.keys">keys</A> </I><I><A href="122.html#CGI.out">out</A> </I><I><A href="122.html#CGI.params">params</A> </I>
<P></P>
<HR>

<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>require&nbsp;"cgi"
cgi&nbsp;=&nbsp;CGI.new("html3")&nbsp;&nbsp;#&nbsp;add&nbsp;HTML&nbsp;generation&nbsp;methods
cgi.out&nbsp;{
&nbsp;&nbsp;CGI.pretty&nbsp;(
&nbsp;&nbsp;&nbsp;&nbsp;cgi.html&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.head&nbsp;{&nbsp;cgi.title{"TITLE"}&nbsp;}&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.body&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.form&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.textarea("get_text")&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.br&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.submit
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.h1&nbsp;{&nbsp;"This&nbsp;is&nbsp;big!"&nbsp;}&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.center&nbsp;{&nbsp;"Jazz&nbsp;Greats&nbsp;of&nbsp;the&nbsp;20"&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.small&nbsp;{"th"}&nbsp;+&nbsp;"&nbsp;century"&nbsp;+&nbsp;cgi.hr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;+&nbsp;cgi.p&nbsp;+&nbsp;cgi.table&nbsp;('BORDER'&nbsp;=&gt;&nbsp;'5')&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.tr&nbsp;{&nbsp;cgi.td&nbsp;{"Artist"}&nbsp;+&nbsp;cgi.td&nbsp;{"Album"}&nbsp;}&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.tr&nbsp;{&nbsp;cgi.td&nbsp;{"Davis,&nbsp;Miles"}&nbsp;+
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cgi.td&nbsp;{"Kind&nbsp;of&nbsp;Blue"}&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;)&nbsp;#&nbsp;CGI.pretty&nbsp;is&nbsp;a&nbsp;method&nbsp;call,&nbsp;not&nbsp;a&nbsp;block
}
</PRE></TD></TR></TBODY></TABLE>
<P></P>(The output of this script is shown in Figure 26.2 on page 499.) 
<P></P>The <CODE>CGI</CODE> class provides support for programs used as a Web server CGI (Common Gateway Interface) script. It contains several methods for accessing fields in a CGI form, manipulating ``cookies'' and the environment, and outputting formatted HTML. 
<P></P>Since environment variables contain a lot of useful information for a CGI script, <CODE>CGI</CODE> makes accessing them very easy---environment variables are accessible as attributes of <CODE>CGI</CODE> objects. For instance, <CODE>cgi.auth_type</CODE> returns the value of <CODE>ENV["AUTH_TYPE"]</CODE>. To create the method name, the environment variable name is translated to all lowercase, and the ``<CODE>HTTP_</CODE>'' prefix is stripped off. Thus, <CODE>HTTP_USER_AGENT</CODE> would be available as the method <CODE>user_agent</CODE>. 
<P></P>Cookies are represented using a separate object of class <CODE>CGI::Cookie</CODE>, containing the following accessors: 
<TABLE class=codebox cellSpacing=0 cellPadding=3 border=0>
<TBODY>
<TR bgColor=#ff9999>
<TD vAlign=top><B>Accessor</B> </TD>
<TD vAlign=top><B>Description</B> </TD></TR>
<TR>
<TD vAlign=top><CODE>name</CODE> </TD>
<TD vAlign=top>Name of this cookie</TD></TR>
<TR>
<TD vAlign=top><CODE>value</CODE> </TD>
<TD vAlign=top>Array of values</TD></TR>
<TR>
<TD vAlign=top><CODE>path</CODE> </TD>
<TD vAlign=top>Path (optional)</TD></TR>
<TR>
<TD vAlign=top><CODE>domain</CODE> </TD>
<TD vAlign=top>Domain (optional)</TD></TR>
<TR>
<TD vAlign=top><CODE>expires</CODE> </TD>
<TD vAlign=top>Time of expiry, defaults to <A href="http://www.ruby-cn.org/book/ProgrammingRuby/ref_c_time.html#Time.now" ><CODE>Time.now</CODE> </A>(optional)</TD></TR>
<TR>
<TD vAlign=top><CODE>secure</CODE> </TD>
<TD vAlign=top><CODE>true</CODE> for a secure cookie</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=2><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<P></P>
<TABLE width=500 bgColor=#ffe0e0 border=2>
<TBODY>
<TR>
<TD>Figure not available...</TD></TR></TBODY></TABLE>
<P></P>You create a cookie object using <CODE>CGI_Cookie.new</CODE>, which takes as arguments the accessors listed above, or <CODE>CGI_Cookie.parse</CODE>, which takes an encoded string and returns a cookie object. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.escape>escape</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.escape( <I>aString</I> ) -&gt; <I>aNewString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a URL-encoded string made from the given argument, where unsafe characters (not alphanumeric, ``_'', ``-'', or ``.'') are encoded using ``%xx'' escapes. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.escapeElement>escapeElement</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.escapeElement( <I>aString</I> <I>[</I>, <I>elements</I> <I>]<SUP>*</SUP> </I>) -&gt; <I>aNewString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a string made from the given argument with certain HTML-special characters escaped. The HTML elements given in <I>elements</I> will be escaped; other HTML elements will not be affected. 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>print&nbsp;CGI::escapeElement('&lt;BR&gt;&lt;A&nbsp;HREF="url"&gt;&lt;/A&gt;&lt;P&gt;',&nbsp;"A",&nbsp;"IMG")
</PRE></TD></TR></TBODY></TABLE><EM>produces:</EM> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 width=400 border=0>
<TBODY>
<TR>
<TD><PRE>&lt;BR&gt;&amp;lt;A&nbsp;HREF=&amp;quot;url&amp;quot;&amp;gt;&amp;lt;/A&amp;gt;&lt;P&gt;
</PRE></TD></TR></TBODY></TABLE>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.escapeHTML>escapeHTML</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.escapeHTML( <I>aString</I> ) -&gt; <I>aNewString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a string made from the given argument with HTML-special characters (such as ``<CODE>&amp;</CODE>'',``<CODE>"</CODE>'',``<CODE>&lt;</CODE>'',``<CODE>&gt;</CODE>'') quoted using ``<CODE>&amp;amp;</CODE>'', ``<CODE>&amp;quot;</CODE>'', ``<CODE>&amp;lt;</CODE>'', ``<CODE>&amp;gt;</CODE>'', and so on. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.new( <I>[</I> <I>aString</I> <I>]<SUP>*</SUP> </I>) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a new <CODE>CGI</CODE> object. If HTML output is required, the desired standards level must be given in <I>aString</I> (otherwise, no output routines will be created). The level may be one of: 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 border=0>
<TBODY>
<TR bgColor=#ff9999>
<TD vAlign=top><B>String</B> </TD>
<TD vAlign=top><B>Standards Level</B> </TD>
<TD vAlign=top><B>String</B> </TD>
<TD vAlign=top><B>Standards Level</B> </TD></TR>
<TR>
<TD vAlign=top>``html3''</TD>
<TD vAlign=top>HTML 3.2</TD>
<TD vAlign=top>``html4''</TD>
<TD vAlign=top>HTML 4.0 Strict</TD></TR>
<TR>
<TD vAlign=top>``html4Tr''</TD>
<TD vAlign=top>HTML 4.0 Transitional</TD>
<TD vAlign=top>``html4Fr''</TD>
<TD vAlign=top>HTML 4.0 Frameset</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=2><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.parse>parse</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.parse( <I>aString</I> ) -&gt; <I>aHash</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Parses a query string and returns a hash of its <EM>key-value</EM> pairs. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.pretty>pretty</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.pretty( <I>anHTMLString</I>, <I>aLeaderString</I>=" " ) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Formats the given <I>anHTMLString</I> in a nice, readable format, optionally prefixing each line with <I>aLeaderString</I>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.rfc1123_date>rfc1123_date</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.rfc1123_date( <I>aTime</I> ) -&gt; <I>aString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a string representing the given time according to RFC 1123 (for instance, <CODE>Mon, 1 Jan 2001 00:00:00 GMT</CODE>). 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.unescape>unescape</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.unescape( <I>aString</I> ) -&gt; <I>aNewString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a string containing ``unsafe'' characters made from the given URL-encoded argument, where unsafe characters were encoded using ``%'' escapes. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.unescapeElement>unescapeElement</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.unescapeElement( <I>aString</I> <I>[</I>, <I>elements</I> <I>]<SUP>*</SUP> </I>) -&gt; <I>aNewString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a string with the selected escaped HTML elements expanded to the actual characters. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.unescapeHTML>unescapeHTML</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI.unescapeHTML( <I>aString</I> ) -&gt; <I>aNewString</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a string made from the given argument with HTML-special quoted characters expanded to the actual characters. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI._ob_cb>[ ]</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>[ <I>[</I> <I>aString</I> <I>]<SUP>+</SUP> </I>] -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the values of the given field names from the CGI form in an <CODE>Array</CODE>. See the note on multipart forms on page 503. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.cookies>cookies</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.cookies -&gt; <I>aHash</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a new <CODE>Hash</CODE> object containing <EM>key-value</EM> pairs of cookie keys and values. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.has_key_qm>has_key?</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.has_key( <I>aString</I> ) -&gt; <CODE>true</CODE> or <CODE>false</CODE> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns <CODE>true</CODE> if the form contains a field named <I>aString</I>. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.header>header</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.header( <I>aContentType</I>="text/html" ) -&gt; <I>aString</I> <BR><I>aSession</I>.header( <I>aHash</I> ) -&gt; <I>aString</I> <BR></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a string containing the given headers (in the <CODE>MOD_RUBY</CODE> environment, the resulting header is sent immediately instead). If a hash is given as an argument, then the <EM>key-value</EM> pairs will be used to generate headers. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.keys>keys</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.keys -&gt; <I>anArray</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns an array of all existing field names for the form. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.out>out</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.out( <I>aContentType</I>="text/html" ) { block } -&gt; <CODE>nil</CODE> <BR><I>aSession</I>.out( <I>aHash</I> ) { block } -&gt; <CODE>nil</CODE> <BR></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Generates HTML output using the results of the block as the content. Headers are generated as with <CODE>CGI#header</CODE>. See the example at the start of this section. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI.params>params</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.params -&gt; <I>aHash</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a new <CODE>Hash</CODE> object containing <EM>key-value</EM> pairs of field names and values from the form. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<H3><A name=UA>HTML Output Methods</A></H3>In addition, <CODE>CGI</CODE> supports the following HTML output methods. Each of these methods is named after the corresponding HTML feature (or close to it). Those tags that require content (such as <CODE>blockquote</CODE>) take an optional block; the block should return a <CODE>String</CODE> that will be used as the content for the feature. These methods may take arguments as indicated, or as a hash with the given names as keys. 
<P></P>\
<HR>
 <BR><CODE>a</CODE>( <EM><I>url</I> </EM>)<BR><CODE>a</CODE>( <EM><CODE>HREF</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>base</CODE>( <EM><I>url</I> </EM>)<BR><CODE>base</CODE>( <EM><CODE>HREF</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>blockquote</CODE>( <EM><I>cite=""</I> </EM>) { <EM>aString</EM> }<BR><CODE>blockquote</CODE>( <EM><CODE>CITE</CODE> </EM>=&gt; ) { <EM>aString</EM> }
<P></P>
<P></P><BR><CODE>caption</CODE>( <EM><I>align=nil</I> </EM>) { <EM>aString</EM> }<BR><CODE>caption</CODE>( <EM><CODE>ALIGN</CODE> </EM>=&gt; ) { <EM>aString</EM> }
<P></P>
<P></P><BR><CODE>checkbox</CODE>( <EM><I>name</I>=<CODE>nil</CODE>, <I>value</I>=<CODE>nil</CODE>, <I>checked</I>=<CODE>nil</CODE> </EM>)<BR><CODE>checkbox</CODE>( <EM><CODE>NAME</CODE>, <CODE>VALUE</CODE>, <CODE>CHECKED</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>checkbox_group</CODE>( <EM><I>name</I>=<CODE>nil</CODE>, <I>[</I> <I>items</I> <I>]<SUP>+</SUP> </I></EM>)<BR><CODE>checkbox_group</CODE>( <EM><CODE>NAME</CODE>, <CODE>VALUES</CODE> </EM>=&gt; )
<P></P>
<P></P>
<BLOCKQUOTE>Items may be individual <CODE>String</CODE> names, or any of: an array of [&nbsp;<I>name</I>,&nbsp;<I>checked</I>&nbsp;], an array of [&nbsp;<I>value</I>,&nbsp;<I>name</I>&nbsp;], or an array of [&nbsp;<I>value</I>,&nbsp;<I>name</I>,&nbsp;<I>checked</I>&nbsp;]. The value for the hash key VALUES should be an array of these items. </BLOCKQUOTE>
<P></P><BR><CODE>file_field</CODE>( <EM><I>name</I>="", <I>size</I>=20, <I>maxlength</I>=<CODE>nil</CODE> </EM>)<BR><CODE>file_field</CODE>( <EM><CODE>NAME</CODE>, <CODE>SIZE</CODE>, <CODE>MAXLENGTH</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>form</CODE>( <EM><I>method</I>="post", <I>action</I>=<CODE>nil</CODE>, <I>enctype</I>="application/x-www-form-urlencoded"</EM> ) { <EM>aStr</EM> }<BR><CODE>form</CODE>( <EM><CODE>METHOD</CODE>, <CODE>ACTION</CODE>, <CODE>ENCTYPE</CODE> </EM>=&gt; ) { <EM>aStr</EM> }
<P></P>
<P></P><BR><CODE>hidden</CODE>( <EM><I>name</I>="", <I>value</I>=<CODE>nil</CODE> </EM>)<BR><CODE>hidden</CODE>( <EM><CODE>NAME</CODE>, <CODE>VALUE</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>html</CODE>( <EM></EM>) { <EM>aString</EM> }<BR><CODE>html</CODE>( <EM><CODE>PRETTY</CODE>, <CODE>DOCTYPE</CODE> </EM>=&gt; ) { <EM>aString</EM> }
<P></P>
<P></P><BR><CODE>img_button</CODE>( <EM><I>src</I>="", <I>name</I>=<CODE>nil</CODE>, <I>alt</I>=<CODE>nil</CODE> </EM>)<BR><CODE>img_button</CODE>( <EM><CODE>SRC</CODE>, <CODE>NAME</CODE>, <CODE>ALT</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>img</CODE>( <EM><I>src</I>="", <I>alt</I>="", <I>width</I>=<CODE>nil</CODE>, <I>height</I>=<CODE>nil</CODE> </EM>)<BR><CODE>img</CODE>( <EM><CODE>SRC</CODE>, <CODE>ALT</CODE>, <CODE>WIDTH</CODE>, <CODE>HEIGHT</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>multipart_form</CODE>( <EM><I>action</I>=<CODE>nil</CODE>, <I>enctype</I>="multipart/form-data"</EM> ) { <EM>aString</EM> }<BR><CODE>multipart_form</CODE>( <EM><CODE>METHOD</CODE>, <CODE>ACTION</CODE>, <CODE>ENCTYPE</CODE> </EM>=&gt; ) { <EM>aString</EM> }
<P></P>
<P></P><BR><CODE>password_field</CODE>( <EM><I>name</I>="", <I>value</I>=<CODE>nil</CODE>, <I>size</I>=40, <I>maxlength</I>=<CODE>nil</CODE> </EM>)<BR><CODE>password_field</CODE>( <EM><CODE>NAME</CODE>, <CODE>VALUE</CODE>, <CODE>SIZE</CODE>, <CODE>MAXLENGTH</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>popup_menu</CODE>( <EM><I>name</I>="", <I>items</I> </EM>)<BR><CODE>popup_menu</CODE>( <EM><CODE>NAME</CODE>, <CODE>SIZE</CODE>, <CODE>MULTIPLE</CODE>, <CODE>VALUES</CODE> <EM>(array of items)</EM> </EM>=&gt; )
<P></P>
<P></P>
<BLOCKQUOTE>Items may be individual <CODE>String</CODE> names, or any of: an array of [&nbsp;<I>name</I>,&nbsp;<I>selected</I>&nbsp;], an array of [&nbsp;<I>value</I>,&nbsp;<I>name</I>&nbsp;], or an array of [&nbsp;<I>value</I>,&nbsp;<I>name</I>,&nbsp;<I>selected</I>&nbsp;]. The value for the hash key VALUES should be an array of these items. </BLOCKQUOTE>
<P></P><BR><CODE>radio_button</CODE>( <EM><I>name</I>="", <I>value</I>=<CODE>nil</CODE>, <I>checked</I>=<CODE>nil</CODE> </EM>)<BR><CODE>radio_button</CODE>( <EM><CODE>NAME</CODE>, <CODE>VALUE</CODE>, <CODE>CHECKED</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>radio_group</CODE>( <EM><I>name</I>="", <I>items</I> </EM>)<BR><CODE>radio_group</CODE>( <EM><CODE>NAME</CODE>, <CODE>VALUES</CODE> <EM>(array of items)</EM> </EM>=&gt; )
<P></P>
<P></P>
<BLOCKQUOTE>Items may be individual <CODE>String</CODE> names, or any of: an array of [&nbsp;<I>name</I>,&nbsp;<I>selected</I>&nbsp;], an array of [&nbsp;<I>value</I>,&nbsp;<I>name</I>&nbsp;], or an array of [&nbsp;<I>value</I>,&nbsp;<I>name</I>,&nbsp;<I>selected</I>&nbsp;]. The value for the hash key VALUES should be an array of these items. </BLOCKQUOTE>
<P></P><BR><CODE>reset</CODE>( <EM><I>value</I>=<CODE>nil</CODE>, <I>name</I>=<CODE>nil</CODE> </EM>)<BR><CODE>reset</CODE>( <EM><CODE>VALUE</CODE>, <CODE>NAME</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>scrolling_list</CODE>( <EM><EM>alias for</EM> popup_menu</EM> )<BR><CODE>scrolling_list</CODE>( <EM></EM>=&gt; )
<P></P>
<P></P><BR><CODE>submit</CODE>( <EM><I>value</I>=<CODE>nil</CODE>, <I>name</I>=<CODE>nil</CODE> </EM>)<BR><CODE>submit</CODE>( <EM><CODE>VALUE</CODE>, <CODE>NAME</CODE> </EM>=&gt; )
<P></P>
<P></P><BR><CODE>text_field</CODE>( <EM><I>name</I>="", <I>value</I>=<CODE>nil</CODE>, <I>size</I>=40, <I>maxlength</I>=<CODE>nil</CODE> </EM>)<BR><CODE>text_field</CODE>( <EM><CODE>NAME</CODE>, <CODE>VALUE</CODE>, <CODE>SIZE</CODE>, MAXLENGTH</EM> =&gt; )
<P></P>
<P></P><BR><CODE>textarea</CODE>( <EM><I>name</I>="", <I>cols</I>=70, <I>rows</I>=10</EM> )<BR><CODE>textarea</CODE>( <EM><CODE>NAME</CODE>, <CODE>COLS</CODE>, <CODE>ROWS</CODE> </EM>=&gt; )
<P></P>
<P></P>\
<HR>
 
<P></P>In addition, all HTML tags are supported as methods, including <CODE>title</CODE>, <CODE>head</CODE>, <CODE>body</CODE>, <CODE>br</CODE>, <CODE>pre</CODE>, and so on. The block given to the method must return a <CODE>String</CODE>, which will be used as the content for that tag type. Not all tags require content: <CODE>&lt;P&gt;</CODE>, for example, does not. The available tags vary according to the supported HTML level---Table 26.1 on page 503 lists the complete set. For these methods, you can pass in a hash with attributes for the given tag. For instance, you might pass in <CODE>'BORDER'=&gt;'5'</CODE> to the <CODE>table</CODE> method to set the border width of the table. 
<TABLE width=500 bgColor=#ffe0e0 border=2>
<TBODY>
<TR>
<TD><B>HTML tags available as methods</B> 
<TABLE class=codebox cellSpacing=0 cellPadding=3 border=0>
<TBODY>
<TR bgColor=#ff9999>
<TD vAlign=top>{<B>HTML 3</B>}</TD></TR>
<TR>
<TD vAlign=top>a address applet area b base basefont big blockquote body br caption center cite code dd dfn dir div dl dt em font form h1 h2 h3 h4 h5 h6 head hr html i img input isindex kbd li link listing map menu meta ol option p param plaintext pre samp script select small strike strong style sub sup table td textarea th title tr tt u ul var xmp</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=3><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR>
<TR>
<TD vAlign=top>{<B>HTML 4</B>}</TD></TR>
<TR bgColor=#ff9999>
<TD vAlign=top>a abbr acronym address area b base bdo big blockquote body br button caption cite code col colgroup dd del dfn div dl dt em fieldset form h1 h2 h3 h4 h5 h6 head hr html i img input ins kbd label legend li link map meta noscript object ol optgroup option p param pre q samp script select small span strong style sub sup table tbody td textarea tfoot th thead title tr tt ul var</TD></TR>
<TR bgColor=#ff9999>
<TD vAlign=top>{<B>HTML 4 Transitional</B>}</TD></TR>
<TR>
<TD vAlign=top>a abbr acronym address applet area b base basefont bdo big blockquote body br button caption center cite code col colgroup dd del dfn dir div dl dt em fieldset font form h1 h2 h3 h4 h5 h6 head hr html i iframe img input ins isindex kbd label legend li link map menu meta noframes noscript object ol optgroup option p param pre q s samp script select small span strike strong style sub sup table tbody td textarea tfoot th thead title tr tt u ul var</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=3><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR>
<TR>
<TD vAlign=top></TD></TR>
<TR bgColor=#ff9999>
<TD vAlign=top>frame frameset</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=2><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<H3><A name=UB>Multipart Form Values</A></H3>
<P></P>When dealing with a multipart form, the array returned by <CODE>CGI#[]</CODE> is composed of objects of class <CODE>Tempfile</CODE>, with the following dynamically added methods: 
<TABLE class=codebox cellSpacing=0 cellPadding=3 border=0>
<TBODY>
<TR bgColor=#ff9999>
<TD vAlign=top><B>Method</B> </TD>
<TD vAlign=top><B>Description</B> </TD></TR>
<TR>
<TD vAlign=top><CODE>read</CODE> </TD>
<TD vAlign=top>Body</TD></TR>
<TR>
<TD vAlign=top><CODE>local_path</CODE> </TD>
<TD vAlign=top>Path to local file containing the content</TD></TR>
<TR>
<TD vAlign=top><CODE>original_filename</CODE> </TD>
<TD vAlign=top>Original filename of the content</TD></TR>
<TR>
<TD vAlign=top><CODE>content_type</CODE> </TD>
<TD vAlign=top>Content type</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=2><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<P></P>
<TABLE>
<TBODY>
<TR>
<TD height=20><IMG height=20 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<TABLE cellPadding=10 width="100%" bgColor=#660066 border=0>
<TBODY>
<TR>
<TD vAlign=center><FONT color=white size=7>class CGI::Session</FONT> </TD>
<TD>
<TABLE border=0>
<TBODY>
<TR>
<TD><FONT color=white>Parent: </FONT></TD>
<TD><FONT color=white>Object</FONT> </TD></TR>
<TR>
<TD><FONT color=white>Version: </FONT></TD>
<TD><FONT color=white>1.6 </FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P></P>
<H3>Index:</H3><A href="122.html#CGI::Session.new">new</A> <I><A href="122.html#CGI::Session._ob_cb">[ ]</A> </I><I><A href="122.html#CGI::Session._ob_cb_eq">[ ]=</A> </I><I><A href="122.html#CGI::Session.delete">delete</A> </I><I><A href="122.html#CGI::Session.update">update</A> </I>
<P></P>
<HR>

<P></P>A <CODE>CGI::Session</CODE> maintains a persistent state for web users in a CGI environment. Sessions may be memory-resident or may be stored on disk. See the discussion on page 146 for details. 
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>class methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI::Session.new>new</A> </B></FONT></TD>
<TD bgColor=#ffaaaa>CGI::Session.new( <I>aCgi</I>, <I>[</I> <I>aHash</I> <I>]<SUP>*</SUP> </I>) -&gt; <I>aSession</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns a new session object for the <CODE>CGI</CODE> query. Options that may be given in <I>aHash</I> include: 
<P></P>
<TABLE class=codebox cellSpacing=0 cellPadding=3 border=0>
<TBODY>
<TR bgColor=#ff9999>
<TD vAlign=top><B>Option</B> </TD>
<TD vAlign=top><B>Description</B> </TD></TR>
<TR>
<TD vAlign=top><CODE>session_key</CODE> </TD>
<TD vAlign=top>Name of CGI key for session identification.</TD></TR>
<TR>
<TD vAlign=top><CODE>session_id</CODE> </TD>
<TD vAlign=top>Value of session id.</TD></TR>
<TR>
<TD vAlign=top><CODE>new_session</CODE> </TD>
<TD vAlign=top>If <CODE>true</CODE>, create a new session id for this session. If <CODE>false</CODE>, use an existing session identified by <CODE>session_id</CODE>. If omitted, use an existing session if available, otherwise create a new one.</TD></TR>
<TR>
<TD vAlign=top><CODE>database_manager</CODE> </TD>
<TD vAlign=top>Class to use to save sessions; may be <CODE>CGI::Session::FileStore</CODE> or <CODE>CGI::Session::MemoryStore</CODE> (or user defined if you're brave). Default is <CODE>FileStore</CODE>.</TD></TR>
<TR bgColor=#ff9999>
<TD vAlign=top><CODE>tmpdir</CODE> </TD>
<TD vAlign=top>For <CODE>FileStore,</CODE> directory for session files.</TD></TR>
<TR bgColor=#ff9999>
<TD vAlign=top><CODE>prefix</CODE> </TD>
<TD vAlign=top>For <CODE>FileStore,</CODE> prefix of session filenames.</TD></TR>
<TR>
<TD bgColor=#ff9999 colSpan=9 height=2><IMG height=1 src="120_files/dot[1].gif"  width=1></TD></TR></TBODY></TABLE>
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<TABLE cellPadding=10 width="100%" border=0>
<TBODY>
<TR>
<TD vAlign=center bgColor=#990066 colSpan=2><FONT color=white size=6>instance methods </FONT></TD></TR>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI::Session._ob_cb>[ ]</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>[ <I>aKey</I> ] -&gt; <I>aValue</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Returns the value for the given key. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI::Session._ob_cb_eq>[ ]=</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>[ <I>aKey</I> ] = <I>aValue</I> -&gt; <I>aValue</I> </TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Sets the value for the given key. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI::Session.delete>delete</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.delete 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Calls the <CODE>delete</CODE> method of the underlying database manager. For <CODE>FileStore</CODE>, deletes the physical file containing the session. For <CODE>MemoryStore</CODE>, removes the session from memory. 
<P></P></TD>
<TR>
<TD vAlign=center bgColor=#ff9999><FONT size=4><B><A name=CGI::Session.update>update</A> </B></FONT></TD>
<TD bgColor=#ffaaaa><I>aSession</I>.update 
<P></P></TD></TR>
<TR>
<TD></TD>
<TD>
<P></P>Calls the <CODE>update</CODE> method of the underlying database manager. For <CODE>FileStore</CODE>, writes the session data out to disk. Has no effect with <CODE>MemoryStore</CODE>. 
<P></P></TD></TR></TBODY></TABLE>
<P></P>
<P></P>
<P></P>
<HR>

<TABLE cellSpacing=0 cellPadding=10 bgColor=#a03030 border=0>
<TBODY>
<TR>
<TD align=left width="33%"><A class=subheader href="121.html" >Previous &lt;</A> </TD>
<TD vAlign=center align=middle width="33%"><A class=subheader href="95.html" >Contents ^</A> <BR></TD>
<TD align=right width="33%"><A class=subheader href="123.html" >Next &gt;</A> <BR></TD></TR></TBODY></TABLE>
<P></P><FONT size=-1>Extracted from the book "Programming Ruby - The Pragmatic Programmer's Guide"</FONT> <BR><FONT size=-3>Copyright  2001 by Addison Wesley Longman, Inc. This material may be distributed only subject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latest version is presently available at <A href="http://www.opencontent.org/openpub/" >http://www.opencontent.org/openpub/</A>)). 
<P></P>Distribution of substantively modified versions of this document is prohibited without the explicit permission of the copyright holder. 
<P></P>Distribution of the work or derivative of the work in any standard (paper) book form is prohibited unless prior permission is obtained from the copyright holder. <BR></FONT></BODY>