<html><HEAD><TITLE>Ruby参考手册 - 对象</TITLE>
<META http-equiv=Content-type content="text/html; charset=gb2312">
<META http-equiv=Content-Style-Type content=text/css><LINK href="65_files/style[1].css"  type=text/css rel=stylesheet></head>
<BODY>
<DIV class=navi><A id=header-navi name=head-navi></A><SPAN class=navi>[<A href="61.html" >Ruby首页</A>]</SPAN>  </DIV>
<DIV class=body>
<H1><A id=a.a5.aa.a5.d6.a5.b8.a5.a7.a5.af.a5.c8 name=a.a5.aa.a5.d6.a5.b8.a5.a7.a5.af.a5.c8>对象</A><!-- RDLabel: "对象" --></H1>
<H2><A id=a.a5.aa.a5.d6.a5.b8.a5.a7.a5.af.a5.c8.a4.c8.a4.cf name=a.a5.aa.a5.d6.a5.b8.a5.a7.a5.af.a5.c8.a4.c8.a4.cf>对象概述</A><!-- RDLabel: "对象概述" --></H2>
<P>Ruby所能处理的值都是对象。Ruby操作对象时的办法只有一种，那就是方法调用。对象所属的类决定了对象所包含的方法。生成对象时，对象的所属类也就确定了，除非导入特殊类以外，对象的所属类不会改变。可以说对象是某个特定类的“实例”。</P>
<P>生成对象一般是通过调用别的对象的方法来实现的。</P>
<H2><A id=a.a5.af.a5.e9.a5.b9 name=a.a5.af.a5.e9.a5.b9>类</A><!-- RDLabel: "类" --></H2>
<P>类决定了归属其下的对象的方法。若能调用归属对象的某方法时，我们就说该方法是“由类定义的”。方法由类和方法名决定。</P>
<P>每个类都必然拥有一个“超类”。若在超类中定义了一个方法，则在当前类中必然也会出现一个相同的方法，这叫做“继承”。继承是发展的，所以超类的超类中的方法也会出现在当前类中。</P>
<H3><A id=a.a5.e2.a5.b8.a5.e5.a1.bc.a5.eb name=a.a5.e2.a5.b8.a5.e5.a1.bc.a5.eb>模块</A><!-- RDLabel: "模块" --></H3>
<P>include</P>
<P>这个有点特殊，它并不是类，但功能相同。</P>
<H2><A id=a.a5.e1.a5.bd.a5.c3.a5.c9 name=a.a5.e1.a5.bd.a5.c3.a5.c9>方法</A><!-- RDLabel: "方法" --></H2>
<P>方法是可以执行的。通常我们把执行方法的动作叫做“调用”。调用方法时可以传递对象，这个对象就是“参数”。可接受的参数数量是在定义方法时确定的，不可改变。</P></DIV>
<HR>

<DIV class=footer>Originally Written by webmaster@ruby-lang.org<BR>Translated by <A href="http://cn.ce-lab.net/" >Community Engine China</A> (<A href="mailto:rubycn@ce-lab.net">Mail</A>)<BR>Last update on 2004-12-22 </DIV></BODY>